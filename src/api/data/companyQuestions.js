/* eslint-disable */

export const companyCategories = [
  'Adobe',
  'Aetion',
  'Affirm',
  'Airbnb',
  'Akuna Capital',
  'Alibaba',
  'Amazon',
  'AppDynamics',
  'Apple',
  'Baidu',
  'Bloomberg',
  'Citadel',
  'Cloudera',
  'Coupang',
  'Coursera',
  'Drawbridge',
  'Dropbox',
  'Epic Systems',
  'Expedia',
  'Facebook',
  'Fallible',
  'GE Digital',
  'Gilt Groupe',
  'GoDaddy',
  'Goldman Sachs',
  'Google',
  'Helix',
  'Houzz',
  'Hulu',
  'IXL',
  'Indeed',
  'Intuit',
  'LinkedIn',
  'LiveRamp',
  'Lyft',
  'MAQ Software',
  'Machine Zone',
  'Mathworks',
  'Microsoft',
  'NetEase',
  'Netsuite',
  'Palantir',
  'Pinterest',
  'Pocket Gems',
  'Poynt',
  'Pure Storage',
  'Quip',
  'Quora',
  'Rackspace',
  'Radius',
  'Riot Games',
  'Rubrik',
  'Samsung',
  'Snapchat',
  'Square',
  'Tencent',
  'TripleByte',
  'Twitter',
  'Two Sigma',
  'Uber',
  'Valve',
  'WAP',
  'Works Applications',
  'Yahoo',
  'Yatra',
  'Yelp',
  'Zappos',
  'Zenefits',
  'databricks',
  'eBay',
  'inmobi',
];

export const companyQuestions = [
  {
    id: '1',
    name: 'Two Sum',
    acceptance: '36.4%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given an array of integers, return <b>indices</b> of the two numbers such that they add up to a specific target.</p>\n\n<p>You may assume that each input would have <b><i>exactly</i></b> one solution, and you may not use the <i>same</i> element twice.</p>\n\n<p>\n<b>Example:</b><br>\n</p><pre>Given nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[<b>0</b>] + nums[<b>1</b>] = 2 + 7 = 9,\nreturn [<b>0</b>, <b>1</b>].\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1 (Brute Force) [Accepted]</a></li>\n<li><a href="#approach-2-two-pass-hash-table-accepted">Approach #2 (Two-pass Hash Table) [Accepted]</a></li>\n<li><a href="#approach-3-one-pass-hash-table-accepted">Approach #3 (One-pass Hash Table) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-accepted">Approach #1 (Brute Force) [Accepted]</h4>\n<p>The brute force approach is simple. Loop through each element <script type="math/tex; mode=display">x</script> and find if there is another value that equals to <script type="math/tex; mode=display">target - x</script>.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>\n                <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span> <span class="o">};</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">"No two sum solution"</span><span class="o">);</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>.\nFor each element, we try to find its complement by looping through the rest of array which takes <script type="math/tex; mode=display">O(n)</script> time. Therefore, the time complexity is <script type="math/tex; mode=display">O(n^2)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-two-pass-hash-table-accepted">Approach #2 (Two-pass Hash Table) [Accepted]</h4>\n<p>To improve our run time complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to look up its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table.</p>\n<p>We reduce the look up time from <script type="math/tex; mode=display">O(n)</script> to <script type="math/tex; mode=display">O(1)</script> by trading space for speed. A hash table is built exactly for this purpose, it supports fast look up in <em>near</em> constant time. I say "near" because if a collision occurred, a look up could degenerate to <script type="math/tex; mode=display">O(n)</script> time. But look up in hash table should be amortized <script type="math/tex; mode=display">O(1)</script> time as long as the hash function was chosen carefully.</p>\n<p>A simple implementation uses two iterations. In the first iteration, we add each element\'s value and its index to the table. Then, in the second iteration we check if each element\'s complement (<script type="math/tex; mode=display">target - nums[i]</script>) exists in the table. Beware that the complement must not be <script type="math/tex; mode=display">nums[i]</script> itself!</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>\n    <span class="o">}</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">complement</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">complement</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">complement</span><span class="o">)</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">i</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">complement</span><span class="o">)</span> <span class="o">};</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">"No two sum solution"</span><span class="o">);</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis:</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nWe traverse the list containing <script type="math/tex; mode=display">n</script> elements exactly twice. Since the hash table reduces the look up time to <script type="math/tex; mode=display">O(1)</script>, the time complexity is <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>.\nThe extra space required depends on the number of items stored in the hash table, which stores exactly <script type="math/tex; mode=display">n</script> elements.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-one-pass-hash-table-accepted">Approach #3 (One-pass Hash Table) [Accepted]</h4>\n<p>It turns out we can do it in one-pass. While we iterate and inserting elements into the table, we also look back to check if current element\'s complement already exists in the table. If it exists, we have found a solution and return immediately.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">complement</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">complement</span><span class="o">))</span> <span class="o">{</span>\n            <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">complement</span><span class="o">),</span> <span class="n">i</span> <span class="o">};</span>\n        <span class="o">}</span>\n        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>\n    <span class="o">}</span>\n    <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">"No two sum solution"</span><span class="o">);</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis:</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nWe traverse the list containing <script type="math/tex; mode=display">n</script> elements only once. Each look up in the table costs only <script type="math/tex; mode=display">O(1)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>.\nThe extra space required depends on the number of items stored in the hash table, which stores at most <script type="math/tex; mode=display">n</script> elements.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: [
      'Facebook',
      'Microsoft',
      'Amazon',
      'Bloomberg',
      'Uber',
      'LinkedIn',
      'Apple',
      'Airbnb',
      'Yelp',
      'Yahoo',
      'Adobe',
      'Dropbox',
    ],
  },
  {
    id: '2',
    name: 'Add Two Numbers',
    acceptance: '28.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>You are given two <b>non-empty</b> linked lists representing two non-negative integers. The digits are stored in <b>reverse order</b> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>\n\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n\n<p>\n<b>Example</b>\n</p><pre><b>Input:</b> (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\n<b>Output:</b> 7 -&gt; 0 -&gt; 8\n<b>Explanation:</b> 342 + 465 = 807.\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<h2 id="solution">Solution</h2>\n<p><strong>Intuition</strong></p>\n<p>Keep track of the carry using a variable and simulate digits-by-digits sum starting from the head of list, which contains the least-significant digit.</p>\n<p align="center"><img alt="Illustration of Adding two numbers" src="https://leetcode.com/articles/Figures/2_add_two_numbers.svg" width="539px"></p>\n<p align="center"><em>Figure 1. Visualization of the addition of two numbers: <script type="math/tex; mode=display">342 + 465 = 807</script>.<br>\nEach node contains a single digit and the digits are stored in reverse order.</em></p>\n<p><strong>Algorithm</strong></p>\n<p>Just like how you would sum two numbers on a piece of paper, we begin by summing the least-significant digits, which is the head of <script type="math/tex; mode=display">l1</script> and <script type="math/tex; mode=display">l2</script>. Since each digit is in the range of <script type="math/tex; mode=display">0 \\ldots 9</script>, summing two digits may "overflow". For example <script type="math/tex; mode=display">5 + 7 = 12</script>. In this case, we set the current digit to <script type="math/tex; mode=display">2</script> and bring over the <script type="math/tex; mode=display">carry = 1</script> to the next iteration. <script type="math/tex; mode=display">carry</script> must be either <script type="math/tex; mode=display">0</script> or <script type="math/tex; mode=display">1</script> because the largest possible sum of two digits (including the carry) is <script type="math/tex; mode=display">9 + 9 + 1 = 19</script>.</p>\n<p>The pseudocode is as following:</p>\n<ul>\n<li>Initialize current node to dummy head of the returning list.</li>\n<li>Initialize carry to <script type="math/tex; mode=display">0</script>.</li>\n<li>Initialize <script type="math/tex; mode=display">p</script> and <script type="math/tex; mode=display">q</script> to head of <script type="math/tex; mode=display">l1</script> and <script type="math/tex; mode=display">l2</script> respectively.</li>\n<li>Loop through lists <script type="math/tex; mode=display">l1</script> and <script type="math/tex; mode=display">l2</script> until you reach both ends.<ul>\n<li>Set <script type="math/tex; mode=display">x</script> to node <script type="math/tex; mode=display">p</script>\'s value. If <script type="math/tex; mode=display">p</script> has reached the end of <script type="math/tex; mode=display">l1</script>, set to <script type="math/tex; mode=display">0</script>.</li>\n<li>Set <script type="math/tex; mode=display">y</script> to node <script type="math/tex; mode=display">q</script>\'s value. If <script type="math/tex; mode=display">q</script> has reached the end of <script type="math/tex; mode=display">l2</script>, set to <script type="math/tex; mode=display">0</script>.</li>\n<li>Set <script type="math/tex; mode=display">sum = x + y + carry</script>.</li>\n<li>Update <script type="math/tex; mode=display">carry = sum / 10</script>.</li>\n<li>Create a new node with the digit value of <script type="math/tex; mode=display">(sum \\bmod 10)</script> and set it to current node\'s next, then advance current node to next.</li>\n<li>Advance both <script type="math/tex; mode=display">p</script> and <script type="math/tex; mode=display">q</script>.</li>\n</ul>\n</li>\n<li>Check if <script type="math/tex; mode=display">carry = 1</script>, if so append a new node with digit <script type="math/tex; mode=display">1</script> to the returning list.</li>\n<li>Return dummy head\'s next node.</li>\n</ul>\n<p>Note that we use a dummy head to simplify the code. Without a dummy head, you would have to write extra conditional statements to initialize the head\'s value.</p>\n<p>Take extra caution of the following cases:</p>\n<table>\n<thead>\n<tr>\n<th>Test case</th>\n<th>Explanation</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<script type="math/tex; mode=display">l1=[0,1]</script><br><script type="math/tex; mode=display">l2=[0,1,2]</script>\n</td>\n<td>When one list is longer than the other.</td>\n</tr>\n<tr>\n<td>\n<script type="math/tex; mode=display">l1=[]</script><br><script type="math/tex; mode=display">l2=[0,1]</script>\n</td>\n<td>When one list is null, which means an empty list.</td>\n</tr>\n<tr>\n<td>\n<script type="math/tex; mode=display">l1=[9,9]</script><br><script type="math/tex; mode=display">l2=[1]</script>\n</td>\n<td>The sum could have an extra carry of one at the end, which is easy to forget.</td>\n</tr>\n</tbody>\n</table>\n<iframe frameborder="0" height="378" name="5icD6MNe" src="https://leetcode.com/playground/5icD6MNe/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(\\max(m, n))</script>. Assume that <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> represents the length of <script type="math/tex; mode=display">l1</script> and <script type="math/tex; mode=display">l2</script> respectively, the algorithm above iterates at most <script type="math/tex; mode=display">\\max(m, n)</script> times.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(\\max(m, n))</script>. The length of the new list is at most <script type="math/tex; mode=display">\\max(m,n) + 1</script>.</p>\n</li>\n</ul>\n<p><strong>Follow up</strong></p>\n<p>What if the the digits in the linked list are stored in non-reversed order? For example:</p>\n<p>\n<script type="math/tex; mode=display">\n(3 \\to 4 \\to 2) + (4 \\to 6 \\to 5) = 8 \\to 0 \\to 7\n</script>\n</p>\n</div>\n          ',
    tags: ['Microsoft', 'Amazon', 'Bloomberg', 'Airbnb', 'Adobe'],
  },
  {
    id: '3',
    name: 'Longest Substring Without Repeating Characters',
    acceptance: '24.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a string, find the length of the <b>longest substring</b> without repeating characters.</p>\n\n<p><b>Examples:</b></p>\n\n<p>Given <code>"abcabcbb"</code>, the answer is <code>"abc"</code>, which the length is 3.</p>\n\n<p>Given <code>"bbbbb"</code>, the answer is <code>"b"</code>, with the length of 1.</p>\n\n<p>Given <code>"pwwkew"</code>, the answer is <code>"wke"</code>, with the length of 3. Note that the answer must be a <b>substring</b>, <code>"pwke"</code> is a <i>subsequence</i> and not a substring.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-sliding-window-accepted">Approach #2 Sliding Window [Accepted]</a></li>\n<li><a href="#approach-3-sliding-window-optimized-accepted">Approach #3 Sliding Window Optimized [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>Check all the substring one by one to see if it has no duplicate character.</p>\n<p><strong>Algorithm</strong></p>\n<p>Suppose we have a function <code>boolean allUnique(String substring)</code> which will return true if the characters in the substring are all unique, otherwise false. We can iterate through all the possible substrings of the given string <code>s</code> and call the function <code>allUnique</code>. If it turns out to be true, then we update our answer of the maximum length of substring without duplicate characters.</p>\n<p>Now let\'s fill the missing parts:</p>\n<ol>\n<li>\n<p>To enumerate all substrings of a given string, we enumerate the start and end indices of them. Suppose the start and end indices are <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script>, respectively. Then we have <script type="math/tex; mode=display">0 \\leq i \\lt j \\leq n</script> (here end index <script type="math/tex; mode=display">j</script> is exclusive by convention). Thus, using two nested loops with <script type="math/tex; mode=display">i</script> from 0 to <script type="math/tex; mode=display">n - 1</script> and <script type="math/tex; mode=display">j</script> from <script type="math/tex; mode=display">i+1</script> to <script type="math/tex; mode=display">n</script>, we can enumerate all the substrings of <code>s</code>.</p>\n</li>\n<li>\n<p>To check if one string has duplicate characters, we can use a set. We iterate through all the characters in the string and put them into the <code>set</code> one by one. Before putting one character, we check if the set already contains it. If so, we return <code>false</code>. After the loop, we return <code>true</code>.</p>\n</li>\n</ol>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>\n        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">allUnique</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="o">);</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">allUnique</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">Set</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="n">Character</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">ch</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>.</li>\n</ul>\n<p>To verify if characters within index range <script type="math/tex; mode=display">[i, j)</script> are all unique, we need to scan all of them. Thus, it costs <script type="math/tex; mode=display">O(j - i)</script> time.</p>\n<p>For a given <code>i</code>, the sum of time costed by each <script type="math/tex; mode=display">j \\in [i+1, n]</script> is</p>\n<p>\n<script type="math/tex; mode=display">\n\\sum_{i+1}^{n}O(j - i)\n</script>\n</p>\n<p>Thus, the sum of all the time consumption is:</p>\n<p>\n<script type="math/tex; mode=display">\nO\\left(\\sum_{i = 0}^{n - 1}\\left(\\sum_{j = i + 1}^{n}(j - i)\\right)\\right) =\nO\\left(\\sum_{i = 0}^{n - 1}\\frac{(1 + n - i)(n - i)}{2}\\right) =\nO(n^3)\n</script>\n</p>\n<ul>\n<li>Space complexity : <script type="math/tex; mode=display">O(min(n, m))</script>. We need <script type="math/tex; mode=display">O(k)</script> space for checking a substring has no duplicate characters, where <script type="math/tex; mode=display">k</script> is the size of the <code>Set</code>. The size of the Set is upper bounded by the size of the string <script type="math/tex; mode=display">n</script> and the size of the charset/alphabet <script type="math/tex; mode=display">m</script>.</li>\n</ul>\n<hr>\n<h4 id="approach-2-sliding-window-accepted">Approach #2 Sliding Window [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The naive approach is very straightforward. But it is too slow. So how can we optimize it?</p>\n<p>In the naive approaches, we repeatedly check a substring to see if it has duplicate character. But it is unnecessary. If a substring <script type="math/tex; mode=display">s_{ij}</script> from index <script type="math/tex; mode=display">i</script> to <script type="math/tex; mode=display">j - 1</script> is already checked to have no duplicate characters. We only need to check if <script type="math/tex; mode=display">s[j]</script> is already in the substring <script type="math/tex; mode=display">s_{ij}</script>.</p>\n<p>To check if a character is already in the substring, we can scan the substring, which leads to an <script type="math/tex; mode=display">O(n^2)</script> algorithm. But we can do better.</p>\n<p>By using HashSet as a sliding window, checking if a character in the current can be done in <script type="math/tex; mode=display">O(1)</script>.</p>\n<p>A sliding window is an abstract concept commonly used in array/string problems. A window is a range of elements in the array/string which usually defined by the start and end indices, i.e. <script type="math/tex; mode=display">[i, j)</script> (left-closed, right-open). A sliding window is a window "slides" its two boundaries to the certain direction. For example, if we slide <script type="math/tex; mode=display">[i, j)</script> to the right by <script type="math/tex; mode=display">1</script> element, then it becomes <script type="math/tex; mode=display">[i+1, j+1)</script> (left-closed, right-open).</p>\n<p>Back to our problem. We use HashSet to store the characters in current window <script type="math/tex; mode=display">[i, j)</script> (<script type="math/tex; mode=display">j = i</script> initially). Then we slide the index <script type="math/tex; mode=display">j</script> to the right. If it is not in the HashSet, we slide <script type="math/tex; mode=display">j</script> further. Doing so until s[j] is already in the HashSet. At this point, we found the maximum size of substrings without duplicate characters start with index <script type="math/tex; mode=display">i</script>. If we do this for all <script type="math/tex; mode=display">i</script>, we get our answer.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>\n        <span class="n">Set</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span>\n        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>\n            <span class="c1">// try to extend the range [i, j]</span>\n            <span class="k">if</span> <span class="o">(!</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))){</span>\n                <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">++));</span>\n                <span class="n">ans</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="o">);</span>\n            <span class="o">}</span>\n            <span class="k">else</span> <span class="o">{</span>\n                <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">++));</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(2n) = O(n)</script>. In the worst case each character will be visited twice by <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(min(m, n))</script>. Same as the previous approach. We need <script type="math/tex; mode=display">O(k)</script> space for the sliding window, where <script type="math/tex; mode=display">k</script> is the size of the <code>Set</code>. The size of the Set is upper bounded by the size of the string <script type="math/tex; mode=display">n</script> and the size of the charset/alphabet <script type="math/tex; mode=display">m</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-sliding-window-optimized-accepted">Approach #3 Sliding Window Optimized [Accepted]</h4>\n<p>The above solution requires at most 2n steps. In fact, it could be optimized to require only n steps. Instead of using a set to tell if a character exists or not, we could define a mapping of the characters to its index. Then we can skip the characters immediately when we found a repeated character.</p>\n<p>The reason is that if <script type="math/tex; mode=display">s[j]</script> have a duplicate in the range <script type="math/tex; mode=display">[i, j)</script> with index <script type="math/tex; mode=display">j\'</script>, we don\'t need to increase <script type="math/tex; mode=display">i</script> little by little. We can skip all the elements in the range <script type="math/tex; mode=display">[i, j\']</script> and let <script type="math/tex; mode=display">i</script> to be <script type="math/tex; mode=display">j\' + 1</script> directly.</p>\n<p><strong>Java (Using HashMap)</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="n">Map</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span> <span class="c1">// current index of character</span>\n        <span class="c1">// try to extend the range [i, j]</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)))</span> <span class="o">{</span>\n                <span class="n">i</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)),</span> <span class="n">i</span><span class="o">);</span>\n            <span class="o">}</span>\n            <span class="n">ans</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">),</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Java (Assuming ASCII 128)</strong></p>\n<p>The previous implements all have no assumption on the charset of the string <code>s</code>.</p>\n<p>If we know that the charset is rather small, we can replace the <code>Map</code> with an integer array as direct access table.</p>\n<p>Commonly used tables are:</p>\n<ul>\n<li><code>int[26]</code> for Letters \'a\' - \'z\' or \'A\' - \'Z\'</li>\n<li><code>int[128]</code> for ASCII</li>\n<li><code>int[256]</code> for Extended ASCII</li>\n</ul>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="kt">int</span><span class="o">[]</span> <span class="n">index</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">128</span><span class="o">];</span> <span class="c1">// current index of character</span>\n        <span class="c1">// try to extend the range [i, j]</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="n">i</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">index</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)],</span> <span class="n">i</span><span class="o">);</span>\n            <span class="n">ans</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n            <span class="n">index</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">)]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Index <script type="math/tex; mode=display">j</script> will iterate <script type="math/tex; mode=display">n</script> times.</p>\n</li>\n<li>\n<p>Space complexity (HashMap) : <script type="math/tex; mode=display">O(min(m, n))</script>. Same as the previous approach.</p>\n</li>\n<li>\n<p>Space complexity (Table): <script type="math/tex; mode=display">O(m)</script>. <script type="math/tex; mode=display">m</script> is the size of the charset.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: ['Amazon', 'Bloomberg', 'Yelp', 'Adobe'],
  },
  {
    id: '4',
    name: 'Median of Two Sorted Arrays',
    acceptance: '22.4%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>There are two sorted arrays <b>nums1</b> and <b>nums2</b> of size m and n respectively.</p>\n\n<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>\n\n<p><b>Example 1:</b><br>\n</p><pre>nums1 = [1, 3]\nnums2 = [2]\n\nThe median is 2.0\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre>nums1 = [1, 2]\nnums2 = [3, 4]\n\nThe median is (2 + 3)/2 = 2.5\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-recursive-approach-accepted">Approach #1 Recursive Approach [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-recursive-approach-accepted">Approach #1 Recursive Approach [Accepted]</h4>\n<p>To solve this problem, we need to understand "What is the use of median". In statistics, the median is used for:</p>\n<blockquote>\n<p>Dividing a set into two equal length subsets, that one subset is always greater than the other.</p>\n</blockquote>\n<p>If we understand the use of median for dividing, we are very close to the answer.</p>\n<p>First let\'s cut <script type="math/tex; mode=display">\\text{A}</script> into two parts at a random position <script type="math/tex; mode=display">i</script>:</p>\n<div class="codehilite"><pre><span></span>          left_A             |        right_A\n    A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]\n</pre></div>\n<p>Since <script type="math/tex; mode=display">\\text{A}</script> has <script type="math/tex; mode=display">m</script> elements, so there are <script type="math/tex; mode=display">m+1</script> kinds of cutting (<script type="math/tex; mode=display">i = 0 \\sim m</script>).</p>\n<p>And we know:</p>\n<blockquote>\n<p>\n<script type="math/tex; mode=display">\\text{len}(\\text{left\\_A}) = i, \\text{len}(\\text{right\\_A}) = m - i</script>.</p>\n<p>Note: when <script type="math/tex; mode=display">i = 0</script>, <script type="math/tex; mode=display">\\text{left\\_A}</script> is empty, and when <script type="math/tex; mode=display">i = m</script>, <script type="math/tex; mode=display">\\text{right\\_A}</script> is empty.</p>\n</blockquote>\n<p>With the same way, cut <script type="math/tex; mode=display">\\text{B}</script> into two parts at a random position <script type="math/tex; mode=display">j</script>:</p>\n<div class="codehilite"><pre><span></span>          left_B             |        right_B\n    B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]\n</pre></div>\n<p>Put <script type="math/tex; mode=display">\\text{left\\_A}</script> and <script type="math/tex; mode=display">\\text{left\\_B}</script> into one set, and put <script type="math/tex; mode=display">\\text{right\\_A}</script> and <script type="math/tex; mode=display">\\text{right\\_B}</script> into another set. Let\'s name them <script type="math/tex; mode=display">\\text{left\\_part}</script> and <script type="math/tex; mode=display">\\text{right\\_part}</script>:</p>\n<div class="codehilite"><pre><span></span>          left_part          |        right_part\n    A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]\n    B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]\n</pre></div>\n<p>If we can ensure:</p>\n<blockquote>\n<ol>\n<li>\n<script type="math/tex; mode=display">\\text{len}(\\text{left\\_part}) = \\text{len}(\\text{right\\_part})</script>\n</li>\n<li>\n<script type="math/tex; mode=display">\\max(\\text{left\\_part}) \\leq \\min(\\text{right\\_part})</script>\n</li>\n</ol>\n</blockquote>\n<p>then we divide all elements in <script type="math/tex; mode=display">\\{\\text{A}, \\text{B}\\}</script> into two parts with equal length, and one part is always greater than the other. Then</p>\n<p>\n<script type="math/tex; mode=display">\n\\text{median} = \\frac{\\text{max}(\\text{left}\\_\\text{part}) + \\text{min}(\\text{right}\\_\\text{part})}{2}\n</script>\n</p>\n<p>To ensure these two conditions, we just need to ensure:</p>\n<blockquote>\n<ol>\n<li>\n<p>\n<script type="math/tex; mode=display">i + j = m - i + n - j</script> (or: <script type="math/tex; mode=display">m - i + n - j + 1</script>)<br>\n  if <script type="math/tex; mode=display">n \\geq m</script>, we just need to set:  <script type="math/tex; mode=display"> \\ i = 0 \\sim m,\\  j = \\frac{m + n + 1}{2} - i \\\\</script>\n</p>\n</li>\n<li>\n<p>\n<script type="math/tex; mode=display">\\text{B}[j-1] \\leq \\text{A}[i]</script> and <script type="math/tex; mode=display">\\text{A}[i-1] \\leq \\text{B}[j]</script>\n</p>\n</li>\n</ol>\n</blockquote>\n<p>ps.1 For simplicity, I presume <script type="math/tex; mode=display">\\text{A}[i-1], \\text{B}[j-1], \\text{A}[i], \\text{B}[j]</script> are always valid even if <script type="math/tex; mode=display">i=0</script>, <script type="math/tex; mode=display">i=m</script>, <script type="math/tex; mode=display">j=0</script>, or <script type="math/tex; mode=display">j=n</script>.\nI will talk about how to deal with these edge values at last.</p>\n<p>ps.2 Why <script type="math/tex; mode=display">n \\geq m</script>? Because I have to make sure <script type="math/tex; mode=display">j</script> is non-negative since <script type="math/tex; mode=display">0 \\leq i \\leq m</script> and <script type="math/tex; mode=display">j = \\frac{m + n + 1}{2} - i</script>. If <script type="math/tex; mode=display">n < m</script>, then <script type="math/tex; mode=display">j</script> may be negative, that will lead to wrong result.</p>\n<p>So, all we need to do is:</p>\n<blockquote>\n<p>Searching <script type="math/tex; mode=display">i</script> in <script type="math/tex; mode=display">[0, m]</script>, to find an object <script type="math/tex; mode=display">i</script> such that:</p>\n<p>\n<script type="math/tex; mode=display">\\qquad \\text{B}[j-1] \\leq \\text{A}[i]\\ </script> and <script type="math/tex; mode=display">\\ \\text{A}[i-1] \\leq \\text{B}[j],\\ </script> where <script type="math/tex; mode=display">j = \\frac{m + n + 1}{2} - i</script>\n</p>\n</blockquote>\n<p>And we can do a binary search following steps described below:</p>\n<ol>\n<li>Set <script type="math/tex; mode=display">\\text{imin} = 0</script>, <script type="math/tex; mode=display">\\text{imax} = m</script>, then start searching in <script type="math/tex; mode=display">[\\text{imin}, \\text{imax}]</script>\n</li>\n<li>Set <script type="math/tex; mode=display">i = \\frac{\\text{imin} + \\text{imax}}{2}</script>, <script type="math/tex; mode=display">j = \\frac{m + n + 1}{2} - i</script>\n</li>\n<li>\n<p>Now we have <script type="math/tex; mode=display">\\text{len}(\\text{left}\\_\\text{part})=\\text{len}(\\text{right}\\_\\text{part})</script>. And there are only 3 situations that we may encounter:  </p>\n<ul>\n<li>\n<p>\n<script type="math/tex; mode=display">\\text{B}[j-1] \\leq \\text{A}[i]</script> and <script type="math/tex; mode=display">\\text{A}[i-1] \\leq \\text{B}[j]</script>\n<br>\n  Means we have found the object <script type="math/tex; mode=display">i</script>, so stop searching.  </p>\n</li>\n<li>\n<p>\n<script type="math/tex; mode=display">\\text{B}[j-1] > \\text{A}[i]</script>\n<br>\n  Means <script type="math/tex; mode=display">\\text{A}[i]</script> is too small. We must adjust <script type="math/tex; mode=display">i</script> to get <script type="math/tex; mode=display">\\text{B}[j-1] \\leq \\text{A}[i]</script>.<br>\n  Can we increase <script type="math/tex; mode=display">i</script>?<br>\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes. Because when <script type="math/tex; mode=display">i</script> is increased, <script type="math/tex; mode=display">j</script> will be decreased.<br>\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;So <script type="math/tex; mode=display">\\text{B}[j-1]</script> is decreased and <script type="math/tex; mode=display">\\text{A}[i]</script> is increased, and <script type="math/tex; mode=display">\\text{B}[j-1] \\leq \\text{A}[i]</script> may<br>\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be satisfied.<br>\n  Can we decrease <script type="math/tex; mode=display">i</script>?<br>\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No! Because when <script type="math/tex; mode=display">i</script> is decreased, <script type="math/tex; mode=display">j</script> will be increased.<br>\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;So <script type="math/tex; mode=display">\\text{B}[j-1]</script> is increased and <script type="math/tex; mode=display">\\text{A}[i]</script> is decreased, and <script type="math/tex; mode=display">\\text{B}[j-1] \\leq \\text{A}[i]</script> will<br>\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be never satisfied.<br>\n  So we must increase <script type="math/tex; mode=display">i</script>. That is, we must adjust the searching range to <script type="math/tex; mode=display">[i+1, \\text{imax}]</script>.<br>\n  So, set <script type="math/tex; mode=display">\\text{imin} = i+1</script>, and goto 2.</p>\n</li>\n<li>\n<p>\n<script type="math/tex; mode=display">\\text{A}[i-1] > \\text{B}[j]</script>:<br>\n  Means <script type="math/tex; mode=display">\\text{A}[i-1]</script> is too big. And we must decrease <script type="math/tex; mode=display">i</script> to get   <script type="math/tex; mode=display">\\text{A}[i-1]\\leq \\text{B}[j]</script>.<br>\n  That is, we must adjust the searching range to <script type="math/tex; mode=display">[\\text{imin}, i-1]</script>.<br>\n  So, set <script type="math/tex; mode=display">\\text{imax} = i-1</script>, and goto 2.</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>When the object <script type="math/tex; mode=display">i</script> is found, the median is:</p>\n<blockquote>\n<p>\n<script type="math/tex; mode=display">\\max(\\text{A}[i-1], \\text{B}[j-1]), \\ </script> when <script type="math/tex; mode=display">m + n</script> is odd</p>\n<p>\n<script type="math/tex; mode=display">\\frac{\\max(\\text{A}[i-1], \\text{B}[j-1]) + \\min(\\text{A}[i], \\text{B}[j])}{2}, \\ </script> when <script type="math/tex; mode=display">m + n</script> is even</p>\n</blockquote>\n<p>Now let\'s consider the edges values <script type="math/tex; mode=display">i=0,i=m,j=0,j=n</script> where <script type="math/tex; mode=display">\\text{A}[i-1],\\text{B}[j-1],\\text{A}[i],\\text{B}[j]</script> may not exist.\nActually this situation is easier than you think.</p>\n<p>What we need to do is ensuring that <script type="math/tex; mode=display">\\text{max}(\\text{left}\\_\\text{part}) \\leq \\text{min}(\\text{right}\\_\\text{part})</script>. So, if <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> are not edges values (means <script type="math/tex; mode=display">\\text{A}[i-1],\n\\text{B}[j-1],\\text{A}[i],\\text{B}[j]</script> all exist), then we must check both <script type="math/tex; mode=display">\\text{B}[j-1] \\leq \\text{A}[i]</script> and <script type="math/tex; mode=display">\\text{A}[i-1] \\leq \\text{B}[j]</script>.\nBut if some of <script type="math/tex; mode=display">\\text{A}[i-1],\\text{B}[j-1],\\text{A}[i],\\text{B}[j]</script> don\'t exist, then we don\'t need to check one (or both) of these two conditions.\nFor example, if <script type="math/tex; mode=display">i=0</script>, then <script type="math/tex; mode=display">\\text{A}[i-1]</script> doesn\'t exist, then we don\'t need to check <script type="math/tex; mode=display">\\text{A}[i-1] \\leq \\text{B}[j]</script>.\nSo, what we need to do is:</p>\n<blockquote>\n<p>Searching <script type="math/tex; mode=display">i</script> in <script type="math/tex; mode=display">[0, m]</script>, to find an object <script type="math/tex; mode=display">i</script> such that:</p>\n<p>\n<script type="math/tex; mode=display">(j = 0</script> or <script type="math/tex; mode=display">i = m</script> or <script type="math/tex; mode=display">\\text{B}[j-1] \\leq \\text{A}[i])</script> and<br>\n<script type="math/tex; mode=display">(i = 0</script> or <script type="math/tex; mode=display">j = n</script> or <script type="math/tex; mode=display">\\text{A}[i-1] \\leq \\text{B}[j]),</script>  where <script type="math/tex; mode=display">j = \\frac{m + n + 1}{2} - i</script>\n</p>\n</blockquote>\n<p>And in a searching loop, we will encounter only three situations:</p>\n<blockquote>\n<ol>\n<li>\n<script type="math/tex; mode=display">(j = 0</script> or <script type="math/tex; mode=display">i = m</script> or <script type="math/tex; mode=display">\\text{B}[j-1] \\leq \\text{A}[i])</script> and<br>\n<script type="math/tex; mode=display">(i = 0</script> or <script type="math/tex; mode=display">j = n</script> or <script type="math/tex; mode=display">\\text{A}[i-1] \\leq \\text{B}[j])</script>\n<br>\n    Means <script type="math/tex; mode=display">i</script> is perfect, we can stop searching.</li>\n<li>\n<script type="math/tex; mode=display">j > 0</script> and <script type="math/tex; mode=display">i < m</script> and <script type="math/tex; mode=display">\\text{B}[j - 1] > \\text{A}[i]</script>\n<br>\n    Means <script type="math/tex; mode=display">i</script> is too small, we must increase it.</li>\n<li>\n<script type="math/tex; mode=display">i > 0</script> and <script type="math/tex; mode=display">j < n</script> and <script type="math/tex; mode=display">\\text{A}[i - 1] > \\text{B}[j]</script>\n<br>\n    Means <script type="math/tex; mode=display">i</script> is too big, we must decrease it.</li>\n</ol>\n</blockquote>\n<p>Thanks to <a href="https://leetcode.com/Quentin.chen">@Quentin.chen</a> for pointing out that: <script type="math/tex; mode=display">i < m \\implies j > 0</script> and <script type="math/tex; mode=display">i > 0 \\implies j < n</script>. Because:</p>\n<blockquote>\n<p>\n<script type="math/tex; mode=display">m \\leq n,\\  i < m \\implies j = \\frac{m+n+1}{2} - i > \\frac{m+n+1}{2} - m \\geq \\frac{2m+1}{2} - m \\geq 0</script>\n</p>\n<p>\n<script type="math/tex; mode=display">m \\leq n,\\  i > 0 \\implies j = \\frac{m+n+1}{2} - i < \\frac{m+n+1}{2} \\leq \\frac{2n+1}{2} \\leq n</script>\n</p>\n</blockquote>\n<p>So in situation 2. and 3. , we don\'t need to check whether <script type="math/tex; mode=display">j > 0</script> and whether <script type="math/tex; mode=display">j < n</script>.</p>\n<iframe frameborder="0" height="515" name="PCe8a3oh" src="https://leetcode.com/playground/PCe8a3oh/shared" width="100%"></iframe>\n<iframe frameborder="0" height="515" name="3eo8NE5A" src="https://leetcode.com/playground/3eo8NE5A/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O\\big(\\log\\big(\\text{min}(m,n)\\big)\\big)</script>.<br>\nAt first, the searching range is <script type="math/tex; mode=display">[0, m]</script>.\nAnd the length of this searching range will be reduced by half after each loop.\nSo, we only need <script type="math/tex; mode=display">\\log(m)</script> loops. Since we do constant operations in each loop, so the time complexity is <script type="math/tex; mode=display">O\\big(\\log(m)\\big)</script>.\nSince <script type="math/tex; mode=display">m \\leq n</script>, so the time complexity is <script type="math/tex; mode=display">O\\big(\\log\\big(\\text{min}(m,n)\\big)\\big)</script>.</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(1)</script>.<br>\nWe only need constant memory to store <script type="math/tex; mode=display">9</script> local variables, so the space complexity is <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/MissMary">@MissMary</a></p>\n</div>\n          ',
    tags: ['Google', 'Microsoft', 'Apple', 'Zenefits', 'Yahoo', 'Adobe', 'Dropbox'],
  },
  {
    id: '5',
    name: 'Longest Palindromic Substring',
    acceptance: '25.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a string <b>s</b>, find the longest palindromic substring in <b>s</b>. You may assume that the maximum length of <b>s</b> is 1000.</p>\n\n<p><b>Example:</b>\n</p><pre><b>Input:</b> "babad"\n\n<b>Output:</b> "bab"\n\n<b>Note:</b> "aba" is also a valid answer.\n</pre>\n<p></p>\n\n<p><b>Example:</b>\n</p><pre><b>Input:</b> "cbbd"\n\n<b>Output:</b> "bb"\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-longest-common-substring-accepted">Approach #1 (Longest Common Substring) [Accepted]</a></li>\n<li><a href="#approach-2-brute-force-time-limit-exceeded">Approach #2 (Brute Force) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-dynamic-programming-accepted">Approach #3 (Dynamic Programming) [Accepted]</a></li>\n<li><a href="#approach-4-expand-around-center-accepted">Approach #4 (Expand Around Center) [Accepted]</a></li>\n<li><a href="#approach-5-manachers-algorithm-accepted">Approach #5 (Manacher\'s Algorithm) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This article is for intermediate readers. It introduces the following ideas:\nPalindrome, Dynamic Programming and String Manipulation. Make sure you understand what a palindrome means. A palindrome is a string which reads the same in both directions. For example, <script type="math/tex; mode=display">\\textrm{\'\'aba\'\'}</script> is a palindome, <script type="math/tex; mode=display">\\textrm{\'\'abc\'\'}</script> is not.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-longest-common-substring-accepted">Approach #1 (Longest Common Substring) [Accepted]</h4>\n<p><strong>Common mistake</strong></p>\n<p>Some people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):</p>\n<blockquote>\n<p>Reverse <script type="math/tex; mode=display">S</script> and become <script type="math/tex; mode=display">S\'</script>. Find the longest common substring between <script type="math/tex; mode=display">S</script> and <script type="math/tex; mode=display">S\'</script>, which must also be the longest palindromic substring.</p>\n</blockquote>\n<p>This seemed to work, let’s see some examples below.</p>\n<p>For example, <script type="math/tex; mode=display">S = \\textrm{\'\'caba"}</script>, <script type="math/tex; mode=display">S\' = \\textrm{\'\'abac\'\'}</script>.</p>\n<p>The longest common substring between <script type="math/tex; mode=display">S</script> and <script type="math/tex; mode=display">S\'</script> is <script type="math/tex; mode=display">\\textrm{\'\'aba\'\'}</script>, which is the answer.</p>\n<p>Let’s try another example: <script type="math/tex; mode=display">S = \\textrm{\'\'abacdfgdcaba\'\'}</script>, <script type="math/tex; mode=display">S\' = \\textrm{\'\'abacdgfdcaba\'\'}</script>.</p>\n<p>The longest common substring between <script type="math/tex; mode=display">S</script> and <script type="math/tex; mode=display">S\'</script> is <script type="math/tex; mode=display">\\textrm{\'\'abacd\'\'}</script>. Clearly, this is not a valid palindrome.</p>\n<p><strong>Algorithm</strong></p>\n<p>We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of <script type="math/tex; mode=display">S</script>. To rectify this, each time we find a longest common substring candidate, we check if the substring’s indices are the same as the reversed substring’s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.</p>\n<p>This gives us an <script type="math/tex; mode=display">O(n^2)</script> Dynamic Programming solution which uses <script type="math/tex; mode=display">O(n^2)</script> space (could be improved to use <script type="math/tex; mode=display">O(n)</script> space). Please read more about Longest Common Substring <a href="https://en.wikipedia.org/wiki/Longest_common_substring">here</a>.</p>\n<hr>\n<h4 id="approach-2-brute-force-time-limit-exceeded">Approach #2 (Brute Force) [Time Limit Exceeded]</h4>\n<p>The obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>.\nAssume that <script type="math/tex; mode=display">n</script> is the length of the input string, there are a total of <script type="math/tex; mode=display">\\binom{n}{2} = \\frac{n(n-1)}{2}</script> such substrings (excluding the trivial solution where a character itself is a palindrome). Since verifying each substring takes <script type="math/tex; mode=display">O(n)</script> time, the run time complexity is <script type="math/tex; mode=display">O(n^3)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-dynamic-programming-accepted">Approach #3 (Dynamic Programming) [Accepted]</h4>\n<p>To improve over the brute force solution, we first observe how we can avoid unnecessary re-computation while validating palindromes. Consider the case <script type="math/tex; mode=display">\\textrm{\'\'ababa\'\'}</script>. If we already knew that <script type="math/tex; mode=display">\\textrm{\'\'bab\'\'}</script> is a palindrome, it is obvious that <script type="math/tex; mode=display">\\textrm{\'\'ababa\'\'}</script> must be a palindrome since the two left and right end letters are the same.</p>\n<p>We define <script type="math/tex; mode=display">P(i,j)</script> as following:</p>\n<p>\n<script type="math/tex; mode=display">\nP(i,j) =\n     \\begin{cases}\n       \\text{true,} &\\quad\\text{if the substring } S_i \\dots S_j \\text{ is a palindrome}\\\\\n       \\text{false,} &\\quad\\text{otherwise.} \\\n     \\end{cases}\n</script>\n</p>\n<p>Therefore,</p>\n<p>\n<script type="math/tex; mode=display">\nP(i, j) = ( P(i+1, j-1) \\text{ and } S_i == S_j )\n</script>\n</p>\n<p>The base cases are:</p>\n<p>\n<script type="math/tex; mode=display">\nP(i, i) = true\n</script>\n</p>\n<p>\n<script type="math/tex; mode=display">\nP(i, i+1) = ( S_i == S_{i+1} )\n</script>\n</p>\n<p>This yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on...</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>.\nThis gives us a runtime complexity of <script type="math/tex; mode=display">O(n^2)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^2)</script>.\nIt uses <script type="math/tex; mode=display">O(n^2)</script> space to store the table.</p>\n</li>\n</ul>\n<p><strong>Additional Exercise</strong></p>\n<p>Could you improve the above space complexity further and how?</p>\n<hr>\n<h4 id="approach-4-expand-around-center-accepted">Approach #4 (Expand Around Center) [Accepted]</h4>\n<p>In fact, we could solve it in <script type="math/tex; mode=display">O(n^2)</script> time using only constant space.</p>\n<p>We observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only <script type="math/tex; mode=display">2n - 1</script> such centers.</p>\n<p>You might be asking why there are <script type="math/tex; mode=display">2n - 1</script> but not <script type="math/tex; mode=display">n</script> centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as <script type="math/tex; mode=display">\\textrm{\'\'abba\'\'}</script>) and its center are between the two <script type="math/tex; mode=display">\\textrm{\'b\'}</script>s.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="n">String</span> <span class="nf">longestPalindrome</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">len1</span> <span class="o">=</span> <span class="n">expandAroundCenter</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>\n        <span class="kt">int</span> <span class="n">len2</span> <span class="o">=</span> <span class="n">expandAroundCenter</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">len1</span><span class="o">,</span> <span class="n">len2</span><span class="o">);</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="o">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>\n            <span class="n">end</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="kt">int</span> <span class="nf">expandAroundCenter</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">L</span> <span class="o">=</span> <span class="n">left</span><span class="o">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">L</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">R</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">L</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">R</span><span class="o">))</span> <span class="o">{</span>\n        <span class="n">L</span><span class="o">--;</span>\n        <span class="n">R</span><span class="o">++;</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">R</span> <span class="o">-</span> <span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>.\nSince expanding a palindrome around its center could take <script type="math/tex; mode=display">O(n)</script> time, the overall complexity is <script type="math/tex; mode=display">O(n^2)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<h4 id="approach-5-manachers-algorithm-accepted">Approach #5 (Manacher\'s Algorithm) [Accepted]</h4>\n<p>There is even an <script type="math/tex; mode=display">O(n)</script> algorithm called Manacher\'s algorithm, explained <a href="http://articles.leetcode.com/longest-palindromic-substring-part-ii/">here in detail</a>. However, it is a non-trivial algorithm, and no one expects you to come up with this algorithm in a 45 minutes coding session. But, please go ahead and understand it, I promise it will be a lot of fun.</p>\n</div>\n          ',
    tags: ['Microsoft', 'Amazon', 'Bloomberg'],
  },
  {
    id: '6',
    name: 'ZigZag Conversion',
    acceptance: '27.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nThe string <code>"PAYPALISHIRING"</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n</p><pre>P   A   H   N\nA P L S I I G\nY   I   R\n</pre>\n\nAnd then read line by line: <code>"PAHNAPLSIIGYIR"</code><p></p>\n\n<p>\nWrite the code that will take a string and make this conversion given a number of rows:\n\n</p><pre>string convert(string text, int nRows);</pre>\n\n<code>convert("PAYPALISHIRING", 3)</code> should return <code>"PAHNAPLSIIGYIR"</code>.\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '7',
    name: 'Reverse Integer',
    acceptance: '24.4%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a 32-bit signed integer, reverse digits of an integer.</p>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b> 123\n<b>Output:</b>  321\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b> -123\n<b>Output:</b> -321\n</pre>\n<p></p>\n\n<p><b>Example 3:</b>\n</p><pre><b>Input:</b> 120\n<b>Output:</b> 21\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\nAssume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Bloomberg', 'Apple'],
  },
  {
    id: '8',
    name: 'String to Integer (atoi)',
    acceptance: '13.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Implement <span style="font-family:monospace">atoi</span> to convert a string to an integer.</p>\n\n<p><b>Hint:</b> Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p>\n\n<p>\n<b>Notes:</b> \nIt is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. </p>\n\n<p>\n<b><font color="red">Update (2015-02-10):</font></b><br>\nThe signature of the <code>C++</code> function had been updated. If you still see your function signature accepts a <code>const char *</code> argument, please click the reload button <span class="glyphicon glyphicon-refresh"></span> to reset your code definition.\n</p>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">spoilers alert... click to show requirements for atoi.</a></p>\n\n<div class="spoilers"><b>Requirements for atoi:</b>\n\n<p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>\n\n<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>\n\n<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>\n\n<p>If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.\n</p>\n</div>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft', 'Amazon', 'Bloomberg', 'Uber'],
  },
  {
    id: '9',
    name: 'Palindrome Number',
    acceptance: '35.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Determine whether an integer is a palindrome. Do this without extra space.</p>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show spoilers.</a></p>\n\n<div class="spoilers"><b>Some hints:</b>\n\n<p>Could negative integers be palindromes? (ie, -1)</p>\n\n<p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p>\n\n<p>You could also try reversing an integer. However, if you have solved the problem "Reverse Integer", you know that the reversed integer might overflow. How would you handle such case?</p>\n\n<p>There is a more generic way of solving this problem.</p>\n\n</div>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-revert-half-of-the-number-accepted">Approach #1 Revert half of the number [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-revert-half-of-the-number-accepted">Approach #1 Revert half of the number [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>The first idea that comes to mind is to convert the number into string, and check if the string is a palindrome, but\nthis would require extra non-constant space for creating the string which is not allowed by the problem description.</p>\n<p>Second idea would be reverting the number itself, and then compare the number with original number, \nif they are the same, then the number is a palindrome. However, if the reversed number is larger than <script type="math/tex; mode=display">\\text{int.MAX}</script>, \nwe will hit integer overflow problem.</p>\n<p>Following the thoughts based on the second idea, to avoid the overflow issue of the reverted number, what if we only \nrevert half of the <script type="math/tex; mode=display">\\text{int}</script> number? After all, the reverse of the last half of the palindrome should be the same as the \nfirst half of the number, if the number is a palindrome.</p>\n<p>For example, if the input is <code>1221</code>, if we can revert the last part of the number "12<strong>21</strong>" from "<strong>21</strong>" to "<strong>12</strong>",\nand compare it with the first half of the number "12", since 12 is the same as 12, we know that the number is a palindrome. </p>\n<p>Let\'s see how we could translate this idea into an algorithm.</p>\n<p><strong>Algorithm</strong></p>\n<p>First of all we should take care of some edge cases. All negative numbers are not palindrome, for example: -123 is \nnot a palindrome since the \'-\' does not equal to \'3\'. So we can return false for all negative numbers.</p>\n<p>Now let\'s think about how to revert the last half of the number. For number <code>1221</code>, if we do <code>1221 % 10</code>, we get the \nlast digit <code>1</code>, to get the second to the last digit, we need to remove the last digit from <code>1221</code>, we could do so by \ndividing it by 10, <code>1221 / 10 = 122</code>. Then we can get the last digit again by doing a modulus by 10, <code>122 % 10 = 2</code>, and if we multiply the last digit by 10 and add the second last digit, <code>1 * 10 + 2 = 12</code>, it gives us the reverted number we want. Continuing this process would give us the reverted number with more digits. </p>\n<p>Now the question is, how do we know that we\'ve reached the half of the number?</p>\n<p>Since we divided the number by 10, and multiplied the reversed number by 10, when the original number is less than the \nreversed number, it means we\'ve processed half of the number digits.</p>\n<iframe frameborder="0" height="445" name="3Qqdm9Ca" src="https://leetcode.com/playground/3Qqdm9Ca/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(log_{10}n)</script>.\nWe divided the input by 10 for every iteration, so the time complexity is <script type="math/tex; mode=display">O(log_{10} n)</script>\n</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/ccwei">@ccwei</a></p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '10',
    name: 'Regular Expression Matching',
    acceptance: '24.3%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Implement regular expression matching with support for <code>\'.\'</code> and <code>\'*\'</code>.</p>\n\n<pre>\'.\' Matches any single character.\n\'*\' Matches zero or more of the preceding element.\n\nThe matching should cover the <b>entire</b> input string (not partial).\n\nThe function prototype should be:\nbool isMatch(const char *s, const char *p)\n\nSome examples:\nisMatch("aa","a") → false\nisMatch("aa","aa") → true\nisMatch("aaa","aa") → false\nisMatch("aa", "a*") → true\nisMatch("aa", ".*") → true\nisMatch("ab", ".*") → true\nisMatch("aab", "c*a*b") → true\n</pre>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-recursion-accepted">Approach #1: Recursion [Accepted]</a></li>\n<li><a href="#approach-2-dynamic-programming-accepted">Approach #2: Dynamic Programming [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-recursion-accepted">Approach #1: Recursion [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If there were no Kleene stars (the <code>*</code> wildcard character for regular expressions), the problem would be easier - we simply check from left to right if each character of the text matches the pattern.</p>\n<p>When a star is present, we may need to check many different suffixes of the text and see if they match the rest of the pattern.  A recursive solution is a straightforward way to represent this relationship.</p>\n<p><strong>Algorithm</strong></p>\n<p>Without a Kleene star, our solution would look like this:</p>\n<iframe frameborder="0" height="122" name="GRAo9oMi" src="https://leetcode.com/playground/GRAo9oMi/shared" width="100%"></iframe>\n<p>If a star is present in the pattern, it will be in the second position <script type="math/tex; mode=display">\\text{pattern[1]}</script>.  Then, we may ignore this part of the pattern, or delete a matching character in the text.  If we have a match on the remaining strings after any of these operations, then the initial inputs matched.</p>\n<iframe frameborder="0" height="258" name="3H6fWLxB" src="https://leetcode.com/playground/3H6fWLxB/shared" width="100%"></iframe>\n<iframe frameborder="0" height="292" name="wu7MiqMW" src="https://leetcode.com/playground/wu7MiqMW/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: Let <script type="math/tex; mode=display">T, P</script> be the lengths of the text and the pattern respectively.  In the worst case, a call to <code>match(text[i:], pattern[2j:])</code> will be made <script type="math/tex; mode=display">\\binom{i+j}{i}</script> times, and strings of the order <script type="math/tex; mode=display">O(T - i)</script> and <script type="math/tex; mode=display">O(P - 2*j)</script> will be made.  Thus, the complexity has the order <script type="math/tex; mode=display">\\sum_{i = 0}^T \\sum_{j = 0}^{P/2} \\binom{i+j}{i} O(T+P-i-2j)</script>.  With some effort outside the scope of this article, we can show this is bounded by <script type="math/tex; mode=display">O\\big((T+P)2^{T + \\frac{P}{2}}\\big)</script>.</p>\n</li>\n<li>\n<p>Space Complexity:  For every call to <code>match</code>, we will create those strings as described above, possibly creating duplicates.  If memory is not freed, this will also take a total of <script type="math/tex; mode=display">O\\big((T+P)2^{T + \\frac{P}{2}}\\big)</script> space, even though there are only order <script type="math/tex; mode=display">O(T^2 + P^2)</script> unique suffixes of <script type="math/tex; mode=display">P</script> and  <script type="math/tex; mode=display">T</script> that are actually required.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-dynamic-programming-accepted">Approach #2: Dynamic Programming [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>As the problem has an <strong>optimal substructure</strong>, it is natural to cache intermediate results.  We ask the question <script type="math/tex; mode=display">\\text{dp(i, j)}</script>: does <script type="math/tex; mode=display">\\text{text[i:]}</script> and <script type="math/tex; mode=display">\\text{pattern[j:]}</script> match?  We can describe our answer in terms of answers to questions involving smaller strings.</p>\n<p><strong>Algorithm</strong></p>\n<p>We proceed with the same recursion as in Approach #1, except because calls will only ever be made to <code>match(text[i:], pattern[j:])</code>, we use <script type="math/tex; mode=display">\\text{dp(i, j)}</script> to handle those calls instead, saving us expensive string-building operations and allowing us to cache the intermediate results.</p>\n<p><em>Top-Down Variation</em>\n<iframe frameborder="0" height="515" name="cn5nKUtP" src="https://leetcode.com/playground/cn5nKUtP/shared" width="100%"></iframe></p>\n<p><em>Bottom-Up Variation</em></p>\n<iframe frameborder="0" height="394" name="bWZCQWWe" src="https://leetcode.com/playground/bWZCQWWe/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: Let <script type="math/tex; mode=display">T, P</script> be the lengths of the text and the pattern respectively.  The work for every call to <code>dp(i, j)</code> for <script type="math/tex; mode=display">i=0, ... ,T</script>; <script type="math/tex; mode=display">j=0, ... ,P</script> is done once, and it is <script type="math/tex; mode=display">O(1)</script> work.  Hence, the time complexity is <script type="math/tex; mode=display">O(TP)</script>.</p>\n</li>\n<li>\n<p>Space Complexity:  The only memory we use is the <script type="math/tex; mode=display">O(TP)</script> boolean entries in our cache.  Hence, the space complexity is <script type="math/tex; mode=display">O(TP)</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Google', 'Facebook', 'Uber', 'Twitter', 'Airbnb'],
  },
  {
    id: '11',
    name: 'Container With Most Water',
    acceptance: '36.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given <i>n</i> non-negative integers <i>a<sub>1</sub></i>, <i>a<sub>2</sub></i>, ..., <i>a<sub>n</sub></i>, where each represents a point at coordinate (<i>i</i>, <i>a<sub>i</sub></i>). <i>n</i> vertical lines are drawn such that the two endpoints of line <i>i</i> is at (<i>i</i>, <i>a<sub>i</sub></i>) and (<i>i</i>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n</p>\n<p>Note: You may not slant the container and <i>n</i> is at least 2.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-two-pointer-approach-accepted">Approach #2 (Two Pointer Approach) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>We have to maximize the Area that can be formed between the vertical lines using the shorter line as length and the distance between the lines as the width of the rectangle forming the area.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this case, we will simply consider the area for every possible pair of the lines and find out the maximum area out of those. </p>\n<iframe frameborder="0" height="207" name="KrMDEXWY" src="https://leetcode.com/playground/KrMDEXWY/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Calculating area for all <script type="math/tex; mode=display">\\frac{n(n-1)}{2}</script> height pairs.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</li>\n</ul>\n<hr>\n<h4 id="approach-2-two-pointer-approach-accepted">Approach #2 (Two Pointer Approach) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The intuition behind this approach is that the area formed between the lines will always be limited by the height of the shorter line. Further, the farther the lines, the more will be the area obtained.</p>\n<p>We take two pointers, one at the beginning and one at the end of the array constituting the length of the lines. Futher, we maintain a variable <script type="math/tex; mode=display">maxarea</script> to store the maximum area obtained till now. At every step, we find out the area formed between them, update <script type="math/tex; mode=display">maxarea</script> and move the pointer pointing to the shorter line towards the other end by one step.</p>\n<p>The algorithm can be better understood by looking at the example below:</p>\n<div class="codehilite"><pre><span></span>1 8 6 2 5 4 8 3 7\n</pre></div>\n<!--![Water_Continer](https://leetcode.com/media/original_images/11_Container_Water.gif)-->\n<p>!?!../Documents/11_Container_Water.json:1000,563!?!</p>\n<p>How this approach works?</p>\n<p>Initially we consider the area constituting the exterior most lines. Now, to maximize the area, we need to consider the area between the lines of larger lengths. If we try to move the pointer at the longer line inwards, we won\'t gain any increase in area, since it is limited by the shorter line. But moving the shorter line\'s pointer could turn out to be beneficial, as per the same argument, despite the reduction in the width. This is done since a relatively longer line obtained by moving the shorter line\'s pointer might overcome the reduction in area caused by the width reduction.</p>\n<p>For further clarification click <a href="https://discuss.leetcode.com/topic/3462/yet-another-way-to-see-what-happens-in-the-o-n-algorithm">here</a> and for the proof click <a href="https://discuss.leetcode.com/topic/503/anyone-who-has-a-o-n-algorithm/2">here</a>.</p>\n<iframe frameborder="0" height="275" name="VrTmDiy5" src="https://leetcode.com/playground/VrTmDiy5/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Single pass.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '12',
    name: 'Integer to Roman',
    acceptance: '45.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given an integer, convert it to a roman numeral.\n</p>\n\n<p>Input is guaranteed to be within the range from 1 to 3999.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Twitter'],
  },
  {
    id: '13',
    name: 'Roman to Integer',
    acceptance: '47.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a roman numeral, convert it to an integer.</p>\n\n<p>Input is guaranteed to be within the range from 1 to 3999.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Bloomberg', 'Uber', 'Yahoo'],
  },
  {
    id: '14',
    name: 'Longest Common Prefix',
    acceptance: '31.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Write a function to find the longest common prefix string amongst an array of strings.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-horizontal-scanning">Approach #1 (Horizontal scanning)</a></li>\n<li><a href="#approach-2-vertical-scanning">Approach #2 (Vertical scanning)</a></li>\n<li><a href="#approach-3-divide-and-conquer">Approach #3 (Divide and conquer)</a></li>\n<li><a href="#approach-4-binary-search">Approach #4  (Binary search)</a></li>\n</ul>\n</li>\n<li><a href="#further-thoughts-follow-up">Further Thoughts / Follow up</a></li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-horizontal-scanning">Approach #1 (Horizontal scanning)</h4>\n<p><strong>Intuition</strong></p>\n<p>For a start we will describe a simple way of finding the longest prefix shared by a set of strings <script type="math/tex; mode=display">LCP(S_1  \\ldots  S_n)</script>.\nWe will use the observation that :</p>\n<p>\n<script type="math/tex; mode=display">LCP(S_1 \\ldots S_n) = LCP(LCP(LCP(S_1, S_2),S_3),\\ldots S_n)</script>\n</p>\n<p><strong>Algorithm</strong></p>\n<p>To employ this idea, the algorithm iterates through the strings <script type="math/tex; mode=display">[S_1  \\ldots  S_n]</script>, finding at each iteration <script type="math/tex; mode=display">i</script> the longest common prefix of strings <script type="math/tex; mode=display">LCP(S_1  \\ldots  S_i)</script> When <script type="math/tex; mode=display">LCP(S_1  \\ldots  S_i)</script> is an empty string, the algorithm ends. Otherwise after <script type="math/tex; mode=display">n</script> iterations, the algorithm returns <script type="math/tex; mode=display">LCP(S_1  \\ldots  S_n)</script>.</p>\n<p align="center"><img alt="Finding the longest common prefix" src="https://leetcode.com/media/original_images/14_basic.png" width="539px"></p>\n<p align="center"><em>Figure 1. Finding the longest common prefix (Horizontal scanning)</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="n">String</span> <span class="nf">longestCommonPrefix</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="s">""</span><span class="o">;</span>\n    <span class="n">String</span> <span class="n">prefix</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">indexOf</span><span class="o">(</span><span class="n">prefix</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">prefix</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">return</span> <span class="s">""</span><span class="o">;</span>\n        <span class="o">}</span>        \n    <span class="k">return</span> <span class="n">prefix</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(S)</script> , where S is the sum of all characters in all strings.</li>\n</ul>\n<p>In the worst case all <script type="math/tex; mode=display">n</script> strings are the same. The algorithm compares the string <script type="math/tex; mode=display">S1</script> with the other strings <script type="math/tex; mode=display">[S_2 \\ldots S_n]</script> There are <script type="math/tex; mode=display">S</script> character comparisons, where <script type="math/tex; mode=display">S</script> is the sum of all characters in the input array.</p>\n<ul>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>.\nWe only used constant extra space.</li>\n</ul>\n<hr>\n<h4 id="approach-2-vertical-scanning">Approach #2 (Vertical scanning)</h4>\n<p><strong>Algorithm</strong></p>\n<p>Imagine a very short string is at the end of the array. The above approach will still do <script type="math/tex; mode=display">S</script> comparisons. One way to optimize this case is to do vertical scanning. We compare characters from top to bottom on the same column (same character index of  the strings) before moving on to the next column.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="n">String</span> <span class="nf">longestCommonPrefix</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">strs</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="s">""</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">()</span> <span class="o">;</span> <span class="n">i</span><span class="o">++){</span>\n        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span> <span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">strs</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">length</span><span class="o">()</span> <span class="o">||</span> <span class="n">strs</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">c</span><span class="o">)</span>\n                <span class="k">return</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>             \n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(S)</script> , where S is the sum of all characters in all strings.\nIn the worst case there will be <script type="math/tex; mode=display">n</script> equal strings with length <script type="math/tex; mode=display">m</script> and the algorithm performs  <script type="math/tex; mode=display">S = m*n</script> character comparisons.\nEven though the worst case is still the same as Approach #1, in the best case there are at most <script type="math/tex; mode=display">n*minLen</script> comparisons where <script type="math/tex; mode=display">minLen</script> is the length of the shortest string in the array.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>.\nWe only used constant extra space.</li>\n</ul>\n<hr>\n<h4 id="approach-3-divide-and-conquer">Approach #3 (Divide and conquer)</h4>\n<p><strong>Intuition</strong></p>\n<p>The idea of the algorithm comes from the associative property of LCP operation. We notice that :\n<script type="math/tex; mode=display">LCP(S_1 \\ldots S_n) = LCP(LCP(S_1 \\ldots S_k), LCP (S_{k+1} \\ldots S_n))</script>\n, where <script type="math/tex; mode=display">LCP(S_1 \\ldots S_n)</script> is the longest common prefix in set of strings <script type="math/tex; mode=display">[S_1 \\ldots S_n]</script> , <script type="math/tex; mode=display">1 < k < n</script>\n</p>\n<p><strong>Algorithm</strong></p>\n<p>To apply the observation above, we use divide and conquer technique, where we split the <script type="math/tex; mode=display">LCP(S_i \\ldots S_j)</script> problem into two subproblems <script type="math/tex; mode=display">LCP(S_i \\ldots S_{mid})</script>   and <script type="math/tex; mode=display">LCP(S_{mid+1} \\ldots S_j)</script>, where <code>mid</code> is <script type="math/tex; mode=display">\\frac{i + j}{2}</script>. We use their solutions <code>lcpLeft</code> and <code>lcpRight</code> to construct the solution of the main problem <script type="math/tex; mode=display">LCP(S_i \\ldots S_j)</script>. To accomplish this we compare one by one the characters of <code>lcpLeft</code> and <code>lcpRight</code> till there is no character match. The found common prefix of <code>lcpLeft</code> and <code>lcpRight</code> is the solution of the  <script type="math/tex; mode=display">LCP(S_i \\ldots S_j)</script>.</p>\n<p align="center"><img alt="Finding the longest common prefix" src="https://leetcode.com/media/original_images/14_lcp_diviso_et_lmpera.png" width="539px"></p>\n<p align="center"><em>Figure 2. Finding the longest common prefix of strings using divide and conquer technique</em></p>\n<p><strong>Java</strong> </p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="n">String</span> <span class="nf">longestCommonPrefix</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">strs</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="s">""</span><span class="o">;</span>    \n        <span class="k">return</span> <span class="n">longestCommonPrefix</span><span class="o">(</span><span class="n">strs</span><span class="o">,</span> <span class="mi">0</span> <span class="o">,</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="n">String</span> <span class="nf">longestCommonPrefix</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">return</span> <span class="n">strs</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>\n    <span class="o">}</span>\n    <span class="k">else</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>\n        <span class="n">String</span> <span class="n">lcpLeft</span> <span class="o">=</span>   <span class="n">longestCommonPrefix</span><span class="o">(</span><span class="n">strs</span><span class="o">,</span> <span class="n">l</span> <span class="o">,</span> <span class="n">mid</span><span class="o">);</span>\n        <span class="n">String</span> <span class="n">lcpRight</span> <span class="o">=</span>  <span class="n">longestCommonPrefix</span><span class="o">(</span><span class="n">strs</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span><span class="n">r</span><span class="o">);</span>\n        <span class="k">return</span> <span class="n">commonPrefix</span><span class="o">(</span><span class="n">lcpLeft</span><span class="o">,</span> <span class="n">lcpRight</span><span class="o">);</span>\n   <span class="o">}</span>\n<span class="o">}</span>\n\n<span class="n">String</span> <span class="nf">commonPrefix</span><span class="o">(</span><span class="n">String</span> <span class="n">left</span><span class="o">,</span><span class="n">String</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">left</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">right</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>       \n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">min</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span> <span class="n">left</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">)</span>\n            <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">min</span><span class="o">);</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>In the worst case we have <script type="math/tex; mode=display">n</script> equal strings with length <script type="math/tex; mode=display">m</script>\n</p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(S)</script>, where <script type="math/tex; mode=display">S</script> is the number of all characters in the array, <script type="math/tex; mode=display">S = m*n</script>\n Time complexity is <script type="math/tex; mode=display">T(n) = 2 T(\\frac{n}{2}) + O(m)</script>. Therefore time complexity is <script type="math/tex; mode=display">O(S)</script>.\n  In the best case this algorithm performs  <script type="math/tex; mode=display">O(minLen*n)</script> comparisons, where  <script type="math/tex; mode=display">minLen</script> is the shortest string of the array</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m*log(n))</script>\n</p>\n</li>\n</ul>\n<p>There is a memory overhead since we store recursive calls in the execution stack. There are <script type="math/tex; mode=display">log(n)</script> recursive calls, each store need <script type="math/tex; mode=display">m</script> space to store the result,  so space complexity is <script type="math/tex; mode=display">O(m*log(n))</script>\n</p>\n<hr>\n<h4 id="approach-4-binary-search">Approach #4  (Binary search)</h4>\n<p>The idea is to apply binary search method to find the string with maximum value <code>L</code>, which is common prefix of all of the strings. The algorithm searches space is the interval <script type="math/tex; mode=display">(0 \\ldots minLen)</script>, where <code>minLen</code> is minimum string length and the maximum possible common prefix. Each time search space is divided in two equal parts, one of them is discarded, because it is sure that it doesn\'t contain the solution. There are two possible cases:\n<em> <code>S[1...mid]</code> is not a common string. This means that for each <code>j &gt; i S[1..j]</code> is not a common string and we discard the second half of the  search space.\n</em> <code>S[1...mid]</code> is common string. This means that for for each <code>i &lt; j S[1..i]</code> is a common string and we discard the first half of the search space, because we try to find longer common prefix.</p>\n<p align="center"><img alt="Finding the longest common prefix" src="https://leetcode.com/media/original_images/14_lcp_binary_search.png" width="539px"></p>\n<p align="center"><em>Figure 3. Finding the longest common prefix of strings using binary search technique</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="n">String</span> <span class="nf">longestCommonPrefix</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">strs</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>\n        <span class="k">return</span> <span class="s">""</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">minLen</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">str</span> <span class="o">:</span> <span class="n">strs</span><span class="o">)</span>\n        <span class="n">minLen</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minLen</span><span class="o">,</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>\n    <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">minLen</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="o">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">isCommonPrefix</span><span class="o">(</span><span class="n">strs</span><span class="o">,</span> <span class="n">middle</span><span class="o">))</span>\n            <span class="n">low</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="k">else</span>\n            <span class="n">high</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">);</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isCommonPrefix</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">){</span>\n    <span class="n">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">len</span><span class="o">);</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>\n        <span class="k">if</span> <span class="o">(!</span><span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">startsWith</span><span class="o">(</span><span class="n">str1</span><span class="o">))</span>\n            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>In the worst case we have <script type="math/tex; mode=display">n</script> equal strings with length <script type="math/tex; mode=display">m</script>\n</p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(S*log(n))</script>, where <script type="math/tex; mode=display">S</script> is the sum of all characters in all strings.</li>\n</ul>\n<p>The algorithm makes <script type="math/tex; mode=display">log(n)</script> iterations, for each of them there are <script type="math/tex; mode=display">S =  m*n</script> comparisons, which gives in total <script type="math/tex; mode=display">O(S*log(n))</script> time complexity.</p>\n<ul>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</li>\n</ul>\n<p>We only used constant extra space.</p>\n<h2 id="further-thoughts-follow-up">Further Thoughts / Follow up</h2>\n<p>Let\'s take a look at a slightly different problem:</p>\n<blockquote>\n<p>Given a set of keys S = <script type="math/tex; mode=display">[S_1,S_2 \\ldots S_n]</script>, find the longest common prefix among a string <code>q</code> and S. This LCP query will be called frequently.</p>\n</blockquote>\n<p>We could optimize LCP queries by storing the set of keys S in a Trie. For more information about Trie, please see this article <a href="https://leetcode.com/articles/implement-trie-prefix-tree/">Implement a trie (Prefix trie)</a>. In a Trie, each node descending from the root represents a common prefix of some keys. But we need to find the longest common prefix of a string <code>q</code> and all key strings. This means that we have to find the deepest path from the root, which satisfies the following conditions:\n<em> it is prefix of query string <code>q</code>\n</em> each node along the path must contain only one child element. Otherwise the found path will not be a common prefix among all strings.\n* the path doesn\'t comprise of nodes which are marked as end of key. Otherwise the path couldn\'t be a prefix a of key which is shorter than itself.</p>\n<p><strong>Algorithm</strong></p>\n<p>The only question left, is how to find the deepest path in the Trie, that fulfills the requirements above. The most effective way is to build a trie from <script type="math/tex; mode=display">[S_1 \\ldots   S_n]</script> strings. Then find the prefix of query string <code>q</code> in the Trie. We traverse the Trie from the root, till it is impossible to continue the path in the Trie because one of the conditions above is not satisfied.</p>\n<p align="center"><img alt="Finding the longest common prefix using Trie" src="https://leetcode.com/media/original_images/14_lcp_trie.png" width="539px"></p>\n<p align="center"><em>Figure 4. Finding the longest common prefix of strings using Trie</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="n">String</span> <span class="nf">longestCommonPrefix</span><span class="o">(</span><span class="n">String</span> <span class="n">q</span><span class="o">,</span> <span class="n">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">strs</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>\n         <span class="k">return</span> <span class="s">""</span><span class="o">;</span>  \n    <span class="k">if</span> <span class="o">(</span><span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>\n         <span class="k">return</span> <span class="n">strs</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>\n    <span class="n">Trie</span> <span class="n">trie</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Trie</span><span class="o">();</span>      \n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strs</span><span class="o">.</span><span class="na">length</span> <span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="n">trie</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">strs</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">trie</span><span class="o">.</span><span class="na">searchLongestPrefix</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>\n<span class="o">}</span>\n\n<span class="kd">class</span> <span class="nc">TrieNode</span> <span class="o">{</span>\n\n    <span class="c1">// R links to node children</span>\n    <span class="kd">private</span> <span class="n">TrieNode</span><span class="o">[]</span> <span class="n">links</span><span class="o">;</span>\n\n    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="mi">26</span><span class="o">;</span>\n\n    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isEnd</span><span class="o">;</span>\n\n    <span class="c1">// number of children non null links</span>\n    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>    \n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch</span><span class="o">,</span> <span class="n">TrieNode</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">links</span><span class="o">[</span><span class="n">ch</span> <span class="o">-</span><span class="sc">\'a\'</span><span class="o">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>\n        <span class="n">size</span><span class="o">++;</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getLinks</span><span class="o">()</span> <span class="o">{</span>\n        <span class="k">return</span> <span class="n">size</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="c1">//assume methods containsKey, isEnd, get, put are implemented as it is described</span>\n   <span class="c1">//in  https://leetcode.com/articles/implement-trie-prefix-tree/)</span>\n<span class="o">}</span>\n\n<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Trie</span> <span class="o">{</span>\n\n    <span class="kd">private</span> <span class="n">TrieNode</span> <span class="n">root</span><span class="o">;</span>\n\n    <span class="kd">public</span> <span class="nf">Trie</span><span class="o">()</span> <span class="o">{</span>\n        <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TrieNode</span><span class="o">();</span>\n    <span class="o">}</span>\n\n<span class="c1">//assume methods insert, search, searchPrefix are implemented as it is described</span>\n<span class="c1">//in  https://leetcode.com/articles/implement-trie-prefix-tree/)</span>\n    <span class="kd">private</span> <span class="n">String</span> <span class="nf">searchLongestPrefix</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>\n        <span class="n">StringBuilder</span> <span class="n">prefix</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="kt">char</span> <span class="n">curLetter</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">curLetter</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getLinks</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(!</span><span class="n">node</span><span class="o">.</span><span class="na">isEnd</span><span class="o">()))</span> <span class="o">{</span>\n                <span class="n">prefix</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">curLetter</span><span class="o">);</span>\n                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">curLetter</span><span class="o">);</span>\n            <span class="o">}</span>\n            <span class="k">else</span>\n                <span class="k">return</span> <span class="n">prefix</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>\n\n         <span class="o">}</span>\n         <span class="k">return</span> <span class="n">prefix</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong>\nIn the worst case query <script type="math/tex; mode=display">q</script> has length <script type="math/tex; mode=display">m</script> and it is equal to all <script type="math/tex; mode=display">n</script> strings of the array.</p>\n<ul>\n<li>Time complexity : preprocessing <script type="math/tex; mode=display">O(S)</script>, where <script type="math/tex; mode=display">S</script> is the number of all characters in the array, LCP query <script type="math/tex; mode=display">O(m)</script>\n</li>\n</ul>\n<p>Trie build has <script type="math/tex; mode=display">O(S)</script> time complexity. To find the common prefix of <script type="math/tex; mode=display">q</script> in the Trie takes in the worst case <script type="math/tex; mode=display">O(m)</script>.</p>\n<ul>\n<li>Space complexity : <script type="math/tex; mode=display">O(S)</script>\n</li>\n</ul>\n<p>We only used additional  <script type="math/tex; mode=display">S</script> extra space for the Trie.</p>\n<p>Analysis written by: @elmirap.</p>\n</div>\n          ',
    tags: ['Yelp'],
  },
  {
    id: '15',
    name: '3Sum',
    acceptance: '21.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given an array <i>S</i> of <i>n</i> integers, are there elements <i>a</i>, <i>b</i>, <i>c</i> in <i>S</i> such that <i>a</i> + <i>b</i> + <i>c</i> = 0? Find all unique triplets in the array which gives the sum of zero.</p>\n\n<p><b>Note:</b> The solution set must not contain duplicate triplets.</p>\n\n<pre>For example, given array S = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n</pre>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Amazon', 'Bloomberg', 'Adobe', 'Works Applications'],
  },
  {
    id: '16',
    name: '3Sum Closest',
    acceptance: '31.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given an array <i>S</i> of <i>n</i> integers, find three integers in <i>S</i> such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>\n\n<pre>    For example, given array S = {-1 2 1 -4}, and target = 1.\n\n    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n</pre>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '17',
    name: 'Letter Combinations of a Phone Number',
    acceptance: '35.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a digit string, return all possible letter combinations that the number could represent.\n</p>\n\n<p>\nA mapping of digit to letters (just like on the telephone buttons) is given below.</p>\n<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png"></p>\n\n<pre><b>Input:</b>Digit string "23"\n<b>Output:</b> ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].\n</pre>\n\n<p>\n<b>Note:</b><br>\nAlthough the above answer is in lexicographical order, your answer could be in any order you want.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Amazon', 'Uber', 'Dropbox'],
  },
  {
    id: '18',
    name: '4Sum',
    acceptance: '27.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given an array <i>S</i> of <i>n</i> integers, are there elements <i>a</i>, <i>b</i>, <i>c</i>, and <i>d</i> in <i>S</i> such that <i>a</i> + <i>b</i> + <i>c</i> + <i>d</i> = target? Find all unique quadruplets in the array which gives the sum of target.</p>\n\n<p><b>Note:</b> The solution set must not contain duplicate quadruplets.\n</p>\n\n<pre>For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.\n\nA solution set is:\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]\n</pre>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '19',
    name: 'Remove Nth Node From End of List',
    acceptance: '34.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a linked list, remove the <i>n</i><sup>th</sup> node from the end of list and return its head.</p>\n\n<p>\nFor example,</p>\n\n<pre>   Given linked list: <b>1-&gt;2-&gt;3-&gt;4-&gt;5</b>, and <b><i>n</i> = 2</b>.\n\n   After removing the second node from the end, the linked list becomes <b>1-&gt;2-&gt;3-&gt;5</b>.\n</pre>\n\n<p>\n<b>Note:</b><br>\nGiven <i>n</i> will always be valid.<br>\nTry to do this in one pass.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-two-pass-algorithm">Approach #1 (Two pass algorithm)</a></li>\n<li><a href="#approach-2-one-pass-algorithm">Approach #2 (One pass algorithm)</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This article is for beginners. It introduces the following idea:\nLinked List traversal and removal of nth element from the end.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-two-pass-algorithm">Approach #1 (Two pass algorithm)</h4>\n<p><strong>Intuition</strong></p>\n<p>We notice that the problem could be simply reduced to another one : Remove the <script type="math/tex; mode=display">(L - n + 1)</script> th node from the beginning in the list , where <script type="math/tex; mode=display">L</script> is the list length. This problem is easy to solve once we found list length <script type="math/tex; mode=display">L</script>.</p>\n<p><strong>Algorithm</strong></p>\n<p>First we will add an auxiliary "dummy" node, which points to the list head. The "dummy" node is used to simplify some corner cases such as a list with only one node, or removing the head of the list. On the first pass, we find the list length <script type="math/tex; mode=display">L</script>. Then we set a pointer to the dummy node and start to move it through the list till it comes to the <script type="math/tex; mode=display">(L - n)</script> th node. We relink <code>next</code> pointer of the <script type="math/tex; mode=display">(L - n)</script> th node to the <script type="math/tex; mode=display">(L - n + 2)</script> th node and we are done.</p>\n<p align="center"><img alt="Remove the nth element from a list" src="https://leetcode.com/media/original_images/19_Remove_nth_node_from_end_of_listA.png"></p>\n<p align="center"><em>Figure 1. Remove the L - n + 1 th element from a list.</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">removeNthFromEnd</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>\n    <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">length</span>  <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="n">ListNode</span> <span class="n">first</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">first</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">length</span><span class="o">++;</span>\n        <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="n">length</span> <span class="o">-=</span> <span class="n">n</span><span class="o">;</span>\n    <span class="n">first</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">length</span><span class="o">--;</span>\n        <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="n">first</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>\n    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(L)</script>.</li>\n</ul>\n<p>The algorithm makes two traversal of the list, first to calculate list length <script type="math/tex; mode=display">L</script> and second to find the <script type="math/tex; mode=display">(L - n)</script> th node. There are <script type="math/tex; mode=display">2L-n</script> operations and time complexity is <script type="math/tex; mode=display">O(L)</script>.</p>\n<ul>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>.\nWe only used constant extra space.</li>\n</ul>\n<hr>\n<h4 id="approach-2-one-pass-algorithm">Approach #2 (One pass algorithm)</h4>\n<p><strong>Algorithm</strong></p>\n<p>The above algorithm could be optimized to one pass. Instead of one pointer, we could use two pointers. The first pointer advances the list by <script type="math/tex; mode=display">n+1</script> steps from the beginning, while the second pointer starts from the beginning of the list. Now, both pointers are exactly separated by <script type="math/tex; mode=display">n</script> nodes apart. We maintain this constant gap by advancing both pointers together until the first pointer arrives past the last node. The second pointer will be pointing at the <script type="math/tex; mode=display">n</script>th node counting from the last.\nWe relink the next pointer of the node referenced by the second pointer to point to the node\'s next next node.</p>\n<p align="center"><img alt="Remove the nth element from a list" src="https://leetcode.com/media/original_images/19_Remove_nth_node_from_end_of_listB.png"></p>\n<p align="center"><em>Figure 2. Remove the nth element from end of a list.</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">removeNthFromEnd</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>\n    <span class="n">dummy</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>\n    <span class="n">ListNode</span> <span class="n">first</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>\n    <span class="n">ListNode</span> <span class="n">second</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>\n    <span class="c1">// Advances first pointer so that the gap between first and second is n nodes apart</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="c1">// Move first to the end, maintaining the gap</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">first</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>\n        <span class="n">second</span> <span class="o">=</span> <span class="n">second</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="n">second</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">second</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>\n    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(L)</script>. The algorithm makes one traversal of the list of <script type="math/tex; mode=display">L</script> nodes. Therefore time complexity is <script type="math/tex; mode=display">O(L)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.\nWe only used constant extra space.</p>\n</li>\n</ul>\n<p>Analysis written by: @elmirap.</p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '20',
    name: 'Valid Parentheses',
    acceptance: '33.7%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>Given a string containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid.</p>\n\n<p>The brackets must close in the correct order, <code>\"()\"</code> and <code>\"()[]{}\"</code> are all valid but <code>\"(]\"</code> and <code>\"([)]\"</code> are not.</p>\n\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Microsoft', 'Amazon', 'Bloomberg', 'Twitter', 'Airbnb', 'Zenefits'],
  },
  {
    id: '21',
    name: 'Merge Two Sorted Lists',
    acceptance: '39.5%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>\n\n<p><b>Example:</b>\n</p><pre><b>Input:</b> 1-&gt;2-&gt;4, 1-&gt;3-&gt;4\n<b>Output:</b> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-recursion-accepted">Approach #1 Recursion [Accepted]</a></li>\n<li><a href="#approach-2-iteration-accepted">Approach #2 Iteration [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-recursion-accepted">Approach #1 Recursion [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can recursively define the result of a <code>merge</code> operation on two lists as\nthe following (avoiding the corner case logic surrounding empty lists):</p>\n<p>\n<script type="math/tex; mode=display">\n\\left\\{\n\\begin{array}{ll}\n      list1[0] + merge(list1[1:], list2) & list1[0] < list2[0] \\\\\n      list2[0] + merge(list1, list2[1:]) & otherwise\n\\end{array} \n\\right.\n</script>\n</p>\n<p>Namely, the smaller of the two lists\' heads plus the result of a <code>merge</code> on\nthe rest of the elements.</p>\n<p><strong>Algorithm</strong></p>\n<p>We model the above recurrence directly, first accounting for edge cases.\nSpecifically, if either of <code>l1</code> or <code>l2</code> is initially <code>null</code>, there is no\nmerge to perform, so we simply return the non-<code>null</code> list. Otherwise, we\ndetermine which of <code>l1</code> and <code>l2</code> has a smaller head, and recursively set the\n<code>next</code> value for that head to the next merge result. Given that both lists\nare <code>null</code>-terminated, the recursion will eventually terminate.</p>\n<iframe frameborder="0" height="378" name="H4rjeobq" src="https://leetcode.com/playground/H4rjeobq/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n + m)</script>\n</p>\n<p>Because each recursive call increments the pointer to <code>l1</code> or <code>l2</code> by one\n(approaching the dangling <code>null</code> at the end of each list), there will be\nexactly one call to <code>mergeTwoLists</code> per element in each list. Therefore,\nthe time complexity is linear in the combined size of the lists.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n + m)</script>\n</p>\n<p>The first call to <code>mergeTwoLists</code> does not return until the ends of both\n<code>l1</code> and <code>l2</code> have been reached, so <script type="math/tex; mode=display">n + m</script> stack frames consume\n<script type="math/tex; mode=display">O(n+m)</script> space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-iteration-accepted">Approach #2 Iteration [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can achieve the same idea via iteration by assuming that <code>l1</code> is entirely\nless than <code>l2</code> and processing the elements one-by-one, inserting elements of\n<code>l2</code> in the necessary places in <code>l1</code>.</p>\n<p><strong>Algorithm</strong></p>\n<p>First, we set up a false "<code>prehead</code>" node that allows us to easily return the\nhead of the merged list later. We also maintain a <code>prev</code> pointer, which\npoints to the current node for which we are considering adjusting its <code>next</code>\npointer. Then, we do the following until at least one of <code>l1</code> and <code>l2</code> points\nto <code>null</code>: if the value at <code>l1</code> is less than or equal to the value at <code>l2</code>,\nthen we connect <code>l1</code> to the previous node and increment <code>l1</code>. Otherwise, we\ndo the same, but for <code>l2</code>. Then, regardless of which list we connected, we\nincrement <code>prev</code> to keep it one step behind one of our list heads.</p>\n<p>After the loop terminates, at most one of <code>l1</code> and <code>l2</code> is non-<code>null</code>.\nTherefore (because the input lists were in sorted order), if either list is\nnon-<code>null</code>, it contains only elements greater than all of the\npreviously-merged elements. This means that we can simply connect the\nnon-<code>null</code> list to the merged list and return it.</p>\n<p>To see this in action on an example, check out the animation below:</p>\n<p>!?!../Documents/21_Merge_Two_Sorted_Lists.json:1280,720!?!</p>\n<iframe frameborder="0" height="463" name="LPmyTYwo" src="https://leetcode.com/playground/LPmyTYwo/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n + m)</script>\n</p>\n<p>Because exactly one of <code>l1</code> and <code>l2</code> is incremented on each loop\niteration, the <code>while</code> loop runs for a number of iterations equal to the\nsum of the lengths of the two lists. All other work is constant, so the\noverall complexity is linear.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n<p>The iterative approach only allocates a few pointers, so it has a\nconstant overall memory footprint.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis and recursive solution written by: <a href="https://leetcode.com/emptyset">@emptyset</a></p>\n<p>Iterative solution written by: <a href="https://leetcode.com/1337c0d3r/">@1337c0d3r</a></p>\n</div>\n          ',
    tags: ['Microsoft', 'Amazon', 'LinkedIn', 'Apple'],
  },
  {
    id: '22',
    name: 'Generate Parentheses',
    acceptance: '46.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven <i>n</i> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n</p>\n\n<p>\nFor example, given <i>n</i> = 3, a solution set is:\n</p>\n<pre>[\n  "((()))",\n  "(()())",\n  "(())()",\n  "()(())",\n  "()()()"\n]\n</pre>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-backtracking-accepted">Approach #2: Backtracking [Accepted]</a></li>\n<li><a href="#approach-3-closure-number-accepted">Approach #3: Closure Number [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can generate all <script type="math/tex; mode=display">2^{2n}</script> sequences of <code>\'(\'</code> and <code>\')\'</code> characters.  Then, we will check if each one is valid.</p>\n<p><strong>Algorithm</strong></p>\n<p>To generate all sequences, we use a recursion.  All sequences of length <code>n</code> is just <code>\'(\'</code> plus all sequences of length <code>n-1</code>, and then <code>\')\'</code> plus all sequences of length <code>n-1</code>.</p>\n<p>To check whether a sequence is valid, we keep track of <code>balance</code>, the net number of opening brackets minus closing brackets.  If it falls below zero at any time, or doesn\'t end in zero, the sequence is invalid - otherwise it is valid.</p>\n<iframe frameborder="0" height="500" name="kQgWndgY" src="https://leetcode.com/playground/kQgWndgY/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity : <script type="math/tex; mode=display">O(2^{2n}n)</script>.  For each of <script type="math/tex; mode=display">2^{2n}</script> sequences, we need to create and validate the sequence, which takes <script type="math/tex; mode=display">O(n)</script> work.</p>\n</li>\n<li>\n<p>Space Complexity : <script type="math/tex; mode=display">O(2^{2n}n)</script>.  Naively, every sequence could be valid.  See <em>Approach #3</em> for development of a tighter asymptotic bound.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-backtracking-accepted">Approach #2: Backtracking [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Instead of adding <code>\'(\'</code> or <code>\')\'</code> every time as in <em>Approach #1</em>, let\'s only add them when we know it will remain a valid sequence.  We can do this by keeping track of the number of opening and closing brackets we have placed so far.</p>\n<p>We can start an opening bracket if we still have one (of <code>n</code>) left to place.  And we can start a closing bracket if it would not exceed the number of opening brackets.</p>\n<iframe frameborder="0" height="378" name="TYczBrmL" src="https://leetcode.com/playground/TYczBrmL/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<p>Our complexity analysis rests on understanding how many elements there are in <code>generateParenthesis(n)</code>.  This analysis is outside the scope of this article, but it turns out this is the <code>n</code>-th Catalan number <script type="math/tex; mode=display">\\frac{1}{n+1}\\binom{2n}{n}</script>, which is bounded asymptotically by <script type="math/tex; mode=display">\\frac{4^n}{n\\sqrt{n}}</script>.</p>\n<ul>\n<li>\n<p>Time Complexity : <script type="math/tex; mode=display">O(\\frac{4^n}{\\sqrt{n}})</script>.  Each valid sequence has at most <code>n</code> steps during the backtracking procedure.</p>\n</li>\n<li>\n<p>Space Complexity : <script type="math/tex; mode=display">O(\\frac{4^n}{\\sqrt{n}})</script>, as described above, and using <script type="math/tex; mode=display">O(n)</script> space to store the sequence.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-closure-number-accepted">Approach #3: Closure Number [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>To enumerate something, generally we would like to express it as a sum of disjoint subsets that are easier to count.</p>\n<p>Consider the <em>closure number</em> of a valid parentheses sequence <code>S</code>: the least <code>index &gt;= 0</code> so that <code>S[0], S[1], ..., S[2*index+1]</code> is valid.  Clearly, every parentheses sequence has a unique <em>closure number</em>.  We can try to enumerate them individually.</p>\n<p><strong>Algorithm</strong></p>\n<p>For each closure number <code>c</code>, we know the starting and ending brackets must be at index <code>0</code> and <code>2*c + 1</code>. Then, the <code>2*c</code> elements between must be a valid sequence, plus the rest of the elements must be a valid sequence.</p>\n<iframe frameborder="0" height="293" name="V6CGHRUP" src="https://leetcode.com/playground/V6CGHRUP/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time and Space Complexity : <script type="math/tex; mode=display">O(\\frac{4^n}{\\sqrt{n}})</script>.  The analysis is similar to <em>Approach #2</em>.</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.  Approach #2 inspired by <a href="https://discuss.leetcode.com/topic/8724/easy-to-understand-java-backtracking-solution">@brobins9</a>.</p>\n</div>\n          ',
    tags: ['Google', 'Uber', 'Zenefits'],
  },
  {
    id: '23',
    name: 'Merge k Sorted Lists',
    acceptance: '27.8%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nMerge <i>k</i> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-compare-one-by-one-accepted">Approach #2 Compare one by one [Accepted]</a></li>\n<li><a href="#approach-3-optimize-approach-2-by-priority-queue-accepted">Approach #3 Optimize Approach 2 by Priority Queue [Accepted]</a></li>\n<li><a href="#approach-4-merge-lists-one-by-one-accepted">Approach #4 Merge lists one by one [Accepted]</a></li>\n<li><a href="#approach-5-merge-with-divide-and-conquer-accepted">Approach #5 Merge with Divide And Conquer [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</h4>\n<p><strong>Intuition &amp; Algorithm</strong></p>\n<ul>\n<li>Traverse all the linked lists and collect the values of the nodes into an array.</li>\n<li>Sort and iterate over this array to get the proper value of nodes.</li>\n<li>Create a new sorted linked list and extend it with the new nodes.</li>\n</ul>\n<p>As for sorting, you can refer <a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Sorting%20Algorithms/sorting.html">here</a> for more about sorting algorithms.</p>\n<iframe frameborder="0" height="326" name="JoCvtQU2" src="https://leetcode.com/playground/JoCvtQU2/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(N\\log N)</script> where <script type="math/tex; mode=display">N</script> is the total number of nodes. </p>\n<ul>\n<li>Collecting all the values costs <script type="math/tex; mode=display">O(N)</script> time.</li>\n<li>A stable sorting algorithm costs <script type="math/tex; mode=display">O(N\\log N)</script> time.</li>\n<li>Iterating for creating the linked list costs <script type="math/tex; mode=display">O(N)</script> time.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(N)</script>.</p>\n<ul>\n<li>Sorting cost <script type="math/tex; mode=display">O(N)</script> space (depends on the algorithm you choose).</li>\n<li>Creating a new linked list costs <script type="math/tex; mode=display">O(N)</script> space.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-compare-one-by-one-accepted">Approach #2 Compare one by one [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>Compare every <script type="math/tex; mode=display">\\text{k}</script> nodes (head of every linked list) and get the node with the smallest value.</li>\n<li>Extend the final sorted linked list with the selected nodes.</li>\n</ul>\n<p>!?!../Documents/23_Merge_lists.json:1000,563!?!</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(kN)</script> where <script type="math/tex; mode=display">\\text{k}</script> is the number of linked lists.</p>\n<ul>\n<li>Almost every selection of node in final linked costs <script type="math/tex; mode=display">O(k)</script> (<script type="math/tex; mode=display">\\text{k-1}</script> times comparison).</li>\n<li>There are <script type="math/tex; mode=display">N</script> nodes in the final linked list.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity :</p>\n<ul>\n<li>\n<script type="math/tex; mode=display">O(n)</script> Creating a new linked list costs <script type="math/tex; mode=display">O(n)</script> space.</li>\n<li>\n<script type="math/tex; mode=display">O(1)</script> It\'s not hard to apply in-place method - connect selected nodes instead of creating new nodes to fill the new linked list.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-optimize-approach-2-by-priority-queue-accepted">Approach #3 Optimize Approach 2 by Priority Queue [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Almost the same as the one above but optimize the <strong>comparison process</strong> by <strong>priority queue</strong>. You can refer <a href="https://en.wikipedia.org/wiki/Priority_queue">here</a> for more information about it.</p>\n<iframe frameborder="0" height="428" name="xxB9pdKV" src="https://leetcode.com/playground/xxB9pdKV/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(N\\log k)</script> where <script type="math/tex; mode=display">\\text{k}</script> is the number of linked lists.</p>\n<ul>\n<li>The comparison cost will be reduced to <script type="math/tex; mode=display">O(\\log k)</script> for every pop and insertion to priority queue. But finding the node with the smallest value just costs <script type="math/tex; mode=display">O(1)</script> time.</li>\n<li>There are <script type="math/tex; mode=display">N</script> nodes in the final linked list.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity :</p>\n<ul>\n<li>\n<script type="math/tex; mode=display">O(n)</script> Creating a new linked list costs <script type="math/tex; mode=display">O(n)</script> space.</li>\n<li>\n<script type="math/tex; mode=display">O(k)</script> The code above present applies in-place method which cost <script type="math/tex; mode=display">O(1)</script> space. And the priority queue (often implemented with heaps) costs <script type="math/tex; mode=display">O(k)</script> space (it\'s far less than <script type="math/tex; mode=display">N</script> in most situations).</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-merge-lists-one-by-one-accepted">Approach #4 Merge lists one by one [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Convert merge <script type="math/tex; mode=display">\\text{k}</script> lists problem to merge 2 lists (<script type="math/tex; mode=display">\\text{k-1}</script>) times. Here is the <a href="https://leetcode.com/problems/merge-two-sorted-lists/description/">merge 2 lists</a> problem page.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(kN)</script> where <script type="math/tex; mode=display">\\text{k}</script> is the number of linked lists.</p>\n<ul>\n<li>We can merge two sorted linked list in <script type="math/tex; mode=display">O(n)</script> time where <script type="math/tex; mode=display">n</script> is the total number of nodes in two lists.</li>\n<li>Sum up the merge process and we can get:  <script type="math/tex; mode=display">O(\\sum_{i=1}^{k-1} (i*(\\frac{N}{k}) + \\frac{N}{k})) = O(kN)</script>.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n<ul>\n<li>We can merge two sorted linked list in <script type="math/tex; mode=display">O(1)</script> space.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-merge-with-divide-and-conquer-accepted">Approach #5 Merge with Divide And Conquer [Accepted]</h4>\n<p><strong>Intuition &amp; Algorithm</strong></p>\n<p>This approach walks alongside the one above but is improved a lot. We don\'t need to traverse most nodes many times repeatedly</p>\n<ul>\n<li>\n<p>Pair up <script type="math/tex; mode=display">\\text{k}</script> lists and merge each pair.</p>\n</li>\n<li>\n<p>After the first pairing, <script type="math/tex; mode=display">\\text{k}</script> lists are merged into <script type="math/tex; mode=display">k/2</script> lists with average <script type="math/tex; mode=display">2N/k</script> length, then <script type="math/tex; mode=display">k/4</script>, <script type="math/tex; mode=display">k/8</script> and so on.</p>\n</li>\n<li>\n<p>Repeat this procedure until we get the final sorted linked list.</p>\n</li>\n</ul>\n<p>Thus, we\'ll traverse almost <script type="math/tex; mode=display">N</script> nodes per pairing and merging, and repeat this procedure about <script type="math/tex; mode=display">\\log_{2}{k}</script>  times.</p>\n<p align="align"><img alt="Divide_and_Conquer" src="https://leetcode.com/articles/Figures/23/23_divide_and_conquer_new.png"></p>\n<iframe frameborder="0" height="515" name="VfAbRJUb" src="https://leetcode.com/playground/VfAbRJUb/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(N\\log k)</script> where <script type="math/tex; mode=display">\\text{k}</script> is the number of linked lists.</p>\n<ul>\n<li>We can merge two sorted linked list in <script type="math/tex; mode=display">O(n)</script> time where <script type="math/tex; mode=display">n</script> is the total number of nodes in two lists.</li>\n<li>Sum up the merge process and we can get: <script type="math/tex; mode=display">O\\big(\\sum_{i=1}^{log_{2}{k}}N \\big)= O(N\\log k)</script>\n</li>\n</ul>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n<ul>\n<li>We can merge two sorted linked lists in <script type="math/tex; mode=display">O(1)</script> space.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/hermann">@Hermann0</a></p>\n</div>\n          ',
    tags: ['Google', 'Facebook', 'Microsoft', 'Amazon', 'Uber', 'LinkedIn', 'Twitter', 'Airbnb', 'IXL'],
  },
  {
    id: '24',
    name: 'Swap Nodes in Pairs',
    acceptance: '38.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a linked list, swap every two adjacent nodes and return its head.\n</p>\n\n<p>\nFor example,<br>\nGiven <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.\n</p>\n\n<p>\nYour algorithm should use only constant space. You may <b>not</b> modify the values in the list, only nodes itself can be changed.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft', 'Bloomberg', 'Uber'],
  },
  {
    id: '25',
    name: 'Reverse Nodes in k-Group',
    acceptance: '31.1%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a linked list, reverse the nodes of a linked list <i>k</i> at a time and return its modified list.\n</p>\n\n<p>\n<i>k</i> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <i>k</i> then left-out nodes in the end should remain as it is.</p>\n\n<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>\n\n<p>Only constant memory is allowed.</p>\n\n<p>\nFor example,<br>\nGiven this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>\n</p>\n\n<p>\nFor <i>k</i> = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code>\n</p>\n\n<p>\nFor <i>k</i> = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code>\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft'],
  },
  {
    id: '26',
    name: 'Remove Duplicates from Sorted Array',
    acceptance: '35.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a sorted array, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank"><b>in-place</b></a> such that each element appear only <i>once</i> and return the new length.</p>\n\n<p>Do not allocate extra space for another array, you must do this by <b>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">in-place</a></b> with O(1) extra memory.</p>\n\n<p>\n<b>Example:</b>\n</p><pre>Given <i>nums</i> = [1,1,2],\n\nYour function should return length = 2, with the first two elements of <i>nums</i> being 1 and 2 respectively.\nIt doesn\'t matter what you leave beyond the new length.\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-two-pointers-accepted">Approach #1 (Two Pointers) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-two-pointers-accepted">Approach #1 (Two Pointers) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Since the array is already sorted, we can keep two pointers <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script>, where <script type="math/tex; mode=display">i</script> is the slow-runner while <script type="math/tex; mode=display">j</script> is the fast-runner. As long as <script type="math/tex; mode=display">nums[i] = nums[j]</script>, we increment <script type="math/tex; mode=display">j</script> to skip the duplicate.</p>\n<p>When we encounter <script type="math/tex; mode=display">nums[j] \\neq nums[i]</script>, the duplicate run has ended so we must copy its value to <script type="math/tex; mode=display">nums[i + 1]</script>. <script type="math/tex; mode=display">i</script> is then incremented and we repeat the same process again until <script type="math/tex; mode=display">j</script> reaches the end of array.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeDuplicates</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>\n            <span class="n">i</span><span class="o">++;</span>\n            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complextiy : <script type="math/tex; mode=display">O(n)</script>.\nAssume that <script type="math/tex; mode=display">n</script> is the length of array. Each of <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> traverses at most <script type="math/tex; mode=display">n</script> steps.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: ['Facebook', 'Microsoft', 'Bloomberg'],
  },
  {
    id: '27',
    name: 'Remove Element',
    acceptance: '40.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given an array and a value, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank"><b>in-place</b></a> and return the new length.\n</p>\n\n<p>Do not allocate extra space for another array, you must do this by <b>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">in-place</a></b> with O(1) extra memory.</p>\n\n<p>The order of elements can be changed. It doesn\'t matter what you leave beyond the new length.</p>\n\n<p>\n<b>Example:</b>\n</p><pre>Given <b>nums</b> = [3,2,2,3], <b>val</b> = 3,\n\nYour function should return length = 2, with the first two elements of <i>nums</i> being 2.\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#hints">Hints</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-two-pointers-accepted">Approach #1 (Two Pointers) [Accepted]</a></li>\n<li><a href="#approach-2-two-pointers-when-elements-to-remove-are-rare-accepted">Approach #2 (Two Pointers - when elements to remove are rare) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This is a pretty easy problem, but one may get confused by the term "in-place" and thought it is impossible to remove an element from the array without making a copy of the array.</p>\n<h2 id="hints">Hints</h2>\n<ol>\n<li>Try two pointers.</li>\n<li>Did you use the property of "the order of elements can be changed"?</li>\n<li>What happens when the elements to remove are rare?</li>\n</ol>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-two-pointers-accepted">Approach #1 (Two Pointers) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Since question asked us to remove all elements of the given value in-place, we have to handle it with <script type="math/tex; mode=display">O(1)</script> extra space. How to solve it? We can keep two pointers <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script>, where <script type="math/tex; mode=display">i</script> is the slow-runner while <script type="math/tex; mode=display">j</script> is the fast-runner.</p>\n<p><strong>Algorithm</strong></p>\n<p>When <script type="math/tex; mode=display">nums[j]</script> equals to the given value, skip this element by incrementing <script type="math/tex; mode=display">j</script>. As long as <script type="math/tex; mode=display">nums[j] \\neq val</script>, we copy <script type="math/tex; mode=display">nums[j]</script> to <script type="math/tex; mode=display">nums[i]</script> and increment both indexes at the same time. Repeat the process until <script type="math/tex; mode=display">j</script> reaches the end of the array and the new length is <script type="math/tex; mode=display">i</script>.</p>\n<p>This solution is very similar to the solution to <a href="https://leetcode.com/articles/remove-duplicates-sorted-array/">Remove Duplicates from Sorted Array</a>.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>\n            <span class="n">i</span><span class="o">++;</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">i</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nAssume the array has a total of <script type="math/tex; mode=display">n</script> elements, both <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> traverse at most <script type="math/tex; mode=display">2n</script> steps.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-two-pointers-when-elements-to-remove-are-rare-accepted">Approach #2 (Two Pointers - when elements to remove are rare) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Now consider cases where the array contains few elements to remove. For example, <script type="math/tex; mode=display">nums = [1,2,3,5,4], val = 4</script>. The previous algorithm will do unnecessary copy operation of the first four elements. Another example is <script type="math/tex; mode=display">nums = [4,1,2,3,5], val = 4</script>. It seems unnecessary to move elements <script type="math/tex; mode=display">[1,2,3,5]</script> one step left as the problem description mentions that the order of elements could be changed.</p>\n<p><strong>Algorithm</strong></p>\n<p>When we encounter <script type="math/tex; mode=display">nums[i] = val</script>, we can swap the current element out with the last element and dispose the last one. This essentially reduces the array\'s size by 1.</p>\n<p>Note that the last element that was swapped in could be the value you want to remove itself. But don\'t worry, in the next iteration we will still check this element.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>\n            <span class="c1">// reduce array size by one</span>\n            <span class="n">n</span><span class="o">--;</span>\n        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>\n            <span class="n">i</span><span class="o">++;</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">n</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nBoth <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">n</script> traverse at most <script type="math/tex; mode=display">n</script> steps. In this approach, the number of assignment operation is equal to the number of elements to remove. So it is more efficient if elements to remove are rare.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<p>Analysis written by @feelxia, revised by @1337c0d3r.</p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '28',
    name: 'Implement strStr()',
    acceptance: '28.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nImplement <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank">strStr()</a>.\n</p>\n\n<p>\nReturn the index of the first occurrence of needle in haystack, or <b>-1</b> if needle is not part of haystack.\n</p>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b> haystack = "hello", needle = "ll"\n<b>Output:</b> 2\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b> haystack = "aaaaa", needle = "bba"\n<b>Output:</b> -1\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Apple', 'Pocket Gems'],
  },
  {
    id: '29',
    name: 'Divide Two Integers',
    acceptance: '15.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nDivide two integers without using multiplication, division and mod operator.\n</p>\n<p>\nIf it is overflow, return MAX_INT.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '30',
    name: 'Substring with Concatenation of All Words',
    acceptance: '22.1%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nYou are given a string, <b>s</b>, and a list of words, <b>words</b>, that are all of the same length. Find all starting indices of substring(s) in <b>s</b> that is a concatenation of each word in <b>words</b> exactly once and without any intervening characters.\n</p>\n\n<p>\nFor example, given:<br>\n<b>s</b>: <code>"barfoothefoobarman"</code><br>\n<b>words</b>: <code>["foo", "bar"]</code>\n</p>\n\n<p>\nYou should return the indices: <code>[0,9]</code>.<br>\n(order does not matter).\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '31',
    name: 'Next Permutation',
    acceptance: '28.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n</p>\n<p>\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\n</p>\n<p>\nThe replacement must be in-place, do not allocate extra memory.\n</p>\n<p>\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br>\n<code>1,2,3</code> → <code>1,3,2</code><br>\n<code>3,2,1</code> → <code>1,2,3</code><br>\n<code>1,1,5</code> → <code>1,5,1</code><br>\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-single-pass-approach-accepted">Approach #2 Single Pass Approach [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>We need to find the next lexicographic permutation of the given list of numbers than the number formed by the given array.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, we find out every possible permutation of list formed by the elements of the given array and find out the permutation which is\njust larger than the given one. But this one will be a very naive approach, since it requires us to find out every possible permutation\n which will take really long time and the implementation is complex.\n Thus, this approach is not acceptable at all. Hence, we move on directly to the correct approach.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n!)</script>. Total possible permutations is <script type="math/tex; mode=display">n!</script>.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Since an array will be used to store the permutations.</li>\n</ul>\n<hr>\n<h4 id="approach-2-single-pass-approach-accepted">Approach #2 Single Pass Approach [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>First, we observe that for any given sequence that is in descending order, no next larger permutation is possible.\n For example, no next permutation is possible for the following array:\n <code>[9, 5, 4, 3, 1]</code></p>\n<p>We need to find the first pair of two successive numbers <script type="math/tex; mode=display">a[i]</script> and <script type="math/tex; mode=display">a[i-1]</script>, from the right, which satisfy\n <script type="math/tex; mode=display">a[i] > a[i-1]</script>. Now, no rearrangements to the right of <script type="math/tex; mode=display">a[i-1]</script> can create a larger permutation since that subarray consists of numbers in descending order.\n Thus, we need to rearrange the numbers to the right of <script type="math/tex; mode=display">a[i-1]</script> including itself.</p>\n<p>Now, what kind of rearrangement will produce the next larger number? We want to create the permutation just larger than the current one. Therefore, we need to replace the number <script type="math/tex; mode=display">a[i-1]</script> with the number which is just larger than itself among the numbers lying to its right section, say <script type="math/tex; mode=display">a[j]</script>.</p>\n<p><img alt=" Next Permutation " src="https://leetcode.com/media/original_images/31_nums_graph.png"></p>\n<p>We swap the numbers <script type="math/tex; mode=display">a[i-1]</script> and <script type="math/tex; mode=display">a[j]</script>. We now have the correct number at index <script type="math/tex; mode=display">i-1</script>. But still the current permutation isn\'t the permutation\n    that we are looking for. We need the smallest permutation that can be formed by using the numbers only to the right of <script type="math/tex; mode=display">a[i-1]</script>. Therefore, we need to place those\n     numbers in ascending order to get their smallest permutation.</p>\n<p>But, recall that while scanning the numbers from the right, we simply kept decrementing the index\n      until we found the pair <script type="math/tex; mode=display">a[i]</script> and <script type="math/tex; mode=display">a[i-1]</script> where,  <script type="math/tex; mode=display">a[i] > a[i-1]</script>. Thus, all numbers to the right of <script type="math/tex; mode=display">a[i-1]</script> were already sorted in descending order.\n      Furthermore, swapping <script type="math/tex; mode=display">a[i-1]</script> and <script type="math/tex; mode=display">a[j]</script> didn\'t change that order.\n      Therefore, we simply need to reverse the numbers following <script type="math/tex; mode=display">a[i-1]</script> to get the next smallest lexicographic permutation.</p>\n<p>The following animation will make things clearer:</p>\n<p><img alt="Next Permutation" src="https://leetcode.com/media/original_images/31_Next_Permutation.gif"></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">nextPermutation</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>\n            <span class="n">i</span><span class="o">--;</span>\n        <span class="o">}</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>\n            <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>\n                <span class="n">j</span><span class="o">--;</span>\n            <span class="o">}</span>\n            <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="n">reverse</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n    <span class="o">}</span>\n\n    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>\n            <span class="n">i</span><span class="o">++;</span>\n            <span class="n">j</span><span class="o">--;</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n\n    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n        <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>\n        <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. In worst case, only two scans of the whole array are needed.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space is used. In place replacements are done.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '32',
    name: 'Longest Valid Parentheses',
    acceptance: '23.1%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given a string containing just the characters <code>\'(\'</code> and <code>\')\'</code>, find the length of the longest valid (well-formed) parentheses substring.\n</p>\n<p>\nFor <code>"(()"</code>, the longest valid parentheses substring is <code>"()"</code>, which has length = 2.\n</p>\n<p>\nAnother example is <code>")()())"</code>, where the longest valid parentheses substring is <code>"()()"</code>, which has length = 4.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-dynamic-programming-accepted">Approach #2 Using Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-3-using-stack-accepted">Approach #3 Using Stack [Accepted]</a></li>\n<li><a href="#approach-4-without-extra-space-accepted">Approach #4 Without extra space [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>We need to determine the length of the largest valid substring of parentheses from a given string.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, we consider every possible non-empty even length substring from the given string and check whether it\'s\na valid string of parentheses or not. In order to check the validity, we use the Stack\'s Method.</p>\n<p>Every time we\nencounter a <script type="math/tex; mode=display">\\text{‘(’}</script>, we push it onto the stack. For every <script type="math/tex; mode=display">\\text{‘)’}</script> encountered, we pop a <script type="math/tex; mode=display">\\text{‘(’}</script> from the stack. If <script type="math/tex; mode=display">\\text{‘(’}</script> isn\'t\n available on the stack for popping at anytime or if stack contains some elements after processing complete substring, the substring of parentheses is invalid. In this way, we repeat the\n process for every possible substring and we keep on\n  storing the length of the longest valid string found so far.</p>\n<div class="codehilite"><pre><span></span>Example:\n"((())"\n\n(( --&gt; invalid\n(( --&gt; invalid\n() --&gt; valid, length=2\n)) --&gt; invalid\n((()--&gt; invalid\n(())--&gt; valid, length=4\nmaxlength=4\n</pre></div>\n<iframe frameborder="0" height="496" name="HyUki2wW" src="https://leetcode.com/playground/HyUki2wW/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. Generating every possible substring from a string of length <script type="math/tex; mode=display">n</script> requires <script type="math/tex; mode=display">O(n^2)</script>. Checking validity of a string of length <script type="math/tex; mode=display">n</script> requires <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. A stack of depth <script type="math/tex; mode=display">n</script> will be required for the longest substring.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-dynamic-programming-accepted">Approach #2 Using Dynamic Programming [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This problem can be solved by using Dynamic Programming. We make use of a <script type="math/tex; mode=display">\\text{dp}</script> array where <script type="math/tex; mode=display">i</script>th element of <script type="math/tex; mode=display">\\text{dp}</script> represents the length of the longest valid substring ending at <script type="math/tex; mode=display">i</script>th index. We initialize the complete <script type="math/tex; mode=display">\\text{dp}</script> array with 0\'s. Now, it\'s obvious that the valid substrings must end with <script type="math/tex; mode=display">\\text{‘)’}</script>. This further leads to the conclusion that the substrings ending with <script type="math/tex; mode=display">\\text{‘(’}</script> will always contain \'0\' at their corresponding <script type="math/tex; mode=display">\\text{dp}</script> indices. Thus, we update the <script type="math/tex; mode=display">\\text{dp}</script> array only when <script type="math/tex; mode=display">\\text{‘)’}</script> is encountered.</p>\n<p>To fill <script type="math/tex; mode=display">\\text{dp}</script> array we will check every two consecutive characters of the string and if</p>\n<ol>\n<li>\n<p>\n<script type="math/tex; mode=display">\\text{s}[i] = \\text{‘)’}</script> and <script type="math/tex; mode=display">\\text{s}[i - 1] = \\text{‘(’}</script>, i.e. string looks like <script type="math/tex; mode=display">``.......()" \\Rightarrow</script>\n</p>\n<p>\n<script type="math/tex; mode=display">\n\\text{dp}[i]=\\text{dp}[i-2]+2\n</script>\n</p>\n<p>We do so because the ending "()" portion is a valid substring anyhow and leads to an increment of 2 in the length of the just previous valid substring\'s length.</p>\n</li>\n<li>\n<p>\n<script type="math/tex; mode=display">\\text{s}[i] = \\text{‘)’}</script> and <script type="math/tex; mode=display">\\text{s}[i - 1] = \\text{‘)’}</script>, i.e. string looks like <script type="math/tex; mode=display">``.......))" \\Rightarrow</script>\n</p>\n<p>if <script type="math/tex; mode=display">\\text{s}[i - \\text{dp}[i - 1] - 1] = \\text{‘(’}</script> then</p>\n<p>\n<script type="math/tex; mode=display">\n\\text{dp}[i]=\\text{dp}[i-1]+\\text{dp}[i-\\text{dp}[i-1]-2]+2\n</script>\n</p>\n</li>\n</ol>\n<p>The reason behind this is that if the 2nd last <script type="math/tex; mode=display">\\text{‘)’}</script> was a part of a valid substring (say <script type="math/tex; mode=display">sub_s</script>), for the last <script type="math/tex; mode=display">\\text{‘)’}</script> to be a part of a larger substring, there must be a corresponding starting <script type="math/tex; mode=display">\\text{‘(’}</script> which lies before the valid substring of which the 2nd last <script type="math/tex; mode=display">\\text{‘)’}</script> is a part (i.e. before <script type="math/tex; mode=display">sub_s</script>). Thus, if the character before <script type="math/tex; mode=display">sub_s</script> happens to be <script type="math/tex; mode=display">\\text{‘(’}</script>, we update the <script type="math/tex; mode=display">\\text{dp}[i]</script> as an addition of <script type="math/tex; mode=display">2</script> in the length of <script type="math/tex; mode=display">sub_s</script> which is <script type="math/tex; mode=display">\\text{dp}[i-1]</script>. To this, we also add the length of the valid substring just before the term "(,sub_s,)" , i.e. <script type="math/tex; mode=display">\\text{dp}[i-\\text{dp}[i-1]-2]</script>.</p>\n<p>For better understanding of this method, see this example:</p>\n<!--![Longest_Valid_Parenthesis](https://leetcode.com/articles/Figures/32_LongestValidParenthesisDP.gif)-->\n<p>!?!../Documents/32_Longest_Valid2.json:1000,563!?!</p>\n<iframe frameborder="0" height="360" name="2dij24pv" src="https://leetcode.com/playground/2dij24pv/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Single traversal of string to fill dp array is done.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. dp array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-stack-accepted">Approach #3 Using Stack [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of finding every possible string and checking its validity, we can make use of stack while scanning\nthe given string to check if the string scanned so far is valid, and also the length of the longest valid string. In order to do so, we start by pushing <script type="math/tex; mode=display">-1</script> onto the stack.</p>\n<p>For every <script type="math/tex; mode=display">\\text{‘(’}</script> encountered, we push its index onto the stack.</p>\n<p>For every <script type="math/tex; mode=display">\\text{‘)’}</script> encountered, we pop the topmost element and subtract the current element\'s index from the top element of the stack, which gives the length of the currently encountered valid string of parentheses. If while popping the element, the stack becomes empty, we push the current element\'s index onto the stack. In this way, we keep on calculating the lengths of the valid substrings, and return the length of the longest valid string at the end.</p>\n<p>See this example for better understanding.</p>\n<!--![Longest_Valid_Parenthesis](https://leetcode.com/articles/Figures/32_LongestValidParenthesisSTACK.gif)-->\n<p>!?!../Documents/32_Longest_Valid_stack_new.json:1000,563!?!</p>\n<iframe frameborder="0" height="428" name="i5yzG7s7" src="https://leetcode.com/playground/i5yzG7s7/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">n</script> is the length of the given string..</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The size of stack can go up to <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-without-extra-space-accepted">Approach #4 Without extra space [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, we make use of two counters <script type="math/tex; mode=display">left</script> and <script type="math/tex; mode=display">right</script>. First, we start traversing the string from the left towards the right and for every <script type="math/tex; mode=display">\\text{‘(’}</script> encountered, we increment the <script type="math/tex; mode=display">left</script> counter and for every <script type="math/tex; mode=display">\\text{‘)’}</script> encountered, we increment the <script type="math/tex; mode=display">right</script> counter. Whenever <script type="math/tex; mode=display">left</script> becomes equal to <script type="math/tex; mode=display">right</script>, we calculate the length of the current valid string and keep track of maximum length substring found so far. If <script type="math/tex; mode=display">right</script> becomes greater than <script type="math/tex; mode=display">left</script> we reset <script type="math/tex; mode=display">left</script> and <script type="math/tex; mode=display">right</script> to <script type="math/tex; mode=display">0</script>.</p>\n<p>Next, we start traversing the string from right to left and similar procedure is applied.</p>\n<p>Example of this approach:</p>\n<!--![Longest_Valid_Parenthesis](https://leetcode.com/articles/Figures/32_LongestValidParenthesisLR.gif)-->\n<p>!?!../Documents/32_Longest_Validlr.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="DSvJtRbb" src="https://leetcode.com/playground/DSvJtRbb/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Two traversals of the string.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Only two extra variables <script type="math/tex; mode=display">left</script> and <script type="math/tex; mode=display">right</script> are needed.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '33',
    name: 'Search in Rotated Sorted Array',
    acceptance: '32.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\n\n<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>\n\n<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>\n\n<p>You may assume no duplicate exists in the array.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Bloomberg', 'Uber', 'LinkedIn'],
  },
  {
    id: '34',
    name: 'Search for a Range',
    acceptance: '31.5%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p>\n\n<p>Your algorithm's runtime complexity must be in the order of <i>O</i>(log <i>n</i>).</p>\n\n<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>\n\n<p>\nFor example,<br>\nGiven <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br>\nreturn <code>[3, 4]</code>.\n</p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-linear-scan-accepted">Approach #1 Linear Scan [Accepted]</a></li>\n<li><a href="#approach-2-binary-search-accepted">Approach #2 Binary Search [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-linear-scan-accepted">Approach #1 Linear Scan [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Checking every index for <code>target</code> exhausts the search space, so it must work.</p>\n<p><strong>Algorithm</strong></p>\n<p>First, we do a linear scan of <code>nums</code> from the left, <code>break</code>ing when we find\nan instance of <code>target</code>. If we never <code>break</code>, then <code>target</code> is not present,\nso we can return the "error code" of <code>[-1, -1]</code> early. Given that we did find\na valid left index, we can do a second linear scan, but this time from the\nright. In this case, the first instance of <code>target</code> encountered will be the\nrightmost one (and because a leftmost one exists, there is guaranteed to also\nbe a rightmost one). We then simply return a list containing the two located\nindices.</p>\n<iframe frameborder="0" height="500" name="w7jHhp3C" src="https://leetcode.com/playground/w7jHhp3C/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>This brute-force approach examines each of the <code>n</code> elements of <code>nums</code>\nexactly twice, so the overall runtime is linear.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n<p>The linear scan method allocates a fixed-size array and a few integers,\nso it has a constant-size memory footprint.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-binary-search-accepted">Approach #2 Binary Search [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Because the array is sorted, we can use binary search to locate the left\nand rightmost indices.</p>\n<p><strong>Algorithm</strong></p>\n<p>The overall algorithm works fairly similarly to the linear scan approach,\nexcept for the subroutine used to find the left and rightmost indices\nthemselves. Here, we use a modified binary search to search a sorted array,\nwith a few minor adjustments. First, because we are locating the leftmost (or\nrightmost) index containing <code>target</code> (rather than returning <code>true</code> iff we\nfind <code>target</code>), the algorithm does not terminate as soon as we find a match.\nInstead, we continue to search until <code>lo == hi</code> and they contain some index\nat which <code>target</code> can be found.</p>\n<p>The other change is the introduction of the <code>left</code> parameter, which is a\nboolean indicating what to do in the event that <code>target == nums[mid]</code>; if\n<code>left</code> is <code>true</code>, then we "recurse" on the left subarray on ties. Otherwise,\nwe go right. To see why this is correct, consider the situation where we find\n<code>target</code> at index <code>i</code>. The leftmost <code>target</code> cannot occur at any index\ngreater than <code>i</code>, so we never need to consider the right subarray. The same\nargument applies to the rightmost index.</p>\n<p>The first animation below shows the process for finding the leftmost index,\nand the second shows the process for finding the index right of the rightmost\nindex.</p>\n<p>!?!../Documents/34_Search_for_a_Range_left.json:1280,720!?!</p>\n<p>!?!../Documents/34_Search_for_a_Range_right.json:1280,720!?!</p>\n<iframe frameborder="0" height="500" name="wbjxDd2P" src="https://leetcode.com/playground/wbjxDd2P/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(lgn)</script>\n</p>\n<p>Because binary search cuts the search space roughly in half on each\niteration, there can be at most <script type="math/tex; mode=display">\\lceil lgn \\rceil</script> iterations. Binary\nsearch is invoked twice, so the overall complexity is logarithmic.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n<p>All work is done in place, so the overall memory usage is constant.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis and solutions written by: <a href="https://leetcode.com/emptyset">@emptyset</a></p>\n</div>\n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '35',
    name: 'Search Insert Position',
    acceptance: '39.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>\n\n<p>You may assume no duplicates in the array.</p>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b> [1,3,5,6], 5\n<b>Output:</b> 2\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b> [1,3,5,6], 2\n<b>Output:</b> 1\n</pre>\n<p></p>\n\n<p><b>Example 3:</b>\n</p><pre><b>Input:</b> [1,3,5,6], 7\n<b>Output:</b> 4\n</pre>\n<p></p>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b> [1,3,5,6], 0\n<b>Output:</b> 0\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '36',
    name: 'Valid Sudoku',
    acceptance: '36.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx">Sudoku Puzzles - The Rules</a>.</p>\n\n<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>\'.\'</code>.</p>\n\n<p>\n<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"><br>\n</p><p style="font-size: 11px">A partially filled sudoku which is valid.</p>\n<p></p>\n\n<p><b>Note:</b><br>\nA valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Uber', 'Apple', 'Snapchat'],
  },
  {
    id: '37',
    name: 'Sudoku Solver',
    acceptance: '31.2%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>\n\n<p>Empty cells are indicated by the character <code>\'.\'</code>.</p>\n\n<p>You may assume that there will be only one unique solution.\n\n</p><p>\n<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"><br>\n</p><p style="font-size: 11px">A sudoku puzzle...</p>\n<p></p>\n\n<p>\n<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png"><br>\n</p><p style="font-size: 11px">...and its solution numbers marked in red.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Uber', 'Snapchat'],
  },
  {
    id: '38',
    name: 'Count and Say',
    acceptance: '35.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>\n<pre>1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221\n</pre>\n\n<p>\n<code>1</code> is read off as <code>"one 1"</code> or <code>11</code>.<br>\n<code>11</code> is read off as <code>"two 1s"</code> or <code>21</code>.<br>\n<code>21</code> is read off as <code>"one 2</code>, then <code>one 1"</code> or <code>1211</code>.<br>\n</p>\n\n<p>\nGiven an integer <i>n</i>, generate the <i>n</i><sup>th</sup> term of the count-and-say sequence.\n</p>\n\n<p>\nNote: Each term of the sequence of integers will be represented as a string.\n</p>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b> 1\n<b>Output:</b> "1"\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b> 4\n<b>Output:</b> "1211"\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook'],
  },
  {
    id: '39',
    name: 'Combination Sum',
    acceptance: '40.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a <b>set</b> of candidate numbers (<b><i>C</i></b>) <b>(without duplicates)</b> and a target number (<b><i>T</i></b>), find all unique combinations in <b><i>C</i></b> where the candidate numbers sums to <b><i>T</i></b>. \n</p>\n\n<p>The <b>same</b> repeated number may be chosen from <b><i>C</i></b> unlimited number of times.\n</p>\n\n<p><b>Note:</b><br>\n</p><ul>\n<li>All numbers (including target) will be positive integers.</li>\n<li>The solution set must not contain duplicate combinations.</li>\n</ul>\n<p></p>\n\n<p>\nFor example, given candidate set <code>[2, 3, 6, 7]</code> and target <code>7</code>, <br>\nA solution set is: <br>\n</p><pre>[\n  [7],\n  [2, 2, 3]\n]\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Uber', 'Snapchat'],
  },
  {
    id: '40',
    name: 'Combination Sum II',
    acceptance: '35.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a collection of candidate numbers (<b><i>C</i></b>) and a target number (<b><i>T</i></b>), find all unique combinations in <b><i>C</i></b> where the candidate numbers sums to <b><i>T</i></b>.\n</p>\n\n<p>Each number in <b><i>C</i></b> may only be used <b>once</b> in the combination.\n</p>\n<p><b>Note:</b><br>\n</p><ul>\n<li>All numbers (including target) will be positive integers.</li>\n<li>The solution set must not contain duplicate combinations.</li>\n</ul>\n<p></p>\n\n<p>\nFor example, given candidate set <code>[10, 1, 2, 7, 6, 1, 5]</code> and target <code>8</code>, <br>\nA solution set is: <br>\n</p><pre>[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Snapchat'],
  },
  {
    id: '41',
    name: 'First Missing Positive',
    acceptance: '25.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an unsorted integer array, find the first missing positive integer.\n</p>\n\n<p>\nFor example,<br>\nGiven <code>[1,2,0]</code> return <code>3</code>,<br>\nand <code>[3,4,-1,1]</code> return <code>2</code>.\n</p>\n\n<p>\nYour algorithm should run in <i>O</i>(<i>n</i>) time and uses constant space.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '42',
    name: 'Trapping Rain Water',
    acceptance: '37.3%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven <i>n</i> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. \n</p>\n\n<p>\nFor example, <br>\nGiven <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>, return <code>6</code>.\n</p>\n\n<p>\n<img src="http://www.leetcode.com/static/images/problemset/rainwatertrap.png"><br>\n</p><p style="font-size: 11px">The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. <b>Thanks Marcos</b> for contributing this image!</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1 Brute force [Accepted]</a></li>\n<li><a href="#approach-2-dynamic-programming-accepted">Approach #2 Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-3-using-stacks-accepted">Approach #3 Using stacks [Accepted]</a></li>\n<li><a href="#approach-4-using-2-pointers-accepted">Approach #4 Using 2 pointers [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-accepted">Approach #1 Brute force [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Do as directed in question. For each element in the array, we find the maximum level of water it can trap after the rain, which is equal to the minimum of maximum height of bars on both the sides minus its own height.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>Initialize <script type="math/tex; mode=display">ans=0</script>\n</li>\n<li>Iterate the array from left to right:</li>\n<li>Initialize <script type="math/tex; mode=display">\\text{max_left}=0</script> and <script type="math/tex; mode=display">\\text{max_right}=0</script>\n</li>\n<li>Iterate from the current element to the beginning of array updating:\n      <script type="math/tex; mode=display">\\text{max_left}=\\max(\\text{max_left},\\text{height}[j])</script>\n</li>\n<li>Iterate from the current element to the end of array updating:\n      <script type="math/tex; mode=display">\\text{max_right}=\\max(\\text{max_right},\\text{height}[j])</script>\n</li>\n<li>Add <script type="math/tex; mode=display">\\min(\\text{max_left},\\text{max_right}) - \\text{height}[i]</script> to <script type="math/tex; mode=display">\\text{ans}</script>\n</li>\n</ul>\n<iframe frameborder="0" height="326" name="B9TFcoVw" src="https://leetcode.com/playground/B9TFcoVw/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O(n^2)</script>. For each element of array, we iterate the left and right parts.</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(1)</script> extra space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-dynamic-programming-accepted">Approach #2 Dynamic Programming [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>In brute force, we iterate over the left and right parts again and again just to find the highest bar size upto that index. But, this could be stored. Voila, dynamic programming.</p>\n<p>The concept is illustrated as shown:</p>\n<p align="center"><img alt="Dynamic programming" src="https://leetcode.com/articles/Figures/42/trapping_rain_water.png" width="500px"></p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>Find maximum height of bar from the left end upto an index i in the array <script type="math/tex; mode=display">\\text{left_max}</script>.</li>\n<li>Find maximum height of bar from the right end upto an index i in the array <script type="math/tex; mode=display">\\text{right_max}</script>.</li>\n<li>Iterate over the <script type="math/tex; mode=display">\\text{height}</script> array and update ans:</li>\n<li>Add <script type="math/tex; mode=display">\\min(\\text{max_left}[i],\\text{max_right}[i]) - \\text{height}[i]</script> to <script type="math/tex; mode=display">ans</script>\n</li>\n</ul>\n<iframe frameborder="0" height="394" name="HbYWDYiJ" src="https://leetcode.com/playground/HbYWDYiJ/shared" width="100%"></iframe>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>Time complexity: <script type="math/tex; mode=display">O(n)</script>.</li>\n<li>We store the maximum heights upto a point using 2 iterations of O(n) each.</li>\n<li>\n<p>We finally update <script type="math/tex; mode=display">\\text{ans}</script> using the stored values in O(n).</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(n)</script> extra space.</p>\n</li>\n<li>Additional <script type="math/tex; mode=display">O(n)</script> space for <script type="math/tex; mode=display">\\text{left_max}</script> and <script type="math/tex; mode=display">\\text{right_max}</script> arrays than in Approach #1.</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-stacks-accepted">Approach #3 Using stacks [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Instead of storing the largest bar upto an index as in Approach #2, we can use stack to keep track of the bars that are bounded by longer bars and hence, may store water. Using the stack, we can do the calculations in only one iteration.</p>\n<p>We keep a stack and iterate over the array. We add the index of the bar to the stack if bar is smaller than or equal to the bar at top of stack, which means that the current bar is bounded by the previous bar in the stack. If we found a bar longer than that at the top, we are sure that the bar at the top of the stack is bounded by the current bar and a previous bar in the stack, hence, we can pop it and add resulting trapped water to <script type="math/tex; mode=display">\\text{ans}</script>.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>Use stack to store the indices of the bars.</li>\n<li>Iterate the array:<ul>\n<li>While stack is not empty and <script type="math/tex; mode=display">\\text{height}[current]>\\text{height}[st.top()]</script>\n<ul>\n<li>It means that the stack element can be popped. Pop the top element as <script type="math/tex; mode=display">\\text{top}</script>.</li>\n<li>Find the distance between the current element and the element at top of stack, which is to be filled.\n<script type="math/tex; mode=display">\\text{distance} = \\text{current} - \\text{st.top}() - 1</script>\n</li>\n<li>Find the bounded height\n<script type="math/tex; mode=display">\\text{bounded_height} = \\min(\\text{height[current]}, \\text{height[st.top()]}) - \\text{height[top]}</script>\n</li>\n<li>Add resulting trapped water to answer\n<script type="math/tex; mode=display">\\text{ans} += \\text{distance} * \\text{bounded_height}</script>\n</li>\n</ul>\n</li>\n<li>Push current index to top of the stack</li>\n<li>Move <script type="math/tex; mode=display">\\text{current}</script> to the next position</li>\n</ul>\n</li>\n</ul>\n<iframe frameborder="0" height="360" name="wqRLDavL" src="https://leetcode.com/playground/wqRLDavL/shared" width="100%"></iframe>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>Time complexity: <script type="math/tex; mode=display">O(n)</script>.<ul>\n<li>Single iteration of <script type="math/tex; mode=display">O(n)</script> in which each bar can be touched at most twice(due to  insertion and deletion from stack) and insertion and deletion from stack takes <script type="math/tex; mode=display">O(1)</script> time.</li>\n</ul>\n</li>\n<li>Space complexity: <script type="math/tex; mode=display">O(n)</script>. Stack can take upto <script type="math/tex; mode=display">O(n)</script> space in case of stairs-like or flat structure.</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-2-pointers-accepted">Approach #4 Using 2 pointers [Accepted]</h4>\n<p><strong>Intuition</strong>\nAs in Approach #2, instead of computing the left and right parts seperately, we may think of some way to do it in one iteration.\nFrom the figure in dynamic programming approach, notice that as long as <script type="math/tex; mode=display">\\text{right_max}[i]>\\text{left_max}[i]</script>(from element 0 to 6), the water trapped depends upon the left_max, and similar is the case when <script type="math/tex; mode=display">\\text{left_max}[i]>\\text{right_max}[i]</script>(from element 8 to 11).\nSo, we can say that if there is a larger bar at one end(say right), we are assured that the water trapped would be dependant on height of bar in current direction(from left to right). As soon as we find the bar at other end(right) is smaller, we start iterating in opposite direction(from right to left).\nWe must maintain <script type="math/tex; mode=display">\\text{left_max}</script> and <script type="math/tex; mode=display">\\text{right_max}</script> during the iteration, but now we can do it in one iteration using 2 pointers, switching between the two.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>Initialize <script type="math/tex; mode=display">\\text{left}</script> pointer to 0 and <script type="math/tex; mode=display">\\text{right}</script> pointer to size-1</li>\n<li>While <script type="math/tex; mode=display">\\text{left}< \\text{right}</script>, do:<ul>\n<li>If <script type="math/tex; mode=display">\\text{height[left]}</script> is smaller than <script type="math/tex; mode=display">\\text{height[right]}</script>\n<ul>\n<li>If <script type="math/tex; mode=display">\\text{height[left]}>=\\text{left_max}</script>, update <script type="math/tex; mode=display">\\text{left_max}</script>\n</li>\n<li>Else add <script type="math/tex; mode=display">\\text{left_max}-\\text{height[left]}</script> to <script type="math/tex; mode=display">\\text{ans}</script>\n</li>\n<li>Add 1 to <script type="math/tex; mode=display">\\text{left}</script>.</li>\n</ul>\n</li>\n<li>Else<ul>\n<li>If <script type="math/tex; mode=display">\\text{height[right]}>=\\text{right_max}</script>, update <script type="math/tex; mode=display">\\text{right_max}</script>\n</li>\n<li>Else add <script type="math/tex; mode=display">\\text{right_max}-\\text{height[right]}</script> to <script type="math/tex; mode=display">\\text{ans}</script>\n</li>\n<li>Subtract 1 from <script type="math/tex; mode=display">\\text{right}</script>.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Refer the example for better understanding:\n!?!../Documents/42_trapping_rain_water.json:1000,662!?!</p>\n<iframe frameborder="0" height="343" name="CvwUEth2" src="https://leetcode.com/playground/CvwUEth2/shared" width="100%"></iframe>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>Time complexity: <script type="math/tex; mode=display">O(n)</script>. Single iteration of <script type="math/tex; mode=display">O(n)</script>.</li>\n<li>Space complexity: <script type="math/tex; mode=display">O(1)</script> extra space. Only constant space required for <script type="math/tex; mode=display">\\text{left}</script>, <script type="math/tex; mode=display">\\text{right}</script>, <script type="math/tex; mode=display">\\text{left_max}</script> and <script type="math/tex; mode=display">\\text{right_max}</script>.</li>\n</ul>\n<hr>\n<p>Analysis written by <a href="https://leetcode.com/abhinavbansal0">@abhinavbansal0</a>.</p>\n</div>\n          ',
    tags: ['Google', 'Amazon', 'Bloomberg', 'Twitter', 'Apple', 'Zenefits'],
  },
  {
    id: '43',
    name: 'Multiply Strings',
    acceptance: '27.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>.</p>\n\n<p><b>Note:</b>\n</p><ol>\n<li>The length of both <code>num1</code> and <code>num2</code> is &lt; 110.</li>\n<li>Both <code>num1</code> and <code>num2</code> contains only digits <code>0-9</code>.</li>\n<li>Both <code>num1</code> and <code>num2</code> does not contain any leading zero.</li>\n<li>You <b>must not use any built-in BigInteger library</b> or <b>convert the inputs to integer</b> directly.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Twitter'],
  },
  {
    id: '44',
    name: 'Wildcard Matching',
    acceptance: '20.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Implement wildcard pattern matching with support for <code>\'?\'</code> and <code>\'*\'</code>.</p>\n\n<pre>\'?\' Matches any single character.\n\'*\' Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the <b>entire</b> input string (not partial).\n\nThe function prototype should be:\nbool isMatch(const char *s, const char *p)\n\nSome examples:\nisMatch("aa","a") → false\nisMatch("aa","aa") → true\nisMatch("aaa","aa") → false\nisMatch("aa", "*") → true\nisMatch("aa", "a*") → true\nisMatch("ab", "?*") → true\nisMatch("aab", "c*a*b") → false\n</pre>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Twitter', 'Snapchat', 'Two Sigma'],
  },
  {
    id: '45',
    name: 'Jump Game II',
    acceptance: '26.2%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\n</p>\n<p>\nEach element in the array represents your maximum jump length at that position. \n</p>\n<p>\nYour goal is to reach the last index in the minimum number of jumps.\n</p>\n\n<p>\nFor example:<br>\nGiven array A = <code>[2,3,1,1,4]</code>\n</p>\n<p>\nThe minimum number of jumps to reach the last index is <code>2</code>. (Jump <code>1</code> step from index 0 to 1, then <code>3</code> steps to the last index.)\n</p>\n\n<p>\n<b>Note:</b><br>\nYou can assume that you can always reach the last index.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '46',
    name: 'Permutations',
    acceptance: '45.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a collection of <b>distinct</b> numbers, return all possible permutations.\n</p>\n\n<p>\nFor example,<br>\n<code>[1,2,3]</code> have the following permutations:<br>\n</p><pre>[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft', 'LinkedIn'],
  },
  {
    id: '47',
    name: 'Permutations II',
    acceptance: '34.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\n</p>\n\n<p>\nFor example,<br>\n<code>[1,1,2]</code> have the following unique permutations:<br>\n</p><pre>[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft', 'LinkedIn'],
  },
  {
    id: '48',
    name: 'Rotate Image',
    acceptance: '40.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>You are given an <i>n</i> x <i>n</i> 2D matrix representing an image.</p>\n\n<p>Rotate the image by 90 degrees (clockwise).</p>\n\n<p><b>Note:</b><br>\nYou have to rotate the image <b>in-place</b>, which means you have to modify the input 2D matrix directly. <b>DO NOT</b> allocate another 2D matrix and do the rotation.\n</p>\n\n<p><b>Example 1:</b>\n</p><pre>Given <b>input matrix</b> = \n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n],\n\nrotate the input matrix <b>in-place</b> such that it becomes:\n[\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre>Given <b>input matrix</b> =\n[\n  [ 5, 1, 9,11],\n  [ 2, 4, 8,10],\n  [13, 3, 6, 7],\n  [15,14,12,16]\n], \n\nrotate the input matrix <b>in-place</b> such that it becomes:\n[\n  [15,13, 2, 5],\n  [14, 3, 4, 1],\n  [12, 6, 8, 9],\n  [16, 7,10,11]\n]\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft', 'Amazon', 'Apple'],
  },
  {
    id: '49',
    name: 'Group Anagrams',
    acceptance: '36.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given an array of strings, group anagrams together.\n</p>\n\n<p>For example, given: <code>["eat", "tea", "tan", "ate", "nat", "bat"]</code>, <br>\nReturn:\n</p><pre>[\n  ["ate", "eat","tea"],\n  ["nat","tan"],\n  ["bat"]\n]</pre><p></p>\n\n<p><b>Note:</b> All inputs will be in lower-case.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-categorize-by-sorted-string-accepted">Approach #1: Categorize by Sorted String [Accepted]</a></li>\n<li><a href="#approach-2-categorize-by-count-accepted">Approach #2: Categorize by Count [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-categorize-by-sorted-string-accepted">Approach #1: Categorize by Sorted String [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Two strings are anagrams if and only if their sorted strings are equal.</p>\n<p><strong>Algorithm</strong></p>\n<p>Maintain a map <code>ans : {String -&gt; List}</code> where each key <script type="math/tex; mode=display">\\text{K}</script> is a sorted string, and each value is the list of strings from the initial input that when sorted, are equal to <script type="math/tex; mode=display">\\text{K}</script>.</p>\n<p>In Java, we will store the key as a string, eg. <code>code</code>.  In Python, we will store the key as a hashable tuple, eg. <code>(\'c\', \'o\', \'d\', \'e\')</code>.</p>\n<p><img alt="Anagrams" src="https://leetcode.com/articles/Figures/49_groupanagrams1.png"></p>\n<iframe frameborder="0" height="292" name="JSn62xKL" src="https://leetcode.com/playground/JSn62xKL/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity:  <script type="math/tex; mode=display">O(NK \\log (K) )</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>strs</code>, and <script type="math/tex; mode=display">K</script> is the maximum length of a string in <code>strs</code>.  The outer loop has complexity <script type="math/tex; mode=display">O(N)</script> as we iterate through each string.  Then, we sort each string in <script type="math/tex; mode=display">O(K \\log K)</script> time.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N*K)</script>, the total information content stored in <code>ans</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-categorize-by-count-accepted">Approach #2: Categorize by Count [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Two strings are anagrams if and only if their character counts (respective number of occurrences of each character) are the same.</p>\n<p><strong>Algorithm</strong></p>\n<p>We can transform each string <script type="math/tex; mode=display">\\text{s}</script> into a character count, <script type="math/tex; mode=display">\\text{count}</script>, consisting of 26 non-negative integers representing the number of <script type="math/tex; mode=display">\\text{a}</script>\'s, <script type="math/tex; mode=display">\\text{b}</script>\'s, <script type="math/tex; mode=display">\\text{c}</script>\'s, etc.  We use these counts as the basis for our hash map.</p>\n<p>In Java, the hashable representation of our count will be a string delimited with \'<strong>#</strong>\' characters.  For example, <code>abbccc</code> will be <code>#1#2#3#0#0#0...#0</code> where there are 26 entries total.  In python, the representation will be a tuple of the counts.  For example, <code>abbccc</code> will be <code>(1, 2, 3, 0, 0, ..., 0)</code>, where again there are 26 entries total.</p>\n<p><img alt="Anagrams" src="https://leetcode.com/articles/Figures/49_groupanagrams2.png"></p>\n<iframe frameborder="0" height="411" name="w29Uqr8R" src="https://leetcode.com/playground/w29Uqr8R/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity:  <script type="math/tex; mode=display">O(N * K)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>strs</code>, and <script type="math/tex; mode=display">K</script> is the maximum length of a string in <code>strs</code>.  Counting each string is linear in the size of the string, and we count every string.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N*K)</script>, the total information content stored in <code>ans</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Facebook', 'Amazon', 'Bloomberg', 'Uber', 'Yelp'],
  },
  {
    id: '50',
    name: 'Pow(x, n)',
    acceptance: '26.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Implement <a href="http://www.cplusplus.com/reference/valarray/pow/" target="_blank">pow(<i>x</i>, <i>n</i>)</a>.\n</p>\n\n<br>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b> 2.00000, 10\n<b>Output:</b> 1024.00000\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b> 2.10000, 3\n<b>Output:</b> 9.26100\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Bloomberg', 'LinkedIn'],
  },
  {
    id: '51',
    name: 'N-Queens',
    acceptance: '32.3%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>The <i>n</i>-queens puzzle is the problem of placing <i>n</i> queens on an <i>n</i>×<i>n</i> chessboard such that no two queens attack each other.</p>\n\n<p><img src="https://leetcode.com/static/images/problemset/8-queens.png"></p>\n\n<p>Given an integer <i>n</i>, return all distinct solutions to the <i>n</i>-queens puzzle.</p>\n\n<p>Each solution contains a distinct board configuration of the <i>n</i>-queens\' placement, where <code>\'Q\'</code> and <code>\'.\'</code> both indicate a queen and an empty space respectively.</p>\n\n<p>For example,<br>\nThere exist two distinct solutions to the 4-queens puzzle:</p>\n<pre>[\n [".Q..",  // Solution 1\n  "...Q",\n  "Q...",\n  "..Q."],\n\n ["..Q.",  // Solution 2\n  "Q...",\n  "...Q",\n  ".Q.."]\n]\n</pre>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '52',
    name: 'N-Queens II',
    acceptance: '46.0%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Follow up for N-Queens problem.</p>\n\n<p>Now, instead outputting board configurations, return the total number of distinct solutions.</p>\n\n<p><img src="https://leetcode.com/static/images/problemset/8-queens.png"></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Zenefits'],
  },
  {
    id: '53',
    name: 'Maximum Subarray',
    acceptance: '40.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nFind the contiguous subarray within an array (containing at least one number) which has the largest sum.\n</p>\n<p>\nFor example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br>\nthe contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>.\n</p>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show more practice.</a></p>\n\n<div class="spoilers"><b>More practice:</b>\n\n<p>If you have figured out the O(<i>n</i>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>\n</div>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft', 'Bloomberg', 'LinkedIn'],
  },
  {
    id: '54',
    name: 'Spiral Matrix',
    acceptance: '26.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a matrix of <i>m</i> x <i>n</i> elements (<i>m</i> rows, <i>n</i> columns), return all elements of the matrix in spiral order.\n</p>\n\n<p>\nFor example,<br>\nGiven the following matrix:\n</p>\n<pre>[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n</pre>\n<p>\nYou should return <code>[1,2,3,6,9,8,7,4,5]</code>.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-simulation-accepted">Approach #1: Simulation [Accepted]</a></li>\n<li><a href="#approach-2-layer-by-layer-accepted">Approach #2: Layer-by-Layer [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-simulation-accepted">Approach #1: Simulation [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Draw the path that the spiral makes.  We know that the path should turn clockwise whenever it would go out of bounds or into a cell that was previously visited.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let the array have <script type="math/tex; mode=display">\\text{R}</script> rows and <script type="math/tex; mode=display">\\text{C}</script> columns.  <script type="math/tex; mode=display">\\text{seen[r][c]}</script> denotes that the cell on the<script type="math/tex; mode=display">\\text{r}</script>-th row and <script type="math/tex; mode=display">\\text{c}</script>-th column was previously visited.  Our current position is <script type="math/tex; mode=display">\\text{(r, c)}</script>, facing direction <script type="math/tex; mode=display">\\text{di}</script>, and we want to visit <script type="math/tex; mode=display">\\text{R}</script> x <script type="math/tex; mode=display">\\text{C}</script> total cells.</p>\n<p>As we move through the matrix, our candidate next position is <script type="math/tex; mode=display">\\text{(cr, cc)}</script>.  If the candidate is in the bounds of the matrix and unseen, then it becomes our next position; otherwise, our next position is the one after performing a clockwise turn.</p>\n<iframe frameborder="0" height="496" name="3AmLCxub" src="https://leetcode.com/playground/3AmLCxub/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity:  <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the total number of elements in the input matrix.  We add every element in the matrix to our final answer.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the information stored in <code>seen</code> and in <code>ans</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-layer-by-layer-accepted">Approach #2: Layer-by-Layer [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>The answer will be all the elements in clockwise order from the first-outer layer, followed by the elements from the second-outer layer, and so on.</p>\n<p><strong>Algorithm</strong></p>\n<p>We define the <script type="math/tex; mode=display">\\text{k}</script>-th outer layer of a matrix as all elements that have minimum distance to some border equal to <script type="math/tex; mode=display">\\text{k}</script>.  For example, the following matrix has all elements in the first-outer layer equal to 1, all elements in the second-outer layer equal to 2, and all elements in the third-outer layer equal to 3.</p>\n<div class="codehilite"><pre><span></span>[[1, 1, 1, 1, 1, 1, 1],\n [1, 2, 2, 2, 2, 2, 1],\n [1, 2, 3, 3, 3, 2, 1],\n [1, 2, 2, 2, 2, 2, 1],\n [1, 1, 1, 1, 1, 1, 1]]\n</pre></div>\n<p>For each outer layer, we want to iterate through its elements in clockwise order starting from the top left corner.  Suppose the current outer layer has top-left coordinates <script type="math/tex; mode=display">\\text{(r1, c1)}</script> and bottom-right coordinates <script type="math/tex; mode=display">\\text{(r2, c2)}</script>.</p>\n<p>Then, the top row is the set of elements <script type="math/tex; mode=display">\\text{(r1, c)}</script> for <script type="math/tex; mode=display">\\text{c = c1,...,c2}</script>, in that order.  The rest of the right side is the set of elements <script type="math/tex; mode=display">\\text{(r, c2)}</script> for <script type="math/tex; mode=display">\\text{r = r1+1,...,r2}</script>, in that order.  Then, if there are four sides to this layer (ie., <script type="math/tex; mode=display">\\text{r1 < r2}</script> and <script type="math/tex; mode=display">\\text{c1 < c2}</script>), we iterate through the bottom side and left side as shown in the solutions below.</p>\n<p><img alt="SpiralMatrix" src="https://leetcode.com/articles/Figures/54_spiralmatrix.png"></p>\n<iframe frameborder="0" height="428" name="Xu8axsEu" src="https://leetcode.com/playground/Xu8axsEu/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity:  <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the total number of elements in the input matrix.  We add every element in the matrix to our final answer.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the information stored in <code>ans</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Google', 'Microsoft', 'Uber'],
  },
  {
    id: '55',
    name: 'Jump Game',
    acceptance: '29.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\n</p>\n<p>\nEach element in the array represents your maximum jump length at that position. \n</p>\n<p>\nDetermine if you are able to reach the last index.\n</p>\n\n<p>\nFor example:<br>\nA = <code>[2,3,1,1,4]</code>, return <code>true</code>.\n</p>\n<p>\nA = <code>[3,2,1,0,4]</code>, return <code>false</code>.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#naming">Naming</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-backtracking-stack-overflow">Approach #1 (Backtracking) [Stack Overflow]</a></li>\n<li><a href="#approach-2-dynamic-programming-top-down-stack-overflow">Approach #2 (Dynamic Programming Top-down) [Stack Overflow]</a></li>\n<li><a href="#approach-3-dynamic-programming-bottom-up-time-limit-exceeded">Approach #3 (Dynamic Programming Bottom-up) [Time limit exceeded]</a></li>\n<li><a href="#approach-4-greedy-accepted">Approach #4 (Greedy) [Accepted]</a></li>\n</ul>\n</li>\n<li><a href="#conclusion">Conclusion</a></li>\n<li><a href="#appendix-a-complexity-analysis-for-approach-1">Appendix A - Complexity Analysis for Approach #1</a></li>\n<li><a href="#references">References</a></li>\n</ul>\n</div>\n<h2 id="naming">Naming</h2>\n<ul>\n<li>We call a position in the array a <strong>"good index"</strong> if starting at that position, we can reach the last index. Otherwise, that index is called a <strong>"bad index"</strong>. The problem then reduces to whether or not index 0 is a "good index".</li>\n</ul>\n<h2 id="solution">Solution</h2>\n<p>This is a dynamic programming<sup>[1]</sup> question. Usually, solving and fully understanding a dynamic programming problem is a 4 step process:</p>\n<ol>\n<li>Start with the recursive backtracking solution</li>\n<li>Optimize by using a memoization table (top-down<sup>[3]</sup> dynamic programming)</li>\n<li>Remove the need for recursion (bottom-up dynamic programming)</li>\n<li>Apply final tricks to reduce the time / memory complexity</li>\n</ol>\n<p>All solutions presented below produce the correct result, but they differ in run time and memory requirements.</p>\n<hr>\n<h4 id="approach-1-backtracking-stack-overflow">Approach #1 (Backtracking) [Stack Overflow]</h4>\n<p>This is the inefficient solution where we try every single jump pattern that takes us from the first position to the last. We start from the first position and jump to every index that is reachable. We repeat the process until last index is reached. When stuck, backtrack.</p>\n<iframe frameborder="0" height="394" name="VQGy6N8P" src="https://leetcode.com/playground/VQGy6N8P/shared" width="100%"></iframe>\n<p>One quick optimization we can do for the code above is to check the <code>nextPosition</code> from right to left. The theoretical worst case performance is the same, but in practice, for silly examples, the code might run faster. Intuitively, this means we always try to make the biggest jump such that we reach the end as soon as possible</p>\n<p>The change required is:</p>\n<iframe frameborder="0" height="122" name="evQvAUZk" src="https://leetcode.com/playground/evQvAUZk/shared" width="100%"></iframe>\n<p>For instance, in the example below, if we start from index <strong>0</strong>, jump as far as possible and reach <strong>1</strong>, jump as far as possible and reach <strong>6</strong>. By doing so, we determine that <strong>0</strong> is a <em>GOOD</em> index in 3 steps.</p>\n<table>\n<thead>\n<tr>\n<th align="center">Index</th>\n<th align="center">0</th>\n<th align="center">1</th>\n<th align="center">2</th>\n<th align="center">3</th>\n<th align="center">4</th>\n<th align="center">5</th>\n<th align="center">6</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">nums</td>\n<td align="center">1</td>\n<td align="center">5</td>\n<td align="center">2</td>\n<td align="center">1</td>\n<td align="center">0</td>\n<td align="center">2</td>\n<td align="center">0</td>\n</tr>\n</tbody>\n</table>\n<p>To illustrate the worst case, where this optimization has no effect, take the example below. Index <strong>6</strong> cannot be reached from any position, but all combinations will be tried.</p>\n<table>\n<thead>\n<tr>\n<th align="center">Index</th>\n<th align="center">0</th>\n<th align="center">1</th>\n<th align="center">2</th>\n<th align="center">3</th>\n<th align="center">4</th>\n<th align="center">5</th>\n<th align="center">6</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">nums</td>\n<td align="center">5</td>\n<td align="center">4</td>\n<td align="center">3</td>\n<td align="center">2</td>\n<td align="center">1</td>\n<td align="center">0</td>\n<td align="center">0</td>\n</tr>\n</tbody>\n</table>\n<p>The first few steps of the backtracking algorithm for the example above are: 0 -&gt; 4 -&gt; 5 -&gt; 4 -&gt; 0 -&gt; 3 -&gt; 5 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; etc.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(2^n)</script>. There are <script type="math/tex; mode=display">2^n</script> (upper bound) ways of jumping from the first position to the last, where <script type="math/tex; mode=display">n</script> is the length of array <code>nums</code>. For a complete proof, please refer to Appendix A.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Recursion requires additional memory for the stack frames.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-dynamic-programming-top-down-stack-overflow">Approach #2 (Dynamic Programming Top-down) [Stack Overflow]</h4>\n<p>Top-down Dynamic Programming can be thought of as optimized backtracking. It relies on the observation that once we determine that a certain index is good / bad, this result will never change. This means that we can store the result and not need to recompute it every time.</p>\n<p>Therefore, for each position in the array, we remember whether the index is good or bad. Let\'s call this array <code>memo</code> and let its values be either one of: GOOD, BAD, UNKNOWN. This technique is called memoization<sup>[2]</sup>.</p>\n<p>An example of a memoization table for input array <code>nums = [2, 4, 2, 1, 0, 2, 0]</code> can be seen in the diagram below. We write <strong>G</strong> for a <em>GOOD</em> position and <strong>B</strong> for a <em>BAD</em> one. We can see that we cannot start from indices 2, 3 or 4 and eventually reach last index (6), but we can do that from indices 0, 1, 5 and (trivially) 6.</p>\n<table>\n<thead>\n<tr>\n<th align="center">Index</th>\n<th align="center">0</th>\n<th align="center">1</th>\n<th align="center">2</th>\n<th align="center">3</th>\n<th align="center">4</th>\n<th align="center">5</th>\n<th align="center">6</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">nums</td>\n<td align="center">2</td>\n<td align="center">4</td>\n<td align="center">2</td>\n<td align="center">1</td>\n<td align="center">0</td>\n<td align="center">2</td>\n<td align="center">0</td>\n</tr>\n<tr>\n<td align="center">memo</td>\n<td align="center">G</td>\n<td align="center">G</td>\n<td align="center">B</td>\n<td align="center">B</td>\n<td align="center">B</td>\n<td align="center">G</td>\n<td align="center">G</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Steps</strong></p>\n<ol>\n<li>Initially, all elements of the <code>memo</code> table are <em>UNKNOWN</em>, except for the last one, which is (trivially) <em>GOOD</em> (it can reach itself)</li>\n<li>Modify the backtracking algorithm such that the recursive step first checks if the index is known (<em>GOOD</em> / <em>BAD</em>)<ol>\n<li>If it is known then return <em>True</em> / <em>False</em></li>\n<li>Otherwise perform the backtracking steps as before</li>\n</ol>\n</li>\n<li>Once we determine the value of the current index, we store it in the <code>memo</code> table</li>\n</ol>\n<iframe frameborder="0" height="515" name="uKMuakkv" src="https://leetcode.com/playground/uKMuakkv/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>.\nFor every element in the array, say <code>i</code>, we are looking at the next <code>nums[i]</code> elements to its right aiming to find a <em>GOOD</em> index. <code>nums[i]</code> can be at most <script type="math/tex; mode=display">n</script>, where <script type="math/tex; mode=display">n</script> is the length of array <code>nums</code>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(2n) = O(n)</script>.\nFirst n originates from recursion. Second n comes from the usage of the memo table.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-dynamic-programming-bottom-up-time-limit-exceeded">Approach #3 (Dynamic Programming Bottom-up) [Time limit exceeded]</h4>\n<p>Top-down to bottom-up conversion is done by eliminating recursion. In practice, this achieves better performance as we no longer have the method stack overhead and might even benefit from some caching. More importantly, this step opens up possibilities for future optimization. The recursion is usually eliminated by trying to reverse the order of the steps from the top-down approach.</p>\n<p>The observation to make here is that we only ever jump to the right. This means that if we start from the right of the array, every time we will query a position to our right, that position has already be determined as being <em>GOOD</em> or <em>BAD</em>. This means we don\'t need to recurse anymore, as we will always hit the <code>memo</code> table.</p>\n<iframe frameborder="0" height="479" name="EhUCY4Fj" src="https://leetcode.com/playground/EhUCY4Fj/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>.\nFor every element in the array, say <code>i</code>, we are looking at the next <code>nums[i]</code> elements to its right aiming to find a <em>GOOD</em> index. <code>nums[i]</code> can be at most <script type="math/tex; mode=display">n</script>, where <script type="math/tex; mode=display">n</script> is the length of array <code>nums</code>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>.\nThis comes from the usage of the memo table.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-greedy-accepted">Approach #4 (Greedy) [Accepted]</h4>\n<p>Once we have our code in the bottom-up state, we can make one final, important observation. From a given position, when we try to see if we can jump to a <em>GOOD</em> position, we only ever use one - the first one (see the break statement). In other words, the left-most one. If we keep track of this left-most <em>GOOD</em> position as a separate variable, we can avoid searching for it in the array. Not only that, but we can stop using the array altogether.</p>\n<p>Iterating right-to-left, for each position we check if there is a potential jump that reaches a <em>GOOD</em> index (<code>currPosition + nums[currPosition] &gt;= leftmostGoodIndex</code>). If we can reach a <em>GOOD</em> index, then our position is itself <em>GOOD</em>. Also, this new <em>GOOD</em> position will be the new leftmost <em>GOOD</em> index. Iteration continues until the beginning of the array. If first position is a <em>GOOD</em> index then we can reach the last index from the first position.</p>\n<p>To illustrate this scenario, we will use the diagram below, for input array <code>nums = [9, 4, 2, 1, 0, 2, 0]</code>. We write <strong>G</strong> for <em>GOOD</em>, <strong>B</strong> for <em>BAD</em> and <strong>U</strong> for <em>UNKNOWN</em>. Let\'s assume we have iterated all the way to position 0 and we need to decide if index 0 is <em>GOOD</em>. Since index 1 was determined to be <em>GOOD</em>, it is enough to jump there and then be sure we can eventually reach index 6. It does not matter that <code>nums[0]</code> is big enough to jump all the way to the last index. All we need is <strong>one</strong> way.</p>\n<table>\n<thead>\n<tr>\n<th align="center">Index</th>\n<th align="center">0</th>\n<th align="center">1</th>\n<th align="center">2</th>\n<th align="center">3</th>\n<th align="center">4</th>\n<th align="center">5</th>\n<th align="center">6</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">nums</td>\n<td align="center">9</td>\n<td align="center">4</td>\n<td align="center">2</td>\n<td align="center">1</td>\n<td align="center">0</td>\n<td align="center">2</td>\n<td align="center">0</td>\n</tr>\n<tr>\n<td align="center">memo</td>\n<td align="center">U</td>\n<td align="center">G</td>\n<td align="center">B</td>\n<td align="center">B</td>\n<td align="center">B</td>\n<td align="center">G</td>\n<td align="center">G</td>\n</tr>\n</tbody>\n</table>\n<iframe frameborder="0" height="241" name="kpJ4aQae" src="https://leetcode.com/playground/kpJ4aQae/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nWe are doing a single pass through the <code>nums</code> array, hence <script type="math/tex; mode=display">n</script> steps, where <script type="math/tex; mode=display">n</script> is the length of array <code>nums</code>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.\nWe are not using any extra memory.</p>\n</li>\n</ul>\n<h2 id="conclusion">Conclusion</h2>\n<p>The question left unanswered is how should one approach such a question in an interview scenario. I would say "it depends". The perfect solution is cleaner and shorter than all the other versions, but it might not be so straightforward to figure out.</p>\n<p>The (recursive) backtracking is the easiest to figure out, so it is worth mentioning it verbally while warming up for the tougher challenge. It might be that your interviewer actually wants to see that solution, but if not, mention that there might be a dynamic programming solution and try to think how could you use a memoization table. If you figure it out and the interviewer wants you to go for the top-down approach, it will not generally be time to think of the bottom-up version, but I would always mention the advantages of this technique as a final thought in the interview.</p>\n<p>Most people are stuck when converting from top-down Dynamic Programming (expressed naturally in recursion) to bottom-up. Practicing similar problems will help bridge this gap.</p>\n<h2 id="appendix-a-complexity-analysis-for-approach-1">Appendix A - Complexity Analysis for Approach #1</h2>\n<p>There are <script type="math/tex; mode=display">2^n</script> (upper bound) ways of jumping from the first position to the last, where <script type="math/tex; mode=display">n</script> is the length of array <code>nums</code>. We get this recursively. Let <script type="math/tex; mode=display">T(x)</script> be the number of possible ways of jumping from position <strong>x</strong> to position <strong>n</strong>. <script type="math/tex; mode=display">T(n) = 1</script> trivially. <script type="math/tex; mode=display">T(x) = \\sum_{i = x + 1}^{n} T(i)</script> because from position <strong>x</strong> we can potentially jump to all following positions <strong>i</strong> and then from there there are <script type="math/tex; mode=display">T(i)</script> ways of continuing. Notice this is an upper bound.</p>\n<p>\n<script type="math/tex; mode=display">\n\\begin{align*}\nT(x) &= \\sum_{i = x + 1}^{n} T(i) \\\\\nT(x) &= T(x + 1) + \\sum_{i = x + 2}^{n} T(i) \\\\\nT(x) &= T(x + 1) + T(x + 1) \\\\\nT(x) &= 2 * T(x + 1)\n\\end{align*}\n</script>\n</p>\n<p>Now by induction, assume <script type="math/tex; mode=display">T(x) = 2^{n - x - 1}</script> and prove <script type="math/tex; mode=display">T(x - 1) = 2^{n - (x - 1) - 1}</script>\n</p>\n<p>\n<script type="math/tex; mode=display">\n\\begin{align*}\nT(x - 1) &= 2 * T(x) \\\\\nT(x - 1) &= 2 * 2^{n - x - 1} \\\\\nT(x - 1) &= 2^{n - x - 1 + 1} \\\\\nT(x - 1) &= 2^{n - (x - 1) - 1}\n\\end{align*}\n</script>\n</p>\n<p>Therefore, since we start from position 1, <script type="math/tex; mode=display">T(1) = 2^{n - 2}</script>. Final complexity <script type="math/tex; mode=display">O(2^{n - 2})</script> = <script type="math/tex; mode=display">O(2^n)</script>.</p>\n<h2 id="references">References</h2>\n<ul>\n<li>[1] <a href="https://en.wikipedia.org/wiki/Dynamic_programming">https://en.wikipedia.org/wiki/Dynamic_programming</a></li>\n<li>[2] <a href="https://en.wikipedia.org/wiki/Memoization">https://en.wikipedia.org/wiki/Memoization</a></li>\n<li>[3] <a href="https://en.wikipedia.org/wiki/Top-down_and_bottom-up_design">https://en.wikipedia.org/wiki/Top-down_and_bottom-up_design</a></li>\n</ul>\n<p>Analysis written by: <a href="http://andrei.cioara.me">@aicioara</a></p>\n<p>Thank you <a href="https://discuss.leetcode.com/user/jied333">@jied333</a> for correcting the backtracking complexity analysis.</p>\n</div>\n          ',
    tags: ['Microsoft'],
  },
  {
    id: '56',
    name: 'Merge Intervals',
    acceptance: '31.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a collection of intervals, merge all overlapping intervals.</p>\n\n<p>\nFor example,<br>\nGiven <code>[1,3],[2,6],[8,10],[15,18]</code>,<br>\nreturn <code>[1,6],[8,10],[15,18]</code>.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-connected-components-time-limited-exceeded">Approach #1 Connected Components [Time Limited Exceeded]</a></li>\n<li><a href="#approach-2-sorting-accepted">Approach #2 Sorting [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-connected-components-time-limited-exceeded">Approach #1 Connected Components [Time Limited Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we draw a graph (with intervals as nodes) that contains undirected edges\nbetween all pairs of intervals that overlap, then all intervals in each\n<em>connected component</em> of the graph can be merged into a single interval.</p>\n<p><strong>Algorithm</strong></p>\n<p>With the above intuition in mind, we can represent the graph as an adjacency\nlist, inserting directed edges in both directions to simulate undirected\nedges. Then, to determine which connected component each node is it, we\nperform graph traversals from arbitrary unvisited nodes until all nodes have\nbeen visited. To do this efficiently, we store visited nodes in a <code>Set</code>,\nallowing for constant time containment checks and insertion. Finally, we\nconsider each connected component, merging all of its intervals by\nconstructing a new <code>Interval</code> with <code>start</code> equal to the minimum start among\nthem and <code>end</code> equal to the maximum end.</p>\n<p>This algorithm is correct simply because it is basically the brute force\nsolution. We compare every interval to every other interval, so we know\nexactly which intervals overlap. The reason for the connected component\nsearch is that two intervals may not directly overlap, but might overlap\nindirectly via a third interval. See the example below to see this more\nclearly.</p>\n<p align="center"><img alt="Components Example" src="https://leetcode.com/articles/Figures/56/component.png"></p>\n<p>Although (1, 5) and (6, 10) do not directly overlap, either would overlap\nwith the other if first merged with (4, 7). There are two connected\ncomponents, so if we merge their nodes, we expect to get the following two\nmerged intervals:</p>\n<p>(1, 10), (15, 20)</p>\n<iframe frameborder="0" height="500" name="x3cmWRvG" src="https://leetcode.com/playground/x3cmWRvG/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>\n</p>\n<p>Building the graph costs <script type="math/tex; mode=display">O(V + E) = O(V) + O(E) = O(n) + O(n^2) = O(n^2)</script>\ntime, as in the worst case all intervals are mutually overlapping.\nTraversing the graph has the same cost (although it might appear higher\nat first) because our <code>visited</code> set guarantees that each node will be\nvisited exactly once. Finally, because each node is part of exactly one\ncomponent, the merge step costs <script type="math/tex; mode=display">O(V) = O(n)</script> time. This all adds up as\nfollows:</p>\n<p>\n<script type="math/tex; mode=display">\n    O(n^2) + O(n^2) + O(n) = O(n^2)\n</script>\n</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^2)</script>\n</p>\n<p>As previously mentioned, in the worst case, all intervals are mutually\noverlapping, so there will be an edge for every pair of intervals.\nTherefore, the memory footprint is quadratic in the input size.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-sorting-accepted">Approach #2 Sorting [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we sort the intervals by their <code>start</code> value, then each set of intervals\nthat can be merged will appear as a contiguous "run" in the sorted list.</p>\n<p><strong>Algorithm</strong></p>\n<p>First, we sort the list as described. Then, we insert the first interval into\nour <code>merged</code> list and continue considering each interval in turn as follows:\nIf the current interval begins <em>after</em> the previous interval ends, then they\ndo not overlap and we can append the current interval to <code>merged</code>. Otherwise,\nthey do overlap, and we merge them by updating the <code>end</code> of the previous\ninterval if it is less than the <code>end</code> of the current interval.</p>\n<p>A simple proof by contradiction shows that this algorithm always produces the\ncorrect answer. First, suppose that the algorithm at some point fails to\nmerge two intervals that should be merged. This would imply that there exists\nsome triple of indices <script type="math/tex; mode=display">i</script>, <script type="math/tex; mode=display">j</script>, and <script type="math/tex; mode=display">k</script> in a list of intervals\n<script type="math/tex; mode=display">ints</script> such that <script type="math/tex; mode=display">i < j < k</script> and (<script type="math/tex; mode=display">ints[i]</script>, <script type="math/tex; mode=display">ints[k]</script>) can be\nmerged, but neither (<script type="math/tex; mode=display">ints[i]</script>, <script type="math/tex; mode=display">ints[j]</script>) nor (<script type="math/tex; mode=display">ints[j]</script>, <script type="math/tex; mode=display">ints[k]</script>)\ncan be merged. From this scenario follow several inequalities:</p>\n<p>\n<script type="math/tex; mode=display">\n\\begin{aligned}\n    ints[i].end < ints[j].start \\\\\n    ints[j].end < ints[k].start \\\\\n    ints[i].end \\geq ints[k].start \\\\\n\\end{aligned}\n</script>\n</p>\n<p>We can chain these inequalities (along with the following inequality, implied\nby the well-formedness of the intervals: <script type="math/tex; mode=display">ints[j].start \\leq ints[j].end</script>) to\ndemonstrate a contradiction:</p>\n<p>\n<script type="math/tex; mode=display">\n\\begin{aligned}\n    ints[i].end < ints[j].start \\leq ints[j].end < ints[k].start \\\\\n    ints[i].end \\geq ints[k].start\n\\end{aligned}\n</script>\n</p>\n<p>Therefore, all mergeable intervals must occur in a contiguous run of the\nsorted list.</p>\n<p align="center"><img alt="Sorting Example" src="https://leetcode.com/articles/Figures/56/sort.png"></p>\n<p>Consider the example above, where the intervals are sorted, and then all\nmergeable intervals form contiguous blocks.</p>\n<iframe frameborder="0" height="500" name="Jkko9mPu" src="https://leetcode.com/playground/Jkko9mPu/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nlgn)</script>\n</p>\n<p>Other than the <code>sort</code> invocation, we do a simple linear scan of the list,\nso the runtime is dominated by the <script type="math/tex; mode=display">O(nlgn)</script> complexity of sorting.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script> (or <script type="math/tex; mode=display">O(n)</script>)</p>\n<p>If we can sort <code>intervals</code> in place, we do not need more than constant\nadditional space. Otherwise, we must allocate linear space to store a\ncopy of <code>intervals</code> and sort that.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis and solutions written by: <a href="https://leetcode.com/emptyset">@emptyset</a></p>\n</div>\n          ',
    tags: ['Google', 'Facebook', 'Microsoft', 'Bloomberg', 'LinkedIn', 'Twitter', 'Yelp'],
  },
  {
    id: '57',
    name: 'Insert Interval',
    acceptance: '28.5%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given a set of <i>non-overlapping</i> intervals, insert a new interval into the intervals (merge if necessary).</p>\n\n<p>You may assume that the intervals were initially sorted according to their start times.</p>\n\n<p>\n<b>Example 1:</b><br>\nGiven intervals <code>[1,3],[6,9]</code>, insert and merge <code>[2,5]</code> in as <code>[1,5],[6,9]</code>.\n</p>\n\n<p>\n<b>Example 2:</b><br>\nGiven <code>[1,2],[3,5],[6,7],[8,10],[12,16]</code>, insert and merge <code>[4,9]</code> in as <code>[1,2],[3,10],[12,16]</code>.\n</p>\n\n<p>\nThis is because the new interval <code>[4,9]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'LinkedIn'],
  },
  {
    id: '58',
    name: 'Length of Last Word',
    acceptance: '32.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a string <i>s</i> consists of upper/lower-case alphabets and empty space characters <code>\' \'</code>, return the length of last word in the string.</p>\n\n<p>If the last word does not exist, return 0.</p>\n\n<p><b>Note:</b> A word is defined as a character sequence consists of non-space characters only.</p>\n\n<p><b>Example:</b>\n</p><pre><b>Input:</b> "Hello World"\n<b>Output:</b> 5\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '59',
    name: 'Spiral Matrix II',
    acceptance: '40.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given an integer <i>n</i>, generate a square matrix filled with elements from 1 to <i>n</i><sup>2</sup> in spiral order.</p>\n\n<p>\nFor example,<br>\nGiven <i>n</i> = <code>3</code>,\n</p>\nYou should return the following matrix:\n<pre>[\n [ 1, 2, 3 ],\n [ 8, 9, 4 ],\n [ 7, 6, 5 ]\n]\n</pre>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '60',
    name: 'Permutation Sequence',
    acceptance: '29.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>The set <code>[1,2,3,…,<i>n</i>]</code> contains a total of <i>n</i>! unique permutations.</p>\n\n<p>By listing and labeling all of the permutations in order,<br>\nWe get the following sequence (ie, for <i>n</i> = 3):\n</p><ol>\n<li><code>"123"</code></li>\n<li><code>"132"</code></li>\n<li><code>"213"</code></li>\n<li><code>"231"</code></li>\n<li><code>"312"</code></li>\n<li><code>"321"</code></li>\n</ol>\n<p></p>\n\n<p>Given <i>n</i> and <i>k</i>, return the <i>k</i><sup>th</sup> permutation sequence.</p>\n\n<p><b>Note:</b> Given <i>n</i> will be between 1 and 9 inclusive.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Twitter'],
  },
  {
    id: '61',
    name: 'Rotate List',
    acceptance: '24.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a list, rotate the list to the right by <i>k</i> places, where <i>k</i> is non-negative.</p>\n\n<br>\n\n<p><b>Example:</b>\n</p><pre>Given <b>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</b> and <i>k</i> = <b>2</b>,\n\nreturn <b>4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</b>.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '62',
    name: 'Unique Paths',
    acceptance: '42.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>A robot is located at the top-left corner of a <i>m</i> x <i>n</i> grid (marked \'Start\' in the diagram below).</p>\n\n<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \'Finish\' in the diagram below).</p>\n\n<p>How many possible unique paths are there?</p>\n\n<p>\n<img src="https://leetcode.com/static/images/problemset/robot_maze.png"><br>\n</p><p style="font-size: 11px">Above is a 3 x 7 grid. How many possible unique paths are there?\n</p>\n\n<p><b>Note:</b> <i>m</i> and <i>n</i> will be at most 100.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '63',
    name: 'Unique Paths II',
    acceptance: '32.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Follow up for "Unique Paths":</p>\n\n<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>\n\n<p>An obstacle and empty space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p>\n\n<p>For example,<br>\n</p><p>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>\n<pre>[\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\n</pre>\n<p>The total number of unique paths is <code>2</code>.</p>\n\n<p><b>Note:</b> <i>m</i> and <i>n</i> will be at most 100.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '64',
    name: 'Minimum Path Sum',
    acceptance: '39.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a <i>m</i> x <i>n</i> grid filled with non-negative numbers, find a path from top left to bottom right which <i>minimizes</i> the sum of all numbers along its path.</p>\n\n<p><b>Note:</b> You can only move either down or right at any point in time.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre>[[1,3,1],\n [1,5,1],\n [4,2,1]]\n</pre>\nGiven the above grid map, return <code>7</code>. Because the path 1→3→1→1→1 minimizes the sum.\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-dynamic-programming-2d-accepted">Approach #2 Dynamic Programming 2D [Accepted]</a></li>\n<li><a href="#approach-3-dynamic-programming-1d-accepted">Approach #3 Dynamic Programming 1D [Accepted]</a></li>\n<li><a href="#approach-4-dynamic-programming-without-extra-space-accepted">Approach #4 Dynamic Programming (Without Extra Space) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>We have to find the minimum sum of numbers over a path from the top left to the bottom right of the given matrix .</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The Brute Force approach involves recursion. For each element, we consider two paths, rightwards and downwards and find the minimum sum out of those two. It specifies whether we need to take a right step or downward step to minimize the sum.</p>\n<p>\n<script type="math/tex; mode=display">\n\\mathrm{cost}(i, j)=\\mathrm{grid}[i][j] + \\min \\big(\\mathrm{cost}(i+1, j), \\mathrm{cost}(i, j+1) \\big)\n</script>\n</p>\n<iframe frameborder="0" height="224" name="kC5Ukq5y" src="https://leetcode.com/playground/kC5Ukq5y/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O\\big(2^{m+n}\\big)</script>. For every move, we have atmost 2 options.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(m+n)</script>. Recursion of depth <script type="math/tex; mode=display">m+n</script>.</li>\n</ul>\n<hr>\n<h4 id="approach-2-dynamic-programming-2d-accepted">Approach #2 Dynamic Programming 2D [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We use an extra matrix <script type="math/tex; mode=display">dp</script> of the same size as the original matrix. In this matrix, <script type="math/tex; mode=display">dp(i, j)</script> represents the minimum sum of the path from the index <script type="math/tex; mode=display">(i, j)</script> to\nthe bottom rightmost element. We start by initializing the bottom rightmost element\nof <script type="math/tex; mode=display">dp</script> as the last element of the given matrix. Then for each element starting from\nthe bottom right, we traverse backwards and fill in the matrix with the required\nminimum sums. Now, we need to note that at every element, we can move either\nrightwards or downwards. Therefore, for filling in the minimum sum, we use the\nequation:</p>\n<p>\n<script type="math/tex; mode=display">\ndp(i, j)=grid(i,j)+\\min\\big(dp(i+1,j),dp(i,j+1)\\big)\n</script>\n</p>\n<p>, taking care of the boundary conditions.</p>\n<p>The following figure illustrates the process:\n<!--<img alt="Minimum Path Sum" src="https://leetcode.com/media/original_images/64_Minimum_Path_Sum.gif" />-->\n!?!../Documents/64_Minimum_Path_Sum.json:859,390!?!</p>\n<iframe frameborder="0" height="377" name="5fJ5HNRc" src="https://leetcode.com/playground/5fJ5HNRc/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. We traverse the entire matrix once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m*n)</script>. Another matrix of the same size is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-dynamic-programming-1d-accepted">Approach #3 Dynamic Programming 1D [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the previous case, instead of using a 2D matrix for dp, we can do the same\nwork using a <script type="math/tex; mode=display">dp</script> array of the row size, since for making the current entry all we need is the dp entry for the bottom and\n the right element. Thus,\nwe start by initializing only the last element of the array as the last element of the given matrix.\nThe last entry is the bottom rightmost element of the given matrix. Then, we start\nmoving towards the left and update the entry <script type="math/tex; mode=display">dp(j)</script> as:</p>\n<p>\n<script type="math/tex; mode=display">\ndp(j)=\\mathrm{grid}(i,j)+\\min\\big(dp(j),dp(j+1)\\big)\n</script>\n</p>\n<p>We repeat the same process for every row as we move upwards. At the end <script type="math/tex; mode=display">dp(0)</script> gives the\n required minimum sum.</p>\n<iframe frameborder="0" height="377" name="XgvFcLsp" src="https://leetcode.com/playground/XgvFcLsp/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. We traverse the entire matrix once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Another array of row size is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-dynamic-programming-without-extra-space-accepted">Approach #4 Dynamic Programming (Without Extra Space) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This approach is same as Approach 2, with a slight difference. Instead of using\nanother <script type="math/tex; mode=display">dp</script> matrix. We can store the minimum sums in the original matrix itself,\nsince we need not retain the original matrix here. Thus, the governing equation\nnow becomes:</p>\n<p>\n<script type="math/tex; mode=display">\n\\mathrm{grid}(i, j)=\\mathrm{grid}(i,j)+\\min \\big(\\mathrm{grid}(i+1,j), \\mathrm{grid}(i,j+1)\\big)\n</script>\n</p>\n<iframe frameborder="0" height="309" name="dkpZnrSg" src="https://leetcode.com/playground/dkpZnrSg/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. We traverse the entire matrix once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '65',
    name: 'Valid Number',
    acceptance: '12.9%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Validate if a given string is numeric.</p>\n\n<p>\nSome examples:<br>\n<code>"0"</code> =&gt; <code>true</code><br>\n<code>"   0.1  "</code> =&gt; <code>true</code><br>\n<code>"abc"</code> =&gt; <code>false</code><br>\n<code>"1 a"</code> =&gt; <code>false</code><br>\n<code>"2e10"</code> =&gt; <code>true</code><br>\n</p>\n\n<p><b>Note:</b> It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.\n</p>\n\n<p>\n<b><font color="red">Update (2015-02-10):</font></b><br>\nThe signature of the <code>C++</code> function had been updated. If you still see your function signature accepts a <code>const char *</code> argument, please click the reload button <span class="glyphicon glyphicon-refresh"></span> to reset your code definition.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '66',
    name: 'Plus One',
    acceptance: '39.2%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a non-negative integer represented as a <b>non-empty</b> array of digits, plus one to the integer.</p>\n\n<p>You may assume the integer do not contain any leading zero, except the number 0 itself.</p>\n\n<p>The digits are stored such that the most significant digit is at the head of the list.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '67',
    name: 'Add Binary',
    acceptance: '33.4%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven two binary strings, return their sum (also a binary string).\n</p>\n\n<p>\nFor example,<br>\na = <code>"11"</code><br>\nb = <code>"1"</code><br>\nReturn <code>"100"</code>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook'],
  },
  {
    id: '68',
    name: 'Text Justification',
    acceptance: '19.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array of words and a length <i>L</i>, format the text such that each line has exactly <i>L</i> characters and is fully (left and right) justified.\n</p> \n\n<p>\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces <code>\' \'</code> when necessary so that each line has exactly <i>L</i> characters.\n</p>\n\n<p>\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n</p>\n\n<p>\nFor the last line of text, it should be left justified and no extra space is inserted between words.\n</p>\n\n<p>\nFor example,<br>\n<b>words</b>: <code>["This", "is", "an", "example", "of", "text", "justification."]</code><br>\n<b>L</b>: <code>16</code>.\n</p>\n\n<p>\nReturn the formatted lines as:<br>\n</p><pre>[\n   "This    is    an",\n   "example  of text",\n   "justification.  "\n]\n</pre>\n<p></p>\n\n<p>\n<b>Note:</b> Each word is guaranteed not to exceed <i>L</i> in length.\n</p>\n\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show corner cases.</a></p>\n\n<div class="spoilers"><b>Corner Cases:</b>\n<p>\n</p><ul>\n<li>A line other than the last line might contain only one word. What should you do in this case?<br>\nIn this case, that line should be left-justified.</li>\n<p></p>\n</ul></div>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'LinkedIn', 'Airbnb'],
  },
  {
    id: '69',
    name: 'Sqrt(x)',
    acceptance: '28.4%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Implement <code>int sqrt(int x)</code>.</p>\n\n<p>Compute and return the square root of <i>x</i>.</p>\n\n<p><b>x</b> is guaranteed to be a non-negative integer.</p>\n\n<br>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b> 4\n<b>Output:</b> 2\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b> 8\n<b>Output:</b> 2\n<b>Explanation:</b> The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Bloomberg', 'Apple'],
  },
  {
    id: '70',
    name: 'Climbing Stairs',
    acceptance: '40.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>You are climbing a stair case. It takes <i>n</i> steps to reach to the top.</p>\n\n<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n</p>\n\n<p><b>Note:</b> Given <i>n</i> will be a positive integer.\n</p>\n\n<br>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b> 2\n<b>Output:</b>  2\n<b>Explanation:</b>  There are two ways to climb to the top.\n\n1. 1 step + 1 step\n2. 2 steps\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b> 3\n<b>Output:</b>  3\n<b>Explanation:</b>  There are three ways to climb to the top.\n\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-recursion-with-memorization-accepted">Approach #2 Recursion with memorization [Accepted]</a></li>\n<li><a href="#approach-3-dynamic-programming-accepted">Approach #3 Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-4-fibonacci-number-accepted">Approach #4 Fibonacci Number [Accepted]:</a></li>\n<li><a href="#approach-5-binets-method-accepted">Approach #5 Binets Method [Accepted]:</a></li>\n<li><a href="#approach-6-fibonacci-formula-accepted">Approach #6 Fibonacci Formula [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>You are climbing a stair case. It takes n steps to reach to the top.</p>\n<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this brute force approach we take all possible step combinations i.e. 1 and 2, at every step. At every step we are calling the function <script type="math/tex; mode=display">climbStairs</script> for step <script type="math/tex; mode=display">1</script> and <script type="math/tex; mode=display">2</script>, and return the sum of returned values of both functions.</p>\n<p>\n<script type="math/tex; mode=display">climbStairs(i,n)=(i + 1, n) + climbStairs(i + 2, n)</script>, where <script type="math/tex; mode=display">i</script> defines the current step and <script type="math/tex; mode=display">n</script> defines the destination step.</p>\n<iframe frameborder="0" height="309" name="9wu5u86u" src="https://leetcode.com/playground/9wu5u86u/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(2^n)</script>. Size of recursion tree will be <script type="math/tex; mode=display">2^n</script>.</p>\n<p>Recursion tree for n=5 would be like this:</p>\n<p><img alt="Climbing_Stairs" src="https://leetcode.com/articles/Figures/70_Climbing_Stairs_rt.jpg"></p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of the recursion tree can go upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-recursion-with-memorization-accepted">Approach #2 Recursion with memorization [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the previous approach we are redundantly calculating the result for every step. Instead, we can store the result at each step in <script type="math/tex; mode=display">memo</script> array and directly returning the result from the memo array whenever that function is called again.</p>\n<p>In this way we are pruning recursion tree with the help of <script type="math/tex; mode=display">memo</script> array and reducing the size of recursion tree upto <script type="math/tex; mode=display">n</script>.</p>\n<iframe frameborder="0" height="411" name="8vstwMnN" src="https://leetcode.com/playground/8vstwMnN/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Size of recursion tree can go upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of recursion tree can go upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-dynamic-programming-accepted">Approach #3 Dynamic Programming [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>As we can see this problem can be broken into subproblems, and it contains the optimal substructure property i.e. its optimal solution can be constructed efficiently from optimal solutions of its subproblems, we can use dynamic programming to solve this problem.</p>\n<p>One can reach <script type="math/tex; mode=display">i^{th}</script> step in one of the two ways:</p>\n<ol>\n<li>\n<p>Taking a single step from <script type="math/tex; mode=display">(i-1)^{th}</script> step.</p>\n</li>\n<li>\n<p>Taking a step of <script type="math/tex; mode=display">2</script> from <script type="math/tex; mode=display">(i-2)^{th}</script> step.</p>\n</li>\n</ol>\n<p>So, the total number of ways to reach <script type="math/tex; mode=display">i^{th}</script> is equal to sum of ways of reaching <script type="math/tex; mode=display">(i-1)^{th}</script> step and ways of reaching <script type="math/tex; mode=display">(i-2)^{th}</script> step.</p>\n<p>Let <script type="math/tex; mode=display">dp[i]</script> denotes the number of ways to reach on <script type="math/tex; mode=display">i^{th}</script> step.</p>\n<p>\n<script type="math/tex; mode=display">dp[i]=dp[i-1]+dp[i-2]</script>\n</p>\n<p>Example:</p>\n<!--![Climbing_Stairs](https://leetcode.com/articles/Figures/70_Climbing_Stairs.gif)-->\n<p>!?!../Documents/70_Climbing_Stairs.json:1000,563!?!</p>\n<iframe frameborder="0" height="309" name="ma2pcxbp" src="https://leetcode.com/playground/ma2pcxbp/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Single loop upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-fibonacci-number-accepted">Approach #4 Fibonacci Number [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the above approach we have used <script type="math/tex; mode=display">dp</script> array where <script type="math/tex; mode=display">dp[i]=dp[i-1]+dp[i-2]</script>. It can be easily analysed that <script type="math/tex; mode=display">dp[i]</script> is nothing but <script type="math/tex; mode=display">i^{th}</script> fibonacci number.</p>\n<p>\n<script type="math/tex; mode=display">Fib(n)=Fib(n-1)+Fib(n-2)</script>\n</p>\n<p>Now we just have to find <script type="math/tex; mode=display">n^{th}</script> number of the fibonacci series having <script type="math/tex; mode=display">1</script> and <script type="math/tex; mode=display">2</script> their first and second term respectively i.e. <script type="math/tex; mode=display">Fib(1)=1</script> and <script type="math/tex; mode=display">Fib(2)=2</script>.</p>\n<iframe frameborder="0" height="309" name="LAPbmrSH" src="https://leetcode.com/playground/LAPbmrSH/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Single loop upto <script type="math/tex; mode=display">n</script> is required to calculate <script type="math/tex; mode=display">n^{th}</script> fibonacci number.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-binets-method-accepted">Approach #5 Binets Method [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>This is an interesting solution which uses matrix multiplication to obtain the <script type="math/tex; mode=display">n^{th}</script> Fibonacci Number. The matrix takes the following form:</p>\n<p>\n<script type="math/tex; mode=display">\\left[ {\\begin{array}{cc} F_{n+1} & F_n \\\\  F_n & F_{n-1}     \\end{array} } \\right] = \\left[ {\\begin{array}{cc} 1 & 1 \\\\  1 & 0     \\end{array} } \\right]</script>.</p>\n<p>Let\'s say <script type="math/tex; mode=display">Q=\\left[ {\\begin{array}{cc} F_{n+1} & F_n \\\\  F_n & F_{n-1}     \\end{array} } \\right]</script>\n</p>\n<p>As per the method, the <script type="math/tex; mode=display">n^{th}</script> Fibonacci Number is given by <script type="math/tex; mode=display">Q^{n-1}[0,0]</script>\n</p>\n<p>Let\'s look at the proof of this method.</p>\n<p>We can prove this method using Mathematical Induction. We know, this matrix gives the correct result for the <script type="math/tex; mode=display">3^{rd}</script> term(base case). Since <script type="math/tex; mode=display">Q^2 = \\left[ {\\begin{array}{cc} 2 & 1 \\\\  1 & 1     \\end{array} } \\right]</script>. This proves that the base case holds.</p>\n<p>Assume that this method holds for finding the <script type="math/tex; mode=display">n^{th}</script> Fibonacci Number i.e. <script type="math/tex; mode=display">F_n=Q^{n-1}[0,0]</script>, where <script type="math/tex; mode=display">Q^{n-1}=\\left[ {\\begin{array}{cc} F_{n} & F_{n-1} \\\\  F_{n-1} & F_{n-2}     \\end{array} } \\right]</script>.</p>\n<p>Now, we need to prove that with the above two conditions holding true, the method is valid for finding the <script type="math/tex; mode=display">(n+1)^{th}</script> Fibonacci Number i.e. <script type="math/tex; mode=display">F_{n+1}=Q^{n}[0,0]</script>\n</p>\n<p>Proof: <script type="math/tex; mode=display">Q^{n} = \\left[ {\\begin{array}{cc} F_{n} & F_{n-1} \\\\  F_{n-1} & F_{n-2}     \\end{array} } \\right]\\left[ {\\begin{array}{cc} 1 & 1 \\\\  1 & 0     \\end{array} } \\right]</script>.\n <script type="math/tex; mode=display">Q^{n} = \\left[ {\\begin{array}{cc} F_{n}+F_{n-1} & F_n \\\\  F_{n-1}+F_{n-2} & F_{n-1}    \\end{array} } \\right]</script>\n<script type="math/tex; mode=display">Q^{n} = \\left[ {\\begin{array}{cc} F_{n+1} & F_n \\\\  F_n & F_{n-1}     \\end{array} } \\right]</script>\n</p>\n<p>Thus, <script type="math/tex; mode=display">F_{n+1}=Q^{n}[0,0]</script>. This completes the proof of this method.</p>\n<p>The only variation we need to do for our problem is that we need to modify the initial terms to 2 and 1 instead of 1 and 0 in the Fibonacci series. Or, another way is to use the same initial <script type="math/tex; mode=display">Q</script> matrix and use <script type="math/tex; mode=display">result = Q^{n}[0,0]</script> to get the final result. This happens because the initial terms we have to use are the 2nd and 3rd terms of the otherwise normal Fibonacci Series.</p>\n<iframe frameborder="0" height="515" name="NV9UfA5Q" src="https://leetcode.com/playground/NV9UfA5Q/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(log(n))</script>. Traversing on <script type="math/tex; mode=display">log(n)</script> bits.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<p>Proof of Time Complexity:</p>\n<p>Let\'s say there is a  matrix <script type="math/tex; mode=display">M</script> to be raised to  power <script type="math/tex; mode=display">n</script>. Suppose, <script type="math/tex; mode=display">n</script> is the power of 2. Thus, <script type="math/tex; mode=display">n = 2^i</script>, <script type="math/tex; mode=display">i\\in\\mathbb{N}</script>, where <script type="math/tex; mode=display">\\mathbb{N}</script> represents the set of natural numbers(including 0). We can represent  in the form of a tree:</p>\n<p><img alt="Climbing Stairs" src="https://leetcode.com/articles/Figures/70_Climbing_Stairs.PNG"></p>\n<p>Meaning that:</p>\n<p>\n<script type="math/tex; mode=display">M^n = M^{n/2}.M^{n/2} = .... = \\prod_{1}^{n} M^{1}</script>\n</p>\n<p>So, to calculate  <script type="math/tex; mode=display">M^{n}</script> matrix, we should calculate <script type="math/tex; mode=display">M^{n/2}</script>  matrix and multiply it by itself. To calculate <script type="math/tex; mode=display">M^{n/2}</script> we would have to do the same with <script type="math/tex; mode=display">M^{n/4}</script> and so on.</p>\n<p>Obviously, the tree height is <script type="math/tex; mode=display">log_{2}n</script>.</p>\n<p>Let’s estimate <script type="math/tex; mode=display">M^{n}</script> calculation time. <script type="math/tex; mode=display">M</script> matrix is of the same size in any power . Therefore, we can perform the multiplication of two matrices in any power in <script type="math/tex; mode=display">O(1)</script>. We should perform <script type="math/tex; mode=display">log_2{n}</script> of such multiplications. So, <script type="math/tex; mode=display">M^{n}</script> calculation complexity is <script type="math/tex; mode=display">O(log_{2}n)</script>.</p>\n<p>In case, the number <script type="math/tex; mode=display">n</script> is not a power of two, we can break it in terms of powers of 2 using its binary representation</p>\n<p>\n<script type="math/tex; mode=display">n= \\sum_{p\\in P} 2^{p}</script>, where <script type="math/tex; mode=display">P\\subset\\mathbb{N}</script>.</p>\n<p>Thus, we can obtain the final result using:</p>\n<p>\n<script type="math/tex; mode=display">M^{n} = \\prod_{p\\in P} M^{2^{p}}</script>\n</p>\n<p>This is the method we\'ve used in our implementation. Again, the complexity remains <script type="math/tex; mode=display">O(log_{2}n)</script> as we have limited the number of multiplications to <script type="math/tex; mode=display">O(log_{2}n)</script>.</p>\n<hr>\n<h4 id="approach-6-fibonacci-formula-accepted">Approach #6 Fibonacci Formula [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can find <script type="math/tex; mode=display">n^{th}</script> fibonacci number using this formula:</p>\n<p>\n<script type="math/tex; mode=display">F_n = 1/\\sqrt{5}\\left[ \\left(\\frac{1+\\sqrt{5}}{2}\\right)^{n} - \\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n} \\right]</script>\n</p>\n<p>For the given problem, the Fibonacci sequence is defined by <script type="math/tex; mode=display">F_0 = 1</script>, <script type="math/tex; mode=display">F_1= 1</script>,  <script type="math/tex; mode=display">F_1= 2</script>, <script type="math/tex; mode=display">F_{n+2}= F_{n+1} + F_n</script>. A standard method of trying to solve such recursion formulas is assume <script type="math/tex; mode=display">F_n</script> of the form <script type="math/tex; mode=display">F_n= a^n</script>. Then, of course, <script type="math/tex; mode=display">F_{n+1} = a^{n+1}</script> and <script type="math/tex; mode=display">F_{n+2}= a^{n+2}</script> so the equation becomes <script type="math/tex; mode=display">a^{n+2}= a^{n+1}+ a^n</script>. If we divide the entire equation by an we arrive at <script type="math/tex; mode=display">a^2= a + 1</script> or the quadratic equation</p>\n<p>\n<script type="math/tex; mode=display">a^2 - a- 1= 0</script>.</p>\n<p>Solving this by the quadratic formula, we get:</p>\n<p>\n<script type="math/tex; mode=display">a=1/\\sqrt{5}\\left(\\left(\\frac{1\\pm \\sqrt{5}}{2}\\right)\\right)</script>.</p>\n<p>The general solution, thus takes the form:</p>\n<p>\n<script type="math/tex; mode=display">F_n = A\\left(\\frac{1+\\sqrt{5}}{2}\\right)^{n} + B\\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n}</script>\n</p>\n<p>For <script type="math/tex; mode=display">n=0</script>, we get <script type="math/tex; mode=display">A + B = 1</script>\n</p>\n<p>For <script type="math/tex; mode=display">n=1</script>, we get <script type="math/tex; mode=display">A\\left(\\frac{1+\\sqrt{5}}{2}\\right) + B\\left(\\frac{1-\\sqrt{5}}{2}\\right) = 1</script>\n</p>\n<p>Solving the above equations, we get:</p>\n<p>\n<script type="math/tex; mode=display">A = \\left(\\frac{1+\\sqrt{5}}{2\\sqrt{5}}\\right), B = \\left(\\frac{1-\\sqrt{5}}{2\\sqrt{5}}\\right)</script>\n</p>\n<p>Putting these values of <script type="math/tex; mode=display">A</script> and <script type="math/tex; mode=display">B</script> in the above general solution equation, we get:</p>\n<p>\n<script type="math/tex; mode=display">F_n = 1/\\sqrt{5}\\left( \\left(\\frac{1+\\sqrt{5}}{2}\\right)^{n+1} - \\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n+1} \\right)</script>\n</p>\n<iframe frameborder="0" height="173" name="eH7EYNzi" src="https://leetcode.com/playground/eH7EYNzi/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(log(n))</script>. <script type="math/tex; mode=display">pow</script> method takes <script type="math/tex; mode=display">log(n)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Apple', 'Adobe'],
  },
  {
    id: '71',
    name: 'Simplify Path',
    acceptance: '25.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given an absolute path for a file (Unix-style), simplify it.</p>\n\n<p>For example,<br>\n<b>path</b> = <code>"/home/"</code>, =&gt; <code>"/home"</code><br>\n<b>path</b> = <code>"/a/./b/../../c/"</code>, =&gt; <code>"/c"</code><br>\n</p>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show corner cases.</a></p>\n\n<div class="spoilers"><b>Corner Cases:</b>\n\n<p>\n</p><ul>\n<li>Did you consider the case where <b>path</b> = <code>"/../"</code>?<br>\nIn this case, you should return <code>"/"</code>.</li>\n<li>Another corner case is the path might contain multiple slashes <code>\'/\'</code> together, such as <code>"/home//foo/"</code>.<br>\nIn this case, you should ignore redundant slashes and return <code>"/home/foo"</code>.</li>\n<p></p>\n</ul></div>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft'],
  },
  {
    id: '72',
    name: 'Edit Distance',
    acceptance: '32.2%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven two words <i>word1</i> and <i>word2</i>, find the minimum number of steps required to convert <i>word1</i> to <i>word2</i>. (each operation is counted as 1 step.)\n</p>\n\n<p>\nYou have the following 3 operations permitted on a word:\n</p>\n\n<p>\na) Insert a character<br>\nb) Delete a character<br>\nc) Replace a character<br>\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '73',
    name: 'Set Matrix Zeroes',
    acceptance: '36.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a <i>m</i> x <i>n</i> matrix, if an element is 0, set its entire row and column to 0. Do it in place.\n</p>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show follow up.</a></p>\n\n<div class="spoilers"><b>Follow up:</b>\n\n<p>\nDid you use extra space?<br>\nA straight forward solution using O(<i>m</i><i>n</i>) space is probably a bad idea.<br>\nA simple improvement uses O(<i>m</i> + <i>n</i>) space, but still not the best solution.<br>\nCould you devise a constant space solution?\n</p>\n</div>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft', 'Amazon'],
  },
  {
    id: '74',
    name: 'Search a 2D Matrix',
    acceptance: '34.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Write an efficient algorithm that searches for a value in an <i>m</i> x <i>n</i> matrix. This matrix has the following properties:</p>\n\n<p>\n</p><ul>\n<li>Integers in each row are sorted from left to right.</li>\n<li>The first integer of each row is greater than the last integer of the previous row.</li>\n</ul>\n<p></p>\n\n<p>\nFor example,</p>\n<p>\nConsider the following matrix:\n</p>\n<pre>[\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\n</pre>\n\n<p>Given <b>target</b> = <code>3</code>, return <code>true</code>.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '75',
    name: 'Sort Colors',
    acceptance: '38.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array with <i>n</i> objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.\n</p>\n\n<p>\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\n</p>\n\n<p>\n<b>Note:</b><br>\nYou are not suppose to use the library\'s sort function for this problem.\n</p>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show follow up.</a></p>\n\n<div class="spoilers">\n<p><b>Follow up:</b><br>\nA rather straight forward solution is a two-pass algorithm using counting sort.<br>\nFirst, iterate the array counting number of 0\'s, 1\'s, and 2\'s, then overwrite array with total number of 0\'s, then 1\'s and followed by 2\'s.</p>\n<p>Could you come up with an one-pass algorithm using only constant space?<br>\n</p>\n</div>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Pocket Gems'],
  },
  {
    id: '76',
    name: 'Minimum Window Substring',
    acceptance: '26.3%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\n</p>\n\n<p>\nFor example,<br>\n<b>S</b> = <code>"ADOBECODEBANC"</code><br>\n<b>T</b> = <code>"ABC"</code><br>\n</p>\n<p>\nMinimum window is <code>"BANC"</code>.\n</p>\n\n<p>\n<b>Note:</b><br>\nIf there is no such window in S that covers all characters in T, return the empty string <code>""</code>.\n</p>\n<p>\nIf there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Uber', 'LinkedIn', 'Snapchat'],
  },
  {
    id: '77',
    name: 'Combinations',
    acceptance: '40.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven two integers <i>n</i> and <i>k</i>, return all possible combinations of <i>k</i> numbers out of 1 ... <i>n</i>.\n</p>\n<p>\nFor example,<br>\nIf <i>n</i> = 4 and <i>k</i> = 2, a solution is:\n</p>\n\n<pre>[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n</pre>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '78',
    name: 'Subsets',
    acceptance: '42.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a set of <b>distinct</b> integers, <i>nums</i>, return all possible subsets (the power set).\n</p>\n<p><b>Note:</b> The solution set must not contain duplicate subsets.\n</p>\n<p>\nFor example,<br>\nIf <b><i>nums</i></b> = <code>[1,2,3]</code>, a solution is:\n</p>\n\n<pre>[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n</pre>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Amazon', 'Bloomberg', 'Uber', 'Coupang'],
  },
  {
    id: '79',
    name: 'Word Search',
    acceptance: '27.6%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nGiven a 2D board and a word, find if the word exists in the grid.\n</p>\n<p>\nThe word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n</p>\n\n<p>\nFor example,<br>\nGiven <b>board</b> = \n</p><pre>[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\n</pre>\n\n<b>word</b> = <code>\"ABCCED\"</code>, -&gt; returns <code>true</code>,<br>\n<b>word</b> = <code>\"SEE\"</code>, -&gt; returns <code>true</code>,<br>\n<b>word</b> = <code>\"ABCB\"</code>, -&gt; returns <code>false</code>.<br>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Bloomberg'],
  },
  {
    id: '80',
    name: 'Remove Duplicates from Sorted Array II',
    acceptance: '36.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nFollow up for "Remove Duplicates":<br>\nWhat if duplicates are allowed at most <i>twice</i>?</p>\n\n<p>\nFor example,<br>\nGiven sorted array <i>nums</i> = <code>[1,1,1,2,2,3]</code>,\n</p>\n<p>\nYour function should return length = <code>5</code>, with the first five elements of <i>nums</i> being <code>1</code>, <code>1</code>, <code>2</code>, <code>2</code> and <code>3</code>. It doesn\'t matter what you leave beyond the new length.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook'],
  },
  {
    id: '81',
    name: 'Search in Rotated Sorted Array II',
    acceptance: '32.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <blockquote>\n<p><i>Follow up</i> for "Search in Rotated Sorted Array":<br>\nWhat if <i>duplicates</i> are allowed?</p>\n\n<p>Would this affect the run-time complexity? How and why?</p>\n</blockquote>\n\n<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\n\n<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>\n\n<p>Write a function to determine if a given target is in the array.</p>\n\n<p>The array may contain duplicates.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '82',
    name: 'Remove Duplicates from Sorted List II',
    acceptance: '29.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only <i>distinct</i> numbers from the original list.\n</p>\n<p>\nFor example,<br>\nGiven <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code>, return <code>1-&gt;2-&gt;5</code>.<br>\nGiven <code>1-&gt;1-&gt;1-&gt;2-&gt;3</code>, return <code>2-&gt;3</code>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '83',
    name: 'Remove Duplicates from Sorted List',
    acceptance: '40.1%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a sorted linked list, delete all duplicates such that each element appear only <i>once</i>.\n</p>\n<p>\nFor example,<br>\nGiven <code>1-&gt;1-&gt;2</code>, return <code>1-&gt;2</code>.<br>\nGiven <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="straight-forward-approach-accepted">Straight-Forward Approach [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This is a simple problem that merely tests your ability to manipulate list node pointers. Because the input list is sorted, we can determine if a node is a duplicate by comparing its value to the node <em>after</em> it in the list. If it is a duplicate, we change the <code>next</code> pointer of the current node so that it skips the next node and points directly to the one after the next node.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">deleteDuplicates</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">ListNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">current</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>\n        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>\n            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">head</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>Because each node in the list is checked exactly once to determine if it is a duplicate or not, the total run time is <script type="math/tex; mode=display">O(n)</script>, where <script type="math/tex; mode=display">n</script> is the number of nodes in the list.</p>\n<p>Space complexity is <script type="math/tex; mode=display">O(1)</script> since no additional space is used.</p>\n<p><strong>Correctness</strong></p>\n<p>We can prove the correctness of this code by defining a <em>loop invariant</em>. A loop invariant is condition that is true before and after every iteration of the loop. In this case, a loop invariant that helps us prove correctness is this:</p>\n<blockquote>\n<p>All nodes in the list up to the pointer <code>current</code> do not contain duplicate elements.</p>\n</blockquote>\n<p>We can prove that this condition is indeed a loop invariant by induction. Before going into the loop, <code>current</code> points to the head of the list. Therefore, the part of the list up to <code>current</code> contains only the head. And so it can not contain any duplicate elements. Now suppose <code>current</code> is now pointing to some node in the list (but not the last element), and the part of the list up to <code>current</code> contains no duplicate elements. After another loop iteration, one of two things happen.</p>\n<ol>\n<li>\n<p><code>current.next</code> was a duplicate of <code>current</code>. In this case, the duplicate node at <code>current.next</code> is deleted, and <code>current</code> stays pointing to the same node as before. Therefore, the condition still holds; there are still no duplicates up to <code>current</code>.</p>\n</li>\n<li>\n<p><code>current.next</code> was not a duplicate of <code>current</code> (and, because the list is sorted, <code>current.next</code> is also not a duplicate of any other element appearing <em>before</em> <code>current</code>). In this case, <code>current</code> moves forward one step to point to <code>current.next</code>. Therefore, the condition still holds; there are no duplicates up to <code>current</code>.</p>\n</li>\n</ol>\n<p>At the last iteration of the loop, <code>current</code> must point to the last element, because afterwards, <code>current.next = null</code>. Therefore, after the loop ends, all elements up to the last element do not contain duplicates.</p>\n<p>Analysis written by: @noran.</p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '84',
    name: 'Largest Rectangle in Histogram',
    acceptance: '27.2%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven <i>n</i> non-negative integers representing the histogram\'s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.\n</p>\n\n<p>\n<img src="https://leetcode.com/static/images/problemset/histogram.png"><br>\n</p><p style="font-size: 11px">Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p>\n<p></p>\n\n<p>\n<img src="https://leetcode.com/static/images/problemset/histogram_area.png"><br>\n</p><p style="font-size: 11px">The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p>\n<p></p>\n\n<p>\nFor example,<br>\nGiven heights = <code>[2,1,5,6,2,3]</code>,<br>\nreturn <code>10</code>.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-forcetime-limit-exceeded">Approach #2 Better Brute Force[Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-divide-and-conquer-approach-time-limit-exceeded">Approach #3 (Divide and Conquer Approach) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-4-better-divide-and-conquer-accepted">Approach #4 (Better Divide and Conquer) [Accepted]</a></li>\n<li><a href="#approach-5-using-stack-accepted">Approach #5 (Using Stack) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>We need to find the rectangle of largest area that can be formed by using the given bars of histogram.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>Firstly, we need to take into account the fact that the height of the rectangle\nformed between any two bars will always be limited by the height of the shortest\nbar lying between them which can be understood by looking at the figure below:</p>\n<p><img alt="Largest Rectangle" src="https://leetcode.com/media/original_images/84_Largest_Rectangle1.PNG"></p>\n<p>Thus, we can simply start off by considering every possible\npair of bars and finding the area of the rectangle formed between them using the\nheight of the shortest bar lying between them as the height\n and the spacing between\nthem as the width of the rectangle. We can thus, find the required rectangle with the\n maximum area.</p>\n<iframe frameborder="0" height="292" name="rdXd49MU" src="https://leetcode.com/playground/rdXd49MU/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. We have to find the minimum height bar <script type="math/tex; mode=display">\\big(O(n)\\big)</script> lying\nbetween every pair <script type="math/tex; mode=display">\\big(O(n^2)\\big)</script>.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-forcetime-limit-exceeded">Approach #2 Better Brute Force[Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can do one slight modification in the previous approach to optimize it to some extent.\n Instead of taking every possible pair and then finding the bar of minimum height\n lying between them everytime, we can find the bar of minimum height for\n current pair by using the minimum height bar of the previous pair.</p>\n<p>In mathematical terms, <script type="math/tex; mode=display">minheight=\\min(minheight, heights(j))</script>, where <script type="math/tex; mode=display">heights(j)</script>\n refers to the height of the <script type="math/tex; mode=display">j</script>th bar.</p>\n<iframe frameborder="0" height="275" name="RPK7YFsC" src="https://leetcode.com/playground/RPK7YFsC/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Every possible pair is considered</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-divide-and-conquer-approach-time-limit-exceeded">Approach #3 (Divide and Conquer Approach) [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This approach relies on the observation that the rectangle with maximum area will be\nthe maximum of:</p>\n<ol>\n<li>\n<p>The widest possible rectangle with height equal to the height of the shortest bar.</p>\n</li>\n<li>\n<p>The largest rectangle confined to the left of the shortest bar(subproblem).</p>\n</li>\n<li>\n<p>The largest rectangle confined to the right of the shortest bar(subproblem).</p>\n</li>\n</ol>\n<p>Let\'s take an example:</p>\n<div class="codehilite"><pre><span></span>[6, 4, 5, 2, 4, 3, 9]\n</pre></div>\n<p>Here, the shortest bar is of height 2. The area of the widest rectangle using this\n  bar as height is 2x8=16. Now, we need to look for cases 2 and 3 mentioned above.\n  Thus, we repeat the same process to the left and right of 2. In the left of 2, 4\n  is the minimum, forming an area of rectangle 4x3=12. Further, rectangles of area 6x1=6 and\n   5x1=5 exist in its left and right respectively. Similarly we find an area of 3x3=9, 4x1=4 and 9x1=9\n   to the left of 2. Thus, we get 16 as the correct maximum area. See the figure below for further clarification:</p>\n<p><img alt="Divide and Conquer" src="https://leetcode.com/media/original_images/84_Largest_Rectangle2.PNG"></p>\n<iframe frameborder="0" height="292" name="VC4poxm8" src="https://leetcode.com/playground/VC4poxm8/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity :</p>\n<p>Average Case:<script type="math/tex; mode=display">O\\big(n \\log(n)\\big)</script>.</p>\n<p>Worst Case: <script type="math/tex; mode=display">O(n^2)</script>. If the numbers in the array are sorted,\n  we don\'t gain the advantage of divide and conquer.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Recursion with worst case depth <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-better-divide-and-conquer-accepted">Approach #4 (Better Divide and Conquer) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>You can observe that in the Divide and Conquer Approach, we gain the advantage, since\n the large problem is divided into substantially smaller subproblems. But, we won\'t gain\n  much advantage with that approach if the array happens to be sorted in either\n  ascending or descending order, since every time we need to find the minimum number in a\n   large subarray <script type="math/tex; mode=display">\\big(O(n)\\big)</script>. Thus, the overall complexity becomes <script type="math/tex; mode=display">O(n^2)</script> in the worst case.\n   We can reduce the time complexity by using a Segment Tree to find the minimum every time which\n   can be done in <script type="math/tex; mode=display">O\\big(\\log(n)\\big)</script> time.</p>\n<p>For implementation, click <a href="https://discuss.leetcode.com/topic/45822/segment-tree-solution-just-another-idea-o-n-logn-solution">here</a>.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(n\\log(n)\\big)</script>. Segment tree takes <script type="math/tex; mode=display">log(n)</script>\n<script type="math/tex; mode=display">n</script> times.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Space required for Segment Tree.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-using-stack-accepted">Approach #5 (Using Stack) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, we maintain a stack. Initially, we push a -1 onto the stack to mark the end.\nWe start with the leftmost bar and keep\npushing the current bar\'s index onto the stack until we get two successive numbers\n in descending order, i.e. until we get <script type="math/tex; mode=display">a[i]<a[i-1]</script>. Now, we start popping the\n numbers from the stack until we hit a number <script type="math/tex; mode=display">stack[j]</script> on the stack such that <script type="math/tex; mode=display">a\\big[stack[j]\\big] \\leq a[i]</script>.\n Every time we pop, we find out the area of rectangle formed using the current element as the height\n  of the rectangle and the difference between the the current element\'s index pointed to in the original array and the element <script type="math/tex; mode=display">stack[top-1] -1</script> as the width\n  i.e. if we pop an element <script type="math/tex; mode=display">stack[top]</script> and i is the current index to which we are pointing in the original array, the current area of the rectangle will be considered as <script type="math/tex; mode=display">(i-stack[top-1]-1) \\times a\\big[stack[top]\\big]</script>.</p>\n<p>Further, if we reach the end of the array, we pop all the elements of the\n  stack and at every pop, this time we use the following equation to find the area:\n     <script type="math/tex; mode=display">(stack[top]-stack[top-1]) \\times a\\big[stack[top]\\big]</script>, where <script type="math/tex; mode=display">stack[top]</script> refers to the\n      element just popped. Thus, we can get the area of the\n   of the largest rectangle by comparing the new area found everytime.</p>\n<p>The following example will clarify the process further:\n   <code>[6, 7, 5, 2, 4, 5, 9, 3]</code></p>\n<p>!?!../Documents/84_Largest_Rectangle.json:1000,563!?!</p>\n<iframe frameborder="0" height="309" name="ods7GRkR" src="https://leetcode.com/playground/ods7GRkR/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">n</script> numbers are pushed and popped.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Stack is used.</p>\n</li>\n</ul>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '85',
    name: 'Maximal Rectangle',
    acceptance: '29.0%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a 2D binary matrix filled with 0\'s and 1\'s, find the largest rectangle containing only 1\'s and return its area.\n</p>\n\n<p>For example, given the following matrix:\n</p><pre>1 0 1 0 0\n1 0 <font color="red">1</font> <font color="red">1</font> <font color="red">1</font>\n1 1 <font color="red">1</font> <font color="red">1</font> <font color="red">1</font>\n1 0 0 1 0\n</pre>\nReturn 6.\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook'],
  },
  {
    id: '86',
    name: 'Partition List',
    acceptance: '33.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a linked list and a value <i>x</i>, partition it such that all nodes less than <i>x</i> come before nodes greater than or equal to <i>x</i>.\n</p>\n<p>\nYou should preserve the original relative order of the nodes in each of the two partitions.\n</p>\n<p>\nFor example,<br>\nGiven <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2</code> and <i>x</i> = 3,<br>\nreturn <code>1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '87',
    name: 'Scramble String',
    acceptance: '29.5%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a string <i>s1</i>, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.\n</p>\n<p>\nBelow is one possible representation of <i>s1</i> = <code>"great"</code>:\n</p>\n<pre>    great\n   /    \\\n  gr    eat\n / \\    /  \\\ng   r  e   at\n           / \\\n          a   t\n</pre>\n<p>\nTo scramble the string, we may choose any non-leaf node and swap its two children.\n</p>\n<p>\nFor example, if we choose the node <code>"gr"</code> and swap its two children, it produces a scrambled string <code>"rgeat"</code>.\n</p>\n<pre>    rgeat\n   /    \\\n  rg    eat\n / \\    /  \\\nr   g  e   at\n           / \\\n          a   t\n</pre>\n<p>\nWe say that <code>"rgeat"</code> is a scrambled string of <code>"great"</code>.\n</p>\n<p>\nSimilarly, if we continue to swap the children of nodes <code>"eat"</code> and <code>"at"</code>, it produces a scrambled string <code>"rgtae"</code>.\n</p>\n<pre>    rgtae\n   /    \\\n  rg    tae\n / \\    /  \\\nr   g  ta  e\n       / \\\n      t   a\n</pre>\n<p>\nWe say that <code>"rgtae"</code> is a scrambled string of <code>"great"</code>.\n</p>\n<p>\nGiven two strings <i>s1</i> and <i>s2</i> of the same length, determine if <i>s2</i> is a scrambled string of <i>s1</i>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '88',
    name: 'Merge Sorted Array',
    acceptance: '32.1%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given two sorted integer arrays <i>nums1</i> and <i>nums2</i>, merge <i>nums2</i> into <i>nums1</i> as one sorted array.</p>\n\n<p>\n<b>Note:</b><br>\nYou may assume that <i>nums1</i> has enough space (size that is greater or equal to <i>m</i> + <i>n</i>) to hold additional elements from <i>nums2</i>. The number of elements initialized in <i>nums1</i> and <i>nums2</i> are <i>m</i> and <i>n</i> respectively.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Bloomberg'],
  },
  {
    id: '89',
    name: 'Gray Code',
    acceptance: '41.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>\n\n<p>Given a non-negative integer <i>n</i> representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>\n\n<p>For example, given <i>n</i> = 2, return <code>[0,1,3,2]</code>. Its gray code sequence is:</p>\n<pre>00 - 0\n01 - 1\n11 - 3\n10 - 2\n</pre>\n\n<p><b>Note:</b><br>\nFor a given <i>n</i>, a gray code sequence is not uniquely defined.\n</p>\n<p>For example, <code>[0,2,3,1]</code> is also a valid gray code sequence according to the above definition.</p>\n\n<p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Amazon'],
  },
  {
    id: '90',
    name: 'Subsets II',
    acceptance: '37.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a collection of integers that might contain duplicates, <b><i>nums</i></b>, return all possible subsets (the power set).\n</p>\n<p><b>Note:</b> The solution set must not contain duplicate subsets.\n</p>\n<p>\nFor example,<br>\nIf <b><i>nums</i></b> = <code>[1,2,2]</code>, a solution is:\n</p>\n\n<pre>[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]\n</pre>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook'],
  },
  {
    id: '91',
    name: 'Decode Ways',
    acceptance: '20.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nA message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:\n</p>\n\n<pre>\'A\' -&gt; 1\n\'B\' -&gt; 2\n...\n\'Z\' -&gt; 26\n</pre>\n\n<p>\nGiven an encoded message containing digits, determine the total number of ways to decode it.\n</p>\n\n<p>\nFor example,<br>\nGiven encoded message <code>"12"</code>,\nit could be decoded as <code>"AB"</code> (1 2) or <code>"L"</code> (12).\n</p>\n\n<p>\nThe number of ways decoding <code>"12"</code> is 2.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Uber'],
  },
  {
    id: '92',
    name: 'Reverse Linked List II',
    acceptance: '31.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nReverse a linked list from position <i>m</i> to <i>n</i>. Do it in-place and in one-pass.\n</p>\n\n<p>\nFor example:<br>\nGiven <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, <i>m</i> = 2 and <i>n</i> = 4,\n</p>\n<p>\nreturn <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.\n</p>\n<p>\n<b>Note:</b><br>\nGiven <i>m</i>, <i>n</i> satisfy the following condition:<br>\n1 ≤ <i>m</i> ≤ <i>n</i> ≤ length of list.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '93',
    name: 'Restore IP Addresses',
    acceptance: '28.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>\n\n<p>\nFor example:<br>\nGiven <code>"25525511135"</code>,\n</p>\n<p>\nreturn <code>["255.255.11.135", "255.255.111.35"]</code>. (Order does not matter)\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '94',
    name: 'Binary Tree Inorder Traversal',
    acceptance: '48.1%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given a binary tree, return the <i>inorder</i> traversal of its nodes' values.</p>\n\n<p>\nFor example:<br>\nGiven binary tree <code>[1,null,2,3]</code>,<br>\n</p><pre>   1\n    \\\n     2\n    /\n   3\n</pre>\n<p></p>\n<p>\nreturn <code>[1,3,2]</code>.\n</p>\n\n<p><b>Note:</b> Recursive solution is trivial, could you do it iteratively?</p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-recursive-approach-accepted">Approach #1 Recursive Approach [Accepted]</a></li>\n<li><a href="#approach-2-iterating-method-using-stack-accepted">Approach #2 Iterating method using Stack [Accepted]</a></li>\n<li><a href="#approach-3-morris-traversal-accepted">Approach #3 Morris Traversal [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-recursive-approach-accepted">Approach #1 Recursive Approach [Accepted]</h4>\n<p>The first method to solve this problem is using recursion.\nThis is the classical method and is straightforward. We can define a helper function to implement recursion.</p>\n<iframe frameborder="0" height="411" name="rPqVxbCF" src="https://leetcode.com/playground/rPqVxbCF/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The time complexity is <script type="math/tex; mode=display">O(n)</script> because the recursive function is <script type="math/tex; mode=display">T(n) = 2*T(n/2)+1</script>.</p>\n</li>\n<li>\n<p>Space complexity : The worst case space required is <script type="math/tex; mode=display">O(n)</script>, and in the average case it\'s <script type="math/tex; mode=display">O(log(n))</script> where <script type="math/tex; mode=display"> n</script> is number of nodes.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-iterating-method-using-stack-accepted">Approach #2 Iterating method using Stack [Accepted]</h4>\n<p>The strategy is very similiar to the first method, the different is using stack.</p>\n<p>Here is an illustration:</p>\n<p>!?!../Documents/94_Binary.json:1000,563!?!</p>\n<iframe frameborder="0" height="377" name="y5roepjz" src="https://leetcode.com/playground/y5roepjz/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. </p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-morris-traversal-accepted">Approach #3 Morris Traversal [Accepted]</h4>\n<p>In this method, we have to use a new data structure-Threaded Binary Tree, and the strategy is as follows:</p>\n<blockquote>\n<p>Step 1: Initialize current as root</p>\n<p>Step 2: While current is not NULL, </p>\n<p>If current does not have left child</p>\n<p>a. Add current’s value </p>\n<p>b. Go to the right, i.e., current = current.right</p>\n<p>Else</p>\n<p>a. In current\'s left subtree, make current the right child of the rightmost node</p>\n<p>b. Go to this left child, i.e., current = current.left</p>\n</blockquote>\n<p>For Example:</p>\n<div class="codehilite"><pre><span></span>          1\n        /   \\\n       2     3\n      / \\   /\n     4   5 6\n</pre></div>\n<p>First, 1 is the root, so initialize 1 as current, 1 has left child which is 2, the current\'s left subtree is</p>\n<div class="codehilite"><pre><span></span>         2\n        / \\\n       4   5\n</pre></div>\n<p>So in this subtree, the rightmost node is 5, then make the current(1) as the right child of 5. Set current = cuurent.left (current = 2).\nThe tree now looks like:</p>\n<div class="codehilite"><pre><span></span>         2\n        / \\\n       4   5\n            \\\n             1\n              \\\n               3\n              /\n             6\n</pre></div>\n<p>For current 2, which has left child 4, we can continue with thesame process as we did above</p>\n<div class="codehilite"><pre><span></span>        4\n         \\\n          2\n           \\\n            5\n             \\\n              1\n               \\\n                3\n               /\n              6\n</pre></div>\n<p>then add 4 because it has no left child, then add 2, 5, 1, 3 one by one, for node 3 which has left child 6, do the same as above.\nFinally, the inorder taversal is [4,2,5,1,6,3].</p>\n<p>For more details, please check \n<a href="https://en.wikipedia.org/wiki/Threaded_binary_tree">Threaded binary tree</a> and \n<a href="https://stackoverflow.com/questions/5502916/explain-morris-inorder-tree-traversal-without-using-stacks-or-recursion">Explaination of Morris Method</a></p>\n<iframe frameborder="0" height="445" name="Nckbvn3x" src="https://leetcode.com/playground/Nckbvn3x/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. To prove that the time complexity is <script type="math/tex; mode=display">O(n)</script>,\nthe biggest problem lies in finding the time complexity of finding the predecessor nodes of all the nodes in the binary tree.\nIntuitively, the complexity is <script type="math/tex; mode=display">O(nlogn)</script>, because to find the predecessor node for a single node related to the height of the tree.\nBut in fact, finding the predecessor nodes for all nodes only needs <script type="math/tex; mode=display">O(n)</script> time. Because a binary Tree with <script type="math/tex; mode=display">n</script> nodes has <script type="math/tex; mode=display">n-1</script> edges, the whole processing for each edges up to 2 times, one is to locate a node, and the other is to find the predecessor node.\nSo the complexity is <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Arraylist of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/monkeykingyan">@monkeykingyan</a></p>\n</div>\n          ',
    tags: ['Microsoft'],
  },
  {
    id: '95',
    name: 'Unique Binary Search Trees II',
    acceptance: '31.8%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given an integer <i>n</i>, generate all structurally unique <b>BST's</b> (binary search trees) that store values 1...<i>n</i>.</p>\n\n<p>\nFor example,<br>\nGiven <i>n</i> = 3, your program should return all 5 unique BST's shown below.\n\n</p><pre>   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n</pre>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '96',
    name: 'Unique Binary Search Trees',
    acceptance: '41.5%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given <i>n</i>, how many structurally unique <b>BST's</b> (binary search trees) that store values 1...<i>n</i>?</p>\n\n<p>\nFor example,<br>\nGiven <i>n</i> = 3, there are a total of 5 unique BST's.\n\n</p><pre>   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n</pre>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Snapchat'],
  },
  {
    id: '97',
    name: 'Interleaving String',
    acceptance: '24.9%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven <i>s1</i>, <i>s2</i>, <i>s3</i>, find whether <i>s3</i> is formed by the interleaving of <i>s1</i> and <i>s2</i>.\n</p>\n\n<p>\nFor example,<br>\nGiven:<br>\n<i>s1</i> = <code>"aabcc"</code>,<br>\n<i>s2</i> = <code>"dbbca"</code>,\n</p>\n<p>\nWhen <i>s3</i> = <code>"aadbbcbcac"</code>, return true.<br>\nWhen <i>s3</i> = <code>"aadbbbaccc"</code>, return false.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-recursion-with-memoization-accepted">Approach #2 Recursion with memoization [Accepted]</a></li>\n<li><a href="#approach-3-using-2-d-dynamic-programming-accepted">Approach #3 Using 2-d Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-4-using-1-d-dynamic-programming-accepted">Approach #4 Using 1-d Dynamic Programming [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>We need to determine whether a given string can be formed by interleaving the other two strings.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The most basic idea is to find every string possible by all interleavings of the two given strings(<script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script>).\nIn order to implement this method, we are using recursion. We start by taking the current character of the\nfirst string(<script type="math/tex; mode=display">s1</script>) and then appending all possible interleavings of the remaining portion of the first string(<script type="math/tex; mode=display">s1</script>) and the second string(<script type="math/tex; mode=display">s2</script>)\nand comparing each result formed with the required interleaved string(<script type="math/tex; mode=display">s3</script>). Similarly, we choose one character from the second\nstring(<script type="math/tex; mode=display">s2</script>) and form all the interleavings with the remaining portion of <script type="math/tex; mode=display">s2</script> and <script type="math/tex; mode=display">s1</script> to check if the required string <script type="math/tex; mode=display">s1</script> can be formed.</p>\n<p>For implementing the recursive function, we make the function call recursively as\n<script type="math/tex; mode=display">is_Interleave(s1,i+1,s2,j,res+s1.charAt(i),s3)</script> in which we have chosen the current character from <script type="math/tex; mode=display">s1</script> and then make another function call <script type="math/tex; mode=display">is_Interleave(s1,i,s2,j+1,res+s2.charAt(j),s3)</script>, in which the current character of <script type="math/tex; mode=display">s2</script> is chosen. Here, <script type="math/tex; mode=display">res</script> refers to that portion(interleaved) of <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> which has already been processed. If anyone of these calls return the result as <script type="math/tex; mode=display">True</script>, it means that atleast one interleaving gives the required result <script type="math/tex; mode=display">s3</script>. The recursive calls end when both the strings <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> have been fully processed.</p>\n<p>Let\'s look at a small example to see how the execution proceeds.</p>\n<div class="codehilite"><pre><span></span>s1="abc"\ns2="bcd"\ns3="abcbdc"\n</pre></div>\n<p>Firstly we choose \'a\' of s1 as the processed part i.e. res and call the recursive function considering the new strings as s1="bc",\ns2="bcd", s3="abcbdc". When this function returns a result, we again call the recursive function but with the new strings as s1="abc", s2="cd", s3="abcbdc"</p>\n<iframe frameborder="0" height="343" name="26n4CNCb" src="https://leetcode.com/playground/26n4CNCb/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(2^(m+n))</script>. <script type="math/tex; mode=display">m</script> is the length of <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">n</script> is the length of <script type="math/tex; mode=display">s2</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m+n)</script>. The size of stack for recursive calls can go upto <script type="math/tex; mode=display">m+n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-recursion-with-memoization-accepted">Approach #2 Recursion with memoization [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the recursive approach discussed above, we are considering every possible string formed by interleaving the two given\nstrings. But, there will be cases encountered in which, the same portion of <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> would have been processed already\nbut in different orders(permutations). But irrespective of the order of processing, if the resultant string formed till now\nis matching with the required string(<script type="math/tex; mode=display">s3</script>), the final result is dependent only on the remaining portions of <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script>, but\nnot on the already processed portion. Thus, the recursive approach leads to redundant computations.</p>\n<p>This redundancy can be removed by making use of memoization along with recursion. For this, we maitain 3 pointers <script type="math/tex; mode=display">i, j, k</script>\n which correspond to the index of the current character of <script type="math/tex; mode=display">s1, s2, s3</script> respectively. Also, we maintain a 2-d memo array to keep a track of the substrings processed so far. <script type="math/tex; mode=display">memo[i][j]</script> stores a 1/0 or -1 depending on\n whether the current portion of strings i.e. upto <script type="math/tex; mode=display">i^{th}</script> index for <script type="math/tex; mode=display">s1</script> and upto <script type="math/tex; mode=display">j^{th}</script> index for s2 has already been evaluated. Again, we start by selecting the current character of <script type="math/tex; mode=display">s1</script>(pointed by $$i$). If it matches the current character\n of <script type="math/tex; mode=display">s3</script>(pointed by <script type="math/tex; mode=display">k</script>), we include it in the processed string and call the same function recurively as:\n <script type="math/tex; mode=display">is\\_Interleave(s1, i+1, s2, j, s3, k+1,memo)</script>\n</p>\n<p>Thus, here we have called the function by incrementing the pointers <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">k</script> since the portion of strings upto those indices\n has already been processed. Similarly, we choose one character from the second string and continue. The recursive function\n ends when either of the two strings <script type="math/tex; mode=display">s1</script> or <script type="math/tex; mode=display">s2</script> has been fully processed. If, let\'s say, the string <script type="math/tex; mode=display">s1</script> has been fully processed,\n we directly compare the remaining portion of <script type="math/tex; mode=display">s2</script> with the remaining portion of <script type="math/tex; mode=display">s3</script>. When the backtrack occurs from the recursive\n calls, we store the value returned by the recursive functions in the memoization array memo appropriatelys so that when it is encountered the next time, the recursive function won\'t be called, but the memoization array itself will return the previous generated result.</p>\n<iframe frameborder="0" height="515" name="STfFmTvN" src="https://leetcode.com/playground/STfFmTvN/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(2^(m+n))</script>. <script type="math/tex; mode=display">m</script> is the length of <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">n</script> is the length of <script type="math/tex; mode=display">s2</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m+n)</script>. The size of stack for recursive calls can go upto <script type="math/tex; mode=display">m+n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-2-d-dynamic-programming-accepted">Approach #3 Using 2-d Dynamic Programming [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The recursive approach discussed in above solution included a character from one of the strings <script type="math/tex; mode=display">s1</script> or <script type="math/tex; mode=display">s2</script> in the resultant\ninterleaved string and called a recursive function to check whether the remaining portions of <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> can be interleaved\nto form the remaining portion of <script type="math/tex; mode=display">s3</script>. In the current approach, we\n look at the same problem the other way around. Here, we include one character from <script type="math/tex; mode=display">s1</script> or <script type="math/tex; mode=display">s2</script> and check whether the\n resultant string formed so far by one particular interleaving of the the current prefix of <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> form a prefix of <script type="math/tex; mode=display">s3</script>.</p>\n<p>Thus, this approach relies on the fact that the in order to determine whether a substring\n of <script type="math/tex; mode=display">s3</script>(upto index <script type="math/tex; mode=display">k</script>), can be formed by interleaving strings <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> upto indices <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> respectively, solely depends\n on the characters of <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> upto indices <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> only and not on the characters coming afterwards.</p>\n<p>To implement this method, we\'ll make use of a 2-d boolean array <script type="math/tex; mode=display">dp</script>. In this array <script type="math/tex; mode=display">dp[i][j]</script> implies if it is possible to\n obtain a substring of length <script type="math/tex; mode=display">(i+j+2)</script> which is a prefix of <script type="math/tex; mode=display">s3</script> by some interleaving of prefixes of strings <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> having\n lengths <script type="math/tex; mode=display">(i+1)</script> and <script type="math/tex; mode=display">(j+1)</script> respectively. For filling in the entry of <script type="math/tex; mode=display">dp[i][j]</script>, we need to consider two cases:</p>\n<ol>\n<li>\n<p>The character\n just included i.e. either at <script type="math/tex; mode=display">i^{th}</script> index of <script type="math/tex; mode=display">s1</script> or at <script type="math/tex; mode=display">j^{th}</script> index of <script type="math/tex; mode=display">s2</script> doesn\'t match the character at <script type="math/tex; mode=display">k^{th}</script> index of <script type="math/tex; mode=display">s3</script>, where <script type="math/tex; mode=display">k=i+j+1</script>.\n In this case, the resultant string formed using some interleaving of prefixes of <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> can never result in a prefix of length <script type="math/tex; mode=display">k+1</script> in <script type="math/tex; mode=display">s3</script>. Thus, we enter <script type="math/tex; mode=display">False</script> at the character <script type="math/tex; mode=display">dp[i][j]</script>.</p>\n</li>\n<li>\n<p>The character\n just included i.e. either at <script type="math/tex; mode=display">i^{th}</script> index of <script type="math/tex; mode=display">s1</script> or at <script type="math/tex; mode=display">j^{th}</script> index of <script type="math/tex; mode=display">s2</script>  matches the character at <script type="math/tex; mode=display">k^{th}</script> index of <script type="math/tex; mode=display">s3</script>, where <script type="math/tex; mode=display">k=i+j+1</script>.\nNow, if the character just included(say <script type="math/tex; mode=display">x</script>) which matches the character at <script type="math/tex; mode=display">k^{th}</script> index of <script type="math/tex; mode=display">s3</script>, is the character at <script type="math/tex; mode=display">i^{th}</script> index of <script type="math/tex; mode=display">s1</script>, we need to keep <script type="math/tex; mode=display">x</script> at the last position in the resultant interleaved string formed so far. Thus, in order to use string <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> upto indices <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> to form a resultant string of length <script type="math/tex; mode=display">(i+j+2)</script> which is a prefix of <script type="math/tex; mode=display">s3</script>, we need to ensure that the strings <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> upto indices <script type="math/tex; mode=display">(i-1)</script> and <script type="math/tex; mode=display">j</script> respectively obey the same property.</p>\n</li>\n</ol>\n<p>Similarly, if we just included the <script type="math/tex; mode=display">j^{th}</script> character of <script type="math/tex; mode=display">s2</script>, which matches with the <script type="math/tex; mode=display">k^{th}</script> character of <script type="math/tex; mode=display">s3</script>, we need to ensure that the strings <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> upto indices <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">(j-1)</script> also obey the same\nproperty to enter a <script type="math/tex; mode=display">true</script> at <script type="math/tex; mode=display">dp[i][j]</script>.</p>\n<p>This can be made clear with the following example:</p>\n<div class="codehilite"><pre><span></span>s1="aabcc"\ns2="dbbca"\ns3="aadbbcbcac"\n</pre></div>\n<!--![97_Interleaving](https://leetcode.com/articles/Figures/97_Interleaving.gif)-->\n<p>!?!../Documents/97_Interleaving.json:1000,563!?!</p>\n<iframe frameborder="0" height="428" name="irqSFkn8" src="https://leetcode.com/playground/irqSFkn8/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. dp array of size <script type="math/tex; mode=display">m*n</script> is filled.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m*n)</script>. 2-d DP of size <script type="math/tex; mode=display">(m+1)*(n+1)</script> is required. <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> are the lengths of strings <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> repectively.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-1-d-dynamic-programming-accepted">Approach #4 Using 1-d Dynamic Programming [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>This approach is the same as the previous approach except that we have used only 1-d <script type="math/tex; mode=display">dp</script> array to store the results of the\n prefixes of the strings processed so far. Instead of maintaining a 2-d array, we can maintain a 1-d array only and update the\n array\'s element <script type="math/tex; mode=display">dp[i]</script> when needed using <script type="math/tex; mode=display">dp[i-1]</script> and the previous value of <script type="math/tex; mode=display">dp[i]</script>.</p>\n<iframe frameborder="0" height="462" name="rmyFh5nF" src="https://leetcode.com/playground/rmyFh5nF/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. dp array of size <script type="math/tex; mode=display">n</script> is filled <script type="math/tex; mode=display">m</script> times.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">n</script> is the length of the string <script type="math/tex; mode=display">s1</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '98',
    name: 'Validate Binary Search Tree',
    acceptance: '23.8%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nGiven a binary tree, determine if it is a valid binary search tree (BST).\n</p>\n\n<p>\nAssume a BST is defined as follows:\n</p><ul>\n<li>The left subtree of a node contains only nodes with keys <b>less than</b> the node's key.</li>\n<li>The right subtree of a node contains only nodes with keys <b>greater than</b> the node's key.</li>\n<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n<p></p>\n\n<p><b>Example 1:</b><br>\n</p><pre>    2\n   / \\\n  1   3\n</pre>\nBinary tree <code>[2,1,3]</code>, return true.\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre>    1\n   / \\\n  2   3\n</pre>\nBinary tree <code>[1,2,3]</code>, return false.\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Amazon', 'Bloomberg'],
  },
  {
    id: '99',
    name: 'Recover Binary Search Tree',
    acceptance: '30.5%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nTwo elements of a binary search tree (BST) are swapped by mistake.</p>\n\n<p>Recover the tree without changing its structure.\n</p>\n\n<b>Note:</b><br>\nA solution using O(<i>n</i>) space is pretty straight forward. Could you devise a constant space solution?\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '100',
    name: 'Same Tree',
    acceptance: '47.1%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven two binary trees, write a function to check if they are the same or not.\n</p>\n\n<p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.\n</p>\n\n<br>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b>     1         1\n          / \\       / \\\n         2   3     2   3\n\n        [1,2,3],   [1,2,3]\n\n<b>Output:</b> true\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b>     1         1\n          /           \\\n         2             2\n\n        [1,2],     [1,null,2]\n\n<b>Output:</b> false\n</pre>\n<p></p>\n\n<p><b>Example 3:</b>\n</p><pre><b>Input:</b>     1         1\n          / \\       / \\\n         2   1     1   2\n\n        [1,2,1],   [1,1,2]\n\n<b>Output:</b> false\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '101',
    name: 'Symmetric Tree',
    acceptance: '39.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>\n\n<p>\nFor example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:\n</p><pre>    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n</pre>\n<p></p>\n<p>\nBut the following <code>[1,2,2,null,3,null,3]</code>  is not:<br>\n</p><pre>    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n</pre>\n<p></p>\n\n<p>\n<b>Note:</b><br>\nBonus points if you could solve it both recursively and iteratively.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-recursive-accepted">Approach #1 (Recursive) [Accepted]</h4>\n<p>A tree is symmetric if the left subtree is a mirror reflection of the right subtree.</p>\n<p align="center"><img alt="Push an element in stack" src="https://leetcode.com/media/original_images/101_Symmetric.png" width="200px"></p>\n<p>Therefore, the question is: when are two trees a mirror reflection of each other?</p>\n<p>Two trees are a mirror reflection of each other if:</p>\n<ol>\n<li>Their two roots have the same value.</li>\n<li>The right subtree of each tree is a mirror reflection of the left subtree of the other tree.</li>\n</ol>\n<p align="center"><img alt="Push an element in stack" src="https://leetcode.com/media/original_images/101_Symmetric_Mirror.png" width="400px"></p>\n<p>This is like a person looking at a mirror. The reflection in the mirror has the same head, but the reflection\'s right arm corresponds to the actual person\'s left arm, and vice versa.</p>\n<p>The explanation above translates naturally to a recursive function as follows.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSymmetric</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">return</span> <span class="n">isMirror</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>\n<span class="o">}</span>\n\n<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isMirror</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">t1</span><span class="o">,</span> <span class="n">TreeNode</span> <span class="n">t2</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">t1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">t2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">t1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">t2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n    <span class="k">return</span> <span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">t2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span>\n        <span class="o">&amp;&amp;</span> <span class="n">isMirror</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">t2</span><span class="o">.</span><span class="na">left</span><span class="o">)</span>\n        <span class="o">&amp;&amp;</span> <span class="n">isMirror</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">t2</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>Because we traverse the entire input tree once, the total run time is <script type="math/tex; mode=display">O(n)</script>, where <script type="math/tex; mode=display">n</script> is the total number of nodes in the tree.</p>\n<p>The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in <script type="math/tex; mode=display">O(n)</script>. Therefore, space complexity due to recursive calls on the stack is <script type="math/tex; mode=display">O(n)</script> in the worst case.</p>\n<hr>\n<h4 id="approach-2-iterative-accepted">Approach #2 (Iterative) [Accepted]</h4>\n<p>Instead of recursion, we can also use iteration with the aid of a queue. Each two consecutive nodes in the queue should be equal, and their subtrees a mirror of each other. Initially, the queue contains <code>root</code> and <code>root</code>. Then the algorithm works similarly to BFS, with some key differences. Each time, two nodes are extracted and their values compared. Then, the right and left children of the two nodes are inserted in the queue in opposite order. The algorithm is done when either the queue is empty, or we detect that the tree is not symmetric (i.e. we pull out two consecutive nodes from the queue that are unequal).</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSymmetric</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>\n    <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>\n    <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>\n    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>\n        <span class="n">TreeNode</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>\n        <span class="n">TreeNode</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">t1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">t2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">t1</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">t2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">t2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n        <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>\n        <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t2</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>\n        <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>\n        <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t2</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>Because we traverse the entire input tree once, the total run time is <script type="math/tex; mode=display">O(n)</script>, where <script type="math/tex; mode=display">n</script> is the total number of nodes in the tree.</p>\n<p>There is additional space required for the search queue. In the worst case, we have to insert <script type="math/tex; mode=display">O(n)</script> nodes in the queue. Therefore, space complexity is <script type="math/tex; mode=display">O(n)</script>.</p>\n<p>Analysis written by: @noran.</p>\n</div>\n          ',
    tags: ['Microsoft', 'Bloomberg', 'LinkedIn'],
  },
  {
    id: '102',
    name: 'Binary Tree Level Order Traversal',
    acceptance: '41.3%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given a binary tree, return the <i>level order</i> traversal of its nodes' values. (ie, from left to right, level by level).</p>\n\n<p>\nFor example:<br>\nGiven binary tree <code>[3,9,20,null,null,15,7]</code>,<br>\n</p><pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n<p></p>\n<p>\nreturn its level order traversal as:<br>\n</p><pre>[\n  [3],\n  [9,20],\n  [15,7]\n]\n</pre>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Amazon', 'Bloomberg', 'LinkedIn', 'Apple'],
  },
  {
    id: '103',
    name: 'Binary Tree Zigzag Level Order Traversal',
    acceptance: '35.8%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given a binary tree, return the <i>zigzag level order</i> traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).</p>\n\n<p>\nFor example:<br>\nGiven binary tree <code>[3,9,20,null,null,15,7]</code>,<br>\n</p><pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n<p></p>\n<p>\nreturn its zigzag level order traversal as:<br>\n</p><pre>[\n  [3],\n  [20,9],\n  [15,7]\n]\n</pre>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft', 'Bloomberg', 'LinkedIn'],
  },
  {
    id: '104',
    name: 'Maximum Depth of Binary Tree',
    acceptance: '53.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a binary tree, find its maximum depth.</p>\n\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Uber', 'LinkedIn', 'Apple', 'Yahoo'],
  },
  {
    id: '105',
    name: 'Construct Binary Tree from Preorder and Inorder Traversal',
    acceptance: '32.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>\n\n<p><b>Note:</b><br>\nYou may assume that duplicates do not exist in the tree.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '106',
    name: 'Construct Binary Tree from Inorder and Postorder Traversal',
    acceptance: '32.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>\n\n<p><b>Note:</b><br>\nYou may assume that duplicates do not exist in the tree.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft'],
  },
  {
    id: '107',
    name: 'Binary Tree Level Order Traversal II',
    acceptance: '41.2%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>Given a binary tree, return the <i>bottom-up level order</i> traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).</p>\n\n<p>\nFor example:<br>\nGiven binary tree <code>[3,9,20,null,null,15,7]</code>,<br>\n</p><pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n</pre>\n<p></p>\n<p>\nreturn its bottom-up level order traversal as:<br>\n</p><pre>[\n  [15,7],\n  [9,20],\n  [3]\n]\n</pre>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '108',
    name: 'Convert Sorted Array to Binary Search Tree',
    acceptance: '43.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>\n\n<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <i>every</i> node never differ by more than 1.</p>\n\n<br>\n\n<p>\n<b>Example:</b>\n</p><pre>Given the sorted array: [-10,-3,0,5,9],\n\nOne possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Airbnb'],
  },
  {
    id: '109',
    name: 'Convert Sorted List to Binary Search Tree',
    acceptance: '34.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>\n\n<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <i>every</i> node never differ by more than 1.</p>\n\n<br>\n\n<p>\n<b>Example:</b>\n</p><pre>Given the sorted linked list: [-10,-3,0,5,9],\n\nOne possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Zenefits'],
  },
  {
    id: '110',
    name: 'Balanced Binary Tree',
    acceptance: '38.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a binary tree, determine if it is height-balanced.\n</p>\n\n<p>\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <i>every</i> node never differ by more than 1.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '111',
    name: 'Minimum Depth of Binary Tree',
    acceptance: '33.4%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a binary tree, find its minimum depth.</p>\n\n<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '112',
    name: 'Path Sum',
    acceptance: '34.4%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\n</p>\n\nFor example:<br>\nGiven the below binary tree and <code>sum = 22</code>,\n<pre>              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\      \\\n        7    2      1\n</pre>\n\n<p>\nreturn true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft'],
  },
  {
    id: '113',
    name: 'Path Sum II',
    acceptance: '34.8%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nGiven a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.\n</p>\n\nFor example:<br>\nGiven the below binary tree and <code>sum = 22</code>,\n<pre>              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\    / \\\n        7    2  5   1\n</pre>\n\n<p>\nreturn<br>\n</p><pre>[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n</pre>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '114',
    name: 'Flatten Binary Tree to Linked List',
    acceptance: '35.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a binary tree, flatten it to a linked list in-place.\n</p>\n\n<p>\nFor example,<br>\nGiven\n</p><pre>         1\n        / \\\n       2   5\n      / \\   \\\n     3   4   6\n</pre>\n<p></p>\n\nThe flattened tree should look like:<br>\n<pre>   1\n    \\\n     2\n      \\\n       3\n        \\\n         4\n          \\\n           5\n            \\\n             6\n</pre>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show hints.</a></p>\n\n<div class="spoilers"><b>Hints:</b>\n<p>If you notice carefully in the flattened tree, each node\'s right child points to the next node of a pre-order traversal.</p>\n</div>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft'],
  },
  {
    id: '115',
    name: 'Distinct Subsequences',
    acceptance: '31.9%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a string <b>S</b> and a string <b>T</b>, count the number of distinct subsequences of <b>S</b> which equals <b>T</b>.\n</p>\n\n<p>\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>"ACE"</code> is a subsequence of <code>"ABCDE"</code> while <code>"AEC"</code> is not).\n</p>\n\n<p>\nHere is an example:<br>\n<b>S</b> = <code>"rabbbit"</code>, <b>T</b> = <code>"rabbit"</code>\n</p>\n<p>\nReturn <code>3</code>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '116',
    name: 'Populating Next Right Pointers in Each Node',
    acceptance: '36.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a binary tree\n</p><pre>    struct TreeLinkNode {\n      TreeLinkNode *left;\n      TreeLinkNode *right;\n      TreeLinkNode *next;\n    }\n</pre>\n<p></p>\n\n<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>\n\n<p>Initially, all next pointers are set to <code>NULL</code>.</p>\n\n<p>\n<b>Note:</b>\n</p><ul>\n<li>You may only use constant extra space.</li>\n<li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li>\n</ul>\n<p></p>\n\n<p>\nFor example,<br>\nGiven the following perfect binary tree,<br>\n</p><pre>         1\n       /  \\\n      2    3\n     / \\  / \\\n    4  5  6  7\n</pre>\n<p></p>\n<p>\nAfter calling your function, the tree should look like:<br>\n</p><pre>         1 -&gt; NULL\n       /  \\\n      2 -&gt; 3 -&gt; NULL\n     / \\  / \\\n    4-&gt;5-&gt;6-&gt;7 -&gt; NULL\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft'],
  },
  {
    id: '117',
    name: 'Populating Next Right Pointers in Each Node II',
    acceptance: '33.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Follow up for problem "<i>Populating Next Right Pointers in Each Node</i>".</p>\n<p>What if the given tree could be any binary tree? Would your previous solution still work?</p>\n<p>\n<b>Note:</b>\n</p><ul><li>You may only use constant extra space.</li></ul>\n<p></p>\n<p>\nFor example,<br>\nGiven the following binary tree,<br>\n</p><pre>         1\n       /  \\\n      2    3\n     / \\    \\\n    4   5    7\n</pre>\n<p></p>\n<p>\nAfter calling your function, the tree should look like:<br>\n</p><pre>         1 -&gt; NULL\n       /  \\\n      2 -&gt; 3 -&gt; NULL\n     / \\    \\\n    4-&gt; 5 -&gt; 7 -&gt; NULL\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Bloomberg'],
  },
  {
    id: '118',
    name: "Pascal's Triangle",
    acceptance: '39.4%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>Given <i>numRows</i>, generate the first <i>numRows</i> of Pascal's triangle.</p>\n\n<p>\nFor example, given <i>numRows</i> = 5,<br>\nReturn\n</p><pre>[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]\n</pre>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-dynamic-programming-accepted">Approach #1 Dynamic Programming [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-dynamic-programming-accepted">Approach #1 Dynamic Programming [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we have the a row of Pascal\'s triangle, we can easily compute the next\nrow by each pair of adjacent values.</p>\n<p><strong>Algorithm</strong></p>\n<p>Although the algorithm is very simple, the iterative approach to constructing\nPascal\'s triangle can be classified as dynamic programming because we\nconstruct each row based on the previous row.</p>\n<p>First, we generate the overall <code>triangle</code> list, which will store each row as\na sublist. Then, we check for the special case of <script type="math/tex; mode=display">0</script>, as we would otherwise\nreturn <script type="math/tex; mode=display">[1]</script>. If <script type="math/tex; mode=display">numRows > 0</script>, then we initialize <code>triangle</code> with <script type="math/tex; mode=display">[1]</script>\nas its first row, and proceed to fill the rows as follows:</p>\n<p>!?!../Documents/118_Pascals_Triangle.json:1280,720!?!</p>\n<iframe frameborder="0" height="500" name="C9aNRTAR" src="https://leetcode.com/playground/C9aNRTAR/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(numRows^2)</script>\n</p>\n<p>Although updating each value of <code>triangle</code> happens in constant time, it\nis performed <script type="math/tex; mode=display">O(numRows^2)</script> times. To see why, consider how many\noverall loop iterations there are. The outer loop obviously runs\n<script type="math/tex; mode=display">numRows</script> times, but for each iteration of the outer loop, the inner\nloop runs <script type="math/tex; mode=display">rowNum</script> times. Therefore, the overall number of <code>triangle</code> updates\nthat occur is <script type="math/tex; mode=display">1 + 2 + 3 + \\ldots + numRows</script>, which, according to Gauss\' formula,\nis</p>\n<p>\n<script type="math/tex; mode=display">\n\\begin{aligned}\n    \\frac{numRows(numRows+1)}{2} &= \\frac{numRows^2 + numRows}{2} \\\\\n    &= \\frac{numRows^2}{2} + \\frac{numRows}{2} \\\\\n    &= O(numRows^2)\n\\end{aligned}\n</script>\n</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(numRows^2)</script>\n</p>\n<p>Because we need to store each number that we update in <code>triangle</code>, the\nspace requirement is the same as the time complexity.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis and solutions written by: <a href="https://leetcode.com/emptyset">@emptyset</a></p>\n</div>\n          ',
    tags: ['Twitter', 'Apple'],
  },
  {
    id: '119',
    name: "Pascal's Triangle II",
    acceptance: '37.6%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>Given an index <i>k</i>, return the <i>k</i><sup>th</sup> row of the Pascal's triangle.</p>\n\n<p>\nFor example, given <i>k</i> = 3,<br>\nReturn <code>[1,3,3,1]</code>.\n</p>\n\n<p>\n<b>Note:</b><br>\nCould you optimize your algorithm to use only <i>O</i>(<i>k</i>) extra space?\n</p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Amazon'],
  },
  {
    id: '120',
    name: 'Triangle',
    acceptance: '34.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>\n\n<p>\nFor example, given the following triangle<br>\n</p><pre>[\n     [<font color="red">2</font>],\n    [<font color="red">3</font>,4],\n   [6,<font color="red">5</font>,7],\n  [4,<font color="red">1</font>,8,3]\n]\n</pre>\n<p></p>\n<p>\nThe minimum path sum from top to bottom is <code>11</code> (i.e., <font color="red">2</font> + <font color="red">3</font> + <font color="red">5</font> + <font color="red">1</font> = 11).\n</p>\n\n<p>\n<b>Note:</b><br>\nBonus point if you are able to do this using only <i>O</i>(<i>n</i>) extra space, where <i>n</i> is the total number of rows in the triangle.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '121',
    name: 'Best Time to Buy and Sell Stock',
    acceptance: '42.2%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>\n\n<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre>Input: [7, 1, 5, 3, 6, 4]\nOutput: 5\n\nmax. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre>Input: [7, 6, 4, 3, 1]\nOutput: 0\n\nIn this case, no transaction is done, i.e. max profit = 0.\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute Force) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-one-pass-accepted">Approach #2 (One Pass) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<p>We need to find out the maximum difference (which will be the maximum profit) between two numbers in the given array. Also, the second number (selling price) must be larger than the first one (buying price).</p>\n<p>In formal terms, we need to find <script type="math/tex; mode=display">\\max(prices[j] - prices[i])</script>, for every <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> such that <script type="math/tex; mode=display">j > i</script>.</p>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute Force) [Time Limit Exceeded]</h4>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span> <span class="n">prices</span><span class="o">[])</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">maxprofit</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>\n                <span class="kt">int</span> <span class="n">profit</span> <span class="o">=</span> <span class="n">prices</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">profit</span> <span class="o">&gt;</span> <span class="n">maxprofit</span><span class="o">)</span>\n                    <span class="n">maxprofit</span> <span class="o">=</span> <span class="n">profit</span><span class="o">;</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">maxprofit</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Loop runs <script type="math/tex; mode=display">\\frac{n (n-1)}{2}</script> times.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Only two variables - maxprofit and profit are used.</li>\n</ul>\n<hr>\n<h4 id="approach-2-one-pass-accepted">Approach #2 (One Pass) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Say the given array is:</p>\n<p>[7, 1, 5, 3, 6, 4]</p>\n<p>If we plot the numbers of the given array on a graph, we get:</p>\n<p><img alt="Profit Graph" src="https://leetcode.com/media/original_images/121_profit_graph.png"></p>\n<p>The points of interest are the peaks and valleys in the given graph. We need to find the largest peak following the smallest valley.\nWe can maintain two variables - minprice and maxprofit corresponding to the smallest valley and maximum profit (maximum difference between selling price and minprice) obtained so far respectively.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span> <span class="n">prices</span><span class="o">[])</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">minprice</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">maxprofit</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">minprice</span><span class="o">)</span>\n                <span class="n">minprice</span> <span class="o">=</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">minprice</span> <span class="o">&gt;</span> <span class="n">maxprofit</span><span class="o">)</span>\n                <span class="n">maxprofit</span> <span class="o">=</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">minprice</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">maxprofit</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Only a single pass is needed.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Only two variables are used.</p>\n</li>\n</ul>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Facebook', 'Microsoft', 'Amazon', 'Bloomberg', 'Uber'],
  },
  {
    id: '122',
    name: 'Best Time to Buy and Sell Stock II',
    acceptance: '47.8%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>\n\n<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-peak-valley-approach-accepted">Approach #2 (Peak Valley Approach) [Accepted]</a></li>\n<li><a href="#approach-3-simple-one-pass-accepted">Approach #3 (Simple One Pass) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>We have to determine the maximum profit that can be obtained by making the transactions (no limit on the number of transactions done). For this we need to find out those sets of buying and selling prices which together lead to the maximization of profit.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>In this case, we simply calculate the profit corresponding to all the possible sets of transactions and find out the maximum profit out of them.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">return</span> <span class="n">calculate</span><span class="o">(</span><span class="n">prices</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">calculate</span><span class="o">(</span><span class="kt">int</span> <span class="n">prices</span><span class="o">[],</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">&gt;=</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>\n            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">start</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">maxprofit</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>\n                    <span class="kt">int</span> <span class="n">profit</span> <span class="o">=</span> <span class="n">calculate</span><span class="o">(</span><span class="n">prices</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>\n                    <span class="k">if</span> <span class="o">(</span><span class="n">profit</span> <span class="o">&gt;</span> <span class="n">maxprofit</span><span class="o">)</span>\n                        <span class="n">maxprofit</span> <span class="o">=</span> <span class="n">profit</span><span class="o">;</span>\n                <span class="o">}</span>\n            <span class="o">}</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">maxprofit</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span>\n                <span class="n">max</span> <span class="o">=</span> <span class="n">maxprofit</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n^n)</script>. Recursive function is called <script type="math/tex; mode=display">n^n</script> times.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Depth of recursion is <script type="math/tex; mode=display">n</script>.</li>\n</ul>\n<hr>\n<h4 id="approach-2-peak-valley-approach-accepted">Approach #2 (Peak Valley Approach) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Say the given array is:</p>\n<p>[7, 1, 5, 3, 6, 4].</p>\n<p>If we plot the numbers of the given array on a graph, we get:</p>\n<p align="center"><img alt="Profit Graph" src="https://leetcode.com/media/original_images/122_maxprofit_1.PNG" width="539px"></p>\n<p>If we analyze the graph, we notice that the points of interest are the consecutive valleys and peaks.</p>\n<p>Mathematically speaking:\n<script type="math/tex; mode=display">\nTotal Profit= \\sum_{i}(height(peak_i)-height(valley_i))\n</script>\n</p>\n<p>The key point is we need to consider every peak immediately following a valley to maximize the profit. In case we skip one of the peaks (trying to obtain more profit), we will end up losing the profit over one of the transactions leading to an overall lesser profit.</p>\n<p>For example, in the above case, if we skip <script type="math/tex; mode=display">peak_i</script> and <script type="math/tex; mode=display">valley_j</script> trying to obtain more profit by considering points with more difference in heights, the net profit obtained will always be lesser than the one obtained by including them, since <script type="math/tex; mode=display">C</script> will always be lesser than <script type="math/tex; mode=display">A+B</script>.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">valley</span> <span class="o">=</span> <span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>\n        <span class="kt">int</span> <span class="n">peak</span> <span class="o">=</span> <span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>\n        <span class="kt">int</span> <span class="n">maxprofit</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span>\n                <span class="n">i</span><span class="o">++;</span>\n            <span class="n">valley</span> <span class="o">=</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span>\n                <span class="n">i</span><span class="o">++;</span>\n            <span class="n">peak</span> <span class="o">=</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n            <span class="n">maxprofit</span> <span class="o">+=</span> <span class="n">peak</span> <span class="o">-</span> <span class="n">valley</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">maxprofit</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Single pass.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space required.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-simple-one-pass-accepted">Approach #3 (Simple One Pass) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This solution follows the logic used in Approach 2 itself, but with only a slight variation. In this case, instead of looking for every peak following a valley, we can simply go on crawling over the slope and keep on adding the profit obtained from every consecutive transaction. In the end,we will be using the peaks and valleys effectively, but we need not track the costs corresponding to the peaks and valleys along with the maximum profit, but we can directly keep on adding the difference between the consecutive numbers of the array if the second number is larger than the first one, and at the total sum we obtain will be the maximum profit. This approach will simplify the solution.\nThis can be made clearer by taking this example:</p>\n<p>[1, 7, 2, 3, 6, 7, 6, 7]</p>\n<p>The graph corresponding to this array is:</p>\n<p align="center"><img alt="Profit Graph" src="https://leetcode.com/media/original_images/122_maxprofit_2.PNG" width="539px"></p>\n<p>From the above graph, we can observe that the sum <script type="math/tex; mode=display">A+B+C</script> is equal to the difference <script type="math/tex; mode=display">D</script> corresponding to the difference between the heights of the consecutive peak and valley.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">maxprofit</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span>\n                <span class="n">maxprofit</span> <span class="o">+=</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">maxprofit</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Single pass.</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(1)</script>. Constant space needed.</p>\n</li>\n</ul>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '123',
    name: 'Best Time to Buy and Sell Stock III',
    acceptance: '29.9%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>\n\n<p>Design an algorithm to find the maximum profit. You may complete at most <i>two</i> transactions.</p>\n\n<p><b>Note:</b><br>\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '124',
    name: 'Binary Tree Maximum Path Sum',
    acceptance: '26.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a binary tree, find the maximum path sum.\n</p>\n\n<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <b>at least one node</b> and does not need to go through the root.</p>\n\n<p>\nFor example:<br>\nGiven the below binary tree,\n</p><pre>       1\n      / \\\n     2   3\n</pre>\n<p></p>\n<p>\nReturn <code>6</code>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft', 'Baidu'],
  },
  {
    id: '125',
    name: 'Valid Palindrome',
    acceptance: '26.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\n</p>\n\n<p>\nFor example,<br>\n<code>"A man, a plan, a canal: Panama"</code> is a palindrome.<br>\n<code>"race a car"</code> is <i>not</i> a palindrome.\n</p>\n\n<p>\n<b>Note:</b><br>\nHave you consider that the string might be empty? This is a good question to ask during an interview.</p>\n<p>\nFor the purpose of this problem, we define empty string as valid palindrome.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Uber', 'Zenefits'],
  },
  {
    id: '126',
    name: 'Word Ladder II',
    acceptance: '14.6%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven two words (<i>beginWord</i> and <i>endWord</i>), and a dictionary\'s word list, find all shortest transformation sequence(s) from <i>beginWord</i> to <i>endWord</i>, such that:\n</p>\n<ol>\n<li>Only one letter can be changed at a time</li>\n<li>Each transformed word must exist in the word list. Note that <i>beginWord</i> is <i>not</i> a transformed word.</li>\n</ol>\n\n<p>\nFor example,\n</p>\n<p>\nGiven:<br>\n<i>beginWord</i> = <code>"hit"</code><br>\n<i>endWord</i> = <code>"cog"</code><br>\n<i>wordList</i> = <code>["hot","dot","dog","lot","log","cog"]</code><br>\n</p>\n<p>\nReturn<br>\n</p><pre>  [\n    ["hit","hot","dot","dog","cog"],\n    ["hit","hot","lot","log","cog"]\n  ]\n</pre>\n<p></p>\n\n<p>\n<b>Note:</b><br>\n</p><ul>\n<li>Return an empty list if there is no such transformation sequence.</li>\n<li>All words have the same length.</li>\n<li>All words contain only lowercase alphabetic characters.</li>\n<li>You may assume no duplicates in the word list.</li>\n<li>You may assume <i>beginWord</i> and <i>endWord</i> are non-empty and are not the same.</li>\n</ul>\n<p></p>\n\n<p>\n<b><font color="red">UPDATE (2017/1/20):</font></b><br>\nThe <i>wordList</i> parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Amazon', 'Yelp'],
  },
  {
    id: '127',
    name: 'Word Ladder',
    acceptance: '19.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven two words (<i>beginWord</i> and <i>endWord</i>), and a dictionary\'s word list, find the length of shortest transformation sequence from <i>beginWord</i> to <i>endWord</i>, such that:\n</p>\n<ol>\n<li>Only one letter can be changed at a time.</li>\n<li>Each transformed word must exist in the word list. Note that <i>beginWord</i> is <i>not</i> a transformed word.</li>\n</ol>\n\n<p>\nFor example,\n</p>\n<p>\nGiven:<br>\n<i>beginWord</i> = <code>"hit"</code><br>\n<i>endWord</i> = <code>"cog"</code><br>\n<i>wordList</i> = <code>["hot","dot","dog","lot","log","cog"]</code><br>\n</p>\n<p>\nAs one shortest transformation is <code>"hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog"</code>,<br>\nreturn its length <code>5</code>.\n</p>\n\n<p>\n<b>Note:</b><br>\n</p><ul>\n<li>Return 0 if there is no such transformation sequence.</li>\n<li>All words have the same length.</li>\n<li>All words contain only lowercase alphabetic characters.</li>\n<li>You may assume no duplicates in the word list.</li>\n<li>You may assume <i>beginWord</i> and <i>endWord</i> are non-empty and are not the same.</li>\n</ul>\n<p></p>\n\n<p>\n<b><font color="red">UPDATE (2017/1/20):</font></b><br>\nThe <i>wordList</i> parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Amazon', 'LinkedIn', 'Snapchat', 'Yelp'],
  },
  {
    id: '128',
    name: 'Longest Consecutive Sequence',
    acceptance: '37.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an unsorted array of integers, find the length of the longest consecutive elements sequence.\n</p>\n<p>\nFor example,<br>\nGiven <code>[100, 4, 200, 1, 3, 2]</code>,<br>\nThe longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Return its length: <code>4</code>.\n</p>\n<p>\nYour algorithm should run in O(<i>n</i>) complexity.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-sorting-accepted">Approach #2 Sorting [Accepted]</a></li>\n<li><a href="#approach-3-hashset-and-intelligent-sequence-building-accepted">Approach #3 HashSet and Intelligent Sequence Building [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>Because a sequence could start at any number in <code>nums</code>, we can exhaust the\nentire search space by building as long a sequence as possible from every\nnumber.</p>\n<p><strong>Algorithm</strong></p>\n<p>The brute force algorithm does not do anything clever - it just considers\neach number in <code>nums</code>, attempting to count as high as possible from that\nnumber using only numbers in <code>nums</code>. After it counts too high (i.e.\n<code>currentNum</code> refers to a number that <code>nums</code> does not contain), it records the\nlength of the sequence if it is larger than the current best. The algorithm\nis necessarily optimal because it explores every possibility.</p>\n<iframe frameborder="0" height="500" name="SvATwBnC" src="https://leetcode.com/playground/SvATwBnC/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>.</p>\n<p>The outer loop runs exactly <script type="math/tex; mode=display">n</script> times, and because <code>currentNum</code>\nincrements by 1 during each iteration of the <code>while</code> loop, it runs in\n<script type="math/tex; mode=display">O(n)</script> time. Then, on each iteration of the <code>while</code> loop, an <script type="math/tex; mode=display">O(n)</script>\nlookup in the array is performed. Therefore, this brute force algorithm\nis really three nested <script type="math/tex; mode=display">O(n)</script> loops, which compound multiplicatively to a\ncubic runtime.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n<p>The brute force algorithm only allocates a handful of integers, so it uses constant\nadditional space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-sorting-accepted">Approach #2 Sorting [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we can iterate over the numbers in ascending order, then it will be\neasy to find sequences of consecutive numbers. To do so, we can sort the\narray.</p>\n<p><strong>Algorithm</strong></p>\n<p>Before we do anything, we check for the base case input of the empty array.\nThe longest sequence in an empty array is, of course, 0, so we can simply\nreturn that. For all other cases, we sort <code>nums</code> and consider each number\nafter the first (because we need to compare each number to its previous\nnumber). If the current number and the previous are equal, then our current\nsequence is neither extended nor broken, so we simply move on to the next\nnumber. If they are unequal, then we must check whether the current number\nextends the sequence (i.e. <code>nums[i] == nums[i-1] + 1</code>). If it does, then we\nadd to our current count and continue. Otherwise, the sequence is broken, so\nwe record our current sequence and reset it to 1 (to include the number that\nbroke the sequence). It is possible that the last element of <code>nums</code> is part\nof the longest sequence, so we return the maximum of the current sequence and\nthe longest one.</p>\n<p align="center"><img alt="Sorting Example" src="https://leetcode.com/articles/Figures/128/sorting.png"></p>\n<p>Here, an example array is sorted before the linear scan identifies all consecutive sequences.\nThe longest sequence is colored in red.</p>\n<iframe frameborder="0" height="497" name="Kk6TtMB4" src="https://leetcode.com/playground/Kk6TtMB4/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nlgn)</script>.</p>\n<p>The main <code>for</code> loop does constant work <script type="math/tex; mode=display">n</script> times, so the algorithm\'s time\ncomplexity is dominated by the invocation of <code>sort</code>, which will run in\n<script type="math/tex; mode=display">O(nlgn)</script> time for any sensible implementation.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script> (or <script type="math/tex; mode=display">O(n)</script>).</p>\n<p>For the implementations provided here, the space complexity is constant\nbecause we sort the input array in place. If we are not allowed to modify\nthe input array, we must spend linear space to store a sorted copy.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-hashset-and-intelligent-sequence-building-accepted">Approach #3 HashSet and Intelligent Sequence Building [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>It turns out that our initial brute force solution was on the right track, but missing\na few optimizations necessary to reach <script type="math/tex; mode=display">O(n)</script> time complexity.</p>\n<p><strong>Algorithm</strong></p>\n<p>This optimized algorithm contains only two changes from the brute force\napproach: the numbers are stored in a <code>HashSet</code> (or <code>Set</code>, in Python) to\nallow <script type="math/tex; mode=display">O(1)</script> lookups, and we only attempt to build sequences from numbers\nthat are not already part of a longer sequence. This is accomplished by first\nensuring that the number that would immediately precede the current number in\na sequence is not present, as that number would necessarily be part of a\nlonger sequence.</p>\n<iframe frameborder="0" height="497" name="b5VsSQVL" src="https://leetcode.com/playground/b5VsSQVL/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.</p>\n<p>Although the time complexity appears to be quadratic due to the <code>while</code>\nloop nested within the <code>for</code> loop, closer inspection reveals it to be\nlinear. Because the <code>while</code> loop is reached only when <code>currentNum</code> marks\nthe beginning of a sequence (i.e. <code>currentNum-1</code> is not present in\n<code>nums</code>), the <code>while</code> loop can only run for <script type="math/tex; mode=display">n</script> iterations throughout the\nentire runtime of the algorithm. This means that despite looking like\n<script type="math/tex; mode=display">O(n*n)</script> complexity, the nested loops actually run in <script type="math/tex; mode=display">O(n + n) = O(n)</script>\ntime. All other computations occur in constant time, so the overall\nruntime is linear.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>.</p>\n<p>In order to set up <script type="math/tex; mode=display">O(1)</script> containment lookups, we allocate linear space\nfor a hash table to store the <script type="math/tex; mode=display">O(n)</script> numbers in <code>nums</code>. Other than that,\nthe space complexity is identical to that of the brute force solution.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/emptyset">@emptyset</a></p>\n</div>\n          ',
    tags: ['Google', 'Facebook'],
  },
  {
    id: '129',
    name: 'Sum Root to Leaf Numbers',
    acceptance: '37.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p>\n<p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p>\n\n<p>Find the total sum of all root-to-leaf numbers.</p>\n\n<p>For example,\n</p><pre>    1\n   / \\\n  2   3\n</pre>\n<p></p>\n<p>\nThe root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.<br>\nThe root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.\n</p>\n<p>\nReturn the sum = 12 + 13 = <code>25</code>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '130',
    name: 'Surrounded Regions',
    acceptance: '19.1%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nGiven a 2D board containing <code>'X'</code> and <code>'O'</code> (the <b>letter</b> O), capture all regions surrounded by <code>'X'</code>.</p>\n\n<p>A region is captured by flipping all <code>'O'</code>s into <code>'X'</code>s in that surrounded region.\n</p>\n\n<p>\nFor example,<br>\n</p><pre>X X X X\nX O O X\nX X O X\nX O X X\n</pre>\n<p></p>\n\n<p>\nAfter running your function, the board should be:\n</p><pre>X X X X\nX X X X\nX X X X\nX O X X\n</pre>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '131',
    name: 'Palindrome Partitioning',
    acceptance: '34.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a string <i>s</i>, partition <i>s</i> such that every substring of the partition is a palindrome.\n</p>\n<p>\nReturn all possible palindrome partitioning of <i>s</i>.\n</p>\n<p>\nFor example, given <i>s</i> = <code>"aab"</code>,<br>\n\nReturn\n</p><pre>[\n  ["aa","b"],\n  ["a","a","b"]\n]\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '132',
    name: 'Palindrome Partitioning II',
    acceptance: '24.6%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a string <i>s</i>, partition <i>s</i> such that every substring of the partition is a palindrome.\n</p>\n<p>\nReturn the minimum cuts needed for a palindrome partitioning of <i>s</i>.\n</p>\n<p>\nFor example, given <i>s</i> = <code>"aab"</code>,<br>\nReturn <code>1</code> since the palindrome partitioning <code>["aa","b"]</code> could be produced using 1 cut.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '133',
    name: 'Clone Graph',
    acceptance: '25.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nClone an undirected graph. Each node in the graph contains a <code>label</code> and a list of its <code>neighbors</code>.\n</p>\n\n<div>\n<br>\n<b>OJ\'s undirected graph serialization:</b>\n\n<p>\nNodes are labeled uniquely.\n</p>\n\nWe use <code>#</code> as a separator for each node, and <code>,</code> as a separator for node label and each neighbor of the node.\n<p></p>\n\n\n<p>\nAs an example, consider the serialized graph <code><font color="red">{<font color="black">0</font>,1,2#</font><font color="blue"><font color="black">1</font>,2#</font><font color="green"><font color="black">2</font>,2}</font></code>.\n</p>\n\n<p>\nThe graph has a total of three nodes, and therefore contains three parts as separated by <code>#</code>.\n</p><ol>\n<li>First node is labeled as <code><font color="black">0</font></code>. Connect node <code><font color="black">0</font></code> to both nodes <code><font color="red">1</font></code> and <code><font color="red">2</font></code>.</li>\n<li>Second node is labeled as <code><font color="black">1</font></code>. Connect node <code><font color="black">1</font></code> to node <code><font color="blue">2</font></code>.</li>\n<li>Third node is labeled as <code><font color="black">2</font></code>. Connect node <code><font color="black">2</font></code> to node <code><font color="green">2</font></code> (itself), thus forming a self-cycle.</li>\n</ol>\n<p></p>\n\n<p>\nVisually, the graph looks like the following:\n</p><pre>       1\n      / \\\n     /   \\\n    0 --- 2\n         / \\\n         \\_/\n</pre>\n<p></p>\n\n</div>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Uber', 'Pocket Gems'],
  },
  {
    id: '134',
    name: 'Gas Station',
    acceptance: '29.7%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nThere are <i>N</i> gas stations along a circular route, where the amount of gas at station <i>i</i> is <code>gas[i]</code>.\n</p>\n\n<p>\nYou have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <i>i</i> to its next station (<i>i</i>+1). You begin the journey with an empty tank at one of the gas stations.\n</p>\n\n<p>\nReturn the starting gas station's index if you can travel around the circuit once, otherwise return -1.\n</p>\n\n<p>\n<b>Note:</b><br>\nThe solution is guaranteed to be unique.\n</p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '135',
    name: 'Candy',
    acceptance: '25.0%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nThere are <i>N</i> children standing in a line. Each child is assigned a rating value. \n</p>\n<p>\nYou are giving candies to these children subjected to the following requirements:\n</p>\n<ul>\n<li>Each child must have at least one candy.</li>\n<li>Children with a higher rating get more candies than their neighbors.</li>\n</ul>\n<p>\nWhat is the minimum candies you must give?\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-two-arrays-accepted">Approach #2 Using two arrays [Accepted]</a></li>\n<li><a href="#approach-3-using-one-array-accepted">Approach #3 Using one array [Accepted]</a></li>\n<li><a href="#approach-4-single-pass-approach-with-constant-space-accepted">Approach #4 Single Pass Approach with Constant Space [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The simplest approach makes use of a 1-d array, <script type="math/tex; mode=display">candies</script> to keep a track of the candies given to the students. Firstly, we give 1 candy to each student. Then, we start scanning the\narray from left-to-right. At every element encountered, firstly, if the current element\'s ratings, <script type="math/tex; mode=display">ratings[i]</script>, is larger than the previous element(<script type="math/tex; mode=display">ratings[i-1]</script>) and <script type="math/tex; mode=display">candies[i]<=candies[i-1]</script>,\nthen we update <script type="math/tex; mode=display">candies[i]</script> as <script type="math/tex; mode=display">candies[i]=candies[i-1] + 1</script>.Thus, now the candy distribution for these two elements <script type="math/tex; mode=display">candies[i-1]</script> and <script type="math/tex; mode=display">candies[i]</script> becomes correct for the time being(locally).\n In the same step, we also check if the current element\'s ratings, <script type="math/tex; mode=display">ratings[i]</script>, is larger than the next element\'s ratings,\ni.e. <script type="math/tex; mode=display">ratings[i]>ratings[i+1]</script>. If so, we again update <script type="math/tex; mode=display">candies[i]=candies[i+1] + 1</script>. We continue this process for the whole <script type="math/tex; mode=display">ratings</script> array. If in any traversal,\nno updation of the <script type="math/tex; mode=display">candies</script> array occurs, it means we\'ve reached at the final required distribution of the candies and we can stop the traversals. To keep a track of\nthis we make use of a <script type="math/tex; mode=display">flag</script> which is set to <script type="math/tex; mode=display">\\text{True}</script> if any updation occurs in a traversal.</p>\n<p>At the end, we can sum up all the elements of the <script type="math/tex; mode=display">candies</script> array to obtain the required minimum number of candies.</p>\n<iframe frameborder="0" height="513" name="7nzEeZYF" src="https://leetcode.com/playground/7nzEeZYF/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. We need to traverse the array at most <script type="math/tex; mode=display">n</script> times.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. One <script type="math/tex; mode=display">candies</script> array of size <script type="math/tex; mode=display">n</script> is used.</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-two-arrays-accepted">Approach #2 Using two arrays [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, we make use of two 1-d arrays <script type="math/tex; mode=display">left2right</script> and <script type="math/tex; mode=display">right2left</script>. The <script type="math/tex; mode=display">left2right</script> array is used to store the number of candies required by the\ncurrent student taking care of the distribution relative to the left neighbours only. i.e. Assuming the distribution rule is: The student with a higher ratings\nthan its left neighbour should always get more candies than its left neighbour. Similarly, the <script type="math/tex; mode=display">right2left</script> array is used to store the number of candies candies required by the\ncurrent student taking care of the distribution relative to the right neighbours only. i.e. Assuming the distribution rule to be: The student with a higher ratings\nthan its right neighbour should always get more candies than its right neighbour. To do so, firstly we assign 1 candy to each student in both <script type="math/tex; mode=display">left2right</script> and <script type="math/tex; mode=display">right2left</script> array.\n Then, we traverse the array from\nleft-to-right and whenever the current element\'s ratings is larger than the left neighbour we update the\ncurrent element\'s candies in the <script type="math/tex; mode=display">left2right</script> array as <script type="math/tex; mode=display">left2right[i] = left2right[i-1] + 1</script>, since the current element\'s candies are always less than or equal candies than its left neighbour before updation.\nAfter the forward traversal, we traverse the array from left-to-right and\nupdate <script type="math/tex; mode=display">right2left[i]</script> as <script type="math/tex; mode=display">right2left[i] = right2left[i + 1] + 1</script>, whenever the current(<script type="math/tex; mode=display">i^{th}</script>) element has a higher ratings than the\nright(<script type="math/tex; mode=display">(i+1)^{th}</script>) element.</p>\n<p>Now, for the <script type="math/tex; mode=display">i^{th}</script> student in the array, we need to give <script type="math/tex; mode=display">\\text{max}(left2right[i], right2left[i])</script> to it, in order to satisfy both the left and the right neighbour\nrelationship. Thus, at the end, we obtain the minimum number of candies required as:</p>\n<p>\n<script type="math/tex; mode=display">\n\\text{minimum_candies}=\\sum_{i=0}^{n-1} \\text{max}(left2right[i], right2left[i]), \\quad\\text{where } n = \\text{length of the ratings array.}\n</script>\n</p>\n<p>The following animation illustrates the method:</p>\n<p><img alt="Candy_Two_Arrays" src="https://leetcode.com/articles/Figures/135_Candy_Two_Pass.gif"></p>\n<iframe frameborder="0" height="462" name="m8n6vXfR" src="https://leetcode.com/playground/m8n6vXfR/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">left2right</script> and <script type="math/tex; mode=display">right2left</script> arrays are traversed thrice.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Two arrays <script type="math/tex; mode=display">left2right</script> and <script type="math/tex; mode=display">right2left</script> of size <script type="math/tex; mode=display">n</script> are used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-one-array-accepted">Approach #3 Using one array [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the previous approach, we used two arrays to keep track of the left neighbour and the right neighbour relation individually and later on combined these two. Instead of this, we\ncan make use of a single array <script type="math/tex; mode=display">candies</script> to keep the count of the number of candies to be allocated to the current student. In order to do so, firstly we assign 1 candy to\neach student. Then, we traverse the array from left-to-right and distribute the candies following only the left neighbour relation i.e. whenever the current element\'s ratings is\nlarger than the left neighbour and has less than or equal candies than its left neighbour, we update the\ncurrent element\'s candies in the <script type="math/tex; mode=display">candies</script> array as <script type="math/tex; mode=display">candies[i] = candies[i-1] + 1</script>. While updating we need not compare <script type="math/tex; mode=display">candies[i]</script> and <script type="math/tex; mode=display">candies[i - 1]</script>, since\n <script type="math/tex; mode=display">candies[i] \\leq candies[i - 1]</script> before updation. After this, we traverse the array from right-to-left. Now, we need to\nupdate the <script type="math/tex; mode=display">i^{th}</script> element\'s candies in order to satisfy both the left neighbour and the right neighbour relation. Now, during the backward traversal, if <script type="math/tex; mode=display">ratings[i]>ratings[i + 1]</script>,\nconsidering only the right neighbour criteria, we could\'ve updated <script type="math/tex; mode=display">candies[i]</script> as <script type="math/tex; mode=display">candies[i] = candies[i + 1] + 1</script>. But, this time we need to update the <script type="math/tex; mode=display">candies[i]</script> only\nif <script type="math/tex; mode=display">candies[i] \\leq candies[i + 1]</script>. This happens because, this time we\'ve already altered the <script type="math/tex; mode=display">candies</script> array during the forward traversal and thus <script type="math/tex; mode=display">candies[i]</script> isn\'t\nnecessarily less than or equal to <script type="math/tex; mode=display">candies[i + 1]</script>. Thus, if <script type="math/tex; mode=display">ratings[i] > ratings[i + 1]</script>, we can update <script type="math/tex; mode=display">candies[i]</script> as <script type="math/tex; mode=display">candies[i] = \\text{max}(candies[i], candies[i + 1] + 1)</script>, which makes\n<script type="math/tex; mode=display">candies[i]</script> satisfy both the left neighbour and the right neighbour criteria.</p>\n<p>Again, we need sum up all the elements of the <script type="math/tex; mode=display">candies</script> array to obtain the required result.</p>\n<p>\n<script type="math/tex; mode=display">\n\\text{minimum_candies} = \\sum_{i=0}^{n-1} candies[i], \\quad\\text{where } n = \\text{length of the ratings array.}\n</script>\n</p>\n<iframe frameborder="0" height="394" name="Wa7z7oF2" src="https://leetcode.com/playground/Wa7z7oF2/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The array <script type="math/tex; mode=display">candies</script> of size <script type="math/tex; mode=display">n</script> is traversed thrice.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. An array <script type="math/tex; mode=display">candies</script> of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-single-pass-approach-with-constant-space-accepted">Approach #4 Single Pass Approach with Constant Space [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This approach relies on the observation(as demonstrated in the figure below as well) that in order to distribute the candies as per the given criteria using\nthe minimum number of candies, the candies are always distributed in terms of increments of 1. Further, while distributing the candies, the local minimum number of candies\ngiven to a student is 1. Thus, the sub-distributions always take the form: <script type="math/tex; mode=display">\\text{1, 2, 3, ..., n}</script> or <script type="math/tex; mode=display">\\text{n,..., 2, 1}</script>, whose sum is simply given by <script type="math/tex; mode=display">n(n+1)/2</script>.</p>\n<p>Now, we can view the given <script type="math/tex; mode=display">rankings</script> as some\nrising and falling slopes. Whenever the slope is rising, the distribution takes the form: <script type="math/tex; mode=display">\\text{1, 2, 3, ..., m}</script>. Similarly, a falling slope takes the form:\n<script type="math/tex; mode=display">\\text{k,..., 2, 1}</script>. An issue that arises now is that the local peak point can be included in only one of the slopes.\nWhether to include the local peak point(<script type="math/tex; mode=display">\\text{n}</script>) in the rising slope or the falling slope?</p>\n<p>In order to decide it,\nwe can observe that in order to satisfy both the right neighbour and the left neighbour criteria, the peak point\'s count needs to be the max. of the counts determined\nby the rising and the falling slopes. Thus, in order to determine the number of candies required, the peak point needs to be included in the slope which contains more\nnumber of points. The local valley point can also be included in only one of the slopes, but this issue can be resolved easily, since the local valley point will\nalways be assigned a candy count of 1(which can be subtracted from the next slope\'s count calculations).</p>\n<p>Coming to the implementation, we maintain two variables <script type="math/tex; mode=display">old\\_slope</script> and <script type="math/tex; mode=display">new\\_slope</script> to determine the occurence of a peak or a valley. We also use\n<script type="math/tex; mode=display">up</script> and <script type="math/tex; mode=display">down</script> variables to keep a track of the count of elements on the rising slope and on the falling slope respectively(without including the peak element). We always update the total count\nof <script type="math/tex; mode=display">candies</script> at the end of a falling slope following a rising slope (or a mountain). The leveling of the points in <script type="math/tex; mode=display">rankings</script> also works as the end of a mountain. At the end of the mountain, we determine whether to include the peak point in the rising slope or in the falling slope by comparing the <script type="math/tex; mode=display">up</script> and <script type="math/tex; mode=display">down</script> variables up to that point. Thus, the count assigned to the peak element becomes: <script type="math/tex; mode=display">\\text{max}(up, down) + 1</script>. At this point, we can reset the <script type="math/tex; mode=display">up</script> and <script type="math/tex; mode=display">down</script> variables indicating the start of a new mountain.</p>\n<p>The following figure shows the cases that need to be handled for this example:</p>\n<p><code>rankings: [1 2 3 4 5 3 2 1 2 6 5 4 3 3 2 1 1 3 3 3 4 2]</code></p>\n<p><img alt="Candy_Two_Arrays" src="https://leetcode.com/articles/Figures/135_Candy_Constant_Space.PNG"></p>\n<p>From this figure, we can see that the candy distributions in the subregions always take the form <script type="math/tex; mode=display">\\text{1, 2, ...n}</script> or <script type="math/tex; mode=display">\\text{n, ..., 2, 1}</script>.\nFor the first mountain comprised by the regions <script type="math/tex; mode=display">a</script> and <script type="math/tex; mode=display">b</script>, while assigning candies to the local peak point(<script type="math/tex; mode=display">pt. 5</script>), it needs to be included in\n<script type="math/tex; mode=display">a</script> to satisfy the left neighbour criteria. The local valley point at the end of region <script type="math/tex; mode=display">b</script>(<script type="math/tex; mode=display">pt. 8</script>) marks the end of the first mountain(region <script type="math/tex; mode=display">c</script>).\n While performing the calculations, we can include this point in either the current or the following mountain. The <script type="math/tex; mode=display">pt. 13</script> marks the end of the second\n mountain due to levelling of the <script type="math/tex; mode=display">pt. 13</script> and <script type="math/tex; mode=display">pt. 14</script>. Since, region <script type="math/tex; mode=display">e</script> has more points than region <script type="math/tex; mode=display">d</script>, the local peak(<script type="math/tex; mode=display">pt. 10</script>) needs to be\n included in region <script type="math/tex; mode=display">e</script> to satisfy the right neighbour criteria. Now, the third mountain <script type="math/tex; mode=display">f</script> can be considered as a mountian with no rising slope(<script type="math/tex; mode=display">up=0</script>)\n but only a falling slope. Similarly, <script type="math/tex; mode=display">pt. 16, 18, 19</script> also act as the mountain ends due to the levelling of the points.</p>\n<iframe frameborder="0" height="515" name="VMXjjp9G" src="https://leetcode.com/playground/VMXjjp9G/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We traverse the <script type="math/tex; mode=display">rankings</script> array once only.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant Extra Space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '136',
    name: 'Single Number',
    acceptance: '55.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given an array of integers, every element appears <i>twice</i> except for one. Find that single one.</p>\n\n<p>\n<b>Note:</b><br>\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-list-operation-time-limit-exceeded">Approach #1 List operation [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-hash-table-accepted">Approach #2 Hash Table [Accepted]</a></li>\n<li><a href="#approach-3-math-accepted">Approach #3 Math [Accepted]</a></li>\n<li><a href="#approach-4-bit-manipulation-accepted">Approach #4 Bit Manipulation [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-list-operation-time-limit-exceeded">Approach #1 List operation [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<ol>\n<li>Iterate over all the elements in <script type="math/tex; mode=display">\\text{nums}</script>\n</li>\n<li>If some number in <script type="math/tex; mode=display">\\text{nums}</script> is new to array, append it</li>\n<li>If some number is already in the array, remove it</li>\n</ol>\n<iframe frameborder="0" height="275" name="JpNhRkPe" src="https://leetcode.com/playground/JpNhRkPe/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. We iterate through <script type="math/tex; mode=display">\\text{nums}</script>, taking <script type="math/tex; mode=display">O(n)</script> time. We search the whole list to find whether there is duplicate number, taking <script type="math/tex; mode=display">O(n)</script> time. Because search is in the <code>for</code> loop, so we have to multiply both time complexities which is <script type="math/tex; mode=display">O(n^2)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>.  We need a list of size <script type="math/tex; mode=display">n</script> to contain elements in <script type="math/tex; mode=display">\\text{nums}</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-hash-table-accepted">Approach #2 Hash Table [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We use hash table to avoid the <script type="math/tex; mode=display">O(n)</script> time required for searching the elements.</p>\n<ol>\n<li>Iterate through all elements in <script type="math/tex; mode=display">\\text{nums}</script>\n</li>\n<li>Try if <script type="math/tex; mode=display">hash\\_table</script> has the key for <code>pop</code></li>\n<li>If not, set up key/value pair</li>\n<li>In the end, there is only one element in <script type="math/tex; mode=display">hash\\_table</script>, so use <code>popitem</code> to get it</li>\n</ol>\n<iframe frameborder="0" height="275" name="pSAMxcjw" src="https://leetcode.com/playground/pSAMxcjw/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n * 1) = O(n)</script>.  Time complexity of <code>for</code> loop is <script type="math/tex; mode=display">O(n)</script>. Time complexity of hash table(dictionary in python) operation <code>pop</code> is <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The space required by <script type="math/tex; mode=display">hash\\_table</script> is equal to the number of elements in <script type="math/tex; mode=display">\\text{nums}</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-math-accepted">Approach #3 Math [Accepted]</h4>\n<p><strong>Concept</strong></p>\n<p>\n<script type="math/tex; mode=display">2 * (a + b + c) - (a + a + b + b + c) = c</script>\n</p>\n<iframe frameborder="0" height="173" name="NXeUS9V2" src="https://leetcode.com/playground/NXeUS9V2/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n + n) = O(n)</script>. <code>sum</code> will call <code>next</code> to iterate through <script type="math/tex; mode=display">\\text{nums}</script>.\nWe can see it as <code>sum(list(i, for i in nums))</code> which means the time complexity is <script type="math/tex; mode=display">O(n)</script> because of the number of elements(<script type="math/tex; mode=display">n</script>) in <script type="math/tex; mode=display">\\text{nums}</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n + n) = O(n)</script>. <code>set</code> needs space for the elements in <code>nums</code></p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-bit-manipulation-accepted">Approach #4 Bit Manipulation [Accepted]</h4>\n<p><strong>Concept</strong></p>\n<ul>\n<li>If we take XOR of zero and some bit, it will return that bit<ul>\n<li>\n<script type="math/tex; mode=display">a \\oplus 0 = a</script>\n</li>\n</ul>\n</li>\n<li>If we take XOR of two same bits, it will return 0<ul>\n<li>\n<script type="math/tex; mode=display">a \\oplus a = 0</script>\n</li>\n</ul>\n</li>\n<li>\n<script type="math/tex; mode=display">a \\oplus b \\oplus a = (a \\oplus a) \\oplus b = 0 \\oplus b = b</script>\n</li>\n</ul>\n<p>So we can XOR all bits together to find the unique number.</p>\n<iframe frameborder="0" height="224" name="tVAd2noE" src="https://leetcode.com/playground/tVAd2noE/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.  We only iterate through <script type="math/tex; mode=display">\\text{nums}</script>, so the time complexity is the number of elements in <script type="math/tex; mode=display">\\text{nums}</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/Ambition_Wang">@Ambition_Wang</a></p>\n</div>\n          ',
    tags: ['Airbnb', 'Palantir'],
  },
  {
    id: '137',
    name: 'Single Number II',
    acceptance: '42.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array of integers, every element appears <i>three</i> times except for one, which appears exactly once. Find that single one.\n</p>\n\n<p>\n<b>Note:</b><br>\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '138',
    name: 'Copy List with Random Pointer',
    acceptance: '26.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nA linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.\n</p>\n\n<p>\nReturn a deep copy of the list.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft', 'Amazon', 'Bloomberg', 'Uber'],
  },
  {
    id: '139',
    name: 'Word Break',
    acceptance: '30.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a <b>non-empty</b> string <i>s</i> and a dictionary <i>wordDict</i> containing a list of <b>non-empty</b> words, determine if <i>s</i> can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.\n</p>\n\n<p>For example, given<br>\n<i>s</i> = <code>"leetcode"</code>,<br>\n<i>dict</i> = <code>["leet", "code"]</code>.\n</p>\n\n<p>\nReturn true because <code>"leetcode"</code> can be segmented as <code>"leet code"</code>.\n</p>\n\n<p>\n<b><font color="red">UPDATE (2017/1/4):</font></b><br>\nThe <i>wordDict</i> parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-recursion-with-memoization-accepted">Approach #2 Recursion with memoization [Accepted]</a></li>\n<li><a href="#approach-3-using-breadth-first-search-accepted">Approach #3 Using Breadth-First-Search [Accepted]</a></li>\n<li><a href="#approach-4-using-dynamic-programming-accepted">Approach #4 Using Dynamic Programming [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The naive approach to solve this problem is to use recursion and backtracking.\nFor finding the solution, we check every possible prefix of that string in the dictionary of words, if it is found in the dictionary, then the recursive function is called for the remaining portion of that string. And, if in some function call it is found that the complete string is in dictionary, then it will return true.</p>\n<iframe frameborder="0" height="326" name="xVARdHyL" src="https://leetcode.com/playground/xVARdHyL/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^n)</script>. Consider the worst case where <script type="math/tex; mode=display">s=``\\text{aaaaaaa}"</script> and every prefix of <script type="math/tex; mode=display">s</script> is present in the dictionary of words, then the recursion tree can grow upto <script type="math/tex; mode=display">n^n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of the recursion tree can go upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-recursion-with-memoization-accepted">Approach #2 Recursion with memoization [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the previous approach we can see that many subproblems were redundant, i.e we were calling the recursive function multiple times for a particular string. To avoid this we can use memoization method, where an array <script type="math/tex; mode=display">memo</script> is used to store the result of the subproblems. Now, when the function is called again for a particular string, value will be fetched and returned using the <script type="math/tex; mode=display">memo</script> array, if its value has been already evaluated.</p>\n<p>With memoization many redundant subproblems are avoided and recursion tree is pruned and thus it reduces the time complexity by a large factor.</p>\n<iframe frameborder="0" height="377" name="5KE8bugL" src="https://leetcode.com/playground/5KE8bugL/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Size of recursion tree can go up to <script type="math/tex; mode=display">n^2</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of recursion tree can go up to <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-breadth-first-search-accepted">Approach #3 Using Breadth-First-Search [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Another approach is to use Breadth-First-Search. Visualize the string as a tree where each node represents the prefix upto index <script type="math/tex; mode=display">end</script>.\nTwo nodes are connected only if the substring between the indices linked with those nodes is also a valid string which is present in the dictionary.\nIn order to form such a tree, we start with the first character of the given string (say <script type="math/tex; mode=display">s</script>) which acts as the root of the tree being formed and find every possible substring starting with that character which is a part of the dictionary. Further, the ending index (say <script type="math/tex; mode=display">i</script>) of every such substring is pushed at the back of a queue which will be used for Breadth First Search. Now, we pop an element out from the front of the queue and perform the same process considering the string <script type="math/tex; mode=display">s(i+1,end)</script> to be the original string and the popped node as the root of the tree this time. This process is continued, for all the nodes appended in the queue during the course of the process. If we are able to obtain the last element of the given string as a node (leaf) of the tree, this implies that the given string can be partitioned into substrings which are all a part of the given dictionary.</p>\n<p>The formation of the tree can be better understood with this example:\n<!--<img alt="Word Break" src="https://leetcode.com/articles/Figures/139_wordbreak.gif" />-->\n!?!../Documents/139_Word_Break.json:1000,563!?!</p>\n<iframe frameborder="0" height="445" name="ajbwneAy" src="https://leetcode.com/playground/ajbwneAy/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. For every starting index, the search can continue till the end of the given string.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Queue of atmost <script type="math/tex; mode=display">n</script> size is needed.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-dynamic-programming-accepted">Approach #4 Using Dynamic Programming [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>The intuition behind this approach is that the given problem (<script type="math/tex; mode=display">s</script>) can be divided into subproblems <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script>. If these subproblems individually satisfy the required conditions, the complete problem, <script type="math/tex; mode=display">s</script> also satisfies the same. e.g. "catsanddog" can be split into two substrings "catsand", "dog". The subproblem "catsand" can be further divided into "cats","and", which individually are a part of the dictionary making "catsand" satisfy the condition. Going further backwards, "catsand", "dog" also satisfy the required criteria individually leading to the complete string "catsanddog" also to satisfy the criteria.</p>\n<p>Now, we\'ll move onto the process of <script type="math/tex; mode=display">\\text{dp}</script> array formation. We make use of <script type="math/tex; mode=display">\\text{dp}</script> array of size <script type="math/tex; mode=display">n+1</script>, where <script type="math/tex; mode=display">n</script> is the length of the given string. We also use two index pointers <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script>, where <script type="math/tex; mode=display">i</script> refers to the length of the substring (<script type="math/tex; mode=display">s\'</script>) considered currently starting from the beginning, and <script type="math/tex; mode=display">j</script> refers to the index partitioning the current substring (<script type="math/tex; mode=display">s\'</script>) into smaller substrings <script type="math/tex; mode=display">s\'(0,j)</script> and <script type="math/tex; mode=display">s\'(j+1,i)</script>. To fill in the <script type="math/tex; mode=display">\\text{dp}</script> array, we initialize the element <script type="math/tex; mode=display">\\text{dp}[0]</script> as <script type="math/tex; mode=display">\\text{true}</script>, since the null string is always present in the dictionary, and the rest of the elements of <script type="math/tex; mode=display">\\text{dp}</script> as <script type="math/tex; mode=display">\\text{false}</script>. We consider substrings of all possible lengths starting from the beginning by making use of index <script type="math/tex; mode=display">i</script>. For every such substring, we partition the string into two further substrings <script type="math/tex; mode=display">s1\'</script> and <script type="math/tex; mode=display">s2\'</script> in all possible ways using the index <script type="math/tex; mode=display">j</script> (Note that the <script type="math/tex; mode=display">i</script> now refers to the ending index of <script type="math/tex; mode=display">s2\'</script>). Now, to fill in the entry <script type="math/tex; mode=display">\\text{dp}[i]</script>, we check if the <script type="math/tex; mode=display">\\text{dp}[j]</script> contains <script type="math/tex; mode=display">\\text{true}</script>, i.e. if the substring <script type="math/tex; mode=display">s1\'</script> fulfills the required criteria. If so, we further check if <script type="math/tex; mode=display">s2\'</script> is present in the dictionary. If both the strings fulfill the criteria, we make <script type="math/tex; mode=display">\\text{dp}[i]</script> as <script type="math/tex; mode=display">\\text{true}</script>, otherwise as <script type="math/tex; mode=display">\\text{false}</script>.</p>\n<iframe frameborder="0" height="326" name="Ay6dHGnM" src="https://leetcode.com/playground/Ay6dHGnM/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Two loops are their to fill <script type="math/tex; mode=display">\\text{dp}</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Length of <script type="math/tex; mode=display">p</script> array is <script type="math/tex; mode=display">n+1</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google', 'Facebook', 'Amazon', 'Bloomberg', 'Uber', 'Yahoo', 'Pocket Gems', 'Square', 'Coupang'],
  },
  {
    id: '140',
    name: 'Word Break II',
    acceptance: '24.0%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a <b>non-empty</b> string <i>s</i> and a dictionary <i>wordDict</i> containing a list of <b>non-empty</b> words, add spaces in <i>s</i> to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words.\n</p>\n\n<p>\nReturn all such possible sentences.\n</p>\n\n<p>\nFor example, given<br>\n<i>s</i> = <code>"catsanddog"</code>,<br>\n<i>dict</i> = <code>["cat", "cats", "and", "sand", "dog"]</code>.\n</p>\n\n<p>\nA solution is <code>["cats and dog", "cat sand dog"]</code>.\n</p>\n\n<p>\n<b><font color="red">UPDATE (2017/1/4):</font></b><br>\nThe <i>wordDict</i> parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-recursion-with-memoization-accepted">Approach #2 Recursion with memoization [Accepted]</a></li>\n<li><a href="#approach-3-using-dynamic-programming-time-limit-exceeded">Approach #3 Using Dynamic Programming [Time Limit Exceeded]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>Given a string <script type="math/tex; mode=display">s</script> and a dictionary of words <script type="math/tex; mode=display">dict</script>, add spaces in <script type="math/tex; mode=display">s</script> to construct every possible sentence such that each word is valid as per the given dictionary.\nReturn all such possible sentences.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The naive approach to solve this problem is to use recursion.\nFor finding the solution, we check every possible prefix of that string (<script type="math/tex; mode=display">s</script>) in the dictionary of words, if it is found in the dictionary (say <script type="math/tex; mode=display">s1</script>), then the recursive function is called for the remaining portion of that string.\nThis function returns the prefix <script type="math/tex; mode=display">s1</script> appended by the result of the recursive call using the remaining portion of the string (<script type="math/tex; mode=display">s-s1</script>), if the remaining portion is a substring\nwhich can lead to the formation of a valid sentence as per the dictionary. Otherwise, empty list is returned.</p>\n<iframe frameborder="0" height="394" name="7t7xWm5m" src="https://leetcode.com/playground/7t7xWm5m/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^n)</script>. Consider the worst case where <script type="math/tex; mode=display">s=``aaaaaaa"</script> and every prefix of <script type="math/tex; mode=display">s</script> is present in the dictionary of words, then the recursion tree can grow up to <script type="math/tex; mode=display">n^n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^3)</script>. In worst case the depth of recursion tree can go up to <script type="math/tex; mode=display">n</script> and nodes can contain <script type="math/tex; mode=display">n</script> strings each of length <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-recursion-with-memoization-accepted">Approach #2 Recursion with memoization [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the previous approach we can see that many subproblems were redundant, i.e we were calling the recursive function multiple times for the same substring appearing through\n multiple paths.\nTo avoid this we can use memorization method, where we are making use of a hashmap to store the results in the form of a <script type="math/tex; mode=display">key:value</script> pair. In this hashmap, the <script type="math/tex; mode=display">key</script>\n used is the starting index of the string currently considered and the <script type="math/tex; mode=display">value</script> contains all the sentences which can be formed using the substring from this starting\n index onwards. Thus, if we encounter the same starting index from different function calls, we can return the result directly from the hashmap rather than going\n for redundant function calls.</p>\n<p>With memorization many redundant subproblems are avoided and recursion tree is pruned and thus it reduces the time complexity by a large factor.</p>\n<iframe frameborder="0" height="515" name="EK5ckR9F" src="https://leetcode.com/playground/EK5ckR9F/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. Size of recursion tree can go up to <script type="math/tex; mode=display">n^2</script>. The creation of list takes <script type="math/tex; mode=display">n</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^3)</script>.The depth of the recursion tree can go up to <script type="math/tex; mode=display">n</script> and each activation record can contains a string list of size <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-dynamic-programming-time-limit-exceeded">Approach #3 Using Dynamic Programming [Time Limit Exceeded]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>The intuition behind this approach is that the given problem (<script type="math/tex; mode=display">s</script>) can be divided into subproblems <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script>. If these subproblems individually satisfy the required conditions, the complete problem, <script type="math/tex; mode=display">s</script> also satisfies the same. e.g. "catsanddog" can be split into two substrings "catsand", "dog". The subproblem "catsand" can be further divided into "cats","and", which individually are a part of the dictionary making "catsand" satisfy the condition. Going further backwards, "catsand", "dog" also satisfy the required criteria individually leading to the complete string "catsanddog" also to satisfy the criteria.</p>\n<p>Now, we\'ll move onto the process of <script type="math/tex; mode=display">\\text{dp}</script> array formation.\nWe make use of <script type="math/tex; mode=display">\\text{dp}</script> array (in the form of a linked list) of size <script type="math/tex; mode=display">n+1</script>, where <script type="math/tex; mode=display">n</script> is the length of the given string.\n<script type="math/tex; mode=display">\\text{dp}[k]</script> is used to store every possible sentence having all valid dictionary words using the substring <script type="math/tex; mode=display">s[0:k-1]</script>.\n We also use two index pointers <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script>, where <script type="math/tex; mode=display">i</script> refers to the length of the substring (<script type="math/tex; mode=display">s\'</script>) considered currently starting from\nthe beginning, and <script type="math/tex; mode=display">j</script> refers to the index partitioning the current substring (<script type="math/tex; mode=display">s\'</script>) into smaller substrings <script type="math/tex; mode=display">s\'(0,j)</script> and <script type="math/tex; mode=display">s\'(j+1,i)</script>.\nTo fill in the <script type="math/tex; mode=display">\\text{dp}</script> array, we initialize the element <script type="math/tex; mode=display">\\text{dp}[0]</script> as an empty string, since no sentence can be formed using a word of size 0.\nWe consider substrings of all possible lengths starting from the beginning by making use of index <script type="math/tex; mode=display">i</script>.\nFor every such substring, we partition the string into two further substrings <script type="math/tex; mode=display">s1\'</script> and <script type="math/tex; mode=display">s2\'</script> in all possible ways using the index <script type="math/tex; mode=display">j</script> (\nNote that the <script type="math/tex; mode=display">i</script> now refers to the ending index of <script type="math/tex; mode=display">s2\'</script>). Now, to fill in the entry <script type="math/tex; mode=display">\\text{dp}[i]</script>, we check if the <script type="math/tex; mode=display">\\text{dp}[j]</script> contains a non-empty string\n i.e. if some valid sentence can be formed using <script type="math/tex; mode=display">s1\'</script>. If so, we further check if <script type="math/tex; mode=display">s2\'</script> is present in the dictionary. If both the conditions are satified,\n we append the substring <script type="math/tex; mode=display">s2\'</script> to every possible sentence that can be formed up to the index <script type="math/tex; mode=display">j</script> (which is already stored in <script type="math/tex; mode=display">d[j]</script>). These newly formed sentences\n are stored in <script type="math/tex; mode=display">\\text{dp}[i]</script>. Finally the element <script type="math/tex; mode=display">\\text{dp}[n]</script> (<script type="math/tex; mode=display">n</script> refers to the length of the given string <script type="math/tex; mode=display">s</script>) gives all possible valid sentences using the complete string <script type="math/tex; mode=display">s</script>.</p>\n<iframe frameborder="0" height="394" name="NMViSLPe" src="https://leetcode.com/playground/NMViSLPe/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. Two loops are required to fill <script type="math/tex; mode=display">\\text{dp}</script> array and one loop for appending a list .</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^3)</script>. Length of <script type="math/tex; mode=display">\\text{dp}</script> array is <script type="math/tex; mode=display">n</script> and each value of <script type="math/tex; mode=display">\\text{dp}</script> array contains a list of string i.e. <script type="math/tex; mode=display">n^2</script> space.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google', 'Uber', 'Twitter', 'Snapchat', 'Dropbox'],
  },
  {
    id: '141',
    name: 'Linked List Cycle',
    acceptance: '35.2%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a linked list, determine if it has a cycle in it.\n</p>\n\n<p>\nFollow up:<br>\nCan you solve it without using extra space?\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-hash-table-accepted">Approach #1 (Hash Table) [Accepted]</a></li>\n<li><a href="#approach-2-two-pointers-accepted">Approach #2 (Two Pointers) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This article is for beginners. It introduces the following ideas: Linked List, Hash Table and Two Pointers.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-hash-table-accepted">Approach #1 (Hash Table) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>To detect if a list is cyclic, we can check whether a node had been visited before. A natural way is to use a hash table.</p>\n<p><strong>Algorithm</strong></p>\n<p>We go through each node one by one and record each node\'s reference (or memory address) in a hash table. If the current node is <code>null</code>, we have reached the end of the list and it must not be cyclic. If current node’s reference is in the hash table, then return true.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasCycle</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">Set</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">&gt;</span> <span class="n">nodesSeen</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">nodesSeen</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">head</span><span class="o">))</span> <span class="o">{</span>\n            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>\n            <span class="n">nodesSeen</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nWe visit each of the <script type="math/tex; mode=display">n</script> elements in the list at most once. Adding a node to the hash table costs only <script type="math/tex; mode=display">O(1)</script> time.</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(n)</script>.\nThe space depends on the number of elements added to the hash table, which contains at most <script type="math/tex; mode=display">n</script> elements.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-two-pointers-accepted">Approach #2 (Two Pointers) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Imagine two runners running on a track at different speed. What happens when the track is actually a circle?</p>\n<p><strong>Algorithm</strong></p>\n<p>The space complexity can be reduced to <script type="math/tex; mode=display">O(1)</script> by considering two pointers at <strong>different speed</strong> - a slow pointer and a fast pointer. The slow pointer moves one step at a time while the fast pointer moves two steps at a time.</p>\n<p>If there is no cycle in the list, the fast pointer will eventually reach the end and we can return false in this case.</p>\n<p>Now consider a cyclic list and imagine the slow and fast pointers are two runners racing around a circle track. The fast runner will eventually meet the slow runner. Why? Consider this case (we name it case A) - The fast runner is just one step behind the slow runner. In the next iteration, they both increment one and two steps respectively and meet each other.</p>\n<p>How about other cases? For example, we have not considered cases where the fast runner is two or three steps behind the slow runner yet. This is simple, because in the next or next\'s next iteration, this case will be reduced to case A mentioned above.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasCycle</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="n">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>\n    <span class="n">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">fast</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>\n        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nLet us denote <script type="math/tex; mode=display">n</script> as the total number of nodes in the linked list. To analyze its time complexity, we consider the following two cases separately.</p>\n<ul>\n<li>\n<p><strong><em>List has no cycle:</em></strong><br>\nThe fast pointer reaches the end first and the run time depends on the list\'s length, which is <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n<li>\n<p><strong><em>List has a cycle:</em></strong><br>\nWe break down the movement of the slow pointer into two steps, the non-cyclic part and the cyclic part:</p>\n<ol>\n<li>\n<p>The slow pointer takes "non-cyclic length" steps to enter the cycle. At this point, the fast pointer has already reached the cycle. <script type="math/tex; mode=display">\\text{Number of iterations} = \\text{non-cyclic length} = N</script>\n</p>\n</li>\n<li>\n<p>Both pointers are now in the cycle. Consider two runners running in a cycle - the fast runner moves 2 steps while the slow runner moves 1 steps at a time. Since the speed difference is 1, it takes <script type="math/tex; mode=display">\\frac{\\text{distance between the 2 runners}}{\\text{difference of speed}}</script> loops for the fast runner to catch up with the slow runner. As the distance is at most "cyclic length K" and the speed difference is 1, we conclude that <script type="math/tex; mode=display">\\text{Number of iterations} = \\text{almost } `` \\text{cyclic length K} ".</script>\n</p>\n</li>\n</ol>\n</li>\n</ul>\n<p>Therefore, the worst case time complexity is <script type="math/tex; mode=display">O(N+K)</script>, which is <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.\nWe only use two nodes (slow and fast) so the space complexity is <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<p>Analysis written by: @tianyi8, revised by @1337c0d3r.</p>\n</div>\n          ',
    tags: ['Microsoft', 'Amazon', 'Bloomberg', 'Yahoo'],
  },
  {
    id: '142',
    name: 'Linked List Cycle II',
    acceptance: '30.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.\n</p>\n\n<p>\n<b>Note:</b> Do not modify the linked list.</p>\n\n<p>\n<b>Follow up</b>:<br>\nCan you solve it without using extra space?\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-hash-table-accepted">Approach #1 Hash Table [Accepted]</a></li>\n<li><a href="#approach-2-floyds-tortoise-and-hare-accepted">Approach #2 Floyd\'s Tortoise and Hare [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-hash-table-accepted">Approach #1 Hash Table [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we keep track of the nodes that we\'ve seen already in a <code>Set</code>, we can\ntraverse the list and return the first duplicate node.</p>\n<p><strong>Algorithm</strong></p>\n<p>First, we allocate a <code>Set</code> to store <code>ListNode</code> references. Then, we traverse\nthe list, checking <code>visited</code> for containment of the current node. If the node\nhas already been seen, then it is necessarily the entrance to the cycle. If\nany other node were the entrance to the cycle, then we would have already\nreturned that node instead. Otherwise, the <code>if</code> condition will never be\nsatisfied, and our function will return <code>null</code>.</p>\n<p>The algorithm necessarily terminates for any list with a finite number of\nnodes, as the domain of input lists can be divided into two categories:\ncyclic and acyclic lists. An acyclic list resembles a <code>null</code>-terminated chain\nof nodes, while a cyclic list can be thought of as an acyclic list with the\nfinal <code>null</code> replaced by a reference to some previous node. If the <code>while</code>\nloop terminates, we return <code>null</code>, as we have traversed the entire list\nwithout encountering a duplicate reference. In this case, the list is\nacyclic. For a cyclic list, the <code>while</code> loop will never terminate, but at\nsome point the <code>if</code> condition will be satisfied and cause the function to\nreturn.</p>\n<iframe frameborder="0" height="327" name="d2vcf6vS" src="https://leetcode.com/playground/d2vcf6vS/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n)</script>\n</li>\n</ul>\n<p>For both cyclic and acyclic inputs, the algorithm must visit each node\nexactly once. This is transparently obvious for acyclic lists because the\n<script type="math/tex; mode=display">n</script>th node points to <code>null</code>, causing the loop to terminate. For cyclic\nlists, the <code>if</code> condition will cause the function to return after\nvisiting the <script type="math/tex; mode=display">n</script>th node, as it points to some node that is already in\n<code>visited</code>. In both cases, the number of nodes visited is exactly <script type="math/tex; mode=display">n</script>,\nso the runtime is linear in the number of nodes.</p>\n<ul>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>\n</li>\n</ul>\n<p>For both cyclic and acyclic inputs, we will need to insert each node into\nthe <code>Set</code> once. The only difference between the two cases is whether we\ndiscover that the "last" node points to <code>null</code> or a previously-visited\nnode. Therefore, because the <code>Set</code> will contain <script type="math/tex; mode=display">n</script> distinct nodes, the\nmemory footprint is linear in the number of nodes.</p>\n<hr>\n<h4 id="approach-2-floyds-tortoise-and-hare-accepted">Approach #2 Floyd\'s Tortoise and Hare [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>What happens when a fast runner (a hare) races a slow runner (a tortoise) on\na circular track? At some point, the fast runner will catch up to the slow\nrunner from behind.</p>\n<p><strong>Algorithm</strong></p>\n<p>Floyd\'s algorithm is separated into two distinct <em>phases</em>. In the first\nphase, it determines whether a cycle is present in the list. If no cycle is\npresent, it returns <code>null</code> immediately, as it is impossible to find the\nentrance to a nonexistant cycle. Otherwise, it uses the located "intersection\nnode" to find the entrance to the cycle.</p>\n<p><em>Phase 1</em></p>\n<p>Here, we initialize two pointers - the fast <code>hare</code> and the slow <code>tortoise</code>.\nThen, until <code>hare</code> can no longer advance, we increment <code>tortoise</code> once and\n<code>hare</code> twice.<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup> If, after advancing them, <code>hare</code> and <code>tortoise</code> point to\nthe same node, we return it. Otherwise, we continue. If the <code>while</code> loop\nterminates without returning a node, then the list is acyclic, and we return\n<code>null</code> to indicate as much.</p>\n<p>To see why this works, consider the image below:</p>\n<p></p><center>\n<img alt="Diagram of cyclic list" src="https://leetcode.com/articles/Figures/142/Slide1.PNG" style="width: 650px;">\n</center><p></p>\n<p>Here, the nodes in the cycle have been labelled from 0 to <script type="math/tex; mode=display">C-1</script>, where\n<script type="math/tex; mode=display">C</script> is the length of the cycle. The noncyclic nodes have been labelled from\n<script type="math/tex; mode=display">-F</script> to -1, where <script type="math/tex; mode=display">F</script> is the number of nodes outside of the cycle. After\n<script type="math/tex; mode=display">F</script> iterations, <code>tortoise</code> points to node 0 and <code>hare</code> points to some node\n<script type="math/tex; mode=display">h</script>, where <script type="math/tex; mode=display">F \\equiv h \\pmod C</script>. This is because <code>hare</code> traverses <script type="math/tex; mode=display">2F</script>\nnodes over the course of <script type="math/tex; mode=display">F</script> iterations, exactly <script type="math/tex; mode=display">F</script> of which are in the\ncycle. After <script type="math/tex; mode=display">C-h</script> more iterations, <code>tortoise</code> obviously points to node\n<script type="math/tex; mode=display">C-h</script>, but (less obviously) <code>hare</code> also points to the same node. To see why,\nremember that <code>hare</code> traverses <script type="math/tex; mode=display">2(C-h)</script> from its starting position of <script type="math/tex; mode=display">h</script>:</p>\n<p>\n<script type="math/tex; mode=display">\n\\begin{aligned}\n    h + 2(C-h) &= 2C - h \\\\ \n                &\\equiv C-h \\pmod C\n\\end{aligned}\n</script>\n</p>\n<p>Therefore, given that the list is cyclic, <code>hare</code> and <code>tortoise</code> will\neventually both point to the same node, known henceforce as the\n<em>intersection</em>.</p>\n<p><em>Phase 2</em></p>\n<p>Given that phase 1 finds an intersection, phase 2 proceeds to find the node\nthat is the entrance to the cycle. To do so, we initialize two more pointers:\n<code>ptr1</code>, which points to the head of the list, and <code>ptr2</code>, which points to\nthe intersection. Then, we advance each of them by 1 until they meet; the\nnode where they meet is the entrance to the cycle, so we return it.</p>\n<p>Use the diagram below to help understand the proof of this approach\'s\ncorrectness.</p>\n<p></p><center>\n<img alt="Phase 2 diagram" src="https://leetcode.com/articles/Figures/142/diagram.png" style="width: 650px;">\n</center><p></p>\n<p>We can harness the fact that <code>hare</code> moves twice as quickly as <code>tortoise</code> to\nassert that when <code>hare</code> and <code>tortoise</code> meet at node <script type="math/tex; mode=display">h</script>, <code>hare</code> has\ntraversed twice as many nodes. Using this fact, we deduce the following:</p>\n<p>\n<script type="math/tex; mode=display">\n\\begin{aligned}\n    2 \\cdot distance(tortoise) &= distance(hare) \\\\\n                        2(F+a) &= F+a+b+a \\\\\n                         2F+2a &= F+2a+b \\\\\n                             F &= b \\\\\n\\end{aligned}\n</script>\n</p>\n<p>Because <script type="math/tex; mode=display">F=b</script>, pointers starting at nodes <script type="math/tex; mode=display">h</script> and <script type="math/tex; mode=display">0</script> will traverse the\nsame number of nodes before meeting.</p>\n<p>To see the entire algorithm in action, check out the animation below:</p>\n<p>!?!../Documents/142_Linked_List_Cycle_II.json:1280,720!?!</p>\n<iframe frameborder="0" height="500" name="Jz68hVCq" src="https://leetcode.com/playground/Jz68hVCq/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>For cyclic lists, <code>hare</code> and <code>tortoise</code> will point to the same node after\n<script type="math/tex; mode=display">F+C-h</script> iterations, as demonstrated in the proof of correctness.\n<script type="math/tex; mode=display">F+C-h \\leq F+C = n</script>, so phase 1 runs in <script type="math/tex; mode=display">O(n)</script> time. Phase 2\nruns for <script type="math/tex; mode=display">F < n</script> iterations, so it also runs in <script type="math/tex; mode=display">O(n)</script> time.</p>\n<p>For acyclic lists, <code>hare</code> will reach the end of the list in roughly\n<script type="math/tex; mode=display">\\frac{n}{2}</script> iterations, causing the function to return before phase\n2. Therefore, regardless of which category of list the algorithm\nreceives, it runs in time linearly proportional to the number of nodes.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n<p>Floyd\'s Tortoise and Hare algorithm allocates only pointers, so it runs\nwith constant overall memory usage.</p>\n</li>\n</ul>\n<hr>\n<p><strong>Footnotes</strong></p>\n<hr>\n<p>Analysis and solutions written by: <a href="https://leetcode.com/emptyset">@emptyset</a></p>\n<p>Proof of phase 1 inspired by paw88789\'s answer <a href="https://math.stackexchange.com/questions/913499/proof-of-floyd-cycle-chasing-tortoise-and-hare">here</a>.</p>\n<p>Proof of phase 2 inspired by Old Monk\'s answer <a href="https://cs.stackexchange.com/questions/10360/floyds-cycle-detection-algorithm-determining-the-starting-point-of-cycle">here</a>.</p>\n<div class="footnote">\n<hr>\n<ol>\n<li id="fn:1">\n<p>It is sufficient to check only <code>hare</code> because it will always be ahead\nof <code>tortoise</code> in an acyclic list.&nbsp;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">↩</a></p>\n</li>\n</ol>\n</div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '143',
    name: 'Reorder List',
    acceptance: '26.2%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nGiven a singly linked list <i>L</i>: <i>L</i><sub>0</sub>→<i>L</i><sub>1</sub>→…→<i>L</i><sub><i>n</i>-1</sub>→<i>L</i><sub>n</sub>,<br>\nreorder it to: <i>L</i><sub>0</sub>→<i>L</i><sub><i>n</i></sub>→<i>L</i><sub>1</sub>→<i>L</i><sub><i>n</i>-1</sub>→<i>L</i><sub>2</sub>→<i>L</i><sub><i>n</i>-2</sub>→…\n</p>\n\n<p>You must do this in-place without altering the nodes' values.</p>\n\n<p>\nFor example,<br>\nGiven <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.\n</p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '144',
    name: 'Binary Tree Preorder Traversal',
    acceptance: '45.9%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given a binary tree, return the <i>preorder</i> traversal of its nodes' values.</p>\n\n<p>\nFor example:<br>\nGiven binary tree <code>[1,null,2,3]</code>,<br>\n</p><pre>   1\n    \\\n     2\n    /\n   3\n</pre>\n<p></p>\n<p>\nreturn <code>[1,2,3]</code>.\n</p>\n\n<p><b>Note:</b> Recursive solution is trivial, could you do it iteratively?</p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '145',
    name: 'Binary Tree Postorder Traversal',
    acceptance: '41.0%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>Given a binary tree, return the <i>postorder</i> traversal of its nodes' values.</p>\n\n<p>\nFor example:<br>\nGiven binary tree <code>{1,#,2,3}</code>,<br>\n</p><pre>   1\n    \\\n     2\n    /\n   3\n</pre>\n<p></p>\n<p>\nreturn <code>[3,2,1]</code>.\n</p>\n\n<p><b>Note:</b> Recursive solution is trivial, could you do it iteratively?</p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '146',
    name: 'LRU Cache',
    acceptance: '18.9%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nDesign and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.\n</p>\n\n<p>\n<code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>\n<code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\n</p>\n\n<p><b>Follow up:</b><br>\nCould you do both operations in <b>O(1)</b> time complexity?</p>\n\n<p><b>Example:</b>\n</p><pre>LRUCache cache = new LRUCache( 2 /* capacity */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // returns 1\ncache.put(3, 3);    // evicts key 2\ncache.get(2);       // returns -1 (not found)\ncache.put(4, 4);    // evicts key 1\ncache.get(1);       // returns -1 (not found)\ncache.get(3);       // returns 3\ncache.get(4);       // returns 4\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [
      'Google',
      'Facebook',
      'Microsoft',
      'Amazon',
      'Bloomberg',
      'Uber',
      'Twitter',
      'Snapchat',
      'Zenefits',
      'Yahoo',
      'Palantir',
    ],
  },
  {
    id: '147',
    name: 'Insertion Sort List',
    acceptance: '33.5%',
    difficulty: 'Medium',
    questionHtml: '\n            <br>\n            <p>Sort a linked list using insertion sort.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '148',
    name: 'Sort List',
    acceptance: '29.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Sort a linked list in <i>O</i>(<i>n</i> log <i>n</i>) time using constant space complexity.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '149',
    name: 'Max Points on a Line',
    acceptance: '15.2%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given <i>n</i> points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['LinkedIn', 'Twitter', 'Apple'],
  },
  {
    id: '150',
    name: 'Evaluate Reverse Polish Notation',
    acceptance: '27.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nEvaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a>.\n</p>\n\n<p>\nValid operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. Each operand may be an integer or another expression.\n</p>\n\n<p>\nSome examples:<br>\n</p><pre>  ["2", "1", "+", "3", "*"] -&gt; ((2 + 1) * 3) -&gt; 9\n  ["4", "13", "5", "/", "+"] -&gt; (4 + (13 / 5)) -&gt; 6\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '151',
    name: 'Reverse Words in a String',
    acceptance: '15.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an input string, reverse the string word by word.\n</p>\n\n<p>\nFor example,<br>\nGiven s = "<code>the sky is blue</code>",<br>\nreturn "<code>blue is sky the</code>".\n</p>\n\n<p>\n<b><font color="red">Update (2015-02-12):</font></b><br>\nFor C programmers: Try to solve it <i>in-place</i> in <i>O</i>(1) space.\n</p>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show clarification.</a></p>\n\n<div class="spoilers"><b>Clarification:</b>\n\n<p>\n</p><ul>\n<li>What constitutes a word?<br>\nA sequence of non-space characters constitutes a word.</li>\n<li>Could the input string contain leading or trailing spaces?<br>\nYes. However, your reversed string should not contain leading or trailing spaces.</li>\n<li>How about multiple spaces between two words?<br>\nReduce them to a single space in the reversed string.</li>\n</ul>\n<p></p>\n</div>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft', 'Bloomberg', 'Apple', 'Snapchat', 'Yelp'],
  },
  {
    id: '152',
    name: 'Maximum Product Subarray',
    acceptance: '26.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nFind the contiguous subarray within an array (containing at least one number) which has the largest product.\n</p>\n\n<p>\nFor example, given the array <code>[2,3,-2,4]</code>,<br>\nthe contiguous subarray <code>[2,3]</code> has the largest product = <code>6</code>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '153',
    name: 'Find Minimum in Rotated Sorted Array',
    acceptance: '40.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\n\n<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>\n\n<p>Find the minimum element.</p>\n\n<p>You may assume no duplicate exists in the array.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft'],
  },
  {
    id: '154',
    name: 'Find Minimum in Rotated Sorted Array II',
    acceptance: '37.6%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <blockquote>\n<p><i>Follow up</i> for "Find Minimum in Rotated Sorted Array":<br>\nWhat if <i>duplicates</i> are allowed?</p>\n\n<p>Would this affect the run-time complexity? How and why?</p>\n</blockquote>\n\n<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\n\n<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>\n\n<p>Find the minimum element.</p>\n\n<p>The array may contain duplicates.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '155',
    name: 'Min Stack',
    acceptance: '30.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n</p><ul>\n<li>\npush(x) -- Push element x onto stack.\n</li>\n<li>\npop() -- Removes the element on top of the stack.\n</li>\n<li>\ntop() -- Get the top element.\n</li>\n<li>\ngetMin() -- Retrieve the minimum element in the stack.\n</li>\n</ul>\n<p></p>\n\n<p><b>Example:</b><br>\n</p><pre>MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --&gt; Returns -3.\nminStack.pop();\nminStack.top();      --&gt; Returns 0.\nminStack.getMin();   --&gt; Returns -2.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Amazon', 'Bloomberg', 'Uber', 'Snapchat', 'Zenefits'],
  },
  {
    id: '156',
    name: 'Binary Tree Upside Down ',
    acceptance: '45.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.\n</p>\n\nFor example:<br>\nGiven a binary tree <code>{1,2,3,4,5}</code>,<br>\n<pre>    1\n   / \\\n  2   3\n / \\\n4   5\n</pre>\n<p></p>\n<p>\nreturn the root of the binary tree <code>[4,5,2,#,#,3,1]</code>.<br>\n</p><pre>   4\n  / \\\n 5   2\n    / \\\n   3   1  \n</pre>\n<p></p>\n\n<p class="showspoilers">confused what <code>"{1,#,2,3}"</code> means? <a href="#" onclick="showSpoilers(this); return false;">&gt; read more on how binary tree is serialized on OJ.</a></p>\n\n<div class="spoilers"><br><b>OJ\'s Binary Tree Serialization:</b>\n<p>\nThe serialization of a binary tree follows a level order traversal, where \'#\' signifies a path terminator where no node exists below.\n</p>\n<p>\nHere\'s an example:<br>\n</p><pre>   1\n  / \\\n 2   3\n    /\n   4\n    \\\n     5\n</pre>\nThe above binary tree is serialized as <code>"{1,2,3,#,#,4,#,#,5}"</code>. \n<p></p>\n</div>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '157',
    name: 'Read N Characters Given Read4 ',
    acceptance: '29.2%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nThe API: <code>int read4(char *buf)</code> reads 4 characters at a time from a file.\n</p>\n\n<p>\nThe return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.\n</p>\n\n<p>\nBy using the <code>read4</code> API, implement the function <code>int read(char *buf, int n)</code> that reads <i>n</i> characters from the file.\n</p>\n\n<p>\n<b>Note:</b><br>\nThe <code>read</code> function will only be called once for each test case.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook'],
  },
  {
    id: '158',
    name: 'Read N Characters Given Read4 II - Call multiple times ',
    acceptance: '24.6%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nThe API: <code>int read4(char *buf)</code> reads 4 characters at a time from a file.\n</p>\n\n<p>\nThe return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.\n</p>\n\n<p>\nBy using the <code>read4</code> API, implement the function <code>int read(char *buf, int n)</code> that reads <i>n</i> characters from the file.\n</p>\n\n<p>\n<b>Note:</b><br>\nThe <code>read</code> function may be called multiple times.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Bloomberg'],
  },
  {
    id: '159',
    name: 'Longest Substring with At Most Two Distinct Characters ',
    acceptance: '42.1%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a string, find the length of the longest substring T that contains at most 2 distinct characters.\n</p>\n\n<p>\nFor example,\n\nGiven s = <code>“eceba”</code>,\n</p>\n\n<p>\nT is "ece" which its length is 3.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '160',
    name: 'Intersection of Two Linked Lists',
    acceptance: '30.8%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>\n<br>\n<p>For example, the following two linked lists: </p>\n<pre>A:          a1 → a2\n                   ↘\n                     c1 → c2 → c3\n                   ↗            \nB:     b1 → b2 → b3\n</pre>\n<p>begin to intersect at node c1.</p>\n<br>\n<p><b>Notes:</b>\n</p><ul>\n<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>\n<li>The linked lists must retain their original structure after the function returns. </li>\n<li>You may assume there are no cycles anywhere in the entire linked structure.</li>\n<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>\n</ul>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/stellari">@stellari</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute Force) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-hash-table-accepted">Approach #2 (Hash Table) [Accepted]</a></li>\n<li><a href="#approach-3-two-pointers-accepted">Approach #3 (Two Pointers) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute Force) [Time Limit Exceeded]</h4>\n<p>For each node a<sub>i</sub> in list A, traverse the entire list B and check if any node in list B coincides with a<sub>i</sub>.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(mn)</script>.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</li>\n</ul>\n<hr>\n<h4 id="approach-2-hash-table-accepted">Approach #2 (Hash Table) [Accepted]</h4>\n<p>Traverse list A and store the address / reference to each node in a hash set. Then check every node b<sub>i</sub> in list B: if b<sub>i</sub> appears in the hash set, then b<sub>i</sub> is the intersection node.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(m+n)</script>.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(m)</script> or <script type="math/tex; mode=display">O(n)</script>.</li>\n</ul>\n<hr>\n<h4 id="approach-3-two-pointers-accepted">Approach #3 (Two Pointers) [Accepted]</h4>\n<ul>\n<li>Maintain two pointers pA and pB initialized at the head of A and B, respectively. Then let them both traverse through the lists, one node at a time.</li>\n<li>When pA reaches the end of a list, then redirect it to the head of B (yes, B, that\'s right.); similarly when pB reaches the end of a list, redirect it the head of A.</li>\n<li>If at any point pA meets pB, then pA/pB is the intersection node.</li>\n<li>To see why the above trick would work, consider the following two lists: A = {1,3,5,7,9,11} and B = {2,4,9,11}, which are intersected at node \'9\'. Since B.length (=4) &lt; A.length (=6), pB would reach the end of the merged list first, because pB traverses exactly 2 nodes less than pA does. By redirecting pB to head A, and pA to head B, we now ask pB to travel exactly 2 more nodes than pA would. So in the second iteration, they are guaranteed to reach the intersection node at the same time.</li>\n<li>If two lists have intersection, then their last nodes must be the same one. So when pA/pB reaches the end of a list, record the last element of A/B respectively. If the two last elements are not the same one, then the two lists have no intersections.</li>\n</ul>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(m+n)</script>.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</li>\n</ul>\n<p>Analysis written by @stellari.</p>\n</div>\n          ',
    tags: ['Microsoft', 'Amazon', 'Bloomberg', 'Airbnb'],
  },
  {
    id: '161',
    name: 'One Edit Distance ',
    acceptance: '31.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given two strings S and T, determine if they are both one edit distance apart.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Uber', 'Twitter', 'Snapchat'],
  },
  {
    id: '162',
    name: 'Find Peak Element',
    acceptance: '38.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>A peak element is an element that is greater than its neighbors.</p>\n\n<p>Given an input array where <code>num[i] ≠ num[i+1]</code>, find a peak element and return its index.</p>\n\n<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>\n\n<p>You may imagine that <code>num[-1] = num[n] = -∞</code>.</p>\n\n<p>For example, in array <code>[1, 2, 3, 1]</code>, 3 is a peak element and your function should return the index number 2.</p>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show spoilers.</a></p>\n\n<div class="spoilers"><b>Note:</b>\n<p>Your solution should be in logarithmic complexity.</p>\n</div>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-linear-scan-accepted">Approach #1 Linear Scan [Accepted]</a></li>\n<li><a href="#approach-2-recursive-binary-search-accepted">Approach #2 Recursive Binary Search [Accepted]</a></li>\n<li><a href="#approach-3-iterative-binary-search-accepted">Approach #3 Iterative Binary Search [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-linear-scan-accepted">Approach #1 Linear Scan [Accepted]</h4>\n<p>In this approach, we make use of the fact that two consecutive numbers <script type="math/tex; mode=display">nums[j]</script> and <script type="math/tex; mode=display">nums[j + 1]</script> are never equal. Thus, we can traverse over the <script type="math/tex; mode=display">nums</script> array starting from the beginning. Whenever, we find a number <script type="math/tex; mode=display">nums[i]</script>, we only need to check if it is larger than the next number <script type="math/tex; mode=display">nums[i+1]</script> for determining if <script type="math/tex; mode=display">nums[i]</script> is the peak element. The reasoning behind this can be understood by taking the following three cases which cover every case into which any problem can be divided.</p>\n<p>Case 1: All the numbers appear in a descending order. In this case, the first element corresponds to the peak element. We start off by checking if the current element is larger than the next one. The first element satisfies this criteria, and is hence identified as the peak correctly. In this case, we didn\'t reach a point where we needed to compare <script type="math/tex; mode=display">nums[i]</script> with <script type="math/tex; mode=display">nums[i-1]</script> also, to determine if it is the peak element or not.</p>\n<p align="center"><img alt="Graph" src="https://leetcode.com/articles/Figures/162/Find_Peak_Case1.PNG"></p>\n<p>Case 2: All the elements appear in ascending order. In this case, we keep on comparing <script type="math/tex; mode=display">nums[i]</script> with <script type="math/tex; mode=display">nums[i+1]</script> to determine if <script type="math/tex; mode=display">nums[i]</script> is the peak element or not. None of the elements satisfy this criteria, indicating that we are currently on a rising slope and not on a peak. Thus, at the end, we need to return the last element as the peak element, which turns out to be correct. In this case also, we need not compare <script type="math/tex; mode=display">nums[i]</script> with <script type="math/tex; mode=display">nums[i-1]</script>, since being on the rising slope is a sufficient condition to ensure that <script type="math/tex; mode=display">nums[i]</script> isn\'t the peak element.</p>\n<p align="center"><img alt="Graph" src="https://leetcode.com/articles/Figures/162/Find_Peak_Case2.PNG"></p>\n<p>Case 3: The peak appears somewhere in the middle. In this case, when we are traversing on the rising edge, as in Case 2, none of the elements will satisfy <script type="math/tex; mode=display">nums[i] > nums[i + 1]</script>. We need not compare <script type="math/tex; mode=display">nums[i]</script> with <script type="math/tex; mode=display">nums[i-1]</script> on the rising slope as discussed above. When we finally reach the peak element, the condition <script type="math/tex; mode=display">nums[i] > nums[i + 1]</script> is satisfied. We again, need not compare <script type="math/tex; mode=display">nums[i]</script> with <script type="math/tex; mode=display">nums[i-1]</script>. This is because, we could reach <script type="math/tex; mode=display">nums[i]</script> as the current element only when the check <script type="math/tex; mode=display">nums[i] > nums[i + 1]</script> failed for the previous(<script type="math/tex; mode=display">(i-1)^{th}</script> element, indicating that <script type="math/tex; mode=display">nums[i-1] < nums[i]</script>. Thus, we are able to identify the peak element correctly in this case as well.</p>\n<p align="center"><img alt="Graph" src="https://leetcode.com/articles/Figures/162/Find_Peak_Case3.PNG"></p>\n<iframe frameborder="0" height="207" name="m9g6nHmm" src="https://leetcode.com/playground/m9g6nHmm/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We traverse the <script type="math/tex; mode=display">nums</script> array of size <script type="math/tex; mode=display">n</script> once only.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-recursive-binary-search-accepted">Approach #2 Recursive Binary Search [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can view any given sequence in <script type="math/tex; mode=display">nums</script> array as alternating ascending and descending sequences. By making use of this, and the fact that we can return any peak as the result, we can make use of Binary Search to find the required peak element.</p>\n<p>In case of simple Binary Search, we work on a sorted sequence of numbers and try to find out the required number by reducing the search space at every step. In this case, we use a modification of this simple Binary Search to our advantage. We start off by finding the middle element, <script type="math/tex; mode=display">mid</script> from the given <script type="math/tex; mode=display">nums</script> array. If this element happens to be lying in a descending sequence of numbers. or a local falling slope(found by comparing <script type="math/tex; mode=display">nums[i]</script> to its right neighbour), it means that the peak will always lie towards the left of this element. Thus, we reduce the search space to the left of <script type="math/tex; mode=display">mid</script>(including itself) and perform the same process on left subarray.</p>\n<p>If the middle element, <script type="math/tex; mode=display">mid</script> lies in an ascending sequence of numbers, or a rising slope(found by comparing <script type="math/tex; mode=display">nums[i]</script> to its right neighbour), it obviously implies that the peak lies towards the right of this element. Thus, we reduce the search space to the right of <script type="math/tex; mode=display">mid</script> and perform the same process on the right subarray.</p>\n<p>In this way, we keep on reducing the search space till we eventually reach a state where only one element is remaining in the search space. This single element is the peak element.</p>\n<p>To see how it works, let\'s consider the three cases discussed above again.</p>\n<p>Case 1. In this case, we firstly find <script type="math/tex; mode=display">3</script> as the middle element. Since it lies on a falling slope, we reduce the search space to <code>[1, 2, 3]</code>. For this subarray, <script type="math/tex; mode=display">2</script> happens to be the middle element, which again lies on a falling slope, reducing the search space to <code>[1, 2]</code>. Now, <script type="math/tex; mode=display">1</script> acts as the middle element and it lies on a falling slope, reducing the search space to <code>[1]</code> only. Thus, <script type="math/tex; mode=display">1</script> is returned as the peak correctly.</p>\n<p>!?!../Documents/Find_Peak_Case1.json:1000,563!?!</p>\n<p>Case 2. In this case, we firstly find <script type="math/tex; mode=display">3</script> as the middle element. Since it lies on a rising slope, we reduce the search space to <code>[4, 5]</code>. Now, <script type="math/tex; mode=display">4</script> acts as the middle element for this subarray and it lies on a rising slope, reducing the search space to <code>[5]</code> only. Thus, <script type="math/tex; mode=display">5</script> is returned as the peak correctly.</p>\n<p>!?!../Documents/Find_Peak_Case2.json:1000,563!?!</p>\n<p>Case 3. In this case, the peak lies somewhere in the middle. The first middle element is <script type="math/tex; mode=display">4</script>. It lies on a rising slope, indicating that the peak lies towards its right. Thus, the search space is reduced to <code>[5, 1]</code>. Now, <script type="math/tex; mode=display">5</script> happens to be the on a falling slope(relative to its right neighbour), reducing the search space to <code>[5]</code> only. Thus, <script type="math/tex; mode=display">5</script> is identified as the peak element correctly.</p>\n<p>!?!../Documents/Find_Peak_Case3.json:1000,563!?!</p>\n<iframe frameborder="0" height="292" name="DQ6yCGV8" src="https://leetcode.com/playground/DQ6yCGV8/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(log_2(n)\\big)</script>. We reduce the search space in half at every step. Thus, the total search space will be consumed in <script type="math/tex; mode=display">log_2(n)</script> steps. Here, <script type="math/tex; mode=display">n</script> refers to the size of <script type="math/tex; mode=display">nums</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O\\big(log_2(n)\\big)</script>. We reduce the search space in half at every step. Thus, the total search space will be consumed in <script type="math/tex; mode=display">log_2(n)</script> steps. Thus, the depth of recursion tree will go upto <script type="math/tex; mode=display">log_2(n)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-iterative-binary-search-accepted">Approach #3 Iterative Binary Search [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The binary search discussed in the previous approach used a recursive method. We can do the same process in an iterative fashion also. This is done in the current approach.</p>\n<iframe frameborder="0" height="275" name="nMPNAyTN" src="https://leetcode.com/playground/nMPNAyTN/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(log_2(n)\\big)</script>. We reduce the search space in half at every step. Thus, the total search space will be consumed in <script type="math/tex; mode=display">log_2(n)</script> steps. Here, <script type="math/tex; mode=display">n</script> refers to the size of <script type="math/tex; mode=display">nums</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google', 'Microsoft'],
  },
  {
    id: '163',
    name: 'Missing Ranges ',
    acceptance: '23.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a sorted integer array where <b>the range of elements are in the inclusive range [<i>lower</i>, <i>upper</i>]</b>, return its missing ranges.</p>\n\n<p>\nFor example, given <code>[0, 1, 3, 50, 75]</code>, <i>lower</i> = 0 and <i>upper</i> = 99, return <code>["2", "4-&gt;49", "51-&gt;74", "76-&gt;99"].</code>\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '164',
    name: 'Maximum Gap',
    acceptance: '29.8%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>\n\n<p>Try to solve it in linear time/space.</p>\n\n<p>Return 0 if the array contains less than 2 elements.</p>\n\n<p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/porker2008">@porker2008</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-comparison-sorting-accepted">Approach #1 Comparison Sorting [Accepted]</a></li>\n<li><a href="#approach-2-radix-sort-accepted">Approach #2 Radix Sort [Accepted]</a></li>\n<li><a href="#approach-3-buckets-and-the-pigeonhole-principle-accepted">Approach #3 Buckets and The Pigeonhole Principle [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-comparison-sorting-accepted">Approach #1 Comparison Sorting [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Do what the question says.</p>\n<p><strong>Algorithm</strong></p>\n<p>Sort the entire array. Then iterate over it to find the maximum gap between two successive elements.</p>\n<iframe frameborder="0" height="292" name="5XF6D9Xw" src="https://leetcode.com/playground/5XF6D9Xw/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O(n \\cdot log(n))</script>.</p>\n<p>Time taken to sort the array is <script type="math/tex; mode=display">O(n \\cdot log(n))</script> (average case). Time taken for linear iteration through the array is of <script type="math/tex; mode=display">O(n)</script> complexity. Hence overall time complexity is <script type="math/tex; mode=display">O(n \\cdot log(n))</script>.</p>\n</li>\n<li>\n<p>Space complexity: No extra space needed, other than the input array (since sorting can usually be done in-place).</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-radix-sort-accepted">Approach #2 Radix Sort [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This approach is similar to <a href="#approach-1-comparison-sorting-accepted">Approach #1</a>, except we use <a href="https://en.wikipedia.org/wiki/Radix_sort">Radix Sort</a> instead of a traditional comparison sort.</p>\n<iframe frameborder="0" height="515" name="3qjCnNai" src="https://leetcode.com/playground/3qjCnNai/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O(d \\cdot (n + k)) \\approx O(n)</script>.</p>\n<p>Since a linear iteration over the array (once it is sorted) is of linear (i.e. <script type="math/tex; mode=display">O(n)</script>) complexity, the performance of this approach is limited by the performance of Radix sort.</p>\n<p>Radix sort uses <a href="https://en.wikipedia.org/wiki/Counting_sort">Counting sort</a> as a subroutine.</p>\n<ul>\n<li>\n<p>Counting sort runs in <script type="math/tex; mode=display">O(n + k)</script> time (where <script type="math/tex; mode=display">k</script> is the radix or base of the digits comprising the <script type="math/tex; mode=display">n</script> elements in the array). If <script type="math/tex; mode=display">k \\leq O(n)</script>, Counting sort would run in linear time. In our case, the radix is fixed (i.e. <script type="math/tex; mode=display">k = 10</script>). Hence our Counting sort subroutine runs in <script type="math/tex; mode=display">O(n)</script> linear time.</p>\n</li>\n<li>\n<p>Radix sort works by running <script type="math/tex; mode=display">d</script> passes of the Counting sort subroutine (where the elements are composed of, maximally, <script type="math/tex; mode=display">d</script> digits). Hence effective runtime of Radix sort would be <script type="math/tex; mode=display">O(d \\cdot (n + k))</script>. However, in our case an element can, maximally, be the maximum 32-bit signed integer <code>2,147,483,647</code>. Hence <script type="math/tex; mode=display">d \\leq 10</script> is a constant.</p>\n</li>\n</ul>\n<p>Thus Radix sort has a runtime performance complexity of about <script type="math/tex; mode=display">O(n)</script> for reasonably large input.</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(n + k) \\approx O(n)</script> extra space.</p>\n<p>Counting sort requires <script type="math/tex; mode=display">O(k)</script> extra space. Radix sort requires an auxiliary array of the same size as input array. However given that <script type="math/tex; mode=display">k</script> is a small fixed constant, the space required by Counting sort can be ignored for reasonably large input.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-buckets-and-the-pigeonhole-principle-accepted">Approach #3 Buckets and The Pigeonhole Principle [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Sorting an entire array can be costly. At worst, it requires comparing each element with <em>every</em> other element.\nWhat if we didn\'t need to compare all pairs of elements? That would be possible if we could somehow divide the elements into representative groups, or rather, <em>buckets</em>. Then we would only need to compare these buckets.</p>\n<blockquote>\n<p><strong>Digression: The Pigeonhole Principle</strong>\nThe <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">Pigeonhole Principle</a> states that if <script type="math/tex; mode=display">n</script> items are put into <script type="math/tex; mode=display">m</script> containers, with <script type="math/tex; mode=display">n > m</script>, then at least one container must contain more than one item.</p>\n</blockquote>\n<p>Suppose for each of the <script type="math/tex; mode=display">n</script> elements in our array, there was a bucket. Then each element would occupy one bucket. Now what if we reduced, the number of buckets? Some buckets would have to accommodate more than one element.</p>\n<p>Now let\'s talk about the gaps between the elements. Let\'s take the best case, where all elements of the array are sorted and have a uniform gap between them. This means every adjacent pair of elements differ by the same constant value. So for <script type="math/tex; mode=display">n</script> elements of the array, there are <script type="math/tex; mode=display">n-1</script> gaps, each of width, say, <script type="math/tex; mode=display">t</script>. It is trivial to deduce that <script type="math/tex; mode=display">t = (max - min)/(n-1)</script> (where <script type="math/tex; mode=display">max</script> and <script type="math/tex; mode=display">min</script> are the minimum and maximum elements of the array). This width is the maximal width/gap between two adjacent elements in the array; precisely the quantity we are looking for!</p>\n<p>One can safely argue that this value of <script type="math/tex; mode=display">t</script>, is in fact, the smallest value that <script type="math/tex; mode=display">t</script> can ever accomplish of any array with the same number of elements (i.e. <script type="math/tex; mode=display">n</script>) and the same range (i.e. <script type="math/tex; mode=display">(max - min)</script>). To test this fact, you can start with a uniform width array (as described above) and try to reduce the gap between any two adjacent elements. If you reduce the gap between <script type="math/tex; mode=display">arr[i-1]</script> and <script type="math/tex; mode=display">arr[i]</script> to some value <script type="math/tex; mode=display">t - p</script>, then you will notice that the gap between <script type="math/tex; mode=display">arr[i]</script> and <script type="math/tex; mode=display">arr[i+1]</script> would have increased to <script type="math/tex; mode=display">t + p</script>. Hence the maximum attainable gap would have become <script type="math/tex; mode=display">t + p</script> from <script type="math/tex; mode=display">t</script>. Thus the value of the <strong>maximum gap</strong> <script type="math/tex; mode=display">t</script> can only increase.</p>\n<p><strong>Buckets!</strong></p>\n<p>Coming back to our problem, we have already established by application of the Pigeonhole Principle, that if we used <em>buckets</em> instead of individual elements as our base for comparison, the number of comparisons would reduce if we could accommodate more than one element in a single bucket. That does not immediately solve the problem though. What if we had to compare elements <em>within</em> a bucket? We would end up no better.</p>\n<p>So the current motivation remains: somehow, if we only had to compare among the buckets, and <em>not</em> the elements <em>within</em> the buckets, we would be good. It would also solve our sorting problem: we would just distribute the elements to the right buckets. Since the buckets can be already ordered, and we only compare among buckets, we wouldn\'t have to compare all elements to sort them!</p>\n<p>But if we only had buckets to compare, we would have to <em>ensure</em>, that the gap between the buckets itself represent the maximal gap in the input array. How do we go about doing that?</p>\n<p>We could do that just by setting the buckets to be smaller than <script type="math/tex; mode=display">t = (max - min)/(n-1)</script> (as described above). Since the gaps (between elements) within the same bucket would only be <script type="math/tex; mode=display">\\leq t</script>, we could deduce that the maximal gap would <em>indeed</em> occur <strong>only between two adjacent buckets</strong>.</p>\n<p>Hence by setting bucket size <script type="math/tex; mode=display">b</script> to be <script type="math/tex; mode=display">1 < b \\leq (max - min)/(n-1)</script>, we can ensure that at least one of the gaps between adjacent buckets would serve as the <strong>maximal gap.</strong></p>\n<p><strong>Clarifications</strong></p>\n<p>A few clarifications are in order:</p>\n<ul>\n<li>\n<p><strong>Would the buckets be of uniform size?</strong>\nYes. Each of them would be of the same size <script type="math/tex; mode=display">b</script>.</p>\n</li>\n<li>\n<p><strong>But, then wouldn\'t the gap between them be uniform/constant as well?</strong>\nYes it would be. The gap between them would be <script type="math/tex; mode=display">1</script> integer unit wide. That means a two adjacent buckets of size <script type="math/tex; mode=display">3</script> could hold integers with values, say, <script type="math/tex; mode=display">3 - 6</script> and <script type="math/tex; mode=display">7 - 9</script>. We avoid overlapping buckets.</p>\n</li>\n<li>\n<p><strong>Then what are you talking about when you say the gap between two adjacent buckets could be the maximal gap?</strong>\nWhen we are talking about the size of a bucket, we are talking about its holding capacity. That is the range of values the bucket can represent (or <em>hold</em>). However the actual extent of the bucket are determined by the values of the maximum and minimum element a bucket holds. For example a bucket of size <script type="math/tex; mode=display">5</script> could have a capacity to hold values between <script type="math/tex; mode=display">6 - 10</script>. However, if it only holds the elements <script type="math/tex; mode=display">7, 8</script> and <script type="math/tex; mode=display">9</script>, then its actual extent is only <script type="math/tex; mode=display">(9 - 7) + 1 = 3</script> which is not the same as the capacity of the bucket.</p>\n</li>\n<li>\n<p><strong>Then how do you compare adjacent buckets?</strong>\nWe do that by comparing their extents. Thus we compare the minimum element of the next bucket to the maximum element of the current bucket. For example: if we have two buckets of size <script type="math/tex; mode=display">5</script> each, holding elements <script type="math/tex; mode=display">[1, 2, 3]</script> and <script type="math/tex; mode=display">[9, 10]</script> respectively, then the gap between the buckets would essentially refer to the value <script type="math/tex; mode=display">9 - 3 = 6</script> (which is larger than the size of either bucket).</p>\n</li>\n<li>\n<p><strong>But then aren\'t we comparing elements again?!</strong>\nWe are, yes! But only compare about twice the elements as the number of buckets (i.e. the minimum and maximum elements of each bucket). If you followed the above, you would realize that this amount is certainly less than the actual number of elements in the array, given a suitable bucket size was chosen.</p>\n</li>\n</ul>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>We choose a bucket size <script type="math/tex; mode=display">b</script> such that <script type="math/tex; mode=display">1 < b \\leq (max - min)/(n-1)</script>. Let\'s just choose <script type="math/tex; mode=display">b = \\lfloor (max - min)/(n-1) \\rfloor</script>.</p>\n</li>\n<li>\n<p>Thus all the <script type="math/tex; mode=display">n</script> elements would be divided among <script type="math/tex; mode=display">k = \\lceil (max - min)/b \\rceil</script> buckets.</p>\n</li>\n<li>\n<p>Hence the <script type="math/tex; mode=display">i^{th}</script> bucket would hold the range of values: <script type="math/tex; mode=display">\\bigg [min + (i-1) * b, \\space min + i*b \\bigg )</script> (<code>1</code>-based indexing).</p>\n</li>\n<li>\n<p>It is trivial to calculate the index of the bucket to which a particular element belongs. That is given by <script type="math/tex; mode=display">\\lfloor (num - min)/b \\rfloor</script> (<code>0</code>-based indexing) where <script type="math/tex; mode=display">num</script> is the element in question.</p>\n</li>\n<li>\n<p>Once all <script type="math/tex; mode=display">n</script> elements have been distributed, we compare <script type="math/tex; mode=display">k-1</script> adjacent bucket pairs to find the maximum gap.</p>\n</li>\n</ul>\n<iframe frameborder="0" height="515" name="iV6KTsnr" src="https://leetcode.com/playground/iV6KTsnr/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O(n + b) \\approx O(n)</script>.</p>\n<p>Distributing the elements of the array takes one linear pass (i.e. <script type="math/tex; mode=display">O(n)</script> complexity). Finding the maximum gap among the buckets takes a linear pass over the bucket storage (i.e. <script type="math/tex; mode=display">O(b)</script> complexity). Hence overall process takes linear runtime.</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(2*b) \\approx O(b)</script> extra space.</p>\n<p>Each bucket stores a maximum and a minimum element. Hence extra space linear to the number of buckets is required.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by <a href="https://leetcode.com/babhishek21">@babhishek21</a>. Shout-out to <a href="https://leetcode.com/zkfairytale/">@zkfairytale</a>, <a href="https://leetcode.com/teddyyyy/">@teddyyyy</a> and <a href="https://leetcode.com/lhearen/">@lhearen</a>!</p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '165',
    name: 'Compare Version Numbers',
    acceptance: '20.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Compare two version numbers <i>version1</i> and <i>version2</i>.<br>\nIf <i>version1</i> &gt; <i>version2</i> return 1, if <i>version1</i> &lt; <i>version2</i> return -1, otherwise return 0.</p>\n\n<p>You may assume that the version strings are non-empty and contain only digits and the <code>.</code> character.<br>\nThe <code>.</code> character does not represent a decimal point and is used to separate number sequences.<br>\nFor instance, <code>2.5</code> is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.</p>\n\n<p>Here is an example of version numbers ordering:</p>\n<pre>0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37</pre>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft', 'Apple'],
  },
  {
    id: '166',
    name: 'Fraction to Recurring Decimal',
    acceptance: '17.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>\n\n<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>\n<p>\nFor example,\n</p><ul>\n<li>Given numerator = 1, denominator = 2, return "0.5".</li>\n<li>Given numerator = 2, denominator = 1, return "2".</li>\n<li>Given numerator = 2, denominator = 3, return "0.(6)".</li>\n</ul>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/Shangrila">@Shangrila</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#hints">Hints</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-long-division-accepted">Approach #1 (Long Division) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This is a straight forward coding problem but with a fair amount of details to get right.</p>\n<h2 id="hints">Hints</h2>\n<ol>\n<li>No scary math, just apply elementary math knowledge. Still remember how to perform a <i>long division</i>?</li>\n<li>Try a long division on <script type="math/tex; mode=display">\\frac{4}{9}</script>, the repeating part is obvious. Now try <script type="math/tex; mode=display">\\frac{4}{333}</script>. Do you see a pattern?</li>\n<li>Be wary of edge cases! List out as many test cases as you can think of and test your code thoroughly.</li>\n</ol>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-long-division-accepted">Approach #1 (Long Division) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>The key insight here is to notice that once the remainder starts repeating, so does the divided result.</p>\n<p>\n<script type="math/tex; mode=display">\\begin{array}{rll}\n    0.16 \\\\[-3pt]\n   6 \\enclose{longdiv}{1.00}\\kern-.2ex \\\\[-3pt]\n      \\underline{0\\phantom{.00}} \\\\[-3pt]\n      1\\phantom{.}0\\phantom{0} && \\hbox{$\\Leftarrow remainder=1$, mark 1 as seen at $position=0$.} \\\\[-3pt]\n      \\underline{\\phantom{0}6\\phantom{0}} \\\\[-3pt]\n      \\phantom{0}40 && \\hbox{$\\Leftarrow remainder=4$, mark 4 as seen at $position=1$.} \\\\[-3pt]\n      \\underline{\\phantom{0}36} \\\\[-3pt]\n      \\phantom{00}4 && \\hbox{$\\Leftarrow remainder=4$ was seen before at $position=1$, so the fractional part which is 16 starts repeating at $position=1$ $\\Rightarrow$ 1(6).}\n\\end{array}</script>\n</p>\n<p><br>\n<strong>Algorithm</strong></p>\n<p>You will need a hash table that maps from the remainder to its position of the fractional part. Once you found a repeating remainder, you may enclose the reoccurring fractional part with parentheses by consulting the position from the table.</p>\n<p>The remainder could be zero while doing the division. That means there is no repeating fractional part and you should stop right away.</p>\n<p>Just like the question <a href="https://leetcode.com/problems/divide-two-integers/">Divide Two Integers</a>, be wary of edge cases such as negative fractions and nasty extreme case such as <script type="math/tex; mode=display">\\frac{-2147483648}{-1}</script>.</p>\n<p>Here are some good test cases:</p>\n<table>\n<thead>\n<tr>\n<th>Test case</th>\n<th>Explanation</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n<script type="math/tex; mode=display">\\frac{0}{1}</script>\n</td>\n<td>Numerator is zero.</td>\n</tr>\n<tr>\n<td>\n<script type="math/tex; mode=display">\\frac{1}{0}</script>\n</td>\n<td>Divisor is 0, should handle it by throwing an exception but here we ignore for simplicity sake.</td>\n</tr>\n<tr>\n<td>\n<script type="math/tex; mode=display">\\frac{20}{4}</script>\n</td>\n<td>Answer is a whole integer, should not contain the fractional part.</td>\n</tr>\n<tr>\n<td>\n<script type="math/tex; mode=display">\\frac{1}{2}</script>\n</td>\n<td>Answer is 0.5, no recurring decimal.</td>\n</tr>\n<tr>\n<td>\n<script type="math/tex; mode=display">\\frac{-1}{4}</script> or <script type="math/tex; mode=display">\\frac{1}{-4}</script>\n</td>\n<td>One of the numerator or denominator is negative, fraction is negative.</td>\n</tr>\n<tr>\n<td>\n<script type="math/tex; mode=display">\\frac{-1}{-4}</script>\n</td>\n<td>Both numerator and denominator are negative, should result in positive fraction.</td>\n</tr>\n<tr>\n<td>\n<script type="math/tex; mode=display">\\frac{-2147483648}{-1}</script>\n</td>\n<td>Beware of overflow if you cast to positive.</td>\n</tr>\n</tbody>\n</table>\n<p><br>\n<iframe frameborder="0" height="515" name="DFzvrb7z" src="https://leetcode.com/playground/DFzvrb7z/shared" width="100%"></iframe></p>\n</div>\n          ',
    tags: ['Google', 'IXL'],
  },
  {
    id: '167',
    name: 'Two Sum II - Input array is sorted',
    acceptance: '47.2%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given an array of integers that is already <b><i>sorted in ascending order</i></b>, find two numbers such that they add up to a specific target number.</p>\n\n<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>\n\n<p>You may assume that each input would have <i>exactly</i> one solution and you may not use the <i>same</i> element twice.</p>\n\n<p style="font-family:monospace">\n<b>Input:</b> numbers={2, 7, 11, 15}, target=9<br>\n<b>Output:</b> index1=1, index2=2\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-two-pointers-accepted">Approach #1 (Two Pointers) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-two-pointers-accepted">Approach #1 (Two Pointers) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can apply <a href="https://leetcode.com/articles/two-sum/">Two Sum\'s solutions</a> directly to get <script type="math/tex; mode=display">O(n^2)</script> time, <script type="math/tex; mode=display">O(1)</script> space using brute force and <script type="math/tex; mode=display">O(n)</script> time, <script type="math/tex; mode=display">O(n)</script> space using hash table. However, both existing solutions do not make use of the property where the input array is sorted. We can do better.</p>\n<p>We use two indexes, initially pointing to the first and last element respectively. Compare the sum of these two elements with target. If the sum is equal to target, we found the exactly only solution. If it is less than target, we increase the smaller index by one. If it is greater than target, we decrease the larger index by one. Move the indexes and repeat the comparison until the solution is found.</p>\n<p>Let <script type="math/tex; mode=display">[... , a, b, c, ... , d, e, f, ...]</script> be the input array that is sorted in ascending order and the element <script type="math/tex; mode=display">b</script>, <script type="math/tex; mode=display">e</script> be the exactly only solution. Because we are moving the smaller index from left to right, and the larger index from right to left, at some point one of the indexes must reach either one of <script type="math/tex; mode=display">b</script> or <script type="math/tex; mode=display">e</script>. Without loss of generality, suppose the smaller index reaches <script type="math/tex; mode=display">b</script> first. At this time, the sum of these two elements must be greater than target. Based on our algorithm, we will keep moving the larger index to its left until we reach the solution.</p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>\n<span class="k">public</span><span class="o">:</span>\n    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">numbers</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>\n        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>\n        <span class="k">while</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>\n            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">[</span><span class="n">low</span><span class="p">]</span> <span class="o">+</span> <span class="n">numbers</span><span class="p">[</span><span class="n">high</span><span class="p">];</span>\n            <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>\n                <span class="k">return</span> <span class="p">{</span><span class="n">low</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">high</span> <span class="o">+</span> <span class="mi">1</span><span class="p">};</span>\n            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span>\n                <span class="o">++</span><span class="n">low</span><span class="p">;</span>\n            <span class="k">else</span>\n                <span class="o">--</span><span class="n">high</span><span class="p">;</span>\n        <span class="p">}</span>\n        <span class="k">return</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>\n    <span class="p">}</span>\n<span class="p">};</span>\n</pre></div>\n<p>Do we need to consider if <script type="math/tex; mode=display">numbers[low] + numbers[high]</script> overflows? The answer is no. Even if adding two elements in the array may overflow, because there is exactly one solution, we will reach the solution first.</p>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nEach of the <script type="math/tex; mode=display">n</script> elements is visited at most once, thus the time complexity is <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.\nWe only use two indexes, the space complexity is <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<p>Analysis written by @maonag6.</p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '168',
    name: 'Excel Sheet Column Title',
    acceptance: '26.8%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>\n\n<p>For example:</p>\n<pre>    1 -&gt; A\n    2 -&gt; B\n    3 -&gt; C\n    ...\n    26 -&gt; Z\n    27 -&gt; AA\n    28 -&gt; AB </pre>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/ifanchu">@ifanchu</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Zenefits'],
  },
  {
    id: '169',
    name: 'Majority Element',
    acceptance: '47.4%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given an array of size <i>n</i>, find the majority element. The majority element is the element that appears <b>more than</b> <code>⌊ n/2 ⌋</code> times.</p>\n\n<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-hashmap-accepted">Approach #2 HashMap [Accepted]</a></li>\n<li><a href="#approach-3-sorting-accepted">Approach #3 Sorting [Accepted]</a></li>\n<li><a href="#approach-4-randomization-accepted">Approach #4 Randomization [Accepted?]</a></li>\n<li><a href="#approach-5-divide-and-conquer-accepted">Approach #5 Divide and Conquer [Accepted]</a></li>\n<li><a href="#approach-6-boyer-moore-voting-algorithm-accepted">Approach #6 Boyer-Moore Voting Algorithm [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can exhaust the search space in quadratic time by checking whether each\nelement is the majority element.</p>\n<p><strong>Algorithm</strong></p>\n<p>The brute force algorithm iterates over the array, and then iterates again\nfor each number to count its occurrences. As soon as a number is found to\nhave appeared more than any other can possibly have appeared, return it.</p>\n<iframe frameborder="0" height="412" name="H2vyWAaF" src="https://leetcode.com/playground/H2vyWAaF/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>\n</p>\n<p>The brute force algorithm contains two nested <code>for</code> loops that each run\nfor <script type="math/tex; mode=display">n</script> iterations, adding up to quadratic time complexity.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n<p>The brute force solution does not allocate additional space proportional\nto the input size.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-hashmap-accepted">Approach #2 HashMap [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We know that the majority element occurs more than <script type="math/tex; mode=display">\\lfloor \\frac{n}{2} \\rfloor</script>\ntimes, and a <code>HashMap</code> allows us to count element occurrences efficiently.</p>\n<p><strong>Algorithm</strong></p>\n<p>We can use a <code>HashMap</code> that maps elements to counts in order to count\noccurrences in linear time by looping over <code>nums</code>. Then, we simply return the\nkey with maximum value.</p>\n<iframe frameborder="0" height="500" name="4nq5cRU7" src="https://leetcode.com/playground/4nq5cRU7/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>We iterate over <code>nums</code> once and make a constant time <code>HashMap</code> insertion\non each iteration. Therefore, the algorithm runs in <script type="math/tex; mode=display">O(n)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>At most, the <code>HashMap</code> can contain <script type="math/tex; mode=display">n - \\lfloor \\frac{n}{2} \\rfloor</script>\nassociations, so it occupies <script type="math/tex; mode=display">O(n)</script> space. This is because an arbitrary\narray of length <script type="math/tex; mode=display">n</script> can contain <script type="math/tex; mode=display">n</script> distinct values, but <code>nums</code> is\nguaranteed to contain a majority element, which will occupy (at minimum)\n<script type="math/tex; mode=display">\\lfloor \\frac{n}{2} \\rfloor + 1</script> array indices. Therefore,\n<script type="math/tex; mode=display">n - (\\lfloor \\frac{n}{2} \\rfloor + 1)</script> indices can be occupied by\ndistinct, non-majority elements (plus 1 for the majority element itself),\nleaving us with (at most) <script type="math/tex; mode=display">n - \\lfloor \\frac{n}{2} \\rfloor</script> distinct\nelements.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-sorting-accepted">Approach #3 Sorting [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If the elements are sorted in monotonically increasing (or decreasing) order,\nthe majority element can be found at index\n<script type="math/tex; mode=display">\\lfloor \\frac{n}{2} \\rfloor</script> (and <script type="math/tex; mode=display">\\lfloor \\frac{n}{2} \\rfloor + 1</script>,\nincidentally, if <script type="math/tex; mode=display">n</script> is even).</p>\n<p><strong>Algorithm</strong></p>\n<p>For this algorithm, we simply do exactly what is described: sort <code>nums</code>, and\nreturn the element in question. To see why this will always return the\nmajority element (given that the array has one), consider the figure below\n(the top example is for an odd-length array and the bottom is for an\neven-length array):</p>\n<p align="center"><img alt="Sorting middle index overlap" src="https://leetcode.com/articles/Figures/169/sorting.png"></p>\n<p>For each example, the line below the array denotes the range of indices that\nare covered by a majority element that happens to be the array minimum. As\nyou might expect, the line above the array is similar, but for the case where\nthe majority element is also the array maximum. In all other cases, this line\nwill lie somewhere between these two, but notice that even in these two most\nextreme cases, they overlap at index <script type="math/tex; mode=display">\\lfloor \\frac{n}{2} \\rfloor</script> for both\neven- and odd-length arrays. Therefore, no matter what value the majority\nelement has in relation to the rest of the array, returning the value at\n<script type="math/tex; mode=display">\\lfloor \\frac{n}{2} \\rfloor</script> will never be wrong.</p>\n<iframe frameborder="0" height="157" name="X9WGS7YM" src="https://leetcode.com/playground/X9WGS7YM/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nlgn)</script>\n</p>\n<p>Sorting the array costs <script type="math/tex; mode=display">O(nlgn)</script> time in Python and Java, so it\ndominates the overall runtime.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script> or (<script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>We sorted <code>nums</code> in place here - if that is not allowed, then we must\nspend linear additional space on a copy of <code>nums</code> and sort the copy\ninstead.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-randomization-accepted">Approach #4 Randomization [Accepted?]</h4>\n<p><strong>Intuition</strong></p>\n<p>Because more than <script type="math/tex; mode=display">\\lfloor \\frac{n}{2} \\rfloor</script> array indices are occupied\nby the majority element, a random array index is likely to contain the\nmajority element.</p>\n<p><strong>Algorithm</strong></p>\n<p>Because a given index is likely to have the majority element, we can just\nselect a random index, check whether its value is the majority element,\nreturn if it is, and repeat if it is not. The algorithm is verifiably correct\nbecause we ensure that the randomly chosen value is the majority element\nbefore ever returning.</p>\n<iframe frameborder="0" height="500" name="w2hsUnvB" src="https://leetcode.com/playground/w2hsUnvB/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(\\infty)</script>\n</p>\n<p>It is technically possible for this algorithm to run indefinitely (if we\nnever manage to randomly select the majority element), so the worst\npossible runtime is unbounded. However, the expected runtime is far\nbetter - linear, in fact. For ease of analysis, convince yourself that\nbecause the majority element is guaranteed to occupy <em>more</em> than half of\nthe array, the expected number of iterations will be less than it would\nbe if the element we sought occupied exactly <em>half</em> of the array.\nTherefore, we can calculate the expected number of iterations for this\nmodified version of the problem and assert that our version is easier.</p>\n<p>\n<script type="math/tex; mode=display">\n\\begin{aligned}\n    EV(iters_{prob}) &\\leq EV(iters_{mod}) \\\\\n                     &= \\lim_{n\\to\\infty} \\sum_{i=1}^{n} i \\cdot \\frac{1}{2^i} \\\\\n                     &= 2\n\\end{aligned}\n</script>\n</p>\n<p>Because the series converges, the expected number of iterations for the\nmodified problem is constant. Based on an expected-constant number of\niterations in which we perform linear work, the expected runtime is\nlinear for the modifed problem. Therefore, the expected runtime for our\nproblem is also linear, as the runtime of the modifed problem serves as\nan upper bound for it.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n<p>Much like the brute force solution, the randomized approach runs with\nconstant additional space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-divide-and-conquer-accepted">Approach #5 Divide and Conquer [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we know the majority element in the left and right halves of an array, we\ncan determine which is the global majority element in linear time.</p>\n<p><strong>Algorithm</strong></p>\n<p>Here, we apply a classical divide &amp; conquer approach that recurses on the\nleft and right halves of an array until an answer can be trivially achieved\nfor a length-1 array. Note that because actually passing copies of subarrays\ncosts time and space, we instead pass <code>lo</code> and <code>hi</code> indices that describe the\nrelevant slice of the overall array. In this case, the majority element for a\nlength-1 slice is trivially its only element, so the recursion stops there.\nIf the current slice is longer than length-1, we must combine the answers for\nthe slice\'s left and right halves. If they agree on the majority element,\nthen the majority element for the overall slice is obviously the same<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>. If\nthey disagree, only one of them can be "right", so we need to count the\noccurrences of the left and right majority elements to determine which\nsubslice\'s answer is globally correct. The overall answer for the array is\nthus the majority element between indices 0 and <script type="math/tex; mode=display">n</script>.</p>\n<iframe frameborder="0" height="500" name="4zVEbCKq" src="https://leetcode.com/playground/4zVEbCKq/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nlgn)</script>\n</p>\n<p>Each recursive call to <code>majority_element_rec</code> performs two recursive\ncalls on subslices of size <script type="math/tex; mode=display">\\frac{n}{2}</script> and two linear scans of length\n<script type="math/tex; mode=display">n</script>. Therefore, the time complexity of the divide &amp; conquer approach\ncan be represented by the following recurrence relation:</p>\n<p>\n<script type="math/tex; mode=display">\n    T(n) = 2T(\\frac{n}{2}) + 2n\n</script>\n</p>\n<p>By the <a href="https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)">master theorem</a>,\nthe recurrence satisfies case 2, so the complexity can be analyzed as such:</p>\n<p>\n<script type="math/tex; mode=display">\n\\begin{aligned}\n    T(n) &= \\Theta(n^{log_{b}a}\\log n) \\\\\n         &= \\Theta(n^{log_{2}2}\\log n) \\\\\n         &= \\Theta(n \\log n) \\\\\n\\end{aligned}\n</script>\n</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(lgn)</script>\n</p>\n<p>Although the divide &amp; conquer does not explicitly allocate any additional\nmemory, it uses a non-constant amount of additional memory in stack\nframes due to recursion. Because the algorithm "cuts" the array in half\nat each level of recursion, it follows that there can only be <script type="math/tex; mode=display">O(lgn)</script>\n"cuts" before the base case of 1 is reached. It follows from this fact\nthat the resulting recursion tree is balanced, and therefore all paths\nfrom the root to a leaf are of length <script type="math/tex; mode=display">O(lgn)</script>. Because the recursion\ntree is traversed in a depth-first manner, the space complexity is\ntherefore equivalent to the length of the longest path, which is, of\ncourse, <script type="math/tex; mode=display">O(lgn)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-6-boyer-moore-voting-algorithm-accepted">Approach #6 Boyer-Moore Voting Algorithm [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we had some way of counting instances of the majority element as <script type="math/tex; mode=display">+1</script>\nand instances of any other element as <script type="math/tex; mode=display">-1</script>, summing them would make it\nobvious that the majority element is indeed the majority element.</p>\n<p><strong>Algorithm</strong></p>\n<p>Essentially, what Boyer-Moore does is look for a suffix <script type="math/tex; mode=display">suf</script> of <code>nums</code>\nwhere <script type="math/tex; mode=display">suf[0]</script> is the majority element in that suffix. To do this, we\nmaintain a count, which is incremented whenever we see an instance of our\ncurrent candidate for majority element and decremented whenever we see\nanything else. Whenever <code>count</code> equals 0, we effectively forget about\neverything in <code>nums</code> up to the current index and consider the current number\nas the candidate for majority element. It is not immediately obvious why we can\nget away with forgetting prefixes of <code>nums</code> - consider the following\nexamples (pipes are inserted to separate runs of nonzero <code>count</code>).</p>\n<p>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</p>\n<p>Here, the <code>7</code> at index 0 is selected to be the first candidate for majority\nelement. <code>count</code> will eventually reach 0 after index 5 is processed, so the\n<code>5</code> at index 6 will be the next candidate. In this case, <code>7</code> is the true\nmajority element, so by disregarding this prefix, we are ignoring an equal\nnumber of majority and minority elements - therefore, <code>7</code> will still be the\nmajority element in the suffix formed by throwing away the first prefix.</p>\n<p>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | <strong>5, 5, 5, 5</strong>]</p>\n<p>Now, the majority element is <code>5</code> (we changed the last run of the array from\n<code>7</code>s to <code>5</code>s), but our first candidate is still <code>7</code>. In this case, our\ncandidate is not the true majority element, but we still cannot discard more\nmajority elements than minority elements (this would imply that <code>count</code> could\nreach -1 before we reassign <code>candidate</code>, which is obviously false).</p>\n<p>Therefore, given that it is impossible (in both cases) to discard more\nmajority elements than minority elements, we are safe in discarding the\nprefix and attempting to recursively solve the majority element problem for the\nsuffix. Eventually, a suffix will be found for which <code>count</code> does not hit\n<code>0</code>, and the majority element of that suffix will necessarily be the same as\nthe majority element of the overall array.</p>\n<iframe frameborder="0" height="310" name="yMbL4Yog" src="https://leetcode.com/playground/yMbL4Yog/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>Boyer-Moore performs constant work exactly <script type="math/tex; mode=display">n</script> times, so the algorithm\nruns in linear time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n<p>Boyer-Moore allocates only constant additional memory.</p>\n</li>\n</ul>\n<hr>\n<p><strong>Footnotes</strong></p>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/emptyset">@emptyset</a></p>\n<p>Approaches and time complexities itemized by <a href="" title="https://oj.leetcode.com/discuss/user/ts">@ts</a> and <a href="" title="https://oj.leetcode.com/discuss/user/1337c0d3r">@1337c0d3r</a></p>\n<div class="footnote">\n<hr>\n<ol>\n<li id="fn:1">\n<p>This is a constant optimization that could be excluded without hurting our\n  overall runtime.&nbsp;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">↩</a></p>\n</li>\n</ol>\n</div>\n</div>\n          ',
    tags: ['Zenefits', 'Adobe'],
  },
  {
    id: '170',
    name: 'Two Sum III - Data structure design ',
    acceptance: '25.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Design and implement a TwoSum class. It should support the following operations: <code>add</code> and <code>find</code>.</p>\n\n<p>\n<code>add</code> - Add the number to an internal data structure.<br>\n<code>find</code> - Find if there exists any pair of numbers which sum is equal to the value.\n</p>\n\n<p>\nFor example,<br>\n</p><pre>add(1); add(3); add(5);\nfind(4) -&gt; true\nfind(7) -&gt; false\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '171',
    name: 'Excel Sheet Column Number',
    acceptance: '47.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Related to question <a href="https://leetcode.com/problems/excel-sheet-column-title/">Excel Sheet Column Title</a></p>\n<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>\n\n<p>For example:</p>\n<pre>    A -&gt; 1\n    B -&gt; 2\n    C -&gt; 3\n    ...\n    Z -&gt; 26\n    AA -&gt; 27\n    AB -&gt; 28 </pre>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft', 'Uber'],
  },
  {
    id: '172',
    name: 'Factorial Trailing Zeroes',
    acceptance: '36.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given an integer <i>n</i>, return the number of trailing zeroes in <i>n</i>!.</p>\n\n<p><b>Note: </b>Your solution should be in logarithmic time complexity.</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '173',
    name: 'Binary Search Tree Iterator',
    acceptance: '42.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>\n\n<p>Calling <code>next()</code> will return the next smallest number in the BST.</p>\n\n<p><b>Note: </b><code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(<i>h</i>) memory, where <i>h</i> is the height of the tree. </p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Microsoft', 'LinkedIn'],
  },
  {
    id: '174',
    name: 'Dungeon Game',
    acceptance: '23.9%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <style>\ntable.dungeon, .dungeon th, .dungeon td {\n  border:3px solid black;\n}\n\n .dungeon th, .dungeon td {\n    text-align: center;\n    height: 70px;\n    width: 70px;\n}\n</style>\n\n<p>The demons had captured the princess (<b>P</b>) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (<b>K</b>) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. </p>\n<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. </p>\n<p>Some of the rooms are guarded by demons, so the knight loses health (<i>negative</i> integers) upon entering these rooms; \nother rooms are either empty (<i>0\'s</i>) or contain magic orbs that increase the knight\'s health (<i>positive</i> integers).</p>\n<p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. </p>\n\n<br>\n<p><b>Write a function to determine the knight\'s minimum initial health so that he is able to rescue the princess.</b></p>\n<p>For example, given the dungeon below, the initial health of the knight must be at least <b>7</b> if he follows the optimal path <code>RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN</code>.</p>\n\n<table class="dungeon">\n<tbody><tr> \n<td>-2 (K)</td> \n<td>-3</td> \n<td>3</td> \n</tr> \n<tr> \n<td>-5</td> \n<td>-10</td> \n<td>1</td> \n</tr> \n<tr> \n<td>10</td> \n<td>30</td> \n<td>-5 (P)</td> \n</tr> \n</tbody></table>\n<!---2K   -3  3\n-5   -10   1\n10 30   5P-->\n\n<br>\n<p><b>Notes:</b>\n</p><ul>\n<li>The knight\'s health has no upper bound.</li>\n<li>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.  </li>\n</ul>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/stellari">@stellari</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft'],
  },
  {
    id: '175',
    name: 'Combine Two Tables',
    acceptance: '40.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nTable: <code>Person</code></p>\n\n<pre>+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| PersonId    | int     |\n| FirstName   | varchar |\n| LastName    | varchar |\n+-------------+---------+\nPersonId is the primary key column for this table.\n</pre>\n\n<p>\nTable: <code>Address</code></p>\n<pre>+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| AddressId   | int     |\n| PersonId    | int     |\n| City        | varchar |\n| State       | varchar |\n+-------------+---------+\nAddressId is the primary key column for this table.\n</pre>\n\n<br>\n<p>\nWrite a SQL query for a report that provides the following information for \neach person in the Person table, regardless if there is an address for each \nof those people:\n</p>\n\n<pre>FirstName, LastName, City, State\n</pre>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-outer-join-accepted">Approach: Using outer join [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-outer-join-accepted">Approach: Using <code>outer join</code> [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Since the <em>PersonId</em> in table <strong>Address</strong> is the foreign key of table <strong>Person</strong>, we can join this two table to get the address information of a person.</p>\n<p>Considering there might not be an address information for every person, we should use <code>outer join</code> instead of the default <code>inner join</code>.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="n">FirstName</span><span class="p">,</span> <span class="n">LastName</span><span class="p">,</span> <span class="n">City</span><span class="p">,</span> <span class="k">State</span>\n<span class="k">from</span> <span class="n">Person</span> <span class="k">left</span> <span class="k">join</span> <span class="n">Address</span>\n<span class="k">on</span> <span class="n">Person</span><span class="p">.</span><span class="n">PersonId</span> <span class="o">=</span> <span class="n">Address</span><span class="p">.</span><span class="n">PersonId</span>\n<span class="p">;</span>\n</pre></div>\n<blockquote>\n<p>Note: Using <code>where</code> clause to filter the records will fail if there is no address information for a person because it will not display the name information.</p>\n</blockquote>\n</div>\n          ',
    tags: [],
  },
  {
    id: '176',
    name: 'Second Highest Salary',
    acceptance: '21.8%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nWrite a SQL query to get the second highest salary from the <code>Employee</code> table.\n</p>\n\n<pre>+----+--------+\n| Id | Salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n</pre>\n\n<p>For example, given the above Employee table, the query should return <code>200</code> as the second highest salary. If there is no second highest salary, then the query should return <code>null</code>.</p>\n\n<pre>+---------------------+\n| SecondHighestSalary |\n+---------------------+\n| 200                 |\n+---------------------+\n</pre>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-sub-query-and-limit-clause-accepted">Approach: Using sub-query and LIMIT clause [Accepted]</a></li>\n<li><a href="#approach-using-ifnull-and-limit-clause-accepted">Approach: Using IFNULL and LIMIT clause [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-sub-query-and-limit-clause-accepted">Approach: Using sub-query and <code>LIMIT</code> clause [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Sort the distinct salary in descend order and then utilize the <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html"><code>LIMIT</code></a> clause to get the second highest salary.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="k">DISTINCT</span>\n    <span class="n">Salary</span> <span class="k">AS</span> <span class="n">SecondHighestSalary</span>\n<span class="k">FROM</span>\n    <span class="n">Employee</span>\n<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">Salary</span> <span class="k">DESC</span>\n<span class="k">LIMIT</span> <span class="mi">1</span> <span class="k">OFFSET</span> <span class="mi">1</span>\n</pre></div>\n<p>However, this solution will be judged as \'Wrong Answer\' if there is no such second highest salary since there might be only one record in this table. To overcome this issue, we can take this as a temp table.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="p">(</span><span class="k">SELECT</span> <span class="k">DISTINCT</span>\n            <span class="n">Salary</span>\n        <span class="k">FROM</span>\n            <span class="n">Employee</span>\n        <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">Salary</span> <span class="k">DESC</span>\n        <span class="k">LIMIT</span> <span class="mi">1</span> <span class="k">OFFSET</span> <span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">SecondHighestSalary</span>\n<span class="p">;</span>\n</pre></div>\n<h4 id="approach-using-ifnull-and-limit-clause-accepted">Approach: Using <code>IFNULL</code> and <code>LIMIT</code> clause [Accepted]</h4>\n<p>Another way to solve the \'NULL\' problem is to use <code>IFNULL</code> funtion as below.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">IFNULL</span><span class="p">(</span>\n      <span class="p">(</span><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">Salary</span>\n       <span class="k">FROM</span> <span class="n">Employee</span>\n       <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">Salary</span> <span class="k">DESC</span>\n        <span class="k">LIMIT</span> <span class="mi">1</span> <span class="k">OFFSET</span> <span class="mi">1</span><span class="p">),</span>\n    <span class="k">NULL</span><span class="p">)</span> <span class="k">AS</span> <span class="n">SecondHighestSalary</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '177',
    name: 'Nth Highest Salary',
    acceptance: '19.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nWrite a SQL query to get the <i>n</i><sup>th</sup> highest salary from the <code>Employee</code> table.\n</p>\n\n<pre>+----+--------+\n| Id | Salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n</pre>\n\n<p>For example, given the above Employee table, the <i>n</i><sup>th</sup> highest salary where <i>n</i> = 2 is <code>200</code>. If there is no <i>n</i><sup>th</sup> highest salary, then the query should return <code>null</code>.</p>\n\n<pre>+------------------------+\n| getNthHighestSalary(2) |\n+------------------------+\n| 200                    |\n+------------------------+\n</pre>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '178',
    name: 'Rank Scores',
    acceptance: '27.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nWrite a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no "holes" between ranks.\n</p>\n\n<pre>+----+-------+\n| Id | Score |\n+----+-------+\n| 1  | 3.50  |\n| 2  | 3.65  |\n| 3  | 4.00  |\n| 4  | 3.85  |\n| 5  | 4.00  |\n| 6  | 3.65  |\n+----+-------+\n</pre>\n\n<p>For example, given the above <code>Scores</code> table, your query should generate the following report (order by highest score):</p>\n\n<pre>+-------+------+\n| Score | Rank |\n+-------+------+\n| 4.00  | 1    |\n| 4.00  | 1    |\n| 3.85  | 2    |\n|&nbsp;3.65  | 3    |\n| 3.65  | 3    |\n| 3.50  | 4    |\n+-------+------+\n</pre>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '179',
    name: 'Largest Number',
    acceptance: '23.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a list of non negative integers, arrange them such that they form the largest number.</p>\n\n<p>For example, given <code>[3, 30, 34, 5, 9]</code>, the largest formed number is <code>9534330</code>.</p>\n\n<p>Note: The result may be very large, so you need to return a string instead of an integer.</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-sorting-via-custom-comparator-accepted">Approach #1 Sorting via Custom Comparator [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-sorting-via-custom-comparator-accepted">Approach #1 Sorting via Custom Comparator [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>To construct the largest number, we want to ensure that the most significant\ndigits are occupied by the largest digits.</p>\n<p><strong>Algorithm</strong></p>\n<p>First, we convert each integer to a string. Then, we sort the array of strings.</p>\n<p>While it might be tempting to simply sort the numbers in descending order,\nthis causes problems for sets of numbers with the same leading digit. For\nexample, sorting the problem example in descending order would produce the\nnumber <script type="math/tex; mode=display">9534303</script>, while the correct answer can be achieved by transposing\nthe <script type="math/tex; mode=display">3</script> and the <script type="math/tex; mode=display">30</script>. Therefore, for each pairwise comparison during the\nsort, we compare the numbers achieved by concatenating the pair in both\norders. We can prove that this sorts into the proper order as follows: </p>\n<p>Assume that (without loss of generality), for some pair of integers <script type="math/tex; mode=display">a</script> and\n<script type="math/tex; mode=display">b</script>, our comparator dictates that <script type="math/tex; mode=display">a</script> should precede <script type="math/tex; mode=display">b</script> in sorted\norder. This means that <script type="math/tex; mode=display">a\\frown b > b\\frown a</script> (where <script type="math/tex; mode=display">\\frown</script> represents\nconcatenation). For the sort to produce an incorrect ordering, there must be\nsome <script type="math/tex; mode=display">c</script> for which <script type="math/tex; mode=display">b</script> precedes <script type="math/tex; mode=display">c</script> and <script type="math/tex; mode=display">c</script> precedes <script type="math/tex; mode=display">a</script>. This is a\ncontradiction because <script type="math/tex; mode=display">a\\frown b > b\\frown a</script> and <script type="math/tex; mode=display">b\\frown c > c\\frown b</script>\nimplies <script type="math/tex; mode=display">a\\frown c > c\\frown a</script>. In other words, our custom comparator\npreserves transitivity, so the sort is correct.</p>\n<p>Once the array is sorted, the most "signficant" number will be at the front.\nThere is a minor edge case that comes up when the array consists of only\nzeroes, so if the most significant number is <script type="math/tex; mode=display">0</script>, we can simply return\n<script type="math/tex; mode=display">0</script>. Otherwise, we build a string out of the sorted array and return it.</p>\n<iframe frameborder="0" height="500" name="KfR2DTj4" src="https://leetcode.com/playground/KfR2DTj4/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nlgn)</script>\n</p>\n<p>Although we are doing extra work in our comparator, it is only by a\nconstant factor. Therefore, the overall runtime is dominated by the\ncomplexity of <code>sort</code>, which is <script type="math/tex; mode=display">O(nlgn)</script> in Python and Java.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>Here, we allocate <script type="math/tex; mode=display">O(n)</script> additional space to store the copy of <code>nums</code>.\nAlthough we could do that work in place (if we decide that it is okay to\nmodify <code>nums</code>), we must allocate <script type="math/tex; mode=display">O(n)</script> space for the final return\nstring. Therefore, the overall memory footprint is linear in the length\nof <code>nums</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis and solutions written by: <a href="https://leetcode.com/emptyset">@emptyset</a></p>\n</div>\n          ',
    tags: ['Works Applications'],
  },
  {
    id: '180',
    name: 'Consecutive Numbers',
    acceptance: '25.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nWrite a SQL query to find all numbers that appear at least three times consecutively.</p>\n\n<pre>+----+-----+\n| Id | Num |\n+----+-----+\n| 1  |  1  |\n| 2  |  1  |\n| 3  |  1  |\n| 4  |  2  |\n| 5  |  1  |\n| 6  |  2  |\n| 7  |  2  |\n+----+-----+\n</pre>\n\n<p>For example, given the above <code>Logs</code> table, <code>1</code> is the only number that appears consecutively for at least three times.</p>\n\n<pre>+-----------------+\n| ConsecutiveNums |\n+-----------------+\n| 1               |\n+-----------------+\n</pre>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-distinct-and-where-clause-accepted">Approach: Using DISTINCT and WHERE clause [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-distinct-and-where-clause-accepted">Approach: Using <code>DISTINCT</code> and <code>WHERE</code> clause [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Consecutive appearing means the Id of the Num are next to each others. Since this problem asks for numbers appearing at least three times consecutively, we can use 3 aliases for this table <strong>Logs</strong>, and then check whether 3 consecutive numbers are all the same.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="o">*</span>\n<span class="k">FROM</span>\n    <span class="n">Logs</span> <span class="n">l1</span><span class="p">,</span>\n    <span class="n">Logs</span> <span class="n">l2</span><span class="p">,</span>\n    <span class="n">Logs</span> <span class="n">l3</span>\n<span class="k">WHERE</span>\n    <span class="n">l1</span><span class="p">.</span><span class="n">Id</span> <span class="o">=</span> <span class="n">l2</span><span class="p">.</span><span class="n">Id</span> <span class="o">-</span> <span class="mi">1</span>\n    <span class="k">AND</span> <span class="n">l2</span><span class="p">.</span><span class="n">Id</span> <span class="o">=</span> <span class="n">l3</span><span class="p">.</span><span class="n">Id</span> <span class="o">-</span> <span class="mi">1</span>\n    <span class="k">AND</span> <span class="n">l1</span><span class="p">.</span><span class="n">Num</span> <span class="o">=</span> <span class="n">l2</span><span class="p">.</span><span class="n">Num</span>\n    <span class="k">AND</span> <span class="n">l2</span><span class="p">.</span><span class="n">Num</span> <span class="o">=</span> <span class="n">l3</span><span class="p">.</span><span class="n">Num</span>\n<span class="p">;</span>\n</pre></div>\n<table>\n<thead>\n<tr>\n<th>Id</th>\n<th>Num</th>\n<th>Id</th>\n<th>Num</th>\n<th>Id</th>\n<th>Num</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>2</td>\n<td>1</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>&gt;Note: The first two columns are from l1, then the next two are from l2, and the last two are from l3.</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>Then we can select any <em>Num</em> column from the above table to get the target data. However, we need to add a keyword <code>DISTINCT</code> because it will display a duplicated number if one number appears more than 3 times consecutively.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="k">DISTINCT</span>\n    <span class="n">l1</span><span class="p">.</span><span class="n">Num</span> <span class="k">AS</span> <span class="n">ConsecutiveNums</span>\n<span class="k">FROM</span>\n    <span class="n">Logs</span> <span class="n">l1</span><span class="p">,</span>\n    <span class="n">Logs</span> <span class="n">l2</span><span class="p">,</span>\n    <span class="n">Logs</span> <span class="n">l3</span>\n<span class="k">WHERE</span>\n    <span class="n">l1</span><span class="p">.</span><span class="n">Id</span> <span class="o">=</span> <span class="n">l2</span><span class="p">.</span><span class="n">Id</span> <span class="o">-</span> <span class="mi">1</span>\n    <span class="k">AND</span> <span class="n">l2</span><span class="p">.</span><span class="n">Id</span> <span class="o">=</span> <span class="n">l3</span><span class="p">.</span><span class="n">Id</span> <span class="o">-</span> <span class="mi">1</span>\n    <span class="k">AND</span> <span class="n">l1</span><span class="p">.</span><span class="n">Num</span> <span class="o">=</span> <span class="n">l2</span><span class="p">.</span><span class="n">Num</span>\n    <span class="k">AND</span> <span class="n">l2</span><span class="p">.</span><span class="n">Num</span> <span class="o">=</span> <span class="n">l3</span><span class="p">.</span><span class="n">Num</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '181',
    name: 'Employees Earning More Than Their Managers',
    acceptance: '36.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nThe <code>Employee</code> table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.</p>\n\n<pre>+----+-------+--------+-----------+\n| Id | Name  | Salary | ManagerId |\n+----+-------+--------+-----------+\n| 1  | Joe   | 70000  | 3         |\n| 2  | Henry | 80000  | 4         |\n| 3  | Sam   | 60000  | NULL      |\n| 4  | Max   | 90000  | NULL      |\n+----+-------+--------+-----------+\n</pre>\n\n<p>Given the <code>Employee</code> table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.</p>\n\n<pre>+----------+\n| Employee |\n+----------+\n| Joe      |\n+----------+\n</pre>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-i-using-where-clause-accepted">Approach I: Using WHERE clause [Accepted]</a></li>\n<li><a href="#approach-i-using-join-clause-accepted">Approach I: Using JOIN clause [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-i-using-where-clause-accepted">Approach I: Using <code>WHERE</code> clause [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>As this table has the employee\'s manager information, we probably need to select information from it twice.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="o">*</span>\n<span class="k">FROM</span> <span class="n">Employee</span> <span class="k">AS</span> <span class="n">a</span><span class="p">,</span> <span class="n">Employee</span> <span class="k">AS</span> <span class="n">b</span>\n<span class="p">;</span>\n</pre></div>\n<blockquote>\n<p>Note: The keyword \'AS\' is optional.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Id</th>\n<th>Name</th>\n<th>Salary</th>\n<th>ManagerId</th>\n<th>Id</th>\n<th>Name</th>\n<th>Salary</th>\n<th>ManagerId</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Joe</td>\n<td>70000</td>\n<td>3</td>\n<td>1</td>\n<td>Joe</td>\n<td>70000</td>\n<td>3</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Henry</td>\n<td>80000</td>\n<td>4</td>\n<td>1</td>\n<td>Joe</td>\n<td>70000</td>\n<td>3</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Sam</td>\n<td>60000</td>\n<td></td>\n<td>1</td>\n<td>Joe</td>\n<td>70000</td>\n<td>3</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Max</td>\n<td>90000</td>\n<td></td>\n<td>1</td>\n<td>Joe</td>\n<td>70000</td>\n<td>3</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Joe</td>\n<td>70000</td>\n<td>3</td>\n<td>2</td>\n<td>Henry</td>\n<td>80000</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Henry</td>\n<td>80000</td>\n<td>4</td>\n<td>2</td>\n<td>Henry</td>\n<td>80000</td>\n<td>4</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Sam</td>\n<td>60000</td>\n<td></td>\n<td>2</td>\n<td>Henry</td>\n<td>80000</td>\n<td>4</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Max</td>\n<td>90000</td>\n<td></td>\n<td>2</td>\n<td>Henry</td>\n<td>80000</td>\n<td>4</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Joe</td>\n<td>70000</td>\n<td>3</td>\n<td>3</td>\n<td>Sam</td>\n<td>60000</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>Henry</td>\n<td>80000</td>\n<td>4</td>\n<td>3</td>\n<td>Sam</td>\n<td>60000</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>Sam</td>\n<td>60000</td>\n<td></td>\n<td>3</td>\n<td>Sam</td>\n<td>60000</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>Max</td>\n<td>90000</td>\n<td></td>\n<td>3</td>\n<td>Sam</td>\n<td>60000</td>\n<td></td>\n</tr>\n<tr>\n<td>1</td>\n<td>Joe</td>\n<td>70000</td>\n<td>3</td>\n<td>4</td>\n<td>Max</td>\n<td>90000</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>Henry</td>\n<td>80000</td>\n<td>4</td>\n<td>4</td>\n<td>Max</td>\n<td>90000</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>Sam</td>\n<td>60000</td>\n<td></td>\n<td>4</td>\n<td>Max</td>\n<td>90000</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>Max</td>\n<td>90000</td>\n<td></td>\n<td>4</td>\n<td>Max</td>\n<td>90000</td>\n<td></td>\n</tr>\n<tr>\n<td>&gt; The first 3 columns are from a and the last 3 ones are from b.</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>Select from two tables will get the <a href="https://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a> of these two tables. In this case, the output will be 4*4 = 16 records. However, what we interest is the employee\'s salary higher than his/her manager. So we should add two conditions in a <code>WHERE</code> clause like below.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="o">*</span>\n<span class="k">FROM</span>\n    <span class="n">Employee</span> <span class="k">AS</span> <span class="n">a</span><span class="p">,</span>\n    <span class="n">Employee</span> <span class="k">AS</span> <span class="n">b</span>\n<span class="k">WHERE</span>\n    <span class="n">a</span><span class="p">.</span><span class="n">ManagerId</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">Id</span>\n        <span class="k">AND</span> <span class="n">a</span><span class="p">.</span><span class="n">Salary</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Salary</span>\n<span class="p">;</span>\n</pre></div>\n<table>\n<thead>\n<tr>\n<th>Id</th>\n<th>Name</th>\n<th>Salary</th>\n<th>ManagerId</th>\n<th>Id</th>\n<th>Name</th>\n<th>Salary</th>\n<th>ManagerId</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Joe</td>\n<td>70000</td>\n<td>3</td>\n<td>3</td>\n<td>Sam</td>\n<td>60000</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>As we only need to output the employee\'s name, so we modify the above code a little to get a solution.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">a</span><span class="p">.</span><span class="n">Name</span> <span class="k">AS</span> <span class="s1">\'Employee\'</span>\n<span class="k">FROM</span>\n    <span class="n">Employee</span> <span class="k">AS</span> <span class="n">a</span><span class="p">,</span>\n    <span class="n">Employee</span> <span class="k">AS</span> <span class="n">b</span>\n<span class="k">WHERE</span>\n    <span class="n">a</span><span class="p">.</span><span class="n">ManagerId</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">Id</span>\n        <span class="k">AND</span> <span class="n">a</span><span class="p">.</span><span class="n">Salary</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Salary</span>\n<span class="p">;</span>\n</pre></div>\n<h4 id="approach-i-using-join-clause-accepted">Approach I: Using <code>JOIN</code> clause [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Actually, <code>JOIN</code> is a more common and efficient way to link tables together, and we can use <code>ON</code> to specify some conditions.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n     <span class="n">a</span><span class="p">.</span><span class="n">NAME</span> <span class="k">AS</span> <span class="n">Employee</span>\n<span class="k">FROM</span> <span class="n">Employee</span> <span class="k">AS</span> <span class="n">a</span> <span class="k">JOIN</span> <span class="n">Employee</span> <span class="k">AS</span> <span class="n">b</span>\n     <span class="k">ON</span> <span class="n">a</span><span class="p">.</span><span class="n">ManagerId</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">Id</span>\n     <span class="k">AND</span> <span class="n">a</span><span class="p">.</span><span class="n">Salary</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Salary</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '182',
    name: 'Duplicate Emails',
    acceptance: '42.8%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nWrite a SQL query to find all duplicate emails in a table named <code>Person</code>.</p>\n\n<pre>+----+---------+\n| Id | Email   |\n+----+---------+\n| 1  | a@b.com |\n| 2  | c@d.com |\n| 3  | a@b.com |\n+----+---------+\n</pre>\n\n<p>For example, your query should return the following for the above table:</p>\n<pre>+---------+\n| Email   |\n+---------+\n| a@b.com |\n+---------+\n</pre>\n\n<p><b>Note</b>: All emails are in lowercase.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-i-using-group-by-and-a-temporary-table-accepted">Approach I: Using GROUP BY and a temporary table [Accepted]</a></li>\n<li><a href="#approach-ii-using-group-by-and-having-condition-accepted">Approach II: Using GROUP BY and HAVING condition [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-i-using-group-by-and-a-temporary-table-accepted">Approach I: Using <code>GROUP BY</code> and a temporary table [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Duplicated emails existed more than one time. To count the times each email exists, we can use the following code.</p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="n">Email</span><span class="p">,</span> <span class="k">count</span><span class="p">(</span><span class="n">Email</span><span class="p">)</span> <span class="k">as</span> <span class="n">num</span>\n<span class="k">from</span> <span class="n">Person</span>\n<span class="k">group</span> <span class="k">by</span> <span class="n">Email</span><span class="p">;</span>\n</pre></div>\n<div class="codehilite"><pre><span></span>| Email   | num |\n|---------|-----|\n| a@b.com | 2   |\n| c@d.com | 1   |\n</pre></div>\n<p>Taking this as a temporary table, we can get a solution as below.</p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="n">Email</span> <span class="k">from</span>\n<span class="p">(</span>\n  <span class="k">select</span> <span class="n">Email</span><span class="p">,</span> <span class="k">count</span><span class="p">(</span><span class="n">Email</span><span class="p">)</span> <span class="k">as</span> <span class="n">num</span>\n  <span class="k">from</span> <span class="n">Person</span>\n  <span class="k">group</span> <span class="k">by</span> <span class="n">Email</span>\n<span class="p">)</span> <span class="k">as</span> <span class="n">statistic</span>\n<span class="k">where</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">1</span>\n<span class="p">;</span>\n</pre></div>\n<h4 id="approach-ii-using-group-by-and-having-condition-accepted">Approach II: Using <code>GROUP BY</code> and <code>HAVING</code> condition [Accepted]</h4>\n<p>A more common used way to add a condition to a <code>GROUP BY</code> is to use the <code>HAVING</code> clause, which is much simpler and more efficient.</p>\n<p>So we can rewrite the above solution to this one.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="n">Email</span>\n<span class="k">from</span> <span class="n">Person</span>\n<span class="k">group</span> <span class="k">by</span> <span class="n">Email</span>\n<span class="k">having</span> <span class="k">count</span><span class="p">(</span><span class="n">Email</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '183',
    name: 'Customers Who Never Order',
    acceptance: '34.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nSuppose that a website contains two tables, the <code>Customers</code> table and the <code>Orders</code> table. Write a SQL query to find all customers who never order anything.</p>\n\n<p>\nTable: <code>Customers</code>.</p>\n<pre>+----+-------+\n| Id | Name  |\n+----+-------+\n| 1  | Joe   |\n| 2  | Henry |\n| 3  | Sam   |\n| 4  | Max   |\n+----+-------+\n</pre>\n\n<p>\nTable: <code>Orders</code>.</p>\n<pre>+----+------------+\n| Id | CustomerId |\n+----+------------+\n| 1  | 3          |\n| 2  | 1          |\n+----+------------+\n</pre>\n\n<p>Using the above tables as example, return the following:</p>\n<pre>+-----------+\n| Customers |\n+-----------+\n| Henry     |\n| Max       |\n+-----------+\n</pre>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-sub-query-and-not-in-clause-accepted">Approach: Using sub-query and NOT IN clause [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-sub-query-and-not-in-clause-accepted">Approach: Using sub-query and <code>NOT IN</code> clause [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>If we have a list of customers who have ever ordered, it will be easy to know who never ordered.</p>\n<p>We can use the following code to get such list.</p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="n">customerid</span> <span class="k">from</span> <span class="n">orders</span><span class="p">;</span>\n</pre></div>\n<p>Then, we can use <code>NOT IN</code> to query the customers who are not in this list.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="n">customers</span><span class="p">.</span><span class="n">name</span> <span class="k">as</span> <span class="s1">\'Customers\'</span>\n<span class="k">from</span> <span class="n">customers</span>\n<span class="k">where</span> <span class="n">customers</span><span class="p">.</span><span class="n">id</span> <span class="k">not</span> <span class="k">in</span>\n<span class="p">(</span>\n    <span class="k">select</span> <span class="n">customerid</span> <span class="k">from</span> <span class="n">orders</span>\n<span class="p">);</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '184',
    name: 'Department Highest Salary',
    acceptance: '21.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nThe <code>Employee</code> table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id.</p>\n\n<pre>+----+-------+--------+--------------+\n| Id | Name  | Salary | DepartmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 70000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n+----+-------+--------+--------------+\n</pre>\n\n<p>\nThe <code>Department</code> table holds all departments of the company.</p>\n<pre>+----+----------+\n| Id | Name     |\n+----+----------+\n| 1  | IT       |\n| 2  | Sales    |\n+----+----------+\n</pre>\n\n<p>Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, Max has the highest salary in the IT department and Henry has the highest salary in the Sales department.</p>\n\n<pre>+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| Sales      | Henry    | 80000  |\n+------------+----------+--------+\n</pre>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-join-and-in-clause-accepted">Approach: Using JOIN and IN clause [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-join-and-in-clause-accepted">Approach: Using <code>JOIN</code> and <code>IN</code> clause [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Since the <strong>Employee</strong> table contains the <em>Salary</em> and <em>DepartmentId</em> information, we can query the highest salary in a department.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">DepartmentId</span><span class="p">,</span> <span class="k">MAX</span><span class="p">(</span><span class="n">Salary</span><span class="p">)</span>\n<span class="k">FROM</span>\n    <span class="n">Employee</span>\n<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">DepartmentId</span><span class="p">;</span>\n</pre></div>\n<blockquote>\n<p>Note: There might be multiple employees having the same highest salary, so it is safe not to include the employee name information in this query.</p>\n</blockquote>\n<div class="codehilite"><pre><span></span>| DepartmentId | MAX(Salary) |\n|--------------|-------------|\n| 1            | 90000       |\n| 2            | 80000       |\n</pre></div>\n<p>Then, we can join table <strong>Employee</strong> and <strong>Department</strong>, and query the (DepartmentId, Salary) are in the temp table using <code>IN</code> statement as below.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">Department</span><span class="p">.</span><span class="n">name</span> <span class="k">AS</span> <span class="s1">\'Department\'</span><span class="p">,</span>\n    <span class="n">Employee</span><span class="p">.</span><span class="n">name</span> <span class="k">AS</span> <span class="s1">\'Employee\'</span><span class="p">,</span>\n    <span class="n">Salary</span>\n<span class="k">FROM</span>\n    <span class="n">Employee</span>\n        <span class="k">JOIN</span>\n    <span class="n">Department</span> <span class="k">ON</span> <span class="n">Employee</span><span class="p">.</span><span class="n">DepartmentId</span> <span class="o">=</span> <span class="n">Department</span><span class="p">.</span><span class="n">Id</span>\n<span class="k">WHERE</span>\n    <span class="p">(</span><span class="n">Employee</span><span class="p">.</span><span class="n">DepartmentId</span> <span class="p">,</span> <span class="n">Salary</span><span class="p">)</span> <span class="k">IN</span>\n    <span class="p">(</span>   <span class="k">SELECT</span>\n            <span class="n">DepartmentId</span><span class="p">,</span> <span class="k">MAX</span><span class="p">(</span><span class="n">Salary</span><span class="p">)</span>\n        <span class="k">FROM</span>\n            <span class="n">Employee</span>\n        <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">DepartmentId</span>\n    <span class="p">)</span>\n<span class="p">;</span>\n</pre></div>\n<div class="codehilite"><pre><span></span>| Department | Employee | Salary |\n|------------|----------|--------|\n| Sales      | Henry    | 80000  |\n| IT         | Max      | 90000  |\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '185',
    name: 'Department Top Three Salaries',
    acceptance: '18.5%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nThe <code>Employee</code> table holds all employees. Every employee has an Id, and there is also a column for the department Id.</p>\n\n<pre>+----+-------+--------+--------------+\n| Id | Name  | Salary | DepartmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 70000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 5  | Janet | 69000  | 1            |\n| 6  | Randy | 85000  | 1            |\n+----+-------+--------+--------------+\n</pre>\n\n<p>\nThe <code>Department</code> table holds all departments of the company.</p>\n<pre>+----+----------+\n| Id | Name     |\n+----+----------+\n| 1  | IT       |\n| 2  | Sales    |\n+----+----------+\n</pre>\n\n<p>Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows.</p>\n\n<pre>+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT         | Randy    | 85000  |\n| IT         | Joe      | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n+------------+----------+--------+\n</pre>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-join-and-sub-query-accepted">Approach: Using JOIN and sub-query [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-join-and-sub-query-accepted">Approach: Using <code>JOIN</code> and sub-query [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>A top 3 salary in this company means there is no more than 3 salary bigger than itself in the company.</p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="n">e1</span><span class="p">.</span><span class="n">Name</span> <span class="k">as</span> <span class="s1">\'Employee\'</span><span class="p">,</span> <span class="n">e1</span><span class="p">.</span><span class="n">Salary</span>\n<span class="k">from</span> <span class="n">Employee</span> <span class="n">e1</span>\n<span class="k">where</span> <span class="mi">3</span> <span class="o">&gt;</span>\n<span class="p">(</span>\n    <span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="k">distinct</span> <span class="n">e2</span><span class="p">.</span><span class="n">Salary</span><span class="p">)</span>\n    <span class="k">from</span> <span class="n">Employee</span> <span class="n">e2</span>\n    <span class="k">where</span> <span class="n">e2</span><span class="p">.</span><span class="n">Salary</span> <span class="o">&gt;</span> <span class="n">e1</span><span class="p">.</span><span class="n">Salary</span>\n<span class="p">)</span>\n<span class="p">;</span>\n</pre></div>\n<p>In this code, we count the salary number of which is bigger than e1.Salary. So the output is as below for the sample data.</p>\n<div class="codehilite"><pre><span></span>| Employee | Salary |\n|----------|--------|\n| Henry    | 80000  |\n| Max      | 90000  |\n| Randy    | 85000  |\n</pre></div>\n<p>Then, we need to join the <strong>Employee</strong> table with <strong>Department</strong> in order to retrieve the department information.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">d</span><span class="p">.</span><span class="n">Name</span> <span class="k">AS</span> <span class="s1">\'Department\'</span><span class="p">,</span> <span class="n">e1</span><span class="p">.</span><span class="n">Name</span> <span class="k">AS</span> <span class="s1">\'Employee\'</span><span class="p">,</span> <span class="n">e1</span><span class="p">.</span><span class="n">Salary</span>\n<span class="k">FROM</span>\n    <span class="n">Employee</span> <span class="n">e1</span>\n        <span class="k">JOIN</span>\n    <span class="n">Department</span> <span class="n">d</span> <span class="k">ON</span> <span class="n">e1</span><span class="p">.</span><span class="n">DepartmentId</span> <span class="o">=</span> <span class="n">d</span><span class="p">.</span><span class="n">Id</span>\n<span class="k">WHERE</span>\n    <span class="mi">3</span> <span class="o">&gt;</span> <span class="p">(</span><span class="k">SELECT</span>\n            <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">e2</span><span class="p">.</span><span class="n">Salary</span><span class="p">)</span>\n        <span class="k">FROM</span>\n            <span class="n">Employee</span> <span class="n">e2</span>\n        <span class="k">WHERE</span>\n            <span class="n">e2</span><span class="p">.</span><span class="n">Salary</span> <span class="o">&gt;</span> <span class="n">e1</span><span class="p">.</span><span class="n">Salary</span>\n                <span class="k">AND</span> <span class="n">e1</span><span class="p">.</span><span class="n">DepartmentId</span> <span class="o">=</span> <span class="n">e2</span><span class="p">.</span><span class="n">DepartmentId</span>\n        <span class="p">)</span>\n<span class="p">;</span>\n</pre></div>\n<div class="codehilite"><pre><span></span>| Department | Employee | Salary |\n|------------|----------|--------|\n| IT         | Joe      | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n| IT         | Max      | 90000  |\n| IT         | Randy    | 85000  |\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '186',
    name: 'Reverse Words in a String II ',
    acceptance: '28.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.\n</p>\n\n<p>\nThe input string does not contain leading or trailing spaces and the words are always separated by a single space.\n</p>\n\n<p>\nFor example,<br>\nGiven s = "<code>the sky is blue</code>",<br>\nreturn "<code>blue is sky the</code>".\n</p>\n\n<p>\nCould you do it <i>in-place</i> without allocating extra space?\n</p>\n\n<p>Related problem: <a href="/problems/rotate-array/">Rotate Array</a></p>\n\n<p>\n<b><font color="red">Update (2017-10-16):</font></b><br>\nWe have updated the function signature to accept a <code>character array</code>, so please <b><u>reset to the default code definition</u></b> by clicking on the reload button above the code editor. Also, <b>Run Code</b> is now available!\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft', 'Amazon', 'Uber'],
  },
  {
    id: '187',
    name: 'Repeated DNA Sequences',
    acceptance: '32.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nAll DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p>\n\n<p>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p>\n\n<p>\nFor example,</p>\n<pre>Given s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT",\n\nReturn:\n["AAAAACCCCC", "CCCCCAAAAA"].\n</pre>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '188',
    name: 'Best Time to Buy and Sell Stock IV',
    acceptance: '24.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>\n\n<p>Design an algorithm to find the maximum profit. You may complete at most <b>k</b> transactions.</p>\n\n<p><b>Note:</b><br>\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/Freezen">@Freezen</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '189',
    name: 'Rotate Array',
    acceptance: '25.1%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Rotate an array of <i>n</i> elements to the right by <i>k</i> steps.</p>\n<p>For example, with <i>n</i> = 7 and <i>k</i> = 3, the array <code>[1,2,3,4,5,6,7]</code> is rotated to <code>[5,6,7,1,2,3,4]</code>. </p>\n\n<p><b>Note:</b><br>\nTry to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\n</p>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">[show hint]</a></p>\n<div class="spoilers"><b>Hint:</b><br>\nCould you do it in-place with O(1) extra space?\n</div>\n\n<p>Related problem: <a href="/problems/reverse-words-in-a-string-ii/">Reverse Words in a String II</a></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/Freezen">@Freezen</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-extra-array-accepted">Approach #2 Using Extra Array [Accepted]</a></li>\n<li><a href="#approach-3-using-cyclic-replacements-accepted">Approach #3 Using Cyclic Replacements [Accepted]</a></li>\n<li><a href="#approach-4-using-reverse-accepted">Approach #4 Using Reverse [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>We have to rotate the elements of the given array k times to the right.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The simplest approach is to rotate all the elements of the array in k steps\n by rotating the elements by 1 unit in each step.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">temp</span><span class="o">,</span> <span class="n">previous</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="n">previous</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>\n                <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>\n                <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">previous</span><span class="o">;</span>\n                <span class="n">previous</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n*k)</script>. All the numbers are shifted by one step(<script type="math/tex; mode=display">O(n)</script>)\n k times(<script type="math/tex; mode=display">O(k)</script>).</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space is used.</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-extra-array-accepted">Approach #2 Using Extra Array [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We use an extra array in which we place every element of the array at its correct\nposition i.e. the number at index <script type="math/tex; mode=display">i</script> in the original array is placed at the\nindex <script type="math/tex; mode=display">(i+k)%(length of array)</script>. Then, we copy the new array to the original one.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="n">a</span><span class="o">[(</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="o">)</span> <span class="o">%</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n        <span class="o">}</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. One pass is used to put the numbers in the new array.\n And another pass to copy the new array to the original one.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Another array of the same size is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-cyclic-replacements-accepted">Approach #3 Using Cyclic Replacements [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can directly place every number of the array at its required correct position.\nBut if we do that, we will destroy the original element. Thus, we need to store\nthe number being replaced in a <script type="math/tex; mode=display">temp</script> variable. Then, we can place the replaced\n number(<script type="math/tex; mode=display">temp</script>) at its correct position and so on, <script type="math/tex; mode=display">n</script> times, where <script type="math/tex; mode=display">n</script> is\n the length of array. We have chosen <script type="math/tex; mode=display">n</script> to be the number of replacements since we have \n to shift all the elements of the array(which is <script type="math/tex; mode=display">n</script>). But, there could be a problem with this method, if <script type="math/tex; mode=display">n%k=0</script>\n where <script type="math/tex; mode=display">k = k%n</script>(since a value of <script type="math/tex; mode=display">k</script> larger than <script type="math/tex; mode=display">n</script> eventually leads to a <script type="math/tex; mode=display">k</script> equivalent to <script type="math/tex; mode=display">k%n</script>). In this case, while picking up numbers to be placed at the\n correct position, we will eventually reach the number from which we originally started. Thus, in such a case, when\n we hit the original number\'s index again, we start the same process with the number following it.</p>\n<p>Now let\'s look at the proof of how the above method works. Suppose, we have <script type="math/tex; mode=display">n</script> as the number of elements in the array and\n <script type="math/tex; mode=display">k</script> is the number of shifts required. Further, assume <script type="math/tex; mode=display">n%k=0</script>. Now, when we start placing the elements at their correct position, in the first cycle all the numbers with their index <script type="math/tex; mode=display">i</script> satisfying <script type="math/tex; mode=display">i%k=0</script> get placed at their required position. This happens because when we jump k steps every time, we will only hit the numbers k steps apart. We start with index <script type="math/tex; mode=display">i=0</script>, having <script type="math/tex; mode=display">i%k=0</script>. Thus, we hit all the numbers satisfying the above condition in the first cycle. When we reach back the original index, we have placed <script type="math/tex; mode=display">\\frac{n}{k}</script> elements at their correct position, since we hit only that many elements in the first cycle. Now, we increment the index for replacing the numbers. This time, we place other <script type="math/tex; mode=display">\\frac{n}{k}</script> elements at their correct position, different from the ones placed correctly in the first cycle, because this time we hit all the numbers satisfy the condition <script type="math/tex; mode=display">i%k=1</script>. When we hit the starting number again, we increment the index and repeat the same process from <script type="math/tex; mode=display">i=1</script> for all the indices satisfying <script type="math/tex; mode=display">i%k==1</script>. This happens till we reach the number with the index <script type="math/tex; mode=display">i%k=0</script> again, which occurs for <script type="math/tex; mode=display">i=k</script>. We will reach such a number after a total of k cycles. Now, the total count of numbers exclusive numbers placed at their correct position will be <script type="math/tex; mode=display">k \\times \\frac{n}{k}=n</script>. Thus, all the numbers will be placed at their correct position.</p>\n<p>Look at the following example to clarify the process:\n <code>nums: [1, 2, 3, 4, 5, 6]\nk: 2</code></p>\n<p><img alt="Rotate Array" src="https://leetcode.com/media/original_images/189_Rotate_Array.png"></p>\n<p><strong>java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">%</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">start</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>\n            <span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>\n            <span class="k">do</span> <span class="o">{</span>\n                <span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="o">(</span><span class="n">current</span> <span class="o">+</span> <span class="n">k</span><span class="o">)</span> <span class="o">%</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>\n                <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">next</span><span class="o">];</span>\n                <span class="n">nums</span><span class="o">[</span><span class="n">next</span><span class="o">]</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>\n                <span class="n">prev</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>\n                <span class="n">current</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>\n                <span class="n">count</span><span class="o">++;</span>\n            <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">start</span> <span class="o">!=</span> <span class="n">current</span><span class="o">);</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Only one pass is used.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-reverse-accepted">Approach #4 Using Reverse [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This approach is based on the fact that when we rotate the array k times, <script type="math/tex; mode=display">k%n</script> elements from the back end of the array come to the front and the rest of the elements from the front shift backwards.</p>\n<p>In this approach, we firstly reverse all the elements of the array. Then, reversing the first k elements followed by reversing the rest <script type="math/tex; mode=display">n-k</script> elements gives us the required result.</p>\n<p>Let <script type="math/tex; mode=display">n=7</script> and <script type="math/tex; mode=display">k=3</script>.</p>\n<div class="codehilite"><pre><span></span>Original List                   : 1 2 3 4 5 6 7\nAfter reversing all numbers     : 7 6 5 4 3 2 1\nAfter reversing first k numbers : 5 6 7 4 3 2 1\nAfter revering last n-k numbers : 5 6 7 1 2 3 4 --&gt; Result\n</pre></div>\n<p><strong>java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">k</span> <span class="o">%=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>\n        <span class="n">reverse</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>\n        <span class="n">reverse</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>\n        <span class="n">reverse</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>\n    <span class="o">}</span>\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reverse</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">start</span><span class="o">];</span>\n            <span class="n">nums</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">end</span><span class="o">];</span>\n            <span class="n">nums</span><span class="o">[</span><span class="n">end</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>\n            <span class="n">start</span><span class="o">++;</span>\n            <span class="n">end</span><span class="o">--;</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">n</script> elements are reversed a total of three times.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space is used.</p>\n</li>\n</ul>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Microsoft', 'Amazon', 'Bloomberg'],
  },
  {
    id: '190',
    name: 'Reverse Bits',
    acceptance: '29.4%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Reverse bits of a given 32 bits unsigned integer.</p>\n\n<p>For example, given input 43261596 (represented in binary as <b>00000010100101000001111010011100</b>), return 964176192 (represented in binary as <b>00111001011110000010100101000000</b>).</p>\n\n<p>\n<b>Follow up</b>:<br>\nIf this function is called many times, how would you optimize it?\n</p>\n\n<p>Related problem: <a href="/problems/reverse-integer/">Reverse Integer</a></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Apple', 'Airbnb'],
  },
  {
    id: '191',
    name: 'Number of 1 Bits',
    acceptance: '40.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Write a function that takes an unsigned integer and returns the number of ’1\' bits it has (also known as the <a href="http://en.wikipedia.org/wiki/Hamming_weight">Hamming weight</a>).</p>\n\n<p>For example, the 32-bit integer ’11\' has binary representation <code>00000000000000000000000000001011</code>, so the function should return 3.</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-loop-and-flip-accepted">Approach #1 (Loop and Flip) [Accepted]</h4>\n<p><strong> Algorithm</strong></p>\n<p>The solution is straight-forward. We check each of the <script type="math/tex; mode=display">32</script> bits of the number. If the bit is <script type="math/tex; mode=display">1</script>, we add one to the number of <script type="math/tex; mode=display">1</script>-bits.</p>\n<p>We can check the <script type="math/tex; mode=display">i^{th}</script> bit of a number using a <em>bit mask</em>. We start with a mask <script type="math/tex; mode=display">m=1</script>, because the binary representation of <script type="math/tex; mode=display">1</script> is,</p>\n<p>\n<script type="math/tex; mode=display">\n0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0001\n</script>\nClearly, a logical AND between any number and the mask <script type="math/tex; mode=display">1</script> gives us the least significant bit of this number. To check the next bit, we shift the mask to the left by one.</p>\n<p>\n<script type="math/tex; mode=display">\n0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0010\n</script>\n</p>\n<p>And so on.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">hammingWeight</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">((</span><span class="n">n</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">bits</span><span class="o">++;</span>\n        <span class="o">}</span>\n        <span class="n">mask</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">bits</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>The run time depends on the number of bits in <script type="math/tex; mode=display">n</script>. Because <script type="math/tex; mode=display">n</script> in this piece of code is a 32-bit integer, the time complexity is <script type="math/tex; mode=display">O(1)</script>.</p>\n<p>The space complexity is <script type="math/tex; mode=display">O(1)</script>, since no additional space is allocated.</p>\n<hr>\n<h4 id="approach-2-bit-manipulation-trick-accepted">Approach #2 (Bit Manipulation Trick) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can make the previous algorithm simpler and a little faster. Instead of checking every bit of the number, we repeatedly flip the least-significant <script type="math/tex; mode=display">1</script>-bit of the number to <script type="math/tex; mode=display">0</script>, and add <script type="math/tex; mode=display">1</script> to the sum. As soon as the number becomes <script type="math/tex; mode=display">0</script>, we know that it does not have any more <script type="math/tex; mode=display">1</script>-bits, and we return the sum.</p>\n<p>The key idea here is to realize that for any number <script type="math/tex; mode=display">n</script>, doing a bit-wise AND of <script type="math/tex; mode=display">n</script> and <script type="math/tex; mode=display">n - 1</script> flips the least-significant <script type="math/tex; mode=display">1</script>-bit in <script type="math/tex; mode=display">n</script> to <script type="math/tex; mode=display">0</script>. Why? Consider the binary representations of <script type="math/tex; mode=display">n</script> and <script type="math/tex; mode=display">n - 1</script>.</p>\n<p align="center"><img alt="Number of 1 Bits" src="https://leetcode.com/media/original_images/191_Number_Of_Bits.png" width="400px"></p>\n<p align="center"><em>Figure 1. AND-ing <script type="math/tex; mode=display">n</script> and <script type="math/tex; mode=display">n-1</script> flips the least-significant <script type="math/tex; mode=display">1</script>-bit to 0.</em></p>\n<p>In the binary representation, the least significant <script type="math/tex; mode=display">1</script>-bit in <script type="math/tex; mode=display">n</script> always corresponds to a <script type="math/tex; mode=display">0</script>-bit in <script type="math/tex; mode=display">n - 1</script>. Therefore, anding the two numbers <script type="math/tex; mode=display">n</script> and <script type="math/tex; mode=display">n - 1</script> always flips the least significant <script type="math/tex; mode=display">1</script>-bit in <script type="math/tex; mode=display">n</script> to <script type="math/tex; mode=display">0</script>, and keeps all other bits the same.</p>\n<p>Using this trick, the code becomes very simple.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">hammingWeight</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">sum</span><span class="o">++;</span>\n        <span class="n">n</span> <span class="o">&amp;=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>The run time depends on the number of <script type="math/tex; mode=display">1</script>-bits in <script type="math/tex; mode=display">n</script>. In the worst case, all bits in <script type="math/tex; mode=display">n</script> are <script type="math/tex; mode=display">1</script>-bits. In case of a 32-bit integer, the run time is <script type="math/tex; mode=display">O(1)</script>.</p>\n<p>The space complexity is <script type="math/tex; mode=display">O(1)</script>, since no additional space is allocated.</p>\n<p>Analysis written by: @noran.</p>\n</div>\n          ',
    tags: ['Microsoft', 'Apple'],
  },
  {
    id: '192',
    name: 'Word Frequency',
    acceptance: '25.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Write a bash script to calculate the frequency of each word in a text file <code>words.txt</code>.</p>\n\n<p>For simplicity sake, you may assume:</p>\n<ul>\n<li><code>words.txt</code> contains only lowercase characters and space <code>\' \'</code> characters.</li>\n<li>Each word must consist of lowercase characters only.</li>\n<li>Words are separated by one or more whitespace characters.</li>\n</ul>\n<p></p>\n\n<p>For example, assume that <code>words.txt</code> has the following content:</p>\n<pre>the day is sunny the the\nthe sunny is is\n</pre>\n\nYour script should output the following, sorted by descending frequency:\n<pre>the 4\nis 3\nsunny 2\nday 1\n</pre>\n\n<p>\n<b>Note:</b><br>\nDon\'t worry about handling ties, it is guaranteed that each word\'s frequency count is unique.\n</p>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">[show hint]</a></p>\n<div class="spoilers"><b>Hint:</b><br>\nCould you write it in one-line using <a href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-4.html">Unix pipes</a>?\n</div>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '193',
    name: 'Valid Phone Numbers',
    acceptance: '24.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a text file <code>file.txt</code> that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers.</p>\n\n<p>You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)</p>\n\n<p>You may also assume each line in the text file must not contain leading or trailing white spaces.</p>\n\n<p>For example, assume that <code>file.txt</code> has the following content:</p>\n<pre>987-123-4567\n123 456 7890\n(123) 456-7890\n</pre>\n\nYour script should output the following valid phone numbers:\n<pre>987-123-4567\n(123) 456-7890\n</pre>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '194',
    name: 'Transpose File',
    acceptance: '21.3%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given a text file <code>file.txt</code>, transpose its content.</p>\n\n<p>You may assume that each row has the same number of columns and each field is separated by the <code>' '</code> character.</p>\n\n<p>\nFor example, if <code>file.txt</code> has the following content:\n</p><pre>name age\nalice 21\nryan 30\n</pre>\n<p></p>\n\n<p>\nOutput the following:\n</p><pre>name alice ryan\nage 21 30\n</pre>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '195',
    name: 'Tenth Line',
    acceptance: '33.3%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>How would you print just the 10th line of a file?</p>\n\n<p>For example, assume that <code>file.txt</code> has the following content:</p>\n<pre>Line 1\nLine 2\nLine 3\nLine 4\nLine 5\nLine 6\nLine 7\nLine 8\nLine 9\nLine 10\n</pre>\n\nYour script should output the tenth line, which is:\n<pre>Line 10\n</pre>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">[show hint]</a></p>\n<div class="spoilers"><b>Hint:</b><br>\n1. If the file contains less than 10 lines, what should you output?<br>\n2. There\'s at least three different solutions. Try to explore all possibilities.\n</div>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Adobe'],
  },
  {
    id: '196',
    name: 'Delete Duplicate Emails',
    acceptance: '23.1%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nWrite a SQL query to delete all duplicate email entries in a table named <code>Person</code>, keeping only unique emails based on its <i>smallest</i> <b>Id</b>.</p>\n\n<pre>+----+------------------+\n| Id | Email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n| 3  | john@example.com |\n+----+------------------+\nId is the primary key column for this table.\n</pre>\n\n<p>For example, after running your query, the above <code>Person</code> table should have the following rows:</p>\n<pre>+----+------------------+\n| Id | Email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n+----+------------------+\n</pre>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-delete-and-where-clause-accepted">Approach: Using DELETE and WHERE clause [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-delete-and-where-clause-accepted">Approach: Using <code>DELETE</code> and <code>WHERE</code> clause [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>By joining this table with itself on the <em>Email</em> column, we can get the following code.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="n">p1</span><span class="p">.</span><span class="o">*</span>\n<span class="k">FROM</span> <span class="n">Person</span> <span class="n">p1</span><span class="p">,</span>\n    <span class="n">Person</span> <span class="n">p2</span>\n<span class="k">WHERE</span>\n    <span class="n">p1</span><span class="p">.</span><span class="n">Email</span> <span class="o">=</span> <span class="n">p2</span><span class="p">.</span><span class="n">Email</span>\n<span class="p">;</span>\n</pre></div>\n<p>Then we need to find the bigger id having same email address with other records. So we can add a new condition to the <code>WHERE</code> clause like this.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="n">p1</span><span class="p">.</span><span class="o">*</span>\n<span class="k">FROM</span> <span class="n">Person</span> <span class="n">p1</span><span class="p">,</span>\n    <span class="n">Person</span> <span class="n">p2</span>\n<span class="k">WHERE</span>\n    <span class="n">p1</span><span class="p">.</span><span class="n">Email</span> <span class="o">=</span> <span class="n">p2</span><span class="p">.</span><span class="n">Email</span> <span class="k">AND</span> <span class="n">p1</span><span class="p">.</span><span class="n">Id</span> <span class="o">&gt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">Id</span>\n<span class="p">;</span>\n</pre></div>\n<p>As we already get the records to be deleted, we can alter this statement to <code>DELETE</code> in the end.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">DELETE</span> <span class="n">p1</span> <span class="k">FROM</span> <span class="n">Person</span> <span class="n">p1</span><span class="p">,</span>\n    <span class="n">Person</span> <span class="n">p2</span>\n<span class="k">WHERE</span>\n    <span class="n">p1</span><span class="p">.</span><span class="n">Email</span> <span class="o">=</span> <span class="n">p2</span><span class="p">.</span><span class="n">Email</span> <span class="k">AND</span> <span class="n">p1</span><span class="p">.</span><span class="n">Id</span> <span class="o">&gt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">Id</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '197',
    name: 'Rising Temperature',
    acceptance: '29.8%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>Given a <code>Weather</code> table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates.</p>\n\n<pre>+---------+------------+------------------+\n| Id(INT) | Date(DATE) | Temperature(INT) |\n+---------+------------+------------------+\n|       1 | 2015-01-01 |               10 |\n|       2 | 2015-01-02 |               25 |\n|       3 | 2015-01-03 |               20 |\n|       4 | 2015-01-04 |               30 |\n+---------+------------+------------------+\n</pre>\n\nFor example, return the following Ids for the above Weather table:\n<pre>+----+\n| Id |\n+----+\n|  2 |\n|  4 |\n+----+\n</pre>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-join-and-datediff-clause-accepted">Approach: Using JOIN and DATEDIFF() clause [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-join-and-datediff-clause-accepted">Approach: Using <code>JOIN</code> and <code>DATEDIFF()</code> clause [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>MySQL uses <a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_datediff">DATEDIFF</a> to compare two date type values.</p>\n<p>So, we can get the result by joining this table <strong>weather</strong> with itself and use this <code>DATEDIFF()</code> function.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">weather</span><span class="p">.</span><span class="n">id</span> <span class="k">AS</span> <span class="s1">\'Id\'</span>\n<span class="k">FROM</span>\n    <span class="n">weather</span>\n        <span class="k">JOIN</span>\n    <span class="n">weather</span> <span class="n">w</span> <span class="k">ON</span> <span class="n">DATEDIFF</span><span class="p">(</span><span class="n">weather</span><span class="p">.</span><span class="nb">date</span><span class="p">,</span> <span class="n">w</span><span class="p">.</span><span class="nb">date</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>\n        <span class="k">AND</span> <span class="n">weather</span><span class="p">.</span><span class="n">Temperature</span> <span class="o">&gt;</span> <span class="n">w</span><span class="p">.</span><span class="n">Temperature</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '198',
    name: 'House Robber',
    acceptance: '39.5%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.</p>\n\n<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <b>without alerting the police</b>.</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ifanchu">@ifanchu</a> for adding this problem and creating all test cases. Also thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding additional test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-dynamic-programming-accepted">Approach #1 (Dynamic Programming) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-dynamic-programming-accepted">Approach #1 (Dynamic Programming) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>It could be overwhelming thinking of all possibilities on which houses to rob.</p>\n<p>A natural way to approach this problem is to work on the simplest case first.</p>\n<p>Let us denote that:</p>\n<blockquote>\n<p><em>f</em>(<em>k</em>) = Largest amount that you can rob from the first <em>k</em> houses.<br>\nA<sub>i</sub> = Amount of money at the i<sup>th</sup> house.</p>\n</blockquote>\n<p>Let us look at the case <code>n = 1</code>, clearly <em>f</em>(1) = A<sub>1</sub>.</p>\n<p>Now, let us look at <code>n = 2</code>, which <em>f</em>(2) = max(A<sub>1</sub>, A<sub>2</sub>).</p>\n<p>For <code>n = 3</code>, you have basically the following two options:</p>\n<ol>\n<li>\n<p>Rob the third house, and add its amount to the first house\'s amount.</p>\n</li>\n<li>\n<p>Do not rob the third house, and stick with the maximum amount of the first two houses.</p>\n</li>\n</ol>\n<p>Clearly, you would want to choose the larger of the two options at each step.</p>\n<p>Therefore, we could summarize the formula as following:</p>\n<blockquote>\n<p><em>f</em>(<em>k</em>) = max(<em>f</em>(<em>k</em> – 2) + A<sub>k</sub>, <em>f</em>(<em>k</em> – 1))</p>\n</blockquote>\n<p>We choose the base case as <em>f</em>(–1) = <em>f</em>(0) = 0, which will greatly simplify our code as you can see.</p>\n<p>The answer will be calculated as <em>f</em>(<em>n</em>). We could use an array to store and calculate the result, but since at each step you only need the previous two maximum values, two variables are suffice.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">rob</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">prevMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">currMax</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">:</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">currMax</span><span class="o">;</span>\n        <span class="n">currMax</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">prevMax</span> <span class="o">+</span> <span class="n">x</span><span class="o">,</span> <span class="n">currMax</span><span class="o">);</span>\n        <span class="n">prevMax</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">currMax</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nAssume that <script type="math/tex; mode=display">n</script> is the number of houses, the time complexity is <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: ['LinkedIn', 'Airbnb'],
  },
  {
    id: '199',
    name: 'Binary Tree Right Side View',
    acceptance: '41.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a binary tree, imagine yourself standing on the <i>right</i> side of it, return the values of the nodes you can see ordered from top to bottom.</p>\n\n<p>\nFor example:<br>\nGiven the following binary tree,<br>\n</p><pre>   1            &lt;---\n /   \\\n2     3         &lt;---\n \\     \\\n  5     4       &lt;---\n</pre>\n<p></p>\n<p>\nYou should return <code>[1, 3, 4]</code>.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/amrsaqr">@amrsaqr</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#initial-thoughts">Initial Thoughts</a></li>\n<li><a href="#approach-1-depth-first-search-accepted">Approach #1 Depth-First Search [Accepted]</a></li>\n<li><a href="#approach-2-breadth-first-search-accepted">Approach #2 Breadth-First Search [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="initial-thoughts">Initial Thoughts</h4>\n<p>Because the tree topography is unknown ahead of time, it is not possible to\ndesign an algorithm that visits asymptotically fewer than <script type="math/tex; mode=display">n</script> nodes.\nTherefore, we should try to aim for a linear time solution. With that in\nmind, let\'s consider a few equally-efficient solutions.</p>\n<h4 id="approach-1-depth-first-search-accepted">Approach #1 Depth-First Search [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can efficiently obtain the right-hand view of the binary tree if we visit\neach node in the proper order.</p>\n<p><strong>Algorithm</strong></p>\n<p>One of the aforementioned orderings is defined by a depth-first search in\nwhich we always visit the right subtree first. This guarantees that the first\ntime we visit a particular depth of the tree, the node that we are visiting\nis the rightmost node at that depth. Therefore, we can store the value of the\nfirst node that we visit at each depth, ultimately generating a final array\nof values once we know exactly how many layers are in the tree.</p>\n<p align="center"><img alt="Depth-First Search" src="https://leetcode.com/articles/Figures/199/199_depth_first.png"></p>\n<p>The figure above illustrates one instance of the problem. The red nodes\ncompose the solution from top to bottom, and the edges are labelled in order\nof visitation.</p>\n<iframe frameborder="0" height="500" name="U8377M7P" src="https://leetcode.com/playground/U8377M7P/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.</p>\n<p>Because a binary tree with only child pointers is <em>directed acyclic graph</em>\nwith only one source node, a traversal of the tree from the root will visit\neach node exactly once (plus a sublinear amount of leaves, represented as\n<code>None</code>). Each visitation requires only <script type="math/tex; mode=display">O(1)</script> work, so the while loop\nruns in linear time. Finally, building the array of rightmost values is\n<script type="math/tex; mode=display">O(</script>height of the tree<script type="math/tex; mode=display">) = O(n)</script> because it is not possible for a\nright-hand view of the tree to contain more nodes than the tree itself.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>.</p>\n<p>At worst, our stack will contain a number of nodes close to the height of\nthe tree. Because we are exploring the tree in a depth-first order, there\nare never two nodes from different subtrees of the same parent node on the\nstack at once. Said another way, the entire right subtree of a node will be\nvisited before any nodes of the left subtree are pushed onto the stack. If\nthis logic is applied recursively down the tree, it follows that the stack\nwill be largest when we have reached the end of the tree\'s longest path\n(the height of the tree). However, because we know nothing about the tree\'s\ntopography, the height of the tree may be equivalent to <script type="math/tex; mode=display">n</script>, causing the\nspace complexity to degrade to <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-breadth-first-search-accepted">Approach #2 Breadth-First Search [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Much like depth-first search can guarantee that we visit a depth\'s rightmost\nnode first, breadth-first search can guarantee that we visit it <em>last</em>.</p>\n<p><strong>Algorithm</strong></p>\n<p>By performing a breadth-first search that enqueues the left child before the\nright child, we visit each node in each layer from left to right. Therefore,\nby retaining only the most recently visited node per depth, we will have\nthe rightmost node for each depth once we finish the tree traversal. The\nalgorithm is unchanged, other than swapping out the stack for a\n<code>deque</code><sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup> and removing the containment check before assigning into\n<code>rightmost_value_at_depth</code>.</p>\n<p align="center"><img alt="Breadth-first Search Example" src="https://leetcode.com/articles/Figures/199/199_breadth_first.png"></p>\n<p>The figure above illustrates the same instance as before, but solved via\nbreadth-first search. The red nodes compose the solution from top to bottom,\nand the edges are labelled in order of visitation.</p>\n<iframe frameborder="0" height="500" name="9Aia2BUi" src="https://leetcode.com/playground/9Aia2BUi/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.</p>\n<p>The differences itemized in the <strong>Algorithm</strong> section do not admit\ndifferences in the time complexity analysis between the bread-first and\ndepth-first search approaches.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>.</p>\n<p>Because breadth-first search visits the tree layer-by-layer, the queue\nwill be at its largest immediately before visiting the largest layer. The\nsize of this layer is <script type="math/tex; mode=display">0.5n = O(n)</script> in the worst case (a complete binary\ntree).</p>\n</li>\n</ul>\n<hr>\n<p><strong>Footnotes</strong></p>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/emptyset">@emptyset</a></p>\n<div class="footnote">\n<hr>\n<ol>\n<li id="fn:1">\n<p>The\n<a href="https://docs.python.org/3/library/collections.html#collections.deque"><code>deque</code></a>\ndatatype from the\n<a href="https://docs.python.org/3/library/collections.html"><code>collections</code></a> module\nsupports constant time append/pop from both the head and the tail. If we were\nto use a Python <code>list</code>, it would cost us <script type="math/tex; mode=display">O(n)</script> time to remove its head via\n<code>list.pop(0)</code>.&nbsp;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">↩</a></p>\n</li>\n</ol>\n</div>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '200',
    name: 'Number of Islands',
    acceptance: '35.8%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given a 2d grid map of <code>'1'</code>s (land) and <code>'0'</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>\n\n<p><i><b>Example 1:</b></i></p>\n<pre>11110<br>11010<br>11000<br>00000</pre>\n<p>Answer: 1</p>\n<p><i><b>Example 2:</b></i></p>\n<pre>11000<br>11000<br>00100<br>00011</pre>\n<p>Answer: 3</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href=\"https://leetcode.com/discuss/user/mithmatt\">@mithmatt</a> for adding this problem and creating all test cases.</p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-dfs-accepted">Approach #1 DFS [Accepted]</a></li>\n<li><a href="#approach-2-bfs-accepted">Approach #2: BFS [Accepted]</a></li>\n<li><a href="#approach-3-union-find-aka-disjoint-set-accepted">Approach #3: Union Find (aka Disjoint Set) [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-dfs-accepted">Approach #1 DFS [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Treat the 2d grid map as an undirected graph and there is an edge\nbetween two horizontally or vertically adjacent nodes of value \'1\'.</p>\n<p><strong>Algorithm</strong></p>\n<p>Linear scan the 2d grid map, if a node contains a \'1\', then it is a root node\nthat triggers a Depth First Search. During DFS, every visited node should be\nset as \'0\' to mark as visited node. Count the number of root nodes that trigger\nDFS, this number would be the number of islands since each DFS starting at some\nroot identifies an island.</p>\n<p>The algorithm can be better illustrated by the animation below:\n!?!../Documents/200_number_of_islands_dfs.json:1024,768!?!</p>\n<iframe frameborder="0" height="500" name="8iHthxuc" src="https://leetcode.com/playground/8iHthxuc/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(M \\times N)</script> where <script type="math/tex; mode=display">M</script> is the number of rows and\n  <script type="math/tex; mode=display">N</script> is the number of columns.</p>\n</li>\n<li>\n<p>Space complexity : worst case <script type="math/tex; mode=display">O(M \\times N)</script> in case that the grid map\n  is filled with lands where DFS goes by <script type="math/tex; mode=display">M \\times N</script> deep.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-bfs-accepted">Approach #2: BFS [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Linear scan the 2d grid map, if a node contains a \'1\', then it is a root node\nthat triggers a Breadth First Search. Put it into a queue and set its value\nas \'0\' to mark as visited node. Iteratively search the neighbors of enqueued\nnodes until the queue becomes empty.</p>\n<iframe frameborder="0" height="500" name="A72rWpdb" src="https://leetcode.com/playground/A72rWpdb/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(M \\times N)</script> where <script type="math/tex; mode=display">M</script> is the number of rows and\n  <script type="math/tex; mode=display">N</script> is the number of columns.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(min(M, N))</script> because in worst case where the\n  grid is filled with lands, the size of queue can grow up to min(<script type="math/tex; mode=display">M,N</script>).</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-union-find-aka-disjoint-set-accepted">Approach #3: Union Find (aka Disjoint Set) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Traverse the 2d grid map and union adjacent lands horizontally or vertically,\nat the end, return the number of connected components maintained in the UnionFind\ndata structure.</p>\n<p>For details regarding to Union Find, you can refer to this <a href="https://leetcode.com/articles/redundant-connection/">article</a>.</p>\n<p>The algorithm can be better illustrated by the animation below:\n!?!../Documents/200_number_of_islands_unionfind.json:1024,768!?!</p>\n<iframe frameborder="0" height="500" name="WxXFcSGH" src="https://leetcode.com/playground/WxXFcSGH/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(M \\times N)</script> where <script type="math/tex; mode=display">M</script> is the number of rows and\n  <script type="math/tex; mode=display">N</script> is the number of columns. Note that Union operation takes essentially constant\n  time<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup> when UnionFind is implemented with both path compression and union by rank.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(M \\times N)</script> as required by UnionFind data structure.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/imsure">@imsure</a>.</p>\n<p>Thanks to <a href="https://leetcode.com/williamfu4leetcode/">@williamfu4leetcode</a> for correcting the space complexity analysis of BFS approach. </p>\n<hr>\n<p><strong>Footnotes</strong></p>\n<div class="footnote">\n<hr>\n<ol>\n<li id="fn:1">\n<p><a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">https://en.wikipedia.org/wiki/Disjoint-set_data_structure</a>&nbsp;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">↩</a></p>\n</li>\n</ol>\n</div>\n</div>\n          ',
    tags: ['Google', 'Facebook', 'Microsoft', 'Amazon', 'Zenefits'],
  },
  {
    id: '201',
    name: 'Bitwise AND of Numbers Range',
    acceptance: '34.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.</p>\n\n<p>\nFor example, given the range [5, 7], you should return 4.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/amrsaqr">@amrsaqr</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '202',
    name: 'Happy Number',
    acceptance: '41.1%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Write an algorithm to determine if a number is "happy".</p>\n\n<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>\n\n<p><b>Example:&nbsp;</b>19 is a happy number</p>\n\n<ul style="list-style: none;">\n<li>1<sup>2</sup> + 9<sup>2</sup> = 82</li>\n<li>8<sup>2</sup> + 2<sup>2</sup> = 68</li>\n<li>6<sup>2</sup> + 8<sup>2</sup> = 100</li>\n<li>1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1</li>\n</ul>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/mithmatt">@mithmatt</a> and <a href="https://leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Uber', 'Twitter', 'Airbnb'],
  },
  {
    id: '203',
    name: 'Remove Linked List Elements',
    acceptance: '33.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Remove all elements from a linked list of integers that have value <b><i>val</i></b>.</p>\n<p>\n<b>Example</b><br>\n<i><b>Given:</b></i> 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6,  <b><i>val</i></b> = 6<br>\n<i><b>Return:</b></i> 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/mithmatt">@mithmatt</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '204',
    name: 'Count Primes',
    acceptance: '26.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p><b>Description:</b></p>\n<p>Count the number of prime numbers less than a non-negative number, <b><i>n</i></b>.</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/mithmatt">@mithmatt</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft', 'Amazon'],
  },
  {
    id: '205',
    name: 'Isomorphic Strings',
    acceptance: '34.3%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given two strings <b><i>s</i></b> and <b><i>t</i></b>, determine if they are isomorphic.</p>\n\n<p>Two strings are isomorphic if the characters in <b><i>s</i></b> can be replaced to get <b><i>t</i></b>.</p>\n\n<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>\n\n<p>For example,<br>\nGiven <code>"egg"</code>, <code>"add"</code>, return true.</p>\n\n<p>Given <code>"foo"</code>, <code>"bar"</code>, return false.</p>\n\n<p>Given <code>"paper"</code>, <code>"title"</code>, return true.</p>\n\n<p><b>Note:</b><br>\nYou may assume both <b><i>s</i></b> and <b><i>t</i></b> have the same length.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '206',
    name: 'Reverse Linked List',
    acceptance: '46.3%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Reverse a singly linked list.</p>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show more hints.</a></p>\n\n<div class="spoilers"><b>Hint:</b>\n<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>\n</div>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-iterative-accepted">Approach #1 (Iterative) [Accepted]</a></li>\n<li><a href="#approach-2-recursive-accepted">Approach #2 (Recursive) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-iterative-accepted">Approach #1 (Iterative) [Accepted]</h4>\n<p>Assume that we have linked list <code>1 → 2 → 3 → Ø</code>, we would like to change it to <code>Ø ← 1 ← 2 ← 3</code>.</p>\n<p>While you are traversing the list, change the current node\'s next pointer to point to its previous element. Since a node does not have reference to its previous node, you must store its previous element beforehand. You also need another pointer to store the next node before changing the reference. Do not forget to return the new head reference at the end!</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">reverseList</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">ListNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>\n    <span class="n">ListNode</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">ListNode</span> <span class="n">nextTemp</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>\n        <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>\n        <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>\n        <span class="n">curr</span> <span class="o">=</span> <span class="n">nextTemp</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">prev</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nAssume that <script type="math/tex; mode=display">n</script> is the list\'s length, the time complexity is <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-recursive-accepted">Approach #2 (Recursive) [Accepted]</h4>\n<p>The recursive version is slightly trickier and the key is to work backwards. Assume that the rest of the list had already been reversed, now how do I reverse the front part? Let\'s assume the list is: n<sub>1</sub> → … → n<sub>k-1</sub> → n<sub>k</sub> → n<sub>k+1</sub> → … → n<sub>m</sub> → Ø</p>\n<p>Assume from node n<sub>k+1</sub> to n<sub>m</sub> had been reversed and you are at node n<sub>k</sub>.</p>\n<p>n<sub>1</sub> → … → n<sub>k-1</sub> → <b>n<sub>k</sub></b> → n<sub>k+1</sub> ← … ← n<sub>m</sub></p>\n<p>We want n<sub>k+1</sub>’s next node to point to n<sub>k</sub>.</p>\n<p>So,</p>\n<p>n<sub>k</sub>.next.next = n<sub>k</sub>;</p>\n<p>Be very careful that n<sub>1</sub>\'s next must point to Ø. If you forget about this, your linked list has a cycle in it. This bug could be caught if you test your code with a linked list of size 2.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">reverseList</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>\n    <span class="n">ListNode</span> <span class="n">p</span> <span class="o">=</span> <span class="n">reverseList</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>\n    <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>\n    <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>\n    <span class="k">return</span> <span class="n">p</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nAssume that <script type="math/tex; mode=display">n</script> is the list\'s length, the time complexity is <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>.\nThe extra space comes from implicit stack space due to recursion. The recursion could go up to <script type="math/tex; mode=display">n</script> levels deep.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: [
      'Facebook',
      'Microsoft',
      'Amazon',
      'Bloomberg',
      'Uber',
      'Twitter',
      'Apple',
      'Snapchat',
      'Zenefits',
      'Yelp',
      'Yahoo',
      'Adobe',
    ],
  },
  {
    id: '207',
    name: 'Course Schedule',
    acceptance: '33.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nThere are a total of <i>n</i> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.</p>\n\n<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>\n\n<p>\nGiven the total number of courses and a list of prerequisite <b>pairs</b>, is it possible for you to finish all courses?\n</p>\n\n<p>For example:</p>\n<pre>2, [[1,0]]</pre>\n<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p>\n\n<pre>2, [[1,0],[0,1]]</pre>\n<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The input prerequisites is a graph represented by <b>a list of edges</b>, not adjacency matrices. Read more about <a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs" target="_blank">how a graph is represented</a>.</li>\n<li>You may assume that there are no duplicate edges in the input prerequisites.</li>\n</ol>\n<p></p>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show more hints.</a></p>\n\n<div class="spoilers"><b>Hints:</b>\n<ol>\n<li>This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.</li>\n<li><a href="https://class.coursera.org/algo-003/lecture/52" target="_blank">Topological Sort via DFS</a> - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.</li>\n<li>Topological sort could also be done via <a href="http://en.wikipedia.org/wiki/Topological_sorting#Algorithms" target="_blank">BFS</a>.</li>\n</ol>\n</div>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Uber', 'Apple', 'Zenefits', 'Yelp'],
  },
  {
    id: '208',
    name: 'Implement Trie (Prefix Tree)',
    acceptance: '29.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nImplement a trie with <code>insert</code>, <code>search</code>, and <code>startsWith</code> methods.\n</p>\n\n<p>\n<b>Note:</b><br>\nYou may assume that all inputs are consist of lowercase letters <code>a-z</code>.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#applications">Applications</a><ul>\n<li><a href="#1-autocomplete">1. Autocomplete</a></li>\n<li><a href="#2-spell-checker">2. Spell checker</a></li>\n<li><a href="#3-ip-routing-longest-prefix-matching">3. IP routing (Longest prefix matching)</a></li>\n<li><a href="#4-t9-predictive-text">4. T9 predictive text</a></li>\n<li><a href="#5-solving-word-games">5. Solving word games</a></li>\n</ul>\n</li>\n<li><a href="#trie-node-structure">Trie node structure</a></li>\n<li><a href="#insertion-of-a-key-to-a-trie">Insertion of a key to a trie</a></li>\n<li><a href="#search-for-a-key-in-a-trie">Search for a key in a trie</a></li>\n<li><a href="#search-for-a-key-prefix-in-a-trie">Search for a key prefix in a trie</a></li>\n</ul>\n</li>\n<li><a href="#practice-problems">Practice Problems</a></li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This article is for intermediate level users. It introduces the following ideas:\nThe data structure Trie (Prefix tree) and most common operations with it.</p>\n<h2 id="solution">Solution</h2>\n<h4 id="applications">Applications</h4>\n<p>Trie (we pronounce "try") or prefix tree is a tree data structure, which is used for retrieval of a key in a dataset of strings.\nThere are various applications of this very efficient data structure such as :</p>\n<h5 id="1-autocomplete">1. <a href="https://en.wikipedia.org/wiki/Autocomplete">Autocomplete</a></h5>\n<p align="center"><img alt="Google Suggest" src="https://leetcode.com/media/original_images/208_GoogleSuggest.png" width="539px"></p>\n<p align="center"><em>Figure 1. Google Suggest in action.</em></p>\n<h5 id="2-spell-checker">2. <a href="https://en.wikipedia.org/wiki/Spell_checker">Spell checker</a></h5>\n<p align="center"><img alt="Spell Checker" src="https://leetcode.com/media/original_images/208_SpellCheck.png" width="400px"></p>\n<p align="center"><em>Figure 2. A spell checker used in word processor.</em></p>\n<h5 id="3-ip-routing-longest-prefix-matching">3. <a href="https://en.wikipedia.org/wiki/Longest_prefix_match">IP routing (Longest prefix matching)</a></h5>\n<p align="center"><img alt="IP Routing" src="https://leetcode.com/media/original_images/208_IPRouting.gif" width="539px"></p>\n<p align="center"><em>Figure 3. Longest prefix matching algorithm uses Tries in Internet Protocol (IP) routing to select an entry from a forwarding table.</em></p>\n<h5 id="4-t9-predictive-text">4. <a href="https://en.wikipedia.org/wiki/T9_(predictive_text)">T9 predictive text</a></h5>\n<p align="center"><img alt="T9 Predictive Text" src="https://leetcode.com/media/original_images/208_T9.jpg"></p>\n<p align="center"><em>Figure 4. T9 which stands for Text on 9 keys, was used on phones to input texts during the late 1990s.</em></p>\n<h5 id="5-solving-word-games">5. <a href="https://en.wikipedia.org/wiki/Boggle">Solving word games</a></h5>\n<p align="center"><img alt="Boggle" src="https://leetcode.com/media/original_images/208_Boggle.png" width="350px"></p>\n<p align="center"><em>Figure 5. Tries is used to solve Boggle efficiently by pruning the search space.</em></p>\n<p>There are several other data structures, like balanced trees and hash tables, which give us the possibility to search for a word in a dataset of strings. Then why do we need trie?\nAlthough hash table has <script type="math/tex; mode=display">O(1)</script> time complexity for looking for a key, it is not efficient in the following operations :</p>\n<ul>\n<li>Finding all keys with a common prefix.</li>\n<li>Enumerating a dataset of strings in lexicographical order.</li>\n</ul>\n<p>Another reason why trie outperforms hash table, is that as hash table increases in size, there are lots of hash collisions and the search time complexity could deteriorate to <script type="math/tex; mode=display">O(n)</script>, where <script type="math/tex; mode=display">n</script> is the number of keys inserted.\nTrie could use less space compared to Hash Table when storing many keys with the same prefix.\nIn this case using trie has only <script type="math/tex; mode=display">O(m)</script> time complexity, where <script type="math/tex; mode=display">m</script> is the key length.\nSearching for a key in a balanced tree costs  <script type="math/tex; mode=display">O(m \\log n)</script> time complexity.</p>\n<h4 id="trie-node-structure">Trie node structure</h4>\n<p>Trie is a rooted tree. Its nodes have the following fields:</p>\n<ul>\n<li>Maximum of <script type="math/tex; mode=display">R</script> links to its children, where each link corresponds to one of <script type="math/tex; mode=display">R</script> character values from dataset alphabet.\nIn this article we assume that <script type="math/tex; mode=display">R</script> is 26, the number of lowercase latin letters.</li>\n<li>Boolean field which specifies whether the node corresponds to the end of the key, or is just a key prefix.</li>\n</ul>\n<p align="center"><img alt="Representation of a key in trie" src="https://leetcode.com/media/original_images/208_Node.png" width="539px"></p>\n<p align="center"><em>Figure 6. Representation of a key "leet" in trie.</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">TrieNode</span> <span class="o">{</span>\n\n    <span class="c1">// R links to node children</span>\n    <span class="kd">private</span> <span class="n">TrieNode</span><span class="o">[]</span> <span class="n">links</span><span class="o">;</span>\n\n    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="mi">26</span><span class="o">;</span>\n\n    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isEnd</span><span class="o">;</span>\n\n    <span class="kd">public</span> <span class="nf">TrieNode</span><span class="o">()</span> <span class="o">{</span>\n        <span class="n">links</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TrieNode</span><span class="o">[</span><span class="n">R</span><span class="o">];</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsKey</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">return</span> <span class="n">links</span><span class="o">[</span><span class="n">ch</span> <span class="o">-</span><span class="sc">\'a\'</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="kd">public</span> <span class="n">TrieNode</span> <span class="nf">get</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">return</span> <span class="n">links</span><span class="o">[</span><span class="n">ch</span> <span class="o">-</span><span class="sc">\'a\'</span><span class="o">];</span>\n    <span class="o">}</span>\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch</span><span class="o">,</span> <span class="n">TrieNode</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">links</span><span class="o">[</span><span class="n">ch</span> <span class="o">-</span><span class="sc">\'a\'</span><span class="o">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setEnd</span><span class="o">()</span> <span class="o">{</span>\n        <span class="n">isEnd</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEnd</span><span class="o">()</span> <span class="o">{</span>\n        <span class="k">return</span> <span class="n">isEnd</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p>Two of the most common operations in a trie are insertion of a key and search for a key.</p>\n<h4 id="insertion-of-a-key-to-a-trie">Insertion of a key to a trie</h4>\n<p>We insert a key by searching into the trie. We start from the root and search a link, which corresponds to the first key character. There are two cases :</p>\n<ul>\n<li>A link exists. Then we move down the tree following the link to the next child level. The algorithm continues with searching for the next key character.</li>\n<li>A link does not exist. Then we create a new node and link it with the parent\'s link matching the current key character.\nWe repeat this step until we encounter the last character of the key, then we mark the current node as an end node and the algorithm finishes.</li>\n</ul>\n<p align="center"><img alt="Insertion of keys into a trie" src="https://leetcode.com/media/original_images/208_TrieInsert.png" width="539px"></p>\n<p align="center"><em>Figure 7. Insertion of keys into a trie.</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Trie</span> <span class="o">{</span>\n    <span class="kd">private</span> <span class="n">TrieNode</span> <span class="n">root</span><span class="o">;</span>\n\n    <span class="kd">public</span> <span class="nf">Trie</span><span class="o">()</span> <span class="o">{</span>\n        <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TrieNode</span><span class="o">();</span>\n    <span class="o">}</span>\n\n    <span class="c1">// Inserts a word into the trie.</span>\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="kt">char</span> <span class="n">currentChar</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>\n            <span class="k">if</span> <span class="o">(!</span><span class="n">node</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">currentChar</span><span class="o">))</span> <span class="o">{</span>\n                <span class="n">node</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">currentChar</span><span class="o">,</span> <span class="k">new</span> <span class="n">TrieNode</span><span class="o">());</span>\n            <span class="o">}</span>\n            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">currentChar</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="n">node</span><span class="o">.</span><span class="na">setEnd</span><span class="o">();</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(m)</script>, where m is the key length.</li>\n</ul>\n<p>In each iteration of the algorithm, we either examine or create a node in the trie till we reach the end of the key. This takes only <script type="math/tex; mode=display">m</script> operations.</p>\n<ul>\n<li>Space complexity : <script type="math/tex; mode=display">O(m)</script>.</li>\n</ul>\n<p>In the worst case newly inserted key doesn\'t share a prefix with the the keys already inserted in the trie. We have to add <script type="math/tex; mode=display">m</script>\nnew nodes, which takes us  <script type="math/tex; mode=display">O(m)</script> space.</p>\n<h4 id="search-for-a-key-in-a-trie">Search for a key in a trie</h4>\n<p>Each key is represented in the trie as a path from the root to the internal node or leaf.\nWe start from the root with the first key character. We examine the current node for a link corresponding to the key character. There are two cases :</p>\n<ul>\n<li>A link exist. We move to the next node in the path following this link, and proceed searching for the next key character.</li>\n<li>\n<p>A link does not exist. If there are no available key characters and current node is marked as <code>isEnd</code> we return true. Otherwise there are possible two cases in each of them we return false :</p>\n<ul>\n<li>There are key characters left, but it is impossible to follow the key path in the trie, and the key is missing.</li>\n<li>No key characters left, but current node is not marked as <code>isEnd</code>. Therefore the search key is only a prefix of another key in the trie.</li>\n</ul>\n</li>\n</ul>\n<p align="center"><img alt="Search of a key in a trie" src="https://leetcode.com/media/original_images/208_TrieSearchKey.png" width="539px"></p>\n<p align="center"><em>Figure 8. Search for a key in a trie.</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Trie</span> <span class="o">{</span>\n    <span class="o">...</span>\n\n    <span class="c1">// search a prefix or whole key in trie and</span>\n    <span class="c1">// returns the node where search ends</span>\n    <span class="kd">private</span> <span class="n">TrieNode</span> <span class="nf">searchPrefix</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n           <span class="kt">char</span> <span class="n">curLetter</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>\n           <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">curLetter</span><span class="o">))</span> <span class="o">{</span>\n               <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">curLetter</span><span class="o">);</span>\n           <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>\n               <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>\n           <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">node</span><span class="o">;</span>\n    <span class="o">}</span>\n\n    <span class="c1">// Returns if the word is in the trie.</span>\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>\n       <span class="n">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">searchPrefix</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>\n       <span class="k">return</span> <span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="na">isEnd</span><span class="o">();</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m)</script>\nIn each step of the algorithm we search for the next key character. In the worst case the algorithm performs <script type="math/tex; mode=display">m</script> operations.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n</li>\n</ul>\n<h4 id="search-for-a-key-prefix-in-a-trie">Search for a key prefix in a trie</h4>\n<p>The approach is very similar to the one we used for searching a key in a trie. We traverse the trie from the root, till there are no characters left in key prefix or it is impossible to continue the path in the trie with the current key character. The only difference with the mentioned above <code>search for a key</code> algorithm is that when we come to an end of the key prefix, we always return true. We don\'t need to consider the <code>isEnd</code> mark of the current trie node, because we are searching for a prefix of a key, not for a whole key.</p>\n<p align="center"><img alt="Search of a key prefix in a trie" src="https://leetcode.com/media/original_images/208_TrieSearchPrefix.png" width="539px"></p>\n<p align="center"><em>Figure 9. Search for a key prefix in a trie.</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Trie</span> <span class="o">{</span>\n    <span class="o">...</span>\n\n    <span class="c1">// Returns if there is any word in the trie</span>\n    <span class="c1">// that starts with the given prefix.</span>\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">startsWith</span><span class="o">(</span><span class="n">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">searchPrefix</span><span class="o">(</span><span class="n">prefix</span><span class="o">);</span>\n        <span class="k">return</span> <span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m)</script>\n</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n</li>\n</ul>\n<h2 id="practice-problems">Practice Problems</h2>\n<p>Here are some wonderful problems for you to practice which uses the Trie data structure.</p>\n<ol>\n<li><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/">Add and Search Word - Data structure design</a> - Pretty much a direct application of Trie.</li>\n<li><a href="https://leetcode.com/problems/word-search-ii/">Word Search II</a> - Similar to Boggle.</li>\n</ol>\n<p>Analysis written by: @elmirap.</p>\n</div>\n          ',
    tags: ['Google', 'Facebook', 'Microsoft', 'Bloomberg', 'Uber', 'Twitter'],
  },
  {
    id: '209',
    name: 'Minimum Size Subarray Sum',
    acceptance: '31.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a <b>contiguous</b> subarray of which the sum ≥ <strong>s</strong>. If there isn\'t one, return 0 instead.\n</p>\n<p>\nFor example, given the array <code>[2,3,1,2,4,3]</code> and <code>s = 7</code>,<br>\nthe subarray <code>[4,3]</code> has the minimal length under the problem constraint.\n</p>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show more practice.</a></p>\n\n<div class="spoilers"><b>More practice:</b>\n\n<p>If you have figured out the <i>O</i>(<i>n</i>) solution, try coding another solution of which the time complexity is <i>O</i>(<i>n</i> log <i>n</i>).</p>\n</div>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/Freezen">@Freezen</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-a-better-brute-force-accepted">Approach #2 A better brute force [Accepted]</a></li>\n<li><a href="#approach-3-using-binary-search-accepted">Approach #3 Using Binary search [Accepted]</a></li>\n<li><a href="#approach-4-using-2-pointers-accepted">Approach #4 Using 2 pointers [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute force [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>Do as directed in question. Find the sum for all the possible subarrays and update the <script type="math/tex; mode=display">\\text{ans}</script> as and when we get a better subarray that fulfill the requirements (<script type="math/tex; mode=display">\\text{sum} \\geq \\text{s}</script>).</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>Initialize <script type="math/tex; mode=display">\\text{ans}=\\text{INT_MAX}</script>\n</li>\n<li>Iterate the array from left to right using <script type="math/tex; mode=display">i</script>:<ul>\n<li>Iterate from the current element to the end of vector using <script type="math/tex; mode=display">j</script>:<ul>\n<li>Find the <script type="math/tex; mode=display">\\text{sum}</script> of elements from index <script type="math/tex; mode=display">i</script> to <script type="math/tex; mode=display">j</script>\n</li>\n<li>If sum is greater then <script type="math/tex; mode=display">s</script>:<ul>\n<li>Update <script type="math/tex; mode=display">\\text{ans} = \\min(\\text{ans}, (j - i + 1))</script>\n</li>\n<li>Start the next <script type="math/tex; mode=display">i</script>th iteration, since, we got the smallest subarray with <script type="math/tex; mode=display">\\text{sum} \\geq s</script> starting from the current index.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<iframe frameborder="0" height="360" name="VzAVPq7w" src="https://leetcode.com/playground/VzAVPq7w/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O(n^3)</script>.</p>\n<ul>\n<li>For each element of array, we find all the subarrays starting from that index which is <script type="math/tex; mode=display">O(n^2)</script>.</li>\n<li>Time complexity to find the sum of each subarray is <script type="math/tex; mode=display">O(n)</script>.</li>\n<li>Thus, the total time complexity : <script type="math/tex; mode=display">O(n^2 * n) = O(n^3)</script>\n</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(1)</script> extra space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-a-better-brute-force-accepted">Approach #2 A better brute force [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>In Approach #1, you may notice that the sum is calculated for every surarray in <script type="math/tex; mode=display">O(n)</script> time. But, we could easily find the sum in O(1) time by storing the cumulative sum from the beginning(Memoization). After we have stored the cumulative sum in <script type="math/tex; mode=display">\\text{sums}</script>, we could easily find the sum of any subarray from <script type="math/tex; mode=display">i</script> to <script type="math/tex; mode=display">j</script>.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>The algorithm is similar to Approach #1.</li>\n<li>The only difference is in the way of finding the sum of subarrays:<ul>\n<li>Create a vector <script type="math/tex; mode=display">\\text{sums}</script> of size of <script type="math/tex; mode=display">\\text{nums}</script>\n</li>\n<li>Initialize <script type="math/tex; mode=display">\\text{sums}[0]=\\text{nums}[0]</script>\n</li>\n<li>Iterate over the <script type="math/tex; mode=display">\\text{sums}</script> vector:<ul>\n<li>Update <script type="math/tex; mode=display">\\text{sums}[i] = \\text{sums}[i-1] + \\text{nums}[i]</script>\n</li>\n</ul>\n</li>\n<li>Sum of subarray from <script type="math/tex; mode=display">i</script> to <script type="math/tex; mode=display">j</script> is calculated as:\n<script type="math/tex; mode=display">\\text{sum}=\\text{sums}[j] - \\text{sums}[i] +\\text{nums}[i]</script>, , wherein <script type="math/tex; mode=display">\\text{sums}[j] - \\text{sums}[i]</script> is the sum from (<script type="math/tex; mode=display">i+1</script>)th element to the <script type="math/tex; mode=display">j</script>th element.</li>\n</ul>\n</li>\n</ul>\n<iframe frameborder="0" height="411" name="zpQxiiBt" src="https://leetcode.com/playground/zpQxiiBt/shared" width="100%"></iframe>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O(n^2)</script>.</p>\n<ul>\n<li>Time complexity to find all the subarrays is <script type="math/tex; mode=display">O(n^2)</script>.</li>\n<li>Sum of the subarrays is calculated in <script type="math/tex; mode=display">O(1)</script> time.</li>\n<li>Thus, the total time complexity: <script type="math/tex; mode=display">O(n^2 * 1) = O(n^2)</script>\n</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(n)</script> extra space.</p>\n<ul>\n<li>Additional <script type="math/tex; mode=display">O(n)</script> space for <script type="math/tex; mode=display">\\text{sums}</script> vector than in Approach #1.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-binary-search-accepted">Approach #3 Using Binary search [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We could further improve the Approach #2 using the binary search. Notice that we find the subarray with <script type="math/tex; mode=display">\\text{sum} >=\\text{s}</script> starting with an index <script type="math/tex; mode=display">i</script> in <script type="math/tex; mode=display">O(n)</script> time. But, we could reduce the time to <script type="math/tex; mode=display">O(\\log(n))</script> using binary search. Note that in Approach #2, we search for subarray starting with index <script type="math/tex; mode=display">i</script>, until we find <script type="math/tex; mode=display">\\text{sum}=\\text{sums}[j] - \\text{sums}[i] +\\text{nums}[i]</script> that is greater than <script type="math/tex; mode=display">\\text{s}</script>. So, instead of iterating linearly to find the sum, we could use binary search to find the index that is not lower than  <script type="math/tex; mode=display">\\text{s}-\\text{sums[i]}</script> in the <script type="math/tex; mode=display">\\text{sums}</script>, which can be done using <script type="math/tex; mode=display">\\text{lower_bound}</script> function in C++ STL or could be implemented manually.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>Create vector <script type="math/tex; mode=display">sums</script> of size <script type="math/tex; mode=display">n+1</script> with :\n<script type="math/tex; mode=display">\\text{sums}[0]=0\\text{, }\\text{sums}[i]=\\text{sums}[i-1]+\\text{nums}[i-1]</script>\n</p>\n</li>\n<li>\n<p>Iterate from <script type="math/tex; mode=display">i=1</script> to <script type="math/tex; mode=display">n</script>:</p>\n<ul>\n<li>Find the value <script type="math/tex; mode=display">\\text{to_find}</script> in <script type="math/tex; mode=display">\\text{sum}</script> required for minimum subarray starting from index <script type="math/tex; mode=display">i</script> to have sum greater than <script type="math/tex; mode=display">s</script>, that is:\n<script type="math/tex; mode=display">\\text{to_find}=\\text{s}+\\text{sums}[i-1]</script>\n</li>\n<li>Find the index in <script type="math/tex; mode=display">\\text{sums}</script> such that value at that index is not lower than the <script type="math/tex; mode=display">\\text{to_find}</script> value, say <script type="math/tex; mode=display">\\text{bound}</script>\n</li>\n<li>If we find the <script type="math/tex; mode=display">\\text{to_find}</script> in <script type="math/tex; mode=display">\\text{sums}</script>, then:<ul>\n<li>Size of current subarray is given by:\n  <script type="math/tex; mode=display">\\text{bound} - (\\text{sums.begin}()+i-1)</script>\n</li>\n<li>Compare <script type="math/tex; mode=display">ans</script> with the current subarray size and store minimum in <script type="math/tex; mode=display">ans</script>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<iframe frameborder="0" height="411" name="hVhQq7az" src="https://leetcode.com/playground/hVhQq7az/shared" width="100%"></iframe>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>Time complexity: <script type="math/tex; mode=display">O(n\\log(n))</script>.<ul>\n<li>For each element in the vector, find the subarray starting from that index, and having sum greater than <script type="math/tex; mode=display">s</script> using binary search. Hence, the time required is <script type="math/tex; mode=display">O(n)</script> for iteration over the vector and <script type="math/tex; mode=display">O(\\log(n))</script> for finding the subarray for each index using binary search.</li>\n<li>Therefore, total time complexity = <script type="math/tex; mode=display">O(n*\\log(n))</script>\n</li>\n</ul>\n</li>\n<li>Space complexity: <script type="math/tex; mode=display">O(n)</script>. Additional <script type="math/tex; mode=display">O(n)</script> space for <script type="math/tex; mode=display">\\text{sums}</script> vector</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-2-pointers-accepted">Approach #4 Using 2 pointers [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Until now, we have kept the starting index of subarray fixed, and found the last position. Instead, we could move the starting index of the current subarray as soon as we know that no better could be done with this index as the starting index. We could keep 2 pointer,one for the start and another for the end of the current subarray, and make optimal moves so as to keep the <script type="math/tex; mode=display">\\text{sum}</script> greater than <script type="math/tex; mode=display">s</script> as well as maintain the lowest size possible.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>Initialize <script type="math/tex; mode=display">\\text{left}</script> pointer to 0 and <script type="math/tex; mode=display">\\text{sum}</script> to 0</li>\n<li>Iterate over the <script type="math/tex; mode=display">\\text{nums}</script>:<ul>\n<li>Add <script type="math/tex; mode=display">\\text{nums}[i]</script> to <script type="math/tex; mode=display">\\text{sum}</script>\n</li>\n<li>While <script type="math/tex; mode=display">\\text{sum}</script> is greater than or equal to <script type="math/tex; mode=display">s</script>:<ul>\n<li>Update <script type="math/tex; mode=display">\\text{ans}=\\min(\\text{ans},i+1-\\text{left})</script>, where <script type="math/tex; mode=display">i+1-\\text{left}</script> is the size of current subarray</li>\n<li>It means that the first index can safely be incremented, since, the minimum subarray starting with this index with <script type="math/tex; mode=display">\\text{sum} \\geq s</script> has been achieved</li>\n<li>Subtract <script type="math/tex; mode=display">\\text{nums[left]}</script> from <script type="math/tex; mode=display">\\text{sum}</script> and increment <script type="math/tex; mode=display">\\text{left}</script>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<iframe frameborder="0" height="309" name="TxnK5kAo" src="https://leetcode.com/playground/TxnK5kAo/shared" width="100%"></iframe>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>Time complexity: <script type="math/tex; mode=display">O(n)</script>. Single iteration of <script type="math/tex; mode=display">O(n)</script>.<ul>\n<li>Each element can be visited atmost twice, once by the right pointer(<script type="math/tex; mode=display">i</script>) and (atmost)once by the <script type="math/tex; mode=display">\\text{left}</script> pointer.</li>\n</ul>\n</li>\n<li>Space complexity: <script type="math/tex; mode=display">O(1)</script> extra space. Only constant space required for <script type="math/tex; mode=display">\\text{left}</script>, <script type="math/tex; mode=display">\\text{sum}</script>, <script type="math/tex; mode=display">\\text{ans}</script> and <script type="math/tex; mode=display">i</script>.</li>\n</ul>\n<hr>\n<p>Analysis written by <a href="https://leetcode.com/abhinavbansal0">@abhinavbansal0</a>.</p>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '210',
    name: 'Course Schedule II',
    acceptance: '29.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nThere are a total of <i>n</i> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.</p>\n\n<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>\n\n<p>\nGiven the total number of courses and a list of prerequisite <b>pairs</b>, return the ordering of courses you should take to finish all courses.</p>\n\n<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.\n</p>\n\n<p>For example:</p>\n<pre>2, [[1,0]]</pre>\n<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is <code>[0,1]</code></p>\n\n<pre>4, [[1,0],[2,0],[3,1],[3,2]]</pre>\n<p>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is <code>[0,1,2,3]</code>. Another correct ordering is<code>[0,2,1,3]</code>.</p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The input prerequisites is a graph represented by <b>a list of edges</b>, not adjacency matrices. Read more about <a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs" target="_blank">how a graph is represented</a>.</li>\n<li>You may assume that there are no duplicate edges in the input prerequisites.</li>\n</ol>\n<p></p>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show more hints.</a></p>\n\n<div class="spoilers"><b>Hints:</b>\n<ol>\n<li>This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.</li>\n<li><a href="https://class.coursera.org/algo-003/lecture/52" target="_blank">Topological Sort via DFS</a> - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.</li>\n<li>Topological sort could also be done via <a href="http://en.wikipedia.org/wiki/Topological_sorting#Algorithms" target="_blank">BFS</a>.</li>\n</ol>\n</div>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Zenefits'],
  },
  {
    id: '211',
    name: 'Add and Search Word - Data structure design',
    acceptance: '24.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nDesign a data structure that supports the following two operations:\n</p>\n<pre>void addWord(word)\nbool search(word)\n</pre>\n\n<p>\nsearch(word) can search a literal word or a regular expression string containing only letters <code>a-z</code> or <code>.</code>. A <code>.</code> means it can represent any one letter.</p>\n\n<p>\nFor example:</p>\n<pre>addWord("bad")\naddWord("dad")\naddWord("mad")\nsearch("pad") -&gt; false\nsearch("bad") -&gt; true\nsearch(".ad") -&gt; true\nsearch("b..") -&gt; true\n</pre>\n\n<p>\n<b>Note:</b><br>\nYou may assume that all words are consist of lowercase letters <code>a-z</code>.\n</p>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show hint.</a></p>\n\n<div class="spoilers">You should be familiar with how a Trie works. If not, please work on this problem: <a href="https://leetcode.com/problems/implement-trie-prefix-tree/">Implement Trie (Prefix Tree)</a> first.\n</div>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook'],
  },
  {
    id: '212',
    name: 'Word Search II',
    acceptance: '24.1%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a 2D board and a list of words from the dictionary, find all words in the board.\n</p>\n<p>\nEach word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n</p>\n\n<p>\nFor example,<br>\nGiven <b>words</b> = <code>["oath","pea","eat","rain"]</code> and <b>board</b> = \n</p><pre>[\n  [\'<span style="color:#d70">o</span>\',\'<span style="color:#d70">a</span>\',\'a\',\'n\'],\n  [\'e\',\'<span style="color:#d30">t</span>\',\'<span style="color:#d00">a</span>\',\'<span style="color:#d00">e</span>\'],\n  [\'i\',\'<span style="color:#d70">h</span>\',\'k\',\'r\'],\n  [\'i\',\'f\',\'l\',\'v\']\n]\n</pre>\n\nReturn <code>["eat","oath"]</code>.\n<p></p>\n\n<p>\n<b>Note:</b><br>\nYou may assume that all inputs are consist of lowercase letters <code>a-z</code>.\n</p>\n\n<p class="showspoilers"><a href="#" onclick="showSpoilers(this); return false;">click to show hint.</a></p>\n\n<div class="spoilers"><p>You would need to optimize your backtracking to pass the larger test. Could you stop backtracking earlier?</p>\n\n<p>If the current candidate does not exist in all words\' prefix, you could stop backtracking immediately. What kind of data structure could answer such query efficiently? Does a hash table work? Why or why not? How about a Trie? If you would like to learn how to implement a basic trie, please work on this problem: <a href="https://leetcode.com/problems/implement-trie-prefix-tree/">Implement Trie (Prefix Tree)</a> first.</p>\n</div>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Microsoft', 'Airbnb'],
  },
  {
    id: '213',
    name: 'House Robber II',
    acceptance: '34.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p><b>Note:</b> This is an extension of <a href="https://leetcode.com/problems/house-robber/">House Robber</a>.</p>\n\n<p>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street. </p>\n\n<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/Freezen">@Freezen</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft'],
  },
  {
    id: '214',
    name: 'Shortest Palindrome',
    acceptance: '24.8%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.\n</p>\n\n<p>For example: </p>\n<p>Given <code>"aacecaaa"</code>, return <code>"aaacecaaa"</code>.</p>\n<p>Given <code>"abcd"</code>, return <code>"dcbabcd"</code>.</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/ifanchu">@ifanchu</a> for adding this problem and creating all test cases. Thanks to <a href="https://leetcode.com/discuss/user/Freezen">@Freezen</a> for additional test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1 Brute force [Accepted]</a></li>\n<li><a href="#approach-2-two-pointers-and-recursion-accepted">Approach #2 Two pointers and recursion [Accepted]</a></li>\n<li><a href="#approach-3-kmp-accepted">Approach #3 KMP [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-accepted">Approach #1 Brute force [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>According to the question, we are allowed to insert the characters only at the beginning of the string. Hence, we can find the largest segment from the beginning that is a palindrome, and we can then easily reverse the remaining segment and append to the beginning. This must be the required answer as no shorter palindrome could be found than this by just appending at the beginning.</p>\n<p>For example: Take the string <script type="math/tex; mode=display">\\text{"abcbabcab"}</script>. Here, the largest palindrome segment from beginning is <script type="math/tex; mode=display">\\text{"abcba"}</script>, and the remaining segment is <script type="math/tex; mode=display">\\text{"bcab"}</script>. Hence the required string is reverse of <script type="math/tex; mode=display">\\text{"bcab"}</script>( = <script type="math/tex; mode=display">\\text{"bacb"}</script>) + original string( = <script type="math/tex; mode=display">\\text{"abcbabcab"}</script>) = <script type="math/tex; mode=display">\\text{"bacbabcbabcab"}</script>.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>Create the reverse of the original string <script type="math/tex; mode=display">s</script>, say <script type="math/tex; mode=display">\\text{rev}</script>. This is used for comparison to find the largest palindrome segment from the front.</li>\n<li>Iterate over the variable <script type="math/tex; mode=display">i</script> from 0 to the <script type="math/tex; mode=display">\\text{size(s)}-1</script>:<ul>\n<li>If <script type="math/tex; mode=display">s[0:n-i] == rev[i:]</script> (i.e. substring of <script type="math/tex; mode=display">s</script> from <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">n-i</script> is equal to the substring of <script type="math/tex; mode=display">\\text{rev}</script> from <script type="math/tex; mode=display">i</script> to the end of string). This essentially means that that substring from <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">n-i</script> is a palindrome, as <script type="math/tex; mode=display">\\text{rev}</script> is the reverse of <script type="math/tex; mode=display">s</script>.</li>\n<li>Since, we find the larger palindromes first, we can return reverse of largest palindrome + <script type="math/tex; mode=display">s</script> as soon as we get it.</li>\n</ul>\n</li>\n</ul>\n<iframe frameborder="0" height="258" name="ofq6FrQW" src="https://leetcode.com/playground/ofq6FrQW/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O(n^2)</script>.</p>\n<ul>\n<li>We iterate over the entire length of string <script type="math/tex; mode=display">s</script>.</li>\n<li>In each iteration, we compare the substrings which is linear in size of substrings to be compared.</li>\n<li>Hence, the total time complexity is <script type="math/tex; mode=display">O(n*n) = O(n^2)</script>.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(n)</script> extra space for the reverse string <script type="math/tex; mode=display">\\text{rev}</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-two-pointers-and-recursion-accepted">Approach #2 Two pointers and recursion [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>In Approach #1, we found the largest palindrome substring from the string using substring matching which is <script type="math/tex; mode=display">O(n)</script> in length of substring. We could make the process more efficient if we could reduce the size of string to search for the substring without checking the complete substring each time.</p>\n<p>Lets take a string <script type="math/tex; mode=display">\\text{"abcbabcaba"}</script>. Let us consider 2 pointers <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script>.\nInitialize <script type="math/tex; mode=display">i = 0</script>. Iterate over <script type="math/tex; mode=display">j</script> from <script type="math/tex; mode=display">n-1</script> to <script type="math/tex; mode=display">0</script>, incrementing <script type="math/tex; mode=display">i</script> each time <script type="math/tex; mode=display">\\text{s[i]==s[j]}</script>. Now, we just need to search in range <script type="math/tex; mode=display">\\text[0,i)</script>. This way, we have reduced the size of string to search for the largest palindrome substring from the beginning. The range <script type="math/tex; mode=display">\\text{[0,i)}</script> must always contain the largest palindrome substring. The proof of correction is that: Say the string was a perfect palindrome, <script type="math/tex; mode=display">i</script> would be incremented <script type="math/tex; mode=display">n</script> times. Had there been other characters at the end, <script type="math/tex; mode=display">i</script> would still be incremented by the size of the palindrome. Hence, even though there is a chance that the range <script type="math/tex; mode=display">\\text{[0,i)}</script> is not always tight, it is ensured that it will always contain the longest palindrome from the beginning.  </p>\n<p>The best case for the algorithm is when the entire string is palindrome and the worst case is string like <script type="math/tex; mode=display">\\text{"aababababababa"}</script>, wherein <script type="math/tex; mode=display">i</script> first becomes <script type="math/tex; mode=display">12</script>(check by doing on paper), and we need to recheck in [0,12) corresponding to string <script type="math/tex; mode=display">\\text{"aabababababa"}</script>. Again continuing in the same way, we get <script type="math/tex; mode=display">{i=10}</script>.  In such a case, the string is reduced only by as few as 2 elements at each step. Hence, the number of steps in such cases is linear(<script type="math/tex; mode=display">n/2</script>).</p>\n<p>This reduction of length could be easily done with the help of a recursive routine, as shown in the algorithm section.</p>\n<p><strong>Algorithm</strong></p>\n<p>The routine <script type="math/tex; mode=display">\\text{shortestPalindrome}</script> is recursive and takes string <script type="math/tex; mode=display">s</script> as parameter:</p>\n<ul>\n<li>Initialize <script type="math/tex; mode=display">i=0</script>\n</li>\n<li>Iterate over <script type="math/tex; mode=display">j</script> from <script type="math/tex; mode=display">n-1</script> to <script type="math/tex; mode=display">0</script>:<ul>\n<li>If <script type="math/tex; mode=display">\\text{s[i]==s[j]}</script>, increase <script type="math/tex; mode=display">i</script> by <script type="math/tex; mode=display">1</script>\n</li>\n</ul>\n</li>\n<li>If <script type="math/tex; mode=display">i</script> equals the size of <script type="math/tex; mode=display">s</script>, the entire string is palindrome, and hence return the entire string <script type="math/tex; mode=display">s</script>.</li>\n<li>Else:<ul>\n<li>Return reverse of remaining substring after <script type="math/tex; mode=display">i</script> to the end of string + <script type="math/tex; mode=display">\\text{shortestPalindrome}</script> routine on substring from start to index <script type="math/tex; mode=display">i-1</script> + remaining substring after <script type="math/tex; mode=display">i</script> to the end of string.</li>\n</ul>\n</li>\n</ul>\n<iframe frameborder="0" height="292" name="zeLz2M4w" src="https://leetcode.com/playground/zeLz2M4w/shared" width="100%"></iframe>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>Time complexity: <script type="math/tex; mode=display">O(n^2)</script>.<ul>\n<li>Each iteration of <script type="math/tex; mode=display">\\text{shortestPalindrome}</script> is linear in size of substring and the maximum number of recursive calls can be <script type="math/tex; mode=display">n/2</script> times as shown in the Intuition section.</li>\n<li>Let the time complexity of the algorithm be T(n). Since, at the each step for the worst case, the string can be divide into 2 parts and we require only one part for further computation. Hence, the time complexity for the worst case can be represented as : <script type="math/tex; mode=display">T(n)=T(n-2)+O(n)</script>. So, <script type="math/tex; mode=display">T(n) = O(n) + O(n-2) + O(n-4) + ... + O(1)</script> which is  <script type="math/tex; mode=display">O(n^2)</script>.</li>\n</ul>\n</li>\n</ul>\n<p>Thanks @CONOVER for the time complexity analysis.</p>\n<ul>\n<li>Space complexity: <script type="math/tex; mode=display">O(n)</script> extra space for <script type="math/tex; mode=display">\\text{remain_rev}</script> string.</li>\n</ul>\n<hr>\n<h4 id="approach-3-kmp-accepted">Approach #3 KMP [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We have seen that the question boils down to  finding the largest palindrome substring from the beginning.</p>\n<p>The people familiar with KMP(Knuth–Morris–Pratt) algorithm may wonder that the task at hand can be easily be compared with the concept of the lookup table in KMP.</p>\n<p><em>KMP Overview:</em></p>\n<p>KMP is a string matching algorithm that runs in <script type="math/tex; mode=display">O(n+m)</script> times, where <script type="math/tex; mode=display">n</script> and <script type="math/tex; mode=display">m</script> are sizes of the text and string to be searched respectively. The key component of KMP is the failure function lookup table,say <script type="math/tex; mode=display">f(s)</script>. The purpose of the lookup table is to store the length of the proper prefix of the string <script type="math/tex; mode=display">b_{1}b_{2}...b_{s}</script> that is also a suffix of <script type="math/tex; mode=display">b_{1}b_{2}...b_{s}</script>. This table is important because if we are trying to match a text string for <script type="math/tex; mode=display">b_{1}b_{2}...b_{n}</script>, and we have matched the first <script type="math/tex; mode=display">s</script> positions, but when we fail, then the value of lookup table for <script type="math/tex; mode=display">s</script> is the longest prefix of <script type="math/tex; mode=display">b_{1}b_{2}...b_{n}</script> that could possibly match the text string upto the point we are at. Thus, we don\'t need to start all over again, and can resume searching from the matching prefix.</p>\n<p>The algorithm to generate the lookup table is easy and inutitive, as given below:</p>\n<div class="codehilite"><pre><span></span>f(0) = 0\nfor(i = 1; i &lt; n; i++)\n{\n    t = f(i-1)\n    while(t &gt; 0 &amp;&amp; b[i] != b[t])\n        t = f(t-1)\n    if(b[i] == b[t]){\n        ++t\n    f(i) = t\n}\n</pre></div>\n<ul>\n<li>Here, we first set f(0)=0 since, no proper prefix is available.</li>\n<li>Next, iterate over <script type="math/tex; mode=display">i</script> from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n-1</script>:<ul>\n<li>Set <script type="math/tex; mode=display">t=f(i-1)</script>\n</li>\n<li>While t&gt;0 and char at <script type="math/tex; mode=display">i</script> doesn\'t match the char at <script type="math/tex; mode=display">t</script> position, set <script type="math/tex; mode=display">t=f(t)</script>, which essentially means that we have problem matching and must consider a shorter prefix, which will be <script type="math/tex; mode=display">b_{f(t-1)}</script>, until we find a match or t becomes 0.</li>\n<li>If <script type="math/tex; mode=display">b_{i}==b_{t}</script>, add 1 to t</li>\n<li>Set <script type="math/tex; mode=display">f(i)=t</script>\n</li>\n</ul>\n</li>\n</ul>\n<p>The lookup table generation is as illustrated below:</p>\n<p align="center"><img alt="KMP" src="https://leetcode.com/articles/Figures/214/shortest_palindrome.png" width="600px"></p>\n<p><em>Wait! I get it!!</em></p>\n<p>In Approach #1, we reserved the original string <script type="math/tex; mode=display">s</script> and stored it as <script type="math/tex; mode=display">\\text{rev}</script>. We iterate over <script type="math/tex; mode=display">i</script> from <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">n-1</script> and check for <script type="math/tex; mode=display">s[0:n-i] == rev[i:]</script>.\nPondering over this statement, had the <script type="math/tex; mode=display">\\text{rev}</script> been concatenated to <script type="math/tex; mode=display">s</script>, this statement is just finding the longest prefix that is equal to the suffix. Voila!</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>We use the KMP lookup table generation</li>\n<li>Create <script type="math/tex; mode=display">\\text{new_s}</script> as <script type="math/tex; mode=display">s + \\text{"#"} + \\text{reverse(s)}</script> and use the string in the lookup-generation algorithm<ul>\n<li>The "#" in the middle is required, since without the #, the  2 strings could mix with each ther, producing wrong answer. For example, take the string <script type="math/tex; mode=display">\\text{"aaaa"}</script>. Had we not inserted "#" in the middle, the new string would be <script type="math/tex; mode=display">\\text{"aaaaaaaa"}</script> and the largest prefix size would be 7 corresponding to "aaaaaaa" which would be obviously wrong. Hence, a delimiter is required at the middle.</li>\n</ul>\n</li>\n<li>Return reversed string after the largest palindrome from beginning length(given by <script type="math/tex; mode=display">n-\\text{f[n_new-1]}</script>) + original string <script type="math/tex; mode=display">s</script>\n</li>\n</ul>\n<iframe frameborder="0" height="360" name="Uu5sN23P" src="https://leetcode.com/playground/Uu5sN23P/shared" width="100%"></iframe>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O(n)</script>.</p>\n<ul>\n<li>In every iteration of the inner while loop, <script type="math/tex; mode=display">t</script> decreases until it reaches 0 or until it matches. After that, it is incremented by one. Therefore, in the worst case, <script type="math/tex; mode=display">t</script> can only be decreased up to <script type="math/tex; mode=display">n</script> times and increased up to <script type="math/tex; mode=display">n</script> times.</li>\n<li>Hence, the algorithm is linear with maximum <script type="math/tex; mode=display">(2 * n) * 2</script> iterations.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(n)</script>. Additional space for the reverse string and the concatenated string.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by <a href="https://leetcode.com/abhinavbansal0">@abhinavbansal0</a>.</p>\n</div>\n          ',
    tags: ['Google', 'Pocket Gems'],
  },
  {
    id: '215',
    name: 'Kth Largest Element in an Array',
    acceptance: '40.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            Find the <b>k</b>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n\n<p>For example,<br>\nGiven <code>[3,2,1,5,6,4]</code> and k = 2, return 5.\n</p>\n\n<p><b>Note: </b><br>\nYou may assume k is always valid, 1 ≤ k ≤ array\'s length.</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/mithmatt">@mithmatt</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Amazon', 'Bloomberg', 'Apple', 'Pocket Gems'],
  },
  {
    id: '216',
    name: 'Combination Sum III',
    acceptance: '46.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <div>\n<p>Find all possible combinations of <i><b>k</b></i> numbers that add up to a number <i><b>n</b></i>, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>\n</div>\n<div>\n<br>\n<p> <i><b>Example 1:</b></i></p>\n<p>Input:  <i><b>k</b></i> = 3,  <i><b>n</b></i> = 7</p>\n<p>Output: </p>\n<p></p><pre>[[1,2,4]]\n</pre><p></p>\n<br>\n<p> <i><b>Example 2:</b></i></p>\n<p>Input:  <i><b>k</b></i> = 3,  <i><b>n</b></i> = 9</p>\n<p>Output: </p>\n<p></p><pre>[[1,2,6], [1,3,5], [2,3,4]]\n</pre><p></p>\n</div>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/mithmatt">@mithmatt</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '217',
    name: 'Contains Duplicate',
    acceptance: '46.4%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-naive-linear-search-time-limit-exceeded">Approach #1 (Naive Linear Search) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-sorting-accepted">Approach #2 (Sorting) [Accepted]</a></li>\n<li><a href="#approach-3-hash-table-accepted">Approach #3 (Hash Table) [Accepted]</a></li>\n</ul>\n</li>\n<li><a href="#see-also">See Also</a></li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This article is for beginners. It introduces the following ideas:\nLoop Invariant, Linear Search, Sorting and Hash Table.</p>\n<h2 id="solution">Solution</h2>\n<h4 id="approach-1-naive-linear-search-time-limit-exceeded">Approach #1 (Naive Linear Search) [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>For an array of <script type="math/tex; mode=display">n</script> integers, there are <script type="math/tex; mode=display">C(n,2) = \\frac{n(n+1)}{2}</script> pairs of integers. Thus, we may check all <script type="math/tex; mode=display">\\frac{n(n+1)}{2}</script> pairs and see if there is any pair with duplicates.</p>\n<p><strong>Algorithm</strong></p>\n<p>To apply this idea, we employ the linear search algorithm which is the simplest search algorithm. Linear search is a method of finding if a particular value is in a list by checking each of its elements, one at a time and in sequence until the desired one is found.</p>\n<p>For our problem, we loop through all <script type="math/tex; mode=display">n</script> integers. For the <script type="math/tex; mode=display">i</script>th integer <code>nums[i]</code>, we search in the previous <code>i-1</code> integers for the duplicate of <code>nums[i]</code>. If we find one, we return true; if not, we continue. Return false at the end of the program.</p>\n<p>To prove the correctness of the algorithm, we define the loop invariant. A loop invariant is a property that holds before (and after) each iteration. Knowing its invariant(s) is essential for understanding the effect of a loop. Here is the <em>loop invariant</em>:</p>\n<blockquote>\n<p>Before the next search, there are no duplicate integers in the searched integers.</p>\n</blockquote>\n<p>The loop invariant holds true before the loop because there is no searched integer.\nEach time through the loop we look for any any possible duplicate of the current element.\nIf we found a duplicate, the function exits by returning true; If not, the invariant still holds true.</p>\n<p>Therefore, if the loop finishes, the invariant tells us that there is no duplicate in all <script type="math/tex; mode=display">n</script> integers.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>  \n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n<span class="o">}</span>\n<span class="c1">// Time Limit Exceeded</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. In the worst case, there are <script type="math/tex; mode=display">\\frac{n(n+1)}{2}</script> pairs of integers to check. Therefore, the time complexity is <script type="math/tex; mode=display">O(n^2)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.\nWe only used constant extra space.</p>\n</li>\n</ul>\n<p><strong>Note</strong></p>\n<p>This approach will get Time Limit Exceeded on LeetCode. Usually, if an algorithm is <script type="math/tex; mode=display">O(n^2)</script>, it can handle <script type="math/tex; mode=display">n</script> up to around <script type="math/tex; mode=display">10^4</script>. It gets Time Limit Exceeded when <script type="math/tex; mode=display">n \\geq 10^5</script>.</p>\n<hr>\n<h4 id="approach-2-sorting-accepted">Approach #2 (Sorting) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If there are any duplicate integers, they will be consecutive after sorting.</p>\n<p><strong>Algorithm</strong></p>\n<p>This approach employs sorting algorithm. Since comparison sorting algorithm like <em>heapsort</em> is known to provide <script type="math/tex; mode=display">O(n \\log n)</script> worst-case performance, sorting is often a good preprocessing step. After sorting, we can sweep the sorted array to find if there are any two consecutive duplicate elements.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n \\log n)</script>.\nSorting is <script type="math/tex; mode=display">O(n \\log n)</script> and the sweeping is <script type="math/tex; mode=display">O(n)</script>. The entire algorithm is dominated by the sorting step, which is <script type="math/tex; mode=display">O(n \\log n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.\nSpace depends on the sorting implementation which, usually, costs <script type="math/tex; mode=display">O(1)</script> auxiliary space if <code>heapsort</code> is used.</p>\n</li>\n</ul>\n<p><strong>Note</strong></p>\n<p>The implementation here modifies the original array by sorting it. In general, it is not a good practice to modify the input unless it is clear to the caller that the input will be modified. One may make a copy of <code>nums</code> and operate on the copy instead.</p>\n<hr>\n<h4 id="approach-3-hash-table-accepted">Approach #3 (Hash Table) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Utilize a dynamic data structure that supports fast search and insert operations.</p>\n<p><strong>Algorithm</strong></p>\n<p>From <a href="#approach-1-naive-linear-search-time-limit-exceeded">Approach #1</a> we know that search operations is <script type="math/tex; mode=display">O(n)</script> in an unsorted array and we did so repeatedly. Utilizing a data structure with faster search time will speed up the entire algorithm.</p>\n<p>There are many data structures commonly used as dynamic sets such as Binary Search Tree and Hash Table. The operations we need to support here are <code>search()</code> and <code>insert()</code>. For a self-balancing Binary Search Tree (TreeSet or TreeMap in Java), <code>search()</code> and <code>insert()</code> are both <script type="math/tex; mode=display">O(\\log n)</script> time. For a Hash Table (HashSet or HashMap in Java), <code>search()</code> and <code>insert()</code> are both <script type="math/tex; mode=display">O(1)</script> on average. Therefore, by using hash table, we can achieve linear time complexity for finding the duplicate in an unsorted array.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nWe do <code>search()</code> and <code>insert()</code> for <script type="math/tex; mode=display">n</script> times and each operation takes constant time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>.\nThe space used by a hash table is linear with the number of elements in it.</p>\n</li>\n</ul>\n<p><strong>Note</strong></p>\n<p>For certain test cases with not very large <script type="math/tex; mode=display">n</script>, the runtime of this method can be slower than <a href="#approach-2-sorting-accepted">Approach #2</a>. The reason is hash table has some overhead in maintaining its property. One should keep in mind that real world performance can be different from what the Big-O notation says. The Big-O notation only tells us that for <em>sufficiently</em> large input, one will be faster than the other. Therefore, when <script type="math/tex; mode=display">n</script> is not sufficiently large, an <script type="math/tex; mode=display">O(n)</script> algorithm can be slower than an <script type="math/tex; mode=display">O(n \\log n)</script> algorithm.</p>\n<h2 id="see-also">See Also</h2>\n<ul>\n<li><a href="https://leetcode.com/articles/contains-duplicate-ii/">Problem 219 Contains Duplicate II</a></li>\n<li><a href="https://leetcode.com/articles/contains-duplicate-iii/">Problem 220 Contains Duplicate III</a></li>\n</ul>\n</div>\n          ',
    tags: ['Airbnb', 'Yahoo', 'Palantir'],
  },
  {
    id: '218',
    name: 'The Skyline Problem',
    acceptance: '28.4%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>A city\'s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are <b>given the locations and height of all the buildings</b> as shown on a cityscape photo (Figure A), write a program to <b>output the skyline</b> formed by these buildings collectively (Figure B).</p>\n\n<!-- Cityscape -->\n<a href="/static/images/problemset/skyline1.jpg" target="_blank">\n    <img style=" max-width: 45%;" src="/static/images/problemset/skyline1.jpg" border="0" alt="Buildings">\n</a>\n\n<!-- Use this image for the \'turning point\' description of skyline -->\n<a href="/static/images/problemset/skyline2.jpg" target="_blank">\n    <img style="max-width: 45%;" src="/static/images/problemset/skyline2.jpg" border="0" alt="Skyline Contour">\n</a>\n\n<!-- Use the following image if we\'d like to define the output as \'horizontal lines\' rather than \'turning points\'-->\n<!--\n<a href="http://tinypic.com?ref=mij3wi" target="_blank">\n<img style="max-width: 45%;" src="http://i59.tinypic.com/mij3wi.jpg" border="0" alt="Skyline Contour">\n</a>\n-->\n\n<p>The geometric information of each building is represented by a triplet of integers <code>[Li, Ri, Hi]</code>, where <code>Li</code> and <code>Ri</code> are the x coordinates of the left and right edge of the ith building, respectively, and <code>Hi</code> is its height. It is guaranteed that <code>0 ≤ Li, Ri ≤ INT_MAX</code>, <code>0 &lt; Hi ≤ INT_MAX</code>, and <code>Ri - Li &gt; 0</code>. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p>\n\n<p>For instance, the dimensions of all buildings in Figure A are recorded as: <code>[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] </code>.</p>\n\n<p>The output is a list of "<b>key points</b>" (red dots in Figure B) in the format of <code>[ [x1,y1], [x2, y2], [x3, y3], ... ]</code> that uniquely defines a skyline. <b>A key point is the left endpoint of a horizontal line segment</b>. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.\n\n</p><p>For instance, the skyline in Figure B should be represented as:<code>[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]</code>.</p>\n\n<p><b>Notes:</b>\n</p><ul>\n<li> The number of buildings in any input list is guaranteed to be in the range <code>[0, 10000]</code>.</li>\n<li> The input list is already sorted in ascending order by the left x position <code>Li</code>. </li>\n<li> The output list must be sorted by the x position. </li>\n<li> There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code> is not acceptable; the three lines of height 5 should be merged into one in the final output as such: <code>[...[2 3], [4 5], [12 7], ...]</code></li>\n</ul>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/stellari">@stellari</a> for adding this problem, creating these two awesome images and all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Microsoft', 'Twitter', 'Yelp'],
  },
  {
    id: '219',
    name: 'Contains Duplicate II',
    acceptance: '32.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array of integers and an integer <i>k</i>, find out whether there are two distinct indices <i>i</i> and <i>j</i> in the array such that <b>nums[i] = nums[j]</b> and the <b>absolute</b> difference between <i>i</i> and <i>j</i> is at most <i>k</i>.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-naive-linear-search-time-limit-exceeded">Approach #1 (Naive Linear Search) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-binary-search-tree-time-limit-exceeded">Approach #2 (Binary Search Tree) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-hash-table-accepted">Approach #3 (Hash Table) [Accepted]</a></li>\n</ul>\n</li>\n<li><a href="#see-also">See Also</a></li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This article is for beginners. It introduces the following ideas:\nLinear Search, Binary Search Tree and Hash Table.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-naive-linear-search-time-limit-exceeded">Approach #1 (Naive Linear Search) [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>Look for duplicate element in the previous <script type="math/tex; mode=display">k</script> elements.</p>\n<p><strong>Algorithm</strong></p>\n<p>This algorithm is the same as <a href="https://leetcode.com/articles/contains-duplicate/#approach-1-naive-linear-search-time-limit-exceeded">Approach #1 in Contains Duplicate solution</a>, except that it looks at previous <script type="math/tex; mode=display">k</script> elements instead of all its previous elements.</p>\n<p>Another perspective of this algorithm is to keep a virtual sliding window of the previous <script type="math/tex; mode=display">k</script> elements. We scan for the duplicate in this window.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsNearbyDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n<span class="o">}</span>\n<span class="c1">// Time Limit Exceeded.</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n \\min(k,n))</script>.\nIt costs <script type="math/tex; mode=display">O(\\min(k, n))</script> time for each linear search. Apparently we do at most <script type="math/tex; mode=display">n</script> comparisons in one search even if <script type="math/tex; mode=display">k</script> can be larger than <script type="math/tex; mode=display">n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-binary-search-tree-time-limit-exceeded">Approach #2 (Binary Search Tree) [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>Keep a sliding window of <script type="math/tex; mode=display">k</script> elements using self-balancing Binary Search Tree (BST).</p>\n<p><strong>Algorithm</strong></p>\n<p>The key to improve upon <a href="#approach-1-naive-linear-search-time-limit-exceeded">Approach #1</a> above is to reduce the search time of the previous <script type="math/tex; mode=display">k</script> elements. Can we use an auxiliary data structure to maintain a sliding window of <script type="math/tex; mode=display">k</script> elements with more efficient <code>search</code>, <code>delete</code>, and <code>insert</code> operations? Since elements in the sliding window are strictly First-In-First-Out (FIFO), queue is a natural data structure. A queue using a linked list implementation supports constant time <code>delete</code> and <code>insert</code> operations, however the <code>search</code> costs linear time, which is <em>no better</em> than <a href="#approach-1-naive-linear-search-time-limit-exceeded">Approach #1</a>.</p>\n<p>A better option is to use a self-balancing BST. A BST supports <code>search</code>, <code>delete</code> and <code>insert</code> operations all in <script type="math/tex; mode=display">O(\\log k)</script> time, where <script type="math/tex; mode=display">k</script> is the number of elements in the BST. In most interviews you are not required to implement a self-balancing BST, so you may think of it as a black box. Most programming languages provide implementations of this useful data structure in its standard library. In Java, you may use a <code>TreeSet</code> or a <code>TreeMap</code>. In C++ STL, you may use a <code>std::set</code> or a <code>std::map</code>.</p>\n<p>If you already have such a data structure available, the pseudocode is:</p>\n<ul>\n<li>Loop through the array, for each element do<ul>\n<li>Search current element in the BST, return <code>true</code> if found</li>\n<li>Put current element in the BST</li>\n<li>If the size of the BST is larger than <script type="math/tex; mode=display">k</script>, remove the oldest item.</li>\n</ul>\n</li>\n<li>Return <code>false</code></li>\n</ul>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsNearbyDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeSet</span><span class="o">&lt;&gt;();</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="o">]);</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n<span class="o">}</span>\n<span class="c1">// Time Limit Exceeded.</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n \\log (\\min(k,n)))</script>. We do <script type="math/tex; mode=display">n</script> operations of <code>search</code>, <code>delete</code> and <code>insert</code>. Each operation costs logarithmic time complexity in the sliding window which size is <script type="math/tex; mode=display">\\min(k, n)</script>. Note that even if <script type="math/tex; mode=display">k</script> can be greater than <script type="math/tex; mode=display">n</script>, the window size can never exceed <script type="math/tex; mode=display">n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(\\min(n,k))</script>.\nSpace is the size of the sliding window which should not exceed <script type="math/tex; mode=display">n</script> or <script type="math/tex; mode=display">k</script>.</p>\n</li>\n</ul>\n<p><strong>Note</strong></p>\n<p>The algorithm still gets Time Limit Exceeded for large <script type="math/tex; mode=display">n</script> and <script type="math/tex; mode=display">k</script>.</p>\n<hr>\n<h4 id="approach-3-hash-table-accepted">Approach #3 (Hash Table) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Keep a sliding window of <script type="math/tex; mode=display">k</script> elements using Hash Table.</p>\n<p><strong>Algorithm</strong></p>\n<p>From the previous approaches, we know that even logarithmic performance in <code>search</code> is not enough.\nIn this case, we need a data structure supporting constant time <code>search</code>, <code>delete</code> and <code>insert</code> operations.\nHash Table is the answer. The algorithm and implementation are almost identical to <a href="#approach-2-binary-search-tree-time-limit-exceeded">Approach #2</a>.</p>\n<ul>\n<li>Loop through the array, for each element do<ul>\n<li>Search current element in the HashTable, return <code>true</code> if found</li>\n<li>Put current element in the HashTable</li>\n<li>If the size of the HashTable is larger than <script type="math/tex; mode=display">k</script>, remove the oldest item.</li>\n</ul>\n</li>\n<li>Return <code>false</code></li>\n</ul>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsNearbyDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="o">]);</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nWe do <script type="math/tex; mode=display">n</script> operations of <code>search</code>, <code>delete</code> and <code>insert</code>, each with constant time complexity.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(\\min(n,k))</script>.\nThe extra space required depends on the number of items stored in the hash table, which is the size of the sliding window, <script type="math/tex; mode=display">\\min(n,k)</script>.</p>\n</li>\n</ul>\n<h2 id="see-also">See Also</h2>\n<ul>\n<li><a href="https://leetcode.com/articles/contains-duplicate/">Problem 217 Contains Duplicate</a></li>\n<li><a href="https://leetcode.com/articles/contains-duplicate-iii/">Problem 220 Contains Duplicate III</a></li>\n</ul>\n</div>\n          ',
    tags: ['Airbnb', 'Palantir'],
  },
  {
    id: '220',
    name: 'Contains Duplicate III',
    acceptance: '18.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array of integers, find out whether there are two distinct indices <i>i</i> and <i>j</i> in the array such that the <b>absolute</b> difference between <b>nums[i]</b> and <b>nums[j]</b> is at most <i>t</i> and the <b>absolute</b> difference between <i>i</i> and <i>j</i> is at most <i>k</i>.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solutions">Solutions</a><ul>\n<li><a href="#approach-1-naive-linear-search-time-limit-exceeded">Approach #1 (Naive Linear Search) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-binary-search-tree-accepted">Approach #2 (Binary Search Tree) [Accepted]</a></li>\n<li><a href="#approach-3-buckets-accepted">Approach #3 (Buckets) [Accepted]</a></li>\n</ul>\n</li>\n<li><a href="#see-also">See Also</a></li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This article is for intermediate readers. It introduces the following ideas:\nBinary Search Tree, HashMap, and Buckets.</p>\n<h2 id="solutions">Solutions</h2>\n<hr>\n<h4 id="approach-1-naive-linear-search-time-limit-exceeded">Approach #1 (Naive Linear Search) [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>Compare each element with the previous <script type="math/tex; mode=display">k</script> elements and see if their difference is at most <script type="math/tex; mode=display">t</script>.</p>\n<p><strong>Algorithm</strong></p>\n<p>This problem requires us to find <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> such that the following conditions are satisfied:</p>\n<ol>\n<li><a name="condition-1"></a><script type="math/tex; mode=display">\\bigl| i-j \\bigr| \\le k</script>\n</li>\n<li><a name="condition-2"></a><script type="math/tex; mode=display">\\bigl| \\mathrm{nums}[i] - \\mathrm{nums}[j] \\bigr| \\le t</script>\n</li>\n</ol>\n<p>The naive approach is the same as <a href="https://leetcode.com/articles/contains-duplicate-ii/#approach-1-naive-linear-search-time-limit-exceeded">Approach #1 in Contains Duplicate II solution</a>, which keeps a virtual sliding window that holds the newest <script type="math/tex; mode=display">k</script> elements. In this way, <a href="#condition-1">Condition 1</a> above is always satisfied. We then check if <a href="#condition-2">Condition 2</a> is also satisfied by applying linear search.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsNearbyAlmostDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n<span class="o">}</span>\n<span class="c1">// Time limit exceeded.</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n \\min(k,n))</script>.\nIt costs <script type="math/tex; mode=display">O(\\min(k, n))</script> time for each linear search. Note that we do at most <script type="math/tex; mode=display">n</script> comparisons in one search even if <script type="math/tex; mode=display">k</script> can be larger than <script type="math/tex; mode=display">n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.\nWe only used constant auxiliary space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-binary-search-tree-accepted">Approach #2 (Binary Search Tree) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<ul>\n<li>\n<p>If elements in the window are maintained in sorted order, we can apply binary search twice to check if <a href="#condition-2">Condition 2</a> is satisfied.</p>\n</li>\n<li>\n<p>By utilizing self-balancing Binary Search Tree, one can keep the window ordered at all times with logarithmic time <code>insert</code> and <code>delete</code>.</p>\n</li>\n</ul>\n<p><strong>Algorithm</strong></p>\n<p>The real bottleneck of <a href="#approach-1-naive-linear-search-time-limit-exceeded">Approach #1</a> is due to all elements in the sliding window are being scanned to check if <a href="#condition-2">Condition 2</a> is satisfied. Could we do better?</p>\n<p>If elements in the window are in sorted order, we can apply Binary Search twice to search for the two boundaries <script type="math/tex; mode=display">x+t</script> and <script type="math/tex; mode=display">x-t</script> for each element <script type="math/tex; mode=display">x</script>.</p>\n<p>Unfortunately, the window is unsorted. A common mistake here is attempting to maintain a sorted array. Although searching in a sorted array costs only logarithmic time, keeping the order of the elements after <code>insert</code> and <code>delete</code> operation is not as efficient. Imagine you have a sorted array with <script type="math/tex; mode=display">k</script> elements and you are adding a new item <script type="math/tex; mode=display">x</script>. Even if you can find the correct position in <script type="math/tex; mode=display">O(\\log k)</script> time, you still need <script type="math/tex; mode=display">O(k)</script> time to insert <script type="math/tex; mode=display">x</script> into the sorted array. The reason is that you need to shift all elements after the insert position one step backward. The same reasoning applies to removal as well. After removing an item from position <script type="math/tex; mode=display">i</script>, you need to shift all elements after <script type="math/tex; mode=display">i</script> one step forward. Thus, we gain nothing in speed compared to the <a href="#approach-1-naive-linear-search-time-limit-exceeded">naive linear search approach</a> above.</p>\n<p>To gain an actual speedup, we need a <em>dynamic</em> data structure that supports faster <code>insert</code>, <code>search</code> and <code>delete</code>. Self-balancing Binary Search Tree (BST) is the right data structure. The term <em>Self-balancing</em> means the tree automatically keeps its height small after arbitrary <code>insert</code> and <code>delete</code> operations. Why does self-balancing matter? That is because most operations on a BST take time directly proportional to the height of the tree. Take a look at the following non-balanced BST which is skewed to the left:</p>\n<div class="codehilite"><pre><span></span>            6\n           /\n          5\n         /\n        4\n       /\n      3\n     /\n    2\n   /\n  1\n</pre></div>\n<p><em>Figure 1. A non-balanced BST that is skewed to the left.</em></p>\n<p>Searching in the above BST degrades to <em>linear</em> time, which is like searching in a linked list. Now compare to the BST below which is balanced:</p>\n<div class="codehilite"><pre><span></span>          4\n        /   \\\n       2     6\n      / \\   /\n     1   3  5\n</pre></div>\n<p><em>Figure 2. A balanced BST.</em></p>\n<p>Assume that <script type="math/tex; mode=display">n</script> is the total number of nodes in the tree, a balanced binary tree maintains its height in the order of <script type="math/tex; mode=display">h = \\log n</script>. Thus it supports <script type="math/tex; mode=display">O(h) = O(\\log n)</script> time for each of <code>insert</code>, <code>search</code> and <code>delete</code> operations.</p>\n<p>Here is the entire algorithm in pseudocode:</p>\n<ul>\n<li>Initialize an empty BST <code>set</code></li>\n<li>Loop through the array, for each element <script type="math/tex; mode=display">x</script>\n<ul>\n<li>Find the <em>smallest</em> element <script type="math/tex; mode=display">s</script> in <code>set</code> that is <em>greater</em> than or equal to <script type="math/tex; mode=display">x</script>, return true if <script type="math/tex; mode=display">s - x \\leq t</script>\n</li>\n<li>Find the <em>greatest</em> element <script type="math/tex; mode=display">g</script> in <code>set</code> that is <em>smaller</em> than or equal to <script type="math/tex; mode=display">x</script>, return true if <script type="math/tex; mode=display">x - g \\leq t</script>\n</li>\n<li>Put <script type="math/tex; mode=display">x</script> in <code>set</code></li>\n<li>If the size of the set is larger than <script type="math/tex; mode=display">k</script>, remove the oldest item.</li>\n</ul>\n</li>\n<li>Return false</li>\n</ul>\n<p>One may consider the smallest element <script type="math/tex; mode=display">s</script> that is greater or equal to <script type="math/tex; mode=display">x</script> as the <em>successor</em> of <script type="math/tex; mode=display">x</script> in the BST, as in: "What is the next greater value of <script type="math/tex; mode=display">x</script>?". Similarly, we consider the greatest element <script type="math/tex; mode=display">g</script> that is smaller or equal to <script type="math/tex; mode=display">x</script> as the <em>predecessor</em> of <script type="math/tex; mode=display">x</script> in the BST, as in: "What is the previous smaller value of <script type="math/tex; mode=display">x</script>?". These two values <script type="math/tex; mode=display">s</script> and <script type="math/tex; mode=display">g</script> are the two closest neighbors from <script type="math/tex; mode=display">x</script>. Thus by checking the distance from them to <script type="math/tex; mode=display">x</script>, we can conclude if <a href="#condition-2">Condition 2</a> is satisfied.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsNearbyAlmostDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">TreeSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeSet</span><span class="o">&lt;&gt;();</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>\n        <span class="c1">// Find the successor of current element</span>\n        <span class="n">Integer</span> <span class="n">s</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">ceiling</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">t</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n\n        <span class="c1">// Find the predecessor of current element</span>\n        <span class="n">Integer</span> <span class="n">g</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">floor</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">g</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">g</span> <span class="o">+</span> <span class="n">t</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n\n        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="o">]);</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n \\log (\\min(n,k)))</script>.\nWe iterate through the array of size <script type="math/tex; mode=display">n</script>. For each iteration, it costs <script type="math/tex; mode=display">O(\\log \\min(k, n))</script> time (<code>search</code>, <code>insert</code> or <code>delete</code>) in the BST, since the size of the BST is upper bounded by both <script type="math/tex; mode=display">k</script> and <script type="math/tex; mode=display">n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(\\min(n,k))</script>.\nSpace is dominated by the size of the BST, which is upper bounded by both <script type="math/tex; mode=display">k</script> and <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<p><strong>Note</strong></p>\n<ul>\n<li>\n<p>When the array\'s elements and <script type="math/tex; mode=display">t</script>\'s value are large, they can cause overflow in arithmetic operation. Consider using a larger size data type instead, such as <em>long</em>.</p>\n</li>\n<li>\n<p>C++\'s <code>std::set</code>, <code>std::set::upper_bound</code> and <code>std::set::lower_bound</code> are equivalent to Java\'s <code>TreeSet</code>, <code>TreeSet::ceiling</code> and <code>TreeSet::floor</code>, respectively. Python does not provide a Self-balancing BST through its library.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-buckets-accepted">Approach #3 (Buckets) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Inspired by <code>bucket sort</code>, we can achieve linear time complexity in our problem using <em>buckets</em> as window.</p>\n<p><strong>Algorithm</strong></p>\n<p>Bucket sort is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, using a different sorting algorithm. Here is an illustration of buckets.</p>\n<p align="center"><img alt="Illustration of buckets" src="https://leetcode.com/media/original_images/220_Buckets.png" title="Illustration of buckets" width="539px"></p>\n<p align="center"><em>Figure 3. Illustration of buckets.</em></p>\n<p>From the above example, we have 8 unsorted integers. We create 5 buckets covering the inclusive ranges of <script type="math/tex; mode=display">[0,9], [10,19], [20, 29], [30, 39], [40, 49]</script> individually. Each of the eight elements is in a particular bucket. For element with value <script type="math/tex; mode=display">x</script>, its bucket label is <script type="math/tex; mode=display">x / w</script> and here we have <script type="math/tex; mode=display">w = 10</script>. Sort each bucket using some other sorting algorithm and then collect all of them bucket by bucket.</p>\n<p>Back to our problem, the critical issue we are trying to solve is:</p>\n<blockquote>\n<ol>\n<li>For a given element <script type="math/tex; mode=display">x</script> is there an item in the window that is within the range of <script type="math/tex; mode=display">[x-t, x+t]</script>?</li>\n<li>Could we do this in constant time?</li>\n</ol>\n</blockquote>\n<p>Let us consider an example where each element is a person\'s birthday. Your birthday, say some day in <em>March</em>, is the new element <script type="math/tex; mode=display">x</script>. Suppose that each month has <script type="math/tex; mode=display">30</script> days and you want to know if anyone has a birthday within <script type="math/tex; mode=display">t = 30</script> days of yours. Immediately, we can rule out all other months except <em>February, March, April</em>.</p>\n<p>The reason we know this is because each birthday belongs to a <em>bucket</em> we called <em>month</em>! And the range covered by the buckets are the same as distance <script type="math/tex; mode=display">t</script> which simplifies things a lot. Any two elements that are not in the same or adjacent buckets must have a distance greater than <script type="math/tex; mode=display">t</script>.</p>\n<p>We apply the above bucketing principle and design buckets covering the ranges of <script type="math/tex; mode=display">..., [0,t], [t+1, 2t+1], ...</script>. We keep the window using this buckets. Then, each time, all we need to check is the bucket that <script type="math/tex; mode=display">x</script> belongs to and its two adjacent buckets. Thus, we have a constant time algorithm for searching almost duplicate in the window.</p>\n<p>One thing worth mentioning is the difference from bucket sort – Each of our buckets contains at most one element at any time, because two elements in a bucket means "almost duplicate" and we can return early from the function. Therefore, a HashMap with an element associated with a bucket label is enough for our purpose.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="c1">// Get the ID of the bucket from element value x and bucket width w</span>\n    <span class="c1">// In Java, `-3 / 5 = 0` and but we need `-3 / 5 = -1`.</span>\n    <span class="kd">private</span> <span class="kt">long</span> <span class="nf">getID</span><span class="o">(</span><span class="kt">long</span> <span class="n">x</span><span class="o">,</span> <span class="kt">long</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">w</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">w</span><span class="o">;</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsNearbyAlmostDuplicate</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n        <span class="n">Map</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>\n        <span class="kt">long</span> <span class="n">w</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">long</span> <span class="n">m</span> <span class="o">=</span> <span class="n">getID</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">w</span><span class="o">);</span>\n            <span class="c1">// check if bucket m is empty, each bucket may contain at most one element</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">m</span><span class="o">))</span>\n                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n            <span class="c1">// check the neighbor buckets for almost duplicate</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">d</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">&lt;</span> <span class="n">w</span><span class="o">)</span>\n                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">d</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span> <span class="o">&lt;</span> <span class="n">w</span><span class="o">)</span>\n                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n            <span class="c1">// now bucket m is empty and no almost duplicate in neighbor buckets</span>\n            <span class="n">d</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="n">d</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">getID</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="o">],</span> <span class="n">w</span><span class="o">));</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nFor each of the <script type="math/tex; mode=display">n</script> elements, we do at most three searches, one insert, and one delete on the HashMap, which costs constant time on average. Thus, the entire algorithm costs <script type="math/tex; mode=display">O(n)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(\\min(n,k))</script>.\nSpace is dominated by the HashMap, which is linear to the size of its elements. The size of the HashMap is upper bounded by both <script type="math/tex; mode=display">n</script> and <script type="math/tex; mode=display">k</script>. Thus the space complexity is <script type="math/tex; mode=display">O(\\min(n, k))</script>.</p>\n</li>\n</ul>\n<h2 id="see-also">See Also</h2>\n<ul>\n<li><a href="https://leetcode.com/articles/contains-duplicate/">Problem 217 Contains Duplicate</a></li>\n<li><a href="https://leetcode.com/articles/contains-duplicate-ii/">Problem 219 Contains Duplicate II</a></li>\n</ul>\n</div>\n          ',
    tags: ['Airbnb', 'Palantir'],
  },
  {
    id: '221',
    name: 'Maximal Square',
    acceptance: '29.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a 2D binary matrix filled with 0\'s and 1\'s, find the largest square containing only 1\'s and return its area.\n</p>\n\n<p>For example, given the following matrix:\n</p><pre>1 0 1 0 0\n1 0 <font color="red">1</font> <font color="red">1</font> 1\n1 1 <font color="red">1</font> <font color="red">1</font> 1\n1 0 0 1 0\n</pre>\nReturn 4.\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/Freezen">@Freezen</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-dynamic-programming-accepted">Approach #2 (Dynamic Programming) [Accepted]</a></li>\n<li><a href="#approach-3-better-dynamic-programming-accepted">Approach #3 (Better Dynamic Programming) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>We need to find the largest square comprising of all ones in the given <script type="math/tex; mode=display">m \\times n</script> matrix. In other words we need to find the largest set of connected ones in the given matrix that forms a square.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</h4>\n<p>The simplest approach consists of trying to find out every possible square of 1’s that can be formed from within the matrix. The question now is – how to go for it?</p>\n<p>We use a variable to contain the size of the largest square found so far and another variable to store the size of the current, both initialized to 0. Starting from the left uppermost point in the matrix, we search for a 1. No operation needs to be done for a 0. Whenever a 1 is found, we try to find out the largest square that can be formed including that 1. For this, we move diagonally (right and downwards), i.e. we increment the row index and column index temporarily and then check whether all the elements of that row and column are 1 or not. If all the elements happen to be 1, we move diagonally further as previously. If even one element turns out to be 0, we stop this diagonal movement and update the size of the largest square. Now we, continue the traversal of the matrix from the element next to the initial 1 found, till all the elements of the matrix have been traversed.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maximalSquare</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">rows</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">maxsqlen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">\'1\'</span><span class="o">)</span> <span class="o">{</span>\n                    <span class="kt">int</span> <span class="n">sqlen</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>\n                    <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>\n                    <span class="k">while</span> <span class="o">(</span><span class="n">sqlen</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="o">&amp;&amp;</span> <span class="n">sqlen</span> <span class="o">+</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cols</span> <span class="o">&amp;&amp;</span> <span class="n">flag</span><span class="o">)</span> <span class="o">{</span>\n                        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">sqlen</span> <span class="o">+</span> <span class="n">j</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>\n                            <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">sqlen</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">==</span> <span class="sc">\'0\'</span><span class="o">)</span> <span class="o">{</span>\n                                <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>\n                                <span class="k">break</span><span class="o">;</span>\n                            <span class="o">}</span>\n                        <span class="o">}</span>\n                        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">sqlen</span> <span class="o">+</span> <span class="n">i</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>\n                            <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">sqlen</span><span class="o">]</span> <span class="o">==</span> <span class="sc">\'0\'</span><span class="o">)</span> <span class="o">{</span>\n                                <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>\n                                <span class="k">break</span><span class="o">;</span>\n                            <span class="o">}</span>\n                        <span class="o">}</span>\n                        <span class="k">if</span> <span class="o">(</span><span class="n">flag</span><span class="o">)</span>\n                            <span class="n">sqlen</span><span class="o">++;</span>\n                    <span class="o">}</span>\n                    <span class="k">if</span> <span class="o">(</span><span class="n">maxsqlen</span> <span class="o">&lt;</span> <span class="n">sqlen</span><span class="o">)</span> <span class="o">{</span>\n                        <span class="n">maxsqlen</span> <span class="o">=</span> <span class="n">sqlen</span><span class="o">;</span>\n                    <span class="o">}</span>\n                <span class="o">}</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">maxsqlen</span> <span class="o">*</span> <span class="n">maxsqlen</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O\\big((mn)^2\\big)</script>. In worst case, we need to traverse the complete matrix for every 1.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space is used.</li>\n</ul>\n<hr>\n<h4 id="approach-2-dynamic-programming-accepted">Approach #2 (Dynamic Programming) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We will explain this approach with the help of an example.</p>\n<div class="codehilite"><pre><span></span>0 1 1 1 0\n1 1 1 1 1\n0 1 1 1 1\n0 1 1 1 1\n0 0 1 1 1\n</pre></div>\n<p>We initialize another matrix (dp) with the same dimensions as the original one initialized with all 0’s.</p>\n<p>dp(i,j) represents the side length of the maximum square whose bottom right corner is the cell with index (i,j) in the original matrix. </p>\n<p>Starting from index (0,0), for every 1 found in the original matrix, we update the value of the current element as </p>\n<p>\n<script type="math/tex; mode=display">\n\\text{dp}(i,\\  j) = \\min \\big( \\text{dp}(i-1,\\  j),\\  \\text{dp}(i-1,\\  j-1),\\  \\text{dp}(i,\\  j-1) \\big) + 1.\n</script>\n</p>\n<p>We also remember the size of the largest square found so far. In this way, we traverse the original matrix once and find out the required maximum size. This gives the side length of the square (say <script type="math/tex; mode=display">maxsqlen</script>). The required result is the area <script type="math/tex; mode=display">maxsqlen^2</script>.</p>\n<p>To understand how this solution works, see the figure below.</p>\n<p><img alt="Max Square" src="https://leetcode.com/media/original_images/221_Maximal_Square.PNG?raw=true"></p>\n<p>An entry 2 at <script type="math/tex; mode=display">(1, 3)</script> implies that we have a square of side 2 up to that index in the original matrix. Similarly, a 2 at <script type="math/tex; mode=display">(1, 2)</script> and <script type="math/tex; mode=display">(2, 2)</script> implies that a square of side 2 exists up to that index in the original matrix. Now to make a square of side 3, only a single entry of 1 is pending at <script type="math/tex; mode=display">(2, 3)</script>. So, we enter a 3 corresponding to that position in the dp array.</p>\n<p>Now consider the case for the index <script type="math/tex; mode=display">(3, 4)</script>. Here, the entries at index <script type="math/tex; mode=display">(3, 3)</script> and <script type="math/tex; mode=display">(2, 3)</script> imply that a square of side 3 is possible up to their indices. But, the entry 1 at index <script type="math/tex; mode=display">(2, 4)</script> indicates that a square of side 1 only can be formed up to its index. Therefore, while making an entry at the index <script type="math/tex; mode=display">(3, 4)</script>, this element obstructs the formation of a square having a side larger than 2. Thus, the maximum sized square that can be formed up to this index is of size <script type="math/tex; mode=display">2\\times2</script>.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maximalSquare</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">rows</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">rows</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">cols</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>\n        <span class="kt">int</span> <span class="n">maxsqlen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">rows</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">cols</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="sc">\'1\'</span><span class="o">){</span>\n                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]),</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n                    <span class="n">maxsqlen</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxsqlen</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>\n                <span class="o">}</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">maxsqlen</span> <span class="o">*</span> <span class="n">maxsqlen</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(mn)</script>. Single pass.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>. Another matrix of same size is used for dp.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-better-dynamic-programming-accepted">Approach #3 (Better Dynamic Programming) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the previous approach for calculating dp of <script type="math/tex; mode=display">i^{th}</script> row we are using only the previous element and the <script type="math/tex; mode=display">(i-1)^{th}</script> row. Therefore, we don\'t need 2D dp matrix as 1D dp array will be sufficient for this.</p>\n<p>Initially the dp array contains all 0\'s. As we scan the elements of the original matrix across a row, we keep on updating the dp array as per the equation <script type="math/tex; mode=display">dp[j]=min(dp[j-1],dp[j],prev)</script>, where prev refers to the old <script type="math/tex; mode=display">dp[j-1]</script>. For every row, we repeat the same process and update in the same dp array.</p>\n<p><img alt=" Max Square " src="https://leetcode.com/media/original_images/221_Maximal_Square1.png?raw=true"></p>\n<p><strong>java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maximalSquare</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">rows</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">cols</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>\n        <span class="kt">int</span> <span class="n">maxsqlen</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">rows</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">cols</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>\n                <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="sc">\'1\'</span><span class="o">)</span> <span class="o">{</span>\n                    <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span> <span class="n">prev</span><span class="o">),</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n                    <span class="n">maxsqlen</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxsqlen</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>\n                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>\n                    <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n                <span class="o">}</span>\n                <span class="n">prev</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">maxsqlen</span> <span class="o">*</span> <span class="n">maxsqlen</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(mn)</script>. Single pass.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Another array which stores elements in a row is used for dp.</p>\n</li>\n</ul>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Facebook', 'Apple', 'Airbnb'],
  },
  {
    id: '222',
    name: 'Count Complete Tree Nodes',
    acceptance: '27.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a <b>complete</b> binary tree, count the number of nodes.</p>\n\n<p><b><u>Definition of a complete binary tree from <a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" target="_blank">Wikipedia</a>:</u></b><br>\nIn a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2<sup>h</sup> nodes inclusive at the last level h.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '223',
    name: 'Rectangle Area',
    acceptance: '33.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Find the total area covered by two <b>rectilinear</b> rectangles in a <b>2D</b> plane.</p>\n<p>Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.</p>\n<div style="width:529px; height:300px; background-color:rgb(235, 235, 235);">\n<img src="/static/images/problemset/rectangle_area.png" border="0" alt="Rectangle Area">\n</div>\n<div style="padding-top:23px;">\n<p>Assume that the total area is never beyond the maximum possible value of <b>int</b>.</p>\n</div>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/mithmatt">@mithmatt</a> for adding this problem, creating the above image and all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '224',
    name: 'Basic Calculator',
    acceptance: '27.9%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Implement a basic calculator to evaluate a simple expression string.</p>\n\n<p>The expression string may contain open <code>(</code> and closing parentheses <code>)</code>, the plus <code>+</code> or minus sign <code>-</code>, <b>non-negative</b> integers and empty spaces <code> </code>.</p>\n\n<p>You may assume that the given expression is always valid.</p>\n\n<p>Some examples:<br>\n</p><pre>"1 + 1" = 2\n" 2-1 + 2 " = 3\n"(1+(4+5+2)-3)+(6+8)" = 23\n</pre>\n<p></p>\n\n<p>\n<b>Note:</b> <b>Do not</b> use the <code>eval</code> built-in library function.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '225',
    name: 'Implement Stack using Queues',
    acceptance: '33.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nImplement the following operations of a stack using queues.\n</p><ul>\n<li>\npush(x) -- Push element x onto stack.\n</li>\n<li>\npop() -- Removes the element on top of the stack.\n</li>\n<li>\ntop() -- Get the top element.\n</li>\n<li>\nempty() -- Return whether the stack is empty.\n</li>\n</ul>\n<b>Notes:</b><br>\n<ul>\n<li>You must use <i>only</i> standard operations of a queue -- which means only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>\n<li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li>\n<li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>\n</ul>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-two-queues-push-o1-pop-on">Approach #1 (Two Queues, push - O(1), pop O(n) )</a></li>\n<li><a href="#approach-2-two-queues-push-on-pop-o1">Approach #2 (Two Queues, push - O(n), pop O(1) )</a></li>\n<li><a href="#approach-3-one-queue-push-on-pop-o1">Approach #3 (One Queue, push - O(n), pop O(1) )</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This article is for beginners. It introduces the following ideas:\nStack, Queue.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-two-queues-push-o1-pop-on">Approach #1 (Two Queues, push - <script type="math/tex; mode=display">O(1)</script>, pop <script type="math/tex; mode=display">O(n)</script> )</h4>\n<p><strong>Intuition</strong></p>\n<p>Stack is <strong>LIFO</strong> (last in - first out) data structure, in which elements are added and removed from the same end, called <code>top</code>.\nIn general stack is implemented using array or linked list, but in the current article we will review a different approach for implementing stack using queues. In contrast queue is <strong>FIFO</strong> (first in - first out) data structure, in which elements are added only from the one side - <code>rear</code> and removed from the other - <code>front</code>. In order to implement stack using queues, we need to maintain two queues <code>q1</code> and <code>q2</code>. Also we will keep top stack element in a constant memory.</p>\n<p><strong>Algorithm</strong></p>\n<p><strong>Push</strong></p>\n<p>The new element is always added to the rear of queue <code>q1</code> and it is kept as <code>top</code> stack element</p>\n<p align="center"><img alt="Push an element in stack" src="https://leetcode.com/media/original_images/225_stack_using_queues_pushA.png" width="539px"></p>\n<p align="center"><em>Figure 1. Push an element in stack</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">q1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>\n<span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">q2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>\n<span class="kd">private</span> <span class="kt">int</span> <span class="n">top</span><span class="o">;</span>\n\n<span class="c1">// Push element x onto stack.</span>\n<span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">q1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>\n    <span class="n">top</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script>. Queue is implemented as linked list and <code>add</code> operation has <script type="math/tex; mode=display">O(1)</script> time complexity.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n</li>\n</ul>\n<p><strong>Pop</strong></p>\n<p>We need to remove the element from the top of the stack. This is the last inserted element in <code>q1</code>.\nBecause queue is FIFO (first in - first out) data structure, the last inserted element could be removed only after all elements, except it, have been removed. For this reason we need to maintain additional queue <code>q2</code>, which will serve as a temporary storage to enqueue the removed elements from q1. The last inserted element in <code>q2</code> is kept as top. Then the algorithm removes the last element in <code>q1</code>. We swap <code>q1</code> with <code>q2</code> to avoid copying all elements from <code>q2</code> to <code>q1</code>.</p>\n<p align="center"><img alt="Pop an element from stack" src="https://leetcode.com/media/original_images/225_stack_using_queues_popA.png" width="539px"></p>\n<p align="center"><em>Figure 2. Pop an element from stack</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="c1">// Removes the element on top of the stack.</span>\n<span class="kd">public</span> <span class="kt">void</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">q1</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">top</span> <span class="o">=</span> <span class="n">q1</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>\n        <span class="n">q2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">top</span><span class="o">);</span>\n    <span class="o">}</span>\n    <span class="n">q1</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>\n    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">q1</span><span class="o">;</span>\n    <span class="n">q1</span> <span class="o">=</span> <span class="n">q2</span><span class="o">;</span>\n    <span class="n">q2</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The algorithm  dequeues n elements from <code>q1</code> and enqueues <script type="math/tex; mode=display">n - 1</script> elements to <code>q2</code>, where <script type="math/tex; mode=display">n</script> is the stack size. This gives <script type="math/tex; mode=display">2n - 1</script> operations.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</li>\n</ul>\n<hr>\n<h4 id="approach-2-two-queues-push-on-pop-o1">Approach #2 (Two Queues, push - <script type="math/tex; mode=display">O(n)</script>, pop <script type="math/tex; mode=display">O(1)</script> )</h4>\n<p><strong>Algorithm</strong></p>\n<p><strong>Push</strong></p>\n<p>The algorithm inserts each new element to queue <code>q2</code> and keep it as the <code>top</code> element. In case queue <code>q1</code> is not empty (there are elements in the stack), we remove all elements from <code>q1</code> and add them to <code>q2</code>. In this way the new inserted element (<code>top</code> element in the stack) will be always positioned at the front of <code>q2</code>. We swap <code>q1</code> with <code>q2</code> to avoid copying all elements from <code>q2</code> to <code>q1</code>.</p>\n<p align="center"><img alt="Push an element in stack" src="https://leetcode.com/media/original_images/225_stack_using_queues_pushB.png" width="539px"></p>\n<p align="center"><em>Figure 3. Push an element in stack</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">q2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>\n    <span class="n">top</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(!</span><span class="n">q1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>                \n        <span class="n">q2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">q1</span><span class="o">.</span><span class="na">remove</span><span class="o">());</span>\n    <span class="o">}</span>\n    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">q1</span><span class="o">;</span>\n    <span class="n">q1</span> <span class="o">=</span> <span class="n">q2</span><span class="o">;</span>\n    <span class="n">q2</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The algorithm  removes n elements from <code>q1</code> and inserts <script type="math/tex; mode=display">n + 1</script> elements to <code>q2</code>, where n is the stack size. This gives <script type="math/tex; mode=display">2n + 1</script> operations. The operations <code>add</code> and <code>remove</code> in linked lists has <script type="math/tex; mode=display">O(1)</script> complexity.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<p><strong>Pop</strong></p>\n<p>The algorithm dequeues an element from  queue <code>q1</code> and keeps front element of <code>q1</code> as <code>top</code>.</p>\n<p align="center"><img alt="Pop an element from stack" src="https://leetcode.com/media/original_images/225_stack_using_queues_popB.png" width="539px"></p>\n<p align="center"><em>Figure 4. Pop an element from stack</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="c1">// Removes the element on top of the stack.</span>\n<span class="kd">public</span> <span class="kt">void</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>\n    <span class="n">q1</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>\n    <span class="k">if</span> <span class="o">(!</span><span class="n">q1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>\n        <span class="n">top</span> <span class="o">=</span> <span class="n">q1</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(1)</script>.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</li>\n</ul>\n<p>In both approaches <code>empty</code> and <code>top</code> operations have the same implementation.</p>\n<p><strong>Empty</strong></p>\n<p>Queue <code>q1</code> always contains all stack elements, so the algorithm checks <code>q1</code> size to return if the stack is empty.</p>\n<div class="codehilite"><pre><span></span><span class="c1">// Return whether the stack is empty.</span>\n<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">empty</span><span class="o">()</span> <span class="o">{</span>\n    <span class="k">return</span> <span class="n">q1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>\n<span class="o">}</span>\n</pre></div>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n<p><strong>Top</strong></p>\n<p>The <code>top</code> element is kept in constant memory and is modified each time when we push or pop an element.</p>\n<div class="codehilite"><pre><span></span><span class="c1">// Get the top element.</span>\n<span class="kd">public</span> <span class="kt">int</span> <span class="nf">top</span><span class="o">()</span> <span class="o">{</span>\n    <span class="k">return</span> <span class="n">top</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script>.\n The <code>top</code> element has been calculated in advance and only returned in <code>top</code> operation.</p>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n<hr>\n<h4 id="approach-3-one-queue-push-on-pop-o1">Approach #3 (One Queue, push - <script type="math/tex; mode=display">O(n)</script>, pop <script type="math/tex; mode=display">O(1)</script> )</h4>\n<p>The mentioned above two approaches have one weakness, they use two queues. This could be optimized as we use only one queue, instead of two.</p>\n<p><strong>Algorithm</strong></p>\n<p><strong>Push</strong></p>\n<p>When we push an element into a queue, it will be stored at back of the queue due to queue\'s properties.\nBut we need to implement a stack, where last inserted element should be in the front of the queue, not at the back. To achieve this we can invert the order of queue elements when pushing a new element.</p>\n<p align="center"><img alt="Push an element in stack" src="https://leetcode.com/media/original_images/225_stack_using_queues_pushC.png" width="539px"></p>\n<p align="center"><em>Figure 5. Push an element in stack</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">private</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">q1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>\n\n<span class="c1">// Push element x onto stack.</span>\n<span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">q1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>\n    <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">q1</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">q1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">q1</span><span class="o">.</span><span class="na">remove</span><span class="o">());</span>\n        <span class="n">sz</span><span class="o">--;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The algorithm  removes n elements and inserts <script type="math/tex; mode=display">n + 1</script> elements to <code>q1</code> , where n is the stack size. This gives <script type="math/tex; mode=display">2n + 1</script> operations. The operations <code>add</code> and <code>remove</code> in linked lists has <script type="math/tex; mode=display">O(1)</script> complexity.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<p><strong>Pop</strong></p>\n<p>The last inserted element is always stored at the front of <code>q1</code> and we can pop it for constant time.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="c1">// Removes the element on top of the stack.</span>\n<span class="kd">public</span> <span class="kt">void</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>\n    <span class="n">q1</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(1)</script>.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</li>\n</ul>\n<p><strong>Empty</strong></p>\n<p>Queue <code>q1</code> contains all stack elements, so the algorithm checks if <code>q1</code> is empty.</p>\n<div class="codehilite"><pre><span></span><span class="c1">// Return whether the stack is empty.</span>\n<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">empty</span><span class="o">()</span> <span class="o">{</span>\n    <span class="k">return</span> <span class="n">q1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>\n<span class="o">}</span>\n</pre></div>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n<p><strong>Top</strong></p>\n<p>The <code>top</code> element is always positioned at the front of <code>q1</code>. Algorithm return it.</p>\n<div class="codehilite"><pre><span></span><span class="c1">// Get the top element.</span>\n<span class="kd">public</span> <span class="kt">int</span> <span class="nf">top</span><span class="o">()</span> <span class="o">{</span>\n    <span class="k">return</span> <span class="n">q1</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>\n<span class="o">}</span>\n</pre></div>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n<p>Analysis written by: @elmirap.</p>\n</div>\n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '226',
    name: 'Invert Binary Tree',
    acceptance: '52.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            Invert a binary tree.\n<pre>     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9</pre>\n\nto\n<pre>     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1</pre>\n\n<b>Trivia:</b><br>\nThis problem was inspired by <a href="https://twitter.com/mxcl/status/608682016205344768" target="_blank">this original tweet</a> by <a href="https://twitter.com/mxcl" target="_blank">Max Howell</a>:\n<blockquote>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.</blockquote>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-recursive-accepted">Approach #1 (Recursive) [Accepted]</a></li>\n<li><a href="#approach-2-iterative-accepted">Approach #2 (Iterative) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-recursive-accepted">Approach #1 (Recursive) [Accepted]</h4>\n<p>This is a classic tree problem that is best-suited for a recursive approach.</p>\n<p><strong>Algorithm</strong></p>\n<p>The inverse of an empty tree is the empty tree. The inverse of a tree with root <script type="math/tex; mode=display">r</script>, and subtrees <script type="math/tex; mode=display">\\mbox{right}</script> and <script type="math/tex; mode=display">\\mbox{left}</script>, is a tree with root <script type="math/tex; mode=display">r</script>, whose right subtree is the inverse of <script type="math/tex; mode=display">\\mbox{left}</script>, and whose left subtree is the inverse of <script type="math/tex; mode=display">\\mbox{right}</script>.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">invertTree</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="n">TreeNode</span> <span class="n">right</span> <span class="o">=</span> <span class="n">invertTree</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>\n    <span class="n">TreeNode</span> <span class="n">left</span> <span class="o">=</span> <span class="n">invertTree</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>\n    <span class="n">root</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>\n    <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>\n    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>Since each node in the tree is visited only once, the time complexity is <script type="math/tex; mode=display">O(n)</script>, where <script type="math/tex; mode=display">n</script> is the number of nodes in the tree. We cannot do better than that, since at the very least we have to visit each node to invert it.</p>\n<p>Because of recursion, <script type="math/tex; mode=display">O(h)</script> function calls will be placed on the stack in the worst case, where <script type="math/tex; mode=display">h</script> is the height of the tree. Because <script type="math/tex; mode=display">h\\in O(n)</script>, the space complexity is <script type="math/tex; mode=display">O(n)</script>.</p>\n<hr>\n<h4 id="approach-2-iterative-accepted">Approach #2 (Iterative) [Accepted]</h4>\n<p>Alternatively, we can solve the problem iteratively, in a manner similar to breadth-first search.</p>\n<p><strong>Algorithm</strong></p>\n<p>The idea is that we need to swap the left and right child of all nodes in the tree. So we create a queue to store nodes whose left and right child have not been swapped yet. Initially, only the root is in the queue. As long as the queue is not empty, remove the next node from the queue, swap its children, and add the children to the queue. Null nodes are not added to the queue. Eventually, the queue will be empty and all the children swapped, and we return the original root.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">invertTree</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>\n    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;();</span>\n    <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>\n    <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>\n        <span class="n">TreeNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>\n        <span class="n">TreeNode</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>\n        <span class="n">current</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>\n        <span class="n">current</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>Since each node in the tree is visited / added to the queue only once, the time complexity is <script type="math/tex; mode=display">O(n)</script>, where <script type="math/tex; mode=display">n</script> is the number of nodes in the tree.</p>\n<p>Space complexity is <script type="math/tex; mode=display">O(n)</script>, since in the worst case, the queue will contain all nodes in one level of the binary tree. For a full binary tree, the leaf level has <script type="math/tex; mode=display">\\lceil \\frac{n}{2}\\rceil=O(n)</script> leaves.</p>\n<p>Analysis written by: @noran</p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '227',
    name: 'Basic Calculator II',
    acceptance: '29.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Implement a basic calculator to evaluate a simple expression string.</p>\n\n<p>The expression string contains only <b>non-negative</b> integers, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> operators and empty spaces <code> </code>. The integer division should truncate toward zero.</p>\n\n<p>You may assume that the given expression is always valid.</p>\n\n<p>Some examples:<br>\n</p><pre>"3+2*2" = 7\n" 3/2 " = 1\n" 3+5 / 2 " = 5\n</pre>\n<p></p>\n\n<p>\n<b>Note:</b> <b>Do not</b> use the <code>eval</code> built-in library function.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Airbnb'],
  },
  {
    id: '228',
    name: 'Summary Ranges',
    acceptance: '31.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a sorted integer array without duplicates, return the summary of its ranges.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [0,1,2,4,5,7]\n<b>Output:</b> ["0-&gt;2","4-&gt;5","7"]\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [0,2,3,4,6,8,9]\n<b>Output:</b> ["0","2-&gt;4","6","8-&gt;9"]\n</pre>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<h2 id="solution">Solution</h2>\n<p><strong>Intuition</strong></p>\n<p>A range covers consecutive elements. If two adjacent elements have difference larger than <script type="math/tex; mode=display">1</script>, the two elements does not belong to the same range.</p>\n<p><strong>Algorithm</strong></p>\n<p>To summarize the ranges, we need to know how to separate them. The array is sorted and without duplicates. In such array, two adjacent elements have difference either 1 or larger than 1. If the difference is 1, they should be put in the same range; otherwise, separate ranges.</p>\n<p>We also need to know the start index of a range so that we can put it in the result list. Thus, we keep two indices, representing the two boundaries of current range. For each new element, we check if it extends the current range. If not, we put the current range into the list.</p>\n<p>Don\'t forget to put the last range into the list. One can do this by either a special condition in the loop or putting the last range in to the list after the loop.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">summaryRanges</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">summary</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>\n            <span class="c1">// check if j + 1 extends the range [nums[i], nums[j]]</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>\n                <span class="k">continue</span><span class="o">;</span>\n            <span class="c1">// put the range [nums[i], nums[j]] into the list</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="o">)</span>\n                <span class="n">summary</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">""</span><span class="o">);</span>\n            <span class="k">else</span>\n                <span class="n">summary</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">"-&gt;"</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>\n            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">summary</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Java (Alternative)</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">summaryRanges</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">summary</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">){</span>\n            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>\n            <span class="c1">// try to extend the range [nums[i], nums[j]]</span>\n            <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>\n                <span class="o">++</span><span class="n">j</span><span class="o">;</span>\n            <span class="c1">// put the range into the list</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="o">)</span>\n                <span class="n">summary</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">""</span><span class="o">);</span>\n            <span class="k">else</span>\n                <span class="n">summary</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">"-&gt;"</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">summary</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Each element is visited constant times: either in comparison with neighbor or put in the result list.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. All the auxiliary space we need is the two indices, if we don\'t count the return list.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '229',
    name: 'Majority Element II',
    acceptance: '28.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given an integer array of size <i>n</i>, find all elements that appear more than <code>⌊ n/3 ⌋</code> times. The algorithm should run in linear time and in O(1) space.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Zenefits'],
  },
  {
    id: '230',
    name: 'Kth Smallest Element in a BST',
    acceptance: '44.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <b>k</b>th smallest element in it.</p>\n\n<p><b>Note: </b><br>\nYou may assume k is always valid, 1 ≤ k ≤ BST\'s total elements.</p>\n\n<p><b>Follow up:</b><br>\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Bloomberg', 'Uber'],
  },
  {
    id: '231',
    name: 'Power of Two',
    acceptance: '40.5%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an integer, write a function to determine if it is a power of two.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '232',
    name: 'Implement Queue using Stacks',
    acceptance: '37.5%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nImplement the following operations of a queue using stacks.\n</p><ul>\n<li>\npush(x) -- Push element x to the back of queue.\n</li>\n<li>\npop() -- Removes the element from in front of queue.\n</li>\n<li>\npeek() -- Get the front element.\n</li>\n<li>\nempty() -- Return whether the queue is empty.\n</li>\n</ul>\n<b>Notes:</b><br>\n<ul>\n<li>You must use <i>only</i> standard operations of a stack -- which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>\n<li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li>\n<li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li>\n</ul>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-two-stacks-push-on-per-operation-pop-o1-per-operation">Approach #1 (Two Stacks) Push - O(n) per operation, Pop - O(1) per operation.</a></li>\n<li><a href="#approach-2-two-stacks-push-o1-per-operation-pop-amortized-o1-per-operation">Approach #2 (Two Stacks) Push - O(1) per operation, Pop - Amortized O(1) per operation.</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This article is for beginners. It introduces the following ideas:\nQueue, Stack.</p>\n<h2 id="solution">Solution</h2>\n<p>Queue is <strong>FIFO</strong> (first in - first out) data structure, in which the elements are inserted from one side - <code>rear</code> and removed from the other - <code>front</code>.\nThe most intuitive way to implement it is with linked lists, but this article will introduce another approach  using stacks.\nStack is <strong>LIFO</strong> (last in - first out) data structure, in which elements are added and removed from the same end, called <code>top</code>.\nTo satisfy <strong>FIFO</strong> property of a queue we need to keep two stacks. They serve to reverse arrival order of the  elements and one of them store the queue elements in their final order.</p>\n<hr>\n<h4 id="approach-1-two-stacks-push-on-per-operation-pop-o1-per-operation">Approach #1 (Two Stacks) Push - <script type="math/tex; mode=display">O(n)</script> per operation, Pop - <script type="math/tex; mode=display">O(1)</script> per operation.</h4>\n<p><strong>Algorithm</strong></p>\n<p><strong>Push</strong></p>\n<p>A queue is FIFO (first-in-first-out) but a stack is LIFO (last-in-first-out). This means the newest element must be pushed to the bottom of the stack. To do so we first transfer all <code>s1</code> elements to auxiliary stack <code>s2</code>. Then the newly arrived element is pushed on top of <code>s2</code> and all its elements are popped and pushed to <code>s1</code>.</p>\n<p align="center"><img alt="Push an element in queue" src="https://leetcode.com/media/original_images/232_queue_using_stacksBPush.png" width="539px"></p>\n<p align="center"><em>Figure 1. Push an element in queue</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">private</span> <span class="kt">int</span> <span class="n">front</span><span class="o">;</span>\n\n<span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">empty</span><span class="o">())</span>\n        <span class="n">front</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(!</span><span class="n">s1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>\n        <span class="n">s2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>\n    <span class="n">s2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>\n    <span class="k">while</span> <span class="o">(!</span><span class="n">s2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>\n        <span class="n">s1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n)</script>.</li>\n</ul>\n<p>Each element, with the exception of the newly arrived, is pushed and popped twice. The last inserted element is popped and pushed once. Therefore this gives  <script type="math/tex; mode=display">4 n + 2</script>  operations where <script type="math/tex; mode=display">n</script> is the queue size. The  <code>push</code> and <code>pop</code> operations have <script type="math/tex; mode=display">O(1)</script> time complexity.</p>\n<ul>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>.\nWe need additional memory to store the queue elements</li>\n</ul>\n<p><strong>Pop</strong></p>\n<p>The algorithm pops an element from  the stack <code>s1</code>, because <code>s1</code> stores always on its top the first inserted element in the queue.\nThe front element of the queue is kept as <code>front</code>.</p>\n<p align="center"><img alt="Pop an element from queue" src="https://leetcode.com/media/original_images/232_queue_using_stacksBPop.png" width="539px"></p>\n<p align="center"><em>Figure 2. Pop an element from queue</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="c1">// Removes the element from the front of queue.</span>\n<span class="kd">public</span> <span class="kt">void</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>\n    <span class="n">s1</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>\n    <span class="k">if</span> <span class="o">(!</span><span class="n">s1</span><span class="o">.</span><span class="na">empty</span><span class="o">())</span>\n        <span class="n">front</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(1)</script>.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</li>\n</ul>\n<p><strong>Empty</strong></p>\n<p>Stack <code>s1</code> contains all stack elements, so the algorithm checks <code>s1</code> size to return if the queue is empty.</p>\n<div class="codehilite"><pre><span></span><span class="c1">// Return whether the queue is empty.</span>\n<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">empty</span><span class="o">()</span> <span class="o">{</span>\n    <span class="k">return</span> <span class="n">s1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>\n<span class="o">}</span>\n</pre></div>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n<p><strong>Peek</strong></p>\n<p>The <code>front</code> element is kept in constant memory and is modified when we push or pop an element.</p>\n<div class="codehilite"><pre><span></span><span class="c1">// Get the front element.</span>\n<span class="kd">public</span> <span class="kt">int</span> <span class="nf">peek</span><span class="o">()</span> <span class="o">{</span>\n  <span class="k">return</span> <span class="n">front</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script>.\nThe <code>front</code> element has been calculated in advance and only returned in <code>peek</code> operation.</p>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n<hr>\n<h4 id="approach-2-two-stacks-push-o1-per-operation-pop-amortized-o1-per-operation">Approach #2 (Two Stacks) Push - <script type="math/tex; mode=display">O(1)</script> per operation, Pop - Amortized <script type="math/tex; mode=display">O(1)</script> per operation.</h4>\n<p><strong>Algorithm</strong></p>\n<p><strong>Push</strong></p>\n<p>The newly arrived element is always added on top of stack <code>s1</code> and the first element is kept as <code>front</code> queue element</p>\n<p align="center"><img alt="Push an element in queue" src="https://leetcode.com/media/original_images/232_queue_using_stacksAPush.png" width="539px"></p>\n<p align="center"><em>Figure 3. Push an element in queue</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">private</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>\n<span class="kd">private</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>\n\n<span class="c1">// Push element x to the back of queue.</span>\n<span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">empty</span><span class="o">())</span>\n        <span class="n">front</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>\n    <span class="n">s1</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(1)</script>.</li>\n</ul>\n<p>Аppending an element to a stack is an O(1) operation.</p>\n<ul>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>.\nWe need additional memory to store the queue elements</li>\n</ul>\n<p><strong>Pop</strong></p>\n<p>We have to remove element in front of the queue. This is the first inserted element in the stack <code>s1</code> and it is positioned at the bottom of the stack because of stack\'s <code>LIFO (last in - first out)</code> policy. To remove the bottom element  from  <code>s1</code>, we have to pop all elements from <code>s1</code> and to push them on to an additional stack <code>s2</code>, which helps us to store the elements of <code>s1</code> in reversed order. This way  the bottom element of <code>s1</code> will be positioned on top of <code>s2</code> and we can simply pop it from stack <code>s2</code>. Once <code>s2</code> is empty, the algorithm transfer data from <code>s1</code> to <code>s2</code> again.</p>\n<p align="center"><img alt="Pop an element from stack" src="https://leetcode.com/media/original_images/232_queue_using_stacksAPop.png" width="539px"></p>\n<p align="center"><em>Figure 4. Pop an element from stack</em></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="c1">// Removes the element from in front of queue.</span>\n<span class="kd">public</span> <span class="kt">void</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>\n        <span class="k">while</span> <span class="o">(!</span><span class="n">s1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>\n            <span class="n">s2</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>\n    <span class="o">}</span>\n    <span class="n">s2</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>    \n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity: Amortized <script type="math/tex; mode=display">O(1)</script>, Worst-case <script type="math/tex; mode=display">O(n)</script>.</li>\n</ul>\n<p>In the worst case scenario when stack <code>s2</code> is empty, the algorithm pops <script type="math/tex; mode=display">n</script> elements from stack s1 and pushes <script type="math/tex; mode=display">n</script> elements to <code>s2</code>, where <script type="math/tex; mode=display">n</script> is the queue size. This gives <script type="math/tex; mode=display">2n</script> operations, which is <script type="math/tex; mode=display">O(n)</script>. But when stack <code>s2</code> is not empty the algorithm has <script type="math/tex; mode=display">O(1)</script> time complexity. So what does it mean by Amortized <script type="math/tex; mode=display">O(1)</script>? Please see the next section on Amortized Analysis for more information.</p>\n<ul>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</li>\n</ul>\n<p><strong>Amortized Analysis</strong></p>\n<p>Amortized analysis gives the average performance (over time) of each operation in the worst case. The basic idea is that a worst case operation can alter the state in such a way that the worst case cannot occur again for a long time, thus amortizing its cost.</p>\n<p>Consider this example where we start with an empty queue with the following sequence of operations applied:</p>\n<p>\n<script type="math/tex; mode=display">\npush_1, push_2, \\ldots, push_n, pop_1,pop_2 \\ldots, pop_n\n</script>\n</p>\n<p>The worst case time complexity of a single pop operation is <script type="math/tex; mode=display">O(n)</script>. Since we have <script type="math/tex; mode=display">n</script> pop operations, using the worst-case per operation analysis gives us a total of <script type="math/tex; mode=display">O(n^2)</script> time.</p>\n<p>However, in a sequence of operations the worst case does not occur often in each operation - some operations may be cheap, some may be expensive. Therefore, a traditional worst-case per operation analysis can give overly pessimistic bound. For example, in a dynamic array only some inserts take a linear time, though others - a constant time.</p>\n<p>In the example above, the number of times pop operation can be called is limited by the number of push operations before it. Although a single pop operation could be expensive, it is expensive only once per <code>n</code> times (queue size), when <code>s2</code> is empty and there is a need for data transfer between <code>s1</code> and <code>s2</code>. Hence the total time complexity of the sequence is : <code>n</code> (for push operations) + <code>2*n</code> (for first pop operation) + <code>n - 1</code> ( for pop operations) which is <script type="math/tex; mode=display">O(2*n)</script>.This gives <script type="math/tex; mode=display">O(2n/2n)</script> = <script type="math/tex; mode=display">O(1)</script> average time per operation.</p>\n<p><strong>Empty</strong></p>\n<p>Both stacks <code>s1</code> and <code>s2</code> contain all stack elements, so the algorithm checks <code>s1</code> and <code>s2</code> size to return if the queue is empty.</p>\n<div class="codehilite"><pre><span></span><span class="c1">// Return whether the queue is empty.</span>\n<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">empty</span><span class="o">()</span> <span class="o">{</span>\n    <span class="k">return</span> <span class="n">s1</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>\n<span class="o">}</span>\n</pre></div>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n<p><strong>Peek</strong></p>\n<p>The <code>front</code> element is kept in constant memory and is modified when we push an element. When <code>s2</code> is not empty, front element is positioned on the top of <code>s2</code></p>\n<div class="codehilite"><pre><span></span><span class="c1">// Get the front element.</span>\n<span class="kd">public</span> <span class="kt">int</span> <span class="nf">peek</span><span class="o">()</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(!</span><span class="n">s2</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>\n            <span class="k">return</span> <span class="n">s2</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">front</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n<p>The <code>front</code> element was either previously calculated or returned as a top element of stack <code>s2</code>. Therefore complexity is <script type="math/tex; mode=display">O(1)</script>\n</p>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n<p>Analysis written by: @elmirap.</p>\n</div>\n          ',
    tags: ['Microsoft', 'Bloomberg'],
  },
  {
    id: '233',
    name: 'Number of Digit One',
    acceptance: '28.8%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.</p>\n\n<p>\nFor example:<br> \nGiven n = 13,<br>\nReturn 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-solve-it-mathematically-accepted">Approach #2 Solve it mathematically [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute force [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>Do as directed in question.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>Iterate over <script type="math/tex; mode=display">i</script> from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script>:</li>\n<li>Convert <script type="math/tex; mode=display">i</script> to string and count <script type="math/tex; mode=display">\\text{\'1\'}</script> in each integer string</li>\n<li>Add count of <script type="math/tex; mode=display">\\text{\'1\'}</script> in each string to the sum, say <script type="math/tex; mode=display">countr</script>\n</li>\n</ul>\n<iframe frameborder="0" height="207" name="VwAzPgne" src="https://leetcode.com/playground/VwAzPgne/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity: <script type="math/tex; mode=display">O(n*log_{10}(n))</script>.</li>\n<li>We iterate from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script>\n</li>\n<li>\n<p>In each iteration, we convert integer to string and count \'1\' in string which takes linear time in number of digits in <script type="math/tex; mode=display">i</script>, which is <script type="math/tex; mode=display">log_{10}(n)</script>.</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(log_{10}(n))</script> Extra space for the countr and the converted string <script type="math/tex; mode=display">\\text{str}</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-solve-it-mathematically-accepted">Approach #2 Solve it mathematically [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>In Approach #1, we manually calculated the number of all the <script type="math/tex; mode=display">\'1\'</script>s in the digits, but this is very slow. Hence, we need a way to find a pattern in the way <script type="math/tex; mode=display">\'1\'</script>s (or for that matter any digit) appears in the numbers. We could then use the pattern to formulate the answer.</p>\n<p>Consider the <script type="math/tex; mode=display">1</script>s in <script type="math/tex; mode=display">\\text{ones}</script> place , <script type="math/tex; mode=display">\\text{tens}</script> place, <script type="math/tex; mode=display">\\text{hundreds}</script> place and so on... An analysis\nhas been performed in the following figure.</p>\n<p align="center"><img alt="Number of digit one" src="https://leetcode.com/articles/Figures/233/number_of_digit_one.png" width="800px"></p>\n<p>From the figure, we can see that from digit \'1\' at <script type="math/tex; mode=display">\\text{ones}</script> place repeat in group of 1 after interval of <script type="math/tex; mode=display">10</script>. Similarly, \'1\' at <script type="math/tex; mode=display">\\text{tens}</script> place repeat in group of 10 after interval of <script type="math/tex; mode=display">100</script>.\nThis can be formulated as <script type="math/tex; mode=display">(n/(i*10))*i</script>.</p>\n<p>Also, notice that if the digit at <script type="math/tex; mode=display">\\text{tens}</script> place is <script type="math/tex; mode=display">\\text{\'1\'}</script>, then the number of terms with <script type="math/tex; mode=display">\\text{\'1\'s}</script>  is increased by <script type="math/tex; mode=display">x+1</script>, if the number is say <script type="math/tex; mode=display">\\text{"ab1x"}</script>. As if digits at <script type="math/tex; mode=display">\\text{tens}</script> place is greater than <script type="math/tex; mode=display">1</script>, then all the <script type="math/tex; mode=display">10</script> occurances of numbers with <script type="math/tex; mode=display">\'1\'</script> at <script type="math/tex; mode=display">\\text{tens}</script> place have taken place, hence, we add <script type="math/tex; mode=display">10</script>.\nThis is formluated as <script type="math/tex; mode=display">{\\min(\\max((\\text{n mod (i*10)} )-i+1,0),i)}</script>.</p>\n<p>Lets take an example, say <script type="math/tex; mode=display">n= 1234</script>.</p>\n<p>No of <script type="math/tex; mode=display">\\text{\'1\'}</script> in <script type="math/tex; mode=display">\\text{ones}</script> place = <script type="math/tex; mode=display">1234/10</script>(corresponding to 1,11,21,...1221) + <script type="math/tex; mode=display">\\min(4,1)</script>(corresponding to 1231) =<script type="math/tex; mode=display">124</script>\n</p>\n<p>No of <script type="math/tex; mode=display">\\text{\'1\'}</script> in <script type="math/tex; mode=display">\\text{tens}</script> place = <script type="math/tex; mode=display">(1234/100)*10</script>(corresponding to 10,11,12,...,110,111,...1919) +<script type="math/tex; mode=display">\\min(21,10)</script>(corresponding to 1210,1211,...1219)=<script type="math/tex; mode=display">130</script>\n</p>\n<p>No of <script type="math/tex; mode=display">\\text{\'1\'}</script> in <script type="math/tex; mode=display">\\text{hundreds}</script> place = <script type="math/tex; mode=display">(1234/1000)*100</script>(corresponding to 100,101,12,...,199) +<script type="math/tex; mode=display">\\min(135,100)</script>(corresponding to 1100,1101...1199)=<script type="math/tex; mode=display">200</script>\n</p>\n<p>No of <script type="math/tex; mode=display">\\text{\'1\'}</script> in <script type="math/tex; mode=display">\\text{thousands}</script> place = <script type="math/tex; mode=display">(1234/10000)*10000</script> +<script type="math/tex; mode=display">\\min(235,1000)</script>(corresponding to 1000,1001,...1234)=<script type="math/tex; mode=display">235</script>\n</p>\n<p>Therefore, Total = <script type="math/tex; mode=display">124+130+200+235 = 689</script>.</p>\n<p>Herein, one formula has been devised, but many other formulae can be devised for faster implementations, but the essence and complexity remains the same. The users are encouraged to try to divise their own version of solution using the mathematical concepts.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>Iterate over <script type="math/tex; mode=display">i</script> from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script> incrementing by <script type="math/tex; mode=display">10</script> each time:</li>\n<li>Add  <script type="math/tex; mode=display">(n/(i*10))*i</script> to <script type="math/tex; mode=display">\\text{countr}</script> representing the repetition of groups of $$i$ sizes after each <script type="math/tex; mode=display">(i*10)</script> interval.</li>\n<li>Add <script type="math/tex; mode=display">{\\min(\\max((\\text{n mod (i*10)} )-i+1,0),i)}</script> to <script type="math/tex; mode=display">\\text{countr}</script> representing the additional digits dependant on the digit in <script type="math/tex; mode=display">i</script>th place as described in intuition.</li>\n</ul>\n<iframe frameborder="0" height="207" name="QVzpgtNB" src="https://leetcode.com/playground/QVzpgtNB/shared" width="100%"></iframe>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>Time complexity: <script type="math/tex; mode=display">O(log_{10}(n))</script>.</li>\n<li>\n<p>No of iterations equal to the number of digits in n which is <script type="math/tex; mode=display">log_{10}(n)</script>\n</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(1)</script> space required.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by <a href="https://leetcode.com/abhinavbansal0">@abhinavbansal0</a>.</p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '234',
    name: 'Palindrome Linked List',
    acceptance: '33.2%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a singly linked list, determine if it is a palindrome.</p>\n\n<p><b>Follow up:</b><br>\nCould you do it in O(n) time and O(1) space?</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Amazon', 'IXL'],
  },
  {
    id: '235',
    name: 'Lowest Common Ancestor of a Binary Search Tree',
    acceptance: '39.5%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.\n</p>\n\n<p>\nAccording to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow <b>a node to be a descendant of itself</b>).”\n</p>\n\n<pre>        _______6______\n       /              \\\n    ___2__          ___8__\n   /      \\        /      \\\n   0      _4       7       9\n         /  \\\n         3   5\n</pre>\n\n<p>\nFor example, the lowest common ancestor (LCA) of nodes <code>2</code> and <code>8</code> is <code>6</code>. Another example is LCA of nodes <code>2</code> and <code>4</code> is <code>2</code>, since a node can be a descendant of itself according to the LCA definition.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Amazon', 'Twitter'],
  },
  {
    id: '236',
    name: 'Lowest Common Ancestor of a Binary Tree',
    acceptance: '30.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n</p>\n\n<p>\nAccording to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow <b>a node to be a descendant of itself</b>).”\n</p>\n\n<pre>        _______3______\n       /              \\\n    ___5__          ___1__\n   /      \\        /      \\\n   6      _2       0       8\n         /  \\\n         7   4\n</pre>\n\n<p>\nFor example, the lowest common ancestor (LCA) of nodes <code>5</code> and <code>1</code> is <code>3</code>. Another example is LCA of nodes <code>5</code> and <code>4</code> is <code>5</code>, since a node can be a descendant of itself according to the LCA definition.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Amazon', 'LinkedIn', 'Apple'],
  },
  {
    id: '237',
    name: 'Delete Node in a Linked List',
    acceptance: '47.1%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nWrite a function to delete a node (except the tail) in a singly linked list, given only access to that node.\n</p>\n\n<p>\nSupposed the linked list is <code>1 -&gt; 2 -&gt; 3 -&gt; 4</code> and you are given the third node with value <code>3</code>, the linked list should become <code>1 -&gt; 2 -&gt; 4</code> after calling your function.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<h2 id="solution">Solution</h2>\n<h4 id="approach-swap-with-next-node-accepted">Approach: Swap with Next Node [Accepted]</h4>\n<p>The usual way of deleting a node <code>node</code> from a linked list is to modify the <code>next</code> pointer of the node <em>before</em> it, to point to the node <em>after</em> it.</p>\n<p><img src="https://leetcode.com/media/original_images/237_LinkedList.png" width="400"></p>\n<p>Since we do not have access to the node <em>before</em> the one we want to delete, we cannot modify the <code>next</code> pointer of that node in any way. Instead, we have to replace the value of the node we want to delete with the value in the node after it, and then delete the node after it.</p>\n<p><img src="https://leetcode.com/media/original_images/237_LinkedList2.png" width="400"></p>\n<p><img src="https://leetcode.com/media/original_images/237_LinkedList3.png" width="400"></p>\n<p><img src="https://leetcode.com/media/original_images/237_LinkedList4.png" width="330"></p>\n<p>Because we know that the node we want to delete is not the tail of the list, we can guarantee that this approach is possible.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteNode</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>\n    <span class="n">node</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>Time and space complexity are both <script type="math/tex; mode=display">O(1)</script>.</p>\n<p>Analysis written by: @noran</p>\n</div>\n          ',
    tags: ['Microsoft', 'Apple', 'Adobe'],
  },
  {
    id: '238',
    name: 'Product of Array Except Self',
    acceptance: '49.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array of <i>n</i> integers where <i>n</i> &gt; 1, <code>nums</code>, return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</p>\n\n<p>Solve it <b>without division</b> and in O(<i>n</i>).</p>\n\n<p>For example, given <code>[1,2,3,4]</code>, return <code>[24,12,8,6]</code>.\n\n</p><p><b>Follow up:</b><br>\nCould you solve it with constant space complexity? (Note: The output array <b>does not</b> count as extra space for the purpose of space complexity analysis.)</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Amazon', 'LinkedIn', 'Apple'],
  },
  {
    id: '239',
    name: 'Sliding Window Maximum',
    acceptance: '33.7%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>Given an array <i>nums</i>, there is a sliding window of size <i>k</i> which is moving from the very left of the array to the very right. You can only see the <i>k</i> numbers in the window. Each time the sliding window moves right by one position.</p>\n\n<p>For example,<br>\nGiven <i>nums</i> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <i>k</i> = 3.</p>\n\n<pre>Window position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n</pre>\n\n<p>Therefore, return the max sliding window as <code>[3,3,5,5,6,7]</code>.</p>\n\n<p><b>Note: </b><br>\nYou may assume <i>k</i> is always valid, ie: 1 ≤ k ≤ input array's size for non-empty array.</p>\n\n<p><b>Follow up:</b><br>\nCould you solve it in linear time?</p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Amazon', 'Zenefits'],
  },
  {
    id: '240',
    name: 'Search a 2D Matrix II',
    acceptance: '38.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Write an efficient algorithm that searches for a value in an <i>m</i> x <i>n</i> matrix. This matrix has the following properties:</p>\n\n<p>\n</p><ul>\n<li>Integers in each row are sorted in ascending from left to right.</li>\n<li>Integers in each column are sorted in ascending from top to bottom.</li>\n</ul>\n<p></p>\n\n<p>\nFor example,</p>\n<p>\nConsider the following matrix:\n</p>\n<pre>[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n</pre>\n\n<p>Given <b>target</b> = <code>5</code>, return <code>true</code>.</p>\n<p>Given <b>target</b> = <code>20</code>, return <code>false</code>.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-search-space-reduction-accepted">Approach #2 Search Space Reduction [Accepted]</a></li>\n<li><a href="#footnotes">Footnotes</a></li>\n</ul>\n</div>\n<h4 id="approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>As a baseline, we can search the 2D array the same way we might search an\nunsorted 1D array -- by examining each element.</p>\n<p><strong>Algorithm</strong></p>\n<p>The algorithm doesn\'t really do anything more clever than what is explained\nby the intuition; we loop over the array, checking each element in turn. If\nwe find it, we return <code>true</code>. Otherwise, if we reach the end of the nested\n<code>for</code> loop without returning, we return <code>false</code>. The algorithm must return\nthe correct answer in all cases because we exhaust the entire search space.</p>\n<iframe frameborder="0" height="276" name="B6qDART7" src="https://leetcode.com/playground/B6qDART7/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nm)</script>\n</p>\n<p>Becase we perform a constant time operation for each element of an\n<script type="math/tex; mode=display">n\\times m</script> element matrix, the overall time complexity is equal to the\nsize of the matrix.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n<p>The brute force approach does not allocate more additional space than a\nhandful of pointers, so the memory footprint is constant.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-search-space-reduction-accepted">Approach #2 Search Space Reduction [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Because the rows and columns of the matrix are sorted (from left-to-right and\ntop-to-bottom, respectively), we can prune one <script type="math/tex; mode=display">O(1</script> row<script type="math/tex; mode=display">)</script> or one\n<script type="math/tex; mode=display">O(1</script> column<script type="math/tex; mode=display">)</script> when looking at any particular value.</p>\n<p><strong>Algorithm</strong></p>\n<p>First, we initialize a <script type="math/tex; mode=display">(row, col)</script> pointer to the bottom-left of the\nmatrix.<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup> Then, until we find <code>target</code> and return <code>true</code> (or the pointer\npoints to a <script type="math/tex; mode=display">(row, col)</script> that lies outside of the dimensions of the\nmatrix), we do the following: if the currently-pointed-to value is larger\nthan <code>target</code> we can move one row "up". Otherwise, if the\ncurrently-pointed-to value is smaller than <code>target</code>, we can move one column\n"right". It is not too tricky to see why doing this will never prune the\ncorrect answer; because the rows are sorted from left-to-right, we know that\nevery value to the right of the current value is larger. Therefore, if the\ncurrent value is already larger than <code>target</code>, we know that every value to\nits right will also be too large. A very similar argument can be made for the\ncolumns, so this manner of search will always find <code>target</code> in the matrix (if\nit is present).</p>\n<p>Check out some sample runs of the algorithm in the animation below:</p>\n<p>!?!../Documents/240_Search_a_2D_Matrix_II.json:1280,720!?!</p>\n<iframe frameborder="0" height="463" name="B3fLkCrG" src="https://leetcode.com/playground/B3fLkCrG/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n+m)</script>\n</p>\n<p>The key to the time complexity analysis is noticing that, on every\niteration (during which we do not return <code>true</code>) either <code>row</code> or <code>col</code> is\nis decremented/incremented exactly once. Because <code>row</code> can only be\ndecremented <script type="math/tex; mode=display">m</script> times and <code>col</code> can only be incremented <script type="math/tex; mode=display">n</script> times\nbefore causing the <code>while</code> loop to terminate, the loop cannot run for\nmore than <script type="math/tex; mode=display">n+m</script> iterations. Because all other work is constant, the\noverall time complexity is linear in the sum of the dimensions of the\nmatrix.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n<p>Because this approach only manipulates a few pointers, its memory\nfootprint is constant.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis and solutions written by: <a href="https://leetcode.com/emptyset">@emptyset</a></p>\n<h4 id="footnotes">Footnotes</h4>\n<div class="footnote">\n<hr>\n<ol>\n<li id="fn:1">\n<p>This would work equally well with a pointer initialized to the\ntop-right. Neither of the other two corners would work, as pruning a\nrow/column might prevent us from achieving the correct answer.&nbsp;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">↩</a></p>\n</li>\n</ol>\n</div>\n</div>\n          ',
    tags: ['Google', 'Amazon', 'Apple'],
  },
  {
    id: '241',
    name: 'Different Ways to Add Parentheses',
    acceptance: '45.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are <code>+</code>, <code>-</code> and <code>*</code>.</p>\n<br>\n<b>Example 1</b>\n<p>Input: <code>"2-1-1"</code>.</p> \n<pre>((2-1)-1) = 0\n(2-(1-1)) = 2</pre>\n<p>Output: <code>[0, 2]</code></p>\n<br>\n<b>Example 2</b>\n<p>Input: <code>"2*3-4*5"</code></p> \n<pre>(2*(3-(4*5))) = -34\n((2*3)-(4*5)) = -14\n((2*(3-4))*5) = -10\n(2*((3-4)*5)) = -10\n(((2*3)-4)*5) = 10</pre>\n<p>Output: <code>[-34, -14, -10, -10, 10]</code></p> \n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/mithmatt">@mithmatt</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '242',
    name: 'Valid Anagram',
    acceptance: '47.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given two strings <i>s</i> and <i>t</i>, write a function to determine if <i>t</i> is an anagram of <i>s</i>.</p> \n\n<p>For example,<br>\n<i>s</i> = "anagram", <i>t</i> = "nagaram", return true.<br>\n<i>s</i> = "rat", <i>t</i> = "car", return false.\n</p>\n\n<p><b>Note:</b><br>\nYou may assume the string contains only lowercase alphabets.</p>\n\n<p><b>Follow up:</b><br>\nWhat if the inputs contain unicode characters? How would you adapt your solution to such case?</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-sorting-accepted">Approach #1 (Sorting) [Accepted]</a></li>\n<li><a href="#approach-2-hash-table-accepted">Approach #2 (Hash Table) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-sorting-accepted">Approach #1 (Sorting) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>An anagram is produced by rearranging the letters of <script type="math/tex; mode=display">s</script> into <script type="math/tex; mode=display">t</script>. Therefore, if <script type="math/tex; mode=display">t</script> is an anagram of <script type="math/tex; mode=display">s</script>, sorting both strings will result in two identical strings. Furthermore, if <script type="math/tex; mode=display">s</script> and <script type="math/tex; mode=display">t</script> have different lengths, <script type="math/tex; mode=display">t</script> must not be an anagram of <script type="math/tex; mode=display">s</script> and we can return early.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isAnagram</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="n">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>\n        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="kt">char</span><span class="o">[]</span> <span class="n">str1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>\n    <span class="kt">char</span><span class="o">[]</span> <span class="n">str2</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>\n    <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">str1</span><span class="o">);</span>\n    <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">str2</span><span class="o">);</span>\n    <span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">str1</span><span class="o">,</span> <span class="n">str2</span><span class="o">);</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n \\log n)</script>.\nAssume that <script type="math/tex; mode=display">n</script> is the length of <script type="math/tex; mode=display">s</script>, sorting costs <script type="math/tex; mode=display">O(n \\log n)</script> and comparing two strings costs <script type="math/tex; mode=display">O(n)</script>. Sorting time dominates and the overall time complexity is <script type="math/tex; mode=display">O(n \\log n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.\nSpace depends on the sorting implementation which, usually, costs <script type="math/tex; mode=display">O(1)</script> auxiliary space if <code>heapsort</code> is used. Note that in Java, <code>toCharArray()</code> makes a copy of the string so it costs <script type="math/tex; mode=display">O(n)</script> extra space, but we ignore this for complexity analysis because:</p>\n<ul>\n<li>It is a language dependent detail.</li>\n<li>It depends on how the function is designed. For example, the function parameter types can be changed to <code>char[]</code>.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-hash-table-accepted">Approach #2 (Hash Table) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>To examine if <script type="math/tex; mode=display">t</script> is a rearrangement of <script type="math/tex; mode=display">s</script>, we can count occurrences of each letter in the two strings and compare them. Since both <script type="math/tex; mode=display">s</script> and <script type="math/tex; mode=display">t</script> contain only letters from <script type="math/tex; mode=display">a-z</script>, a simple counter table of size 26 is suffice.</p>\n<p>Do we need <em>two</em> counter tables for comparison? Actually no, because we could increment the counter for each letter in <script type="math/tex; mode=display">s</script> and decrement the counter for each letter in <script type="math/tex; mode=display">t</script>, then check if the counter reaches back to zero.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isAnagram</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="n">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>\n        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="kt">int</span><span class="o">[]</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="n">counter</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">\'a\'</span><span class="o">]++;</span>\n        <span class="n">counter</span><span class="o">[</span><span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">\'a\'</span><span class="o">]--;</span>\n    <span class="o">}</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">count</span> <span class="o">:</span> <span class="n">counter</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p>Or we could first increment the counter for <script type="math/tex; mode=display">s</script>, then decrement the counter for <script type="math/tex; mode=display">t</script>. If at any point the counter drops below zero, we know that <script type="math/tex; mode=display">t</script> contains an extra letter not in <script type="math/tex; mode=display">s</script> and return false immediately.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isAnagram</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="n">String</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>\n        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="kt">int</span><span class="o">[]</span> <span class="n">table</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="n">table</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">\'a\'</span><span class="o">]++;</span>\n    <span class="o">}</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="n">table</span><span class="o">[</span><span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">\'a\'</span><span class="o">]--;</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">table</span><span class="o">[</span><span class="n">t</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="sc">\'a\'</span><span class="o">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nTime complexity is <script type="math/tex; mode=display">O(n)</script> because accessing the counter table is a constant time operation.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.\nAlthough we do use extra space, the space complexity is <script type="math/tex; mode=display">O(1)</script> because the table\'s size stays constant no matter how large <script type="math/tex; mode=display">n</script> is.</p>\n</li>\n</ul>\n<p><strong>Follow up</strong></p>\n<p>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>\n<p><strong>Answer</strong></p>\n<p>Use a hash table instead of a fixed size counter. Imagine allocating a large size array to fit the entire range of unicode characters, which could go up to <a href="https://stackoverflow.com/a/5928054/490463">more than 1 million</a>. A hash table is a more generic solution and could adapt to any range of characters.</p>\n</div>\n          ',
    tags: ['Amazon', 'Uber', 'Yelp'],
  },
  {
    id: '243',
    name: 'Shortest Word Distance ',
    acceptance: '53.1%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a list of words and two words <i>word1</i> and <i>word2</i>, return the shortest distance between these two words in the list.</p>\n<p>For example,<br>\nAssume that words = <code>["practice", "makes", "perfect", "coding", "makes"]</code>.\n</p>\n<p>\nGiven <i>word1</i> = <code>“coding”</code>, <i>word2</i> = <code>“practice”</code>, return 3.<br>\nGiven <i>word1</i> = <code>"makes"</code>, <i>word2</i> = <code>"coding"</code>, return 1.\n</p>\n\n<p>\n<b>Note:</b><br>\nYou may assume that <i>word1</i> <b>does not equal to</b> <i>word2</i>, and <i>word1</i> and <i>word2</i> are both in the list.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1 (Brute Force) [Accepted]</a></li>\n<li><a href="#approach-2-one-pass-accepted">Approach #2 (One-pass) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<p>This is a straight-forward coding problem. The distance between any two positions <script type="math/tex; mode=display">i_1</script> and <script type="math/tex; mode=display">i_2</script> in an array is <script type="math/tex; mode=display">|i_1 - i_2|</script>. To find the shortest distance between <code>word1</code> and <code>word2</code>, we need to traverse the input array and find all occurrences <script type="math/tex; mode=display">i_1</script> and <script type="math/tex; mode=display">i_2</script> of the two words, and check if <script type="math/tex; mode=display">|i_1 - i_2|</script> is less than the minimum distance computed so far.</p>\n<hr>\n<h4 id="approach-1-brute-force-accepted">Approach #1 (Brute Force) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>A naive solution to this problem is to go through the entire array looking for the first word. Every time we find an occurrence of the first word, we search the entire array for the closest occurrence of the second word.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">shortestDistance</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">,</span> <span class="n">String</span> <span class="n">word1</span><span class="o">,</span> <span class="n">String</span> <span class="n">word2</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">minDistance</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">word1</span><span class="o">))</span> <span class="o">{</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">word2</span><span class="o">))</span> <span class="o">{</span>\n                    <span class="n">minDistance</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minDistance</span><span class="o">,</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="o">));</span>\n                <span class="o">}</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">minDistance</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>The time complexity is <script type="math/tex; mode=display">O(n^2)</script>, since for every occurrence of <code>word1</code>, we traverse the entire array in search for the closest occurrence of <code>word2</code>.</p>\n<p>Space complexity is <script type="math/tex; mode=display">O(1)</script>, since no additional space is used.</p>\n<hr>\n<h4 id="approach-2-one-pass-accepted">Approach #2 (One-pass) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can greatly improve on the brute-force approach by keeping two indices <code>i1</code> and <code>i2</code> where we store the <em>most recent</em> locations of <code>word1</code> and <code>word2</code>. Each time we find a new occurrence of one of the words, we do not need to search the entire array for the other word, since we already have the index of its most recent occurrence.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">shortestDistance</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">,</span> <span class="n">String</span> <span class="n">word1</span><span class="o">,</span> <span class="n">String</span> <span class="n">word2</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">minDistance</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">currentDistance</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">word1</span><span class="o">))</span> <span class="o">{</span>\n            <span class="n">i1</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>\n        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">word2</span><span class="o">))</span> <span class="o">{</span>\n            <span class="n">i2</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>\n        <span class="o">}</span>\n\n        <span class="k">if</span> <span class="o">(</span><span class="n">i1</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i2</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">minDistance</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minDistance</span><span class="o">,</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">i1</span> <span class="o">-</span> <span class="n">i2</span><span class="o">));</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">minDistance</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>The time complexity is <script type="math/tex; mode=display">O(n)</script>. This problem is inherently linear; we cannot do better than <script type="math/tex; mode=display">O(n)</script> because at the very least, we have to read the entire input.</p>\n<p>Space complexity is <script type="math/tex; mode=display">O(1)</script>, since no additional space is allocated.</p>\n<p>Analysis written by: @noran</p>\n</div>\n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '244',
    name: 'Shortest Word Distance II ',
    acceptance: '40.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>This is a <b>follow up</b> of <a href="/problems/shortest-word-distance">Shortest Word Distance</a>. The only difference is now you are given the list of words and your method will be called <i>repeatedly</i> many times with different parameters. How would you optimize it?</p>\n\n<p>Design a class which receives a list of words in the constructor, and implements a method that takes two words <i>word1</i> and <i>word2</i> and return the shortest distance between these two words in the list.</p>\n\n<p>For example,<br>\nAssume that words = <code>["practice", "makes", "perfect", "coding", "makes"]</code>.\n</p>\n\n<p>\nGiven <i>word1</i> = <code>“coding”</code>, <i>word2</i> = <code>“practice”</code>, return 3.<br>\nGiven <i>word1</i> = <code>"makes"</code>, <i>word2</i> = <code>"coding"</code>, return 1.\n</p>\n\n<p>\n<b>Note:</b><br>\nYou may assume that <i>word1</i> <b>does not equal to</b> <i>word2</i>, and <i>word1</i> and <i>word2</i> are both in the list.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '245',
    name: 'Shortest Word Distance III ',
    acceptance: '51.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>This is a <b>follow up</b> of <a href="/problems/shortest-word-distance">Shortest Word Distance</a>. The only difference is now <i>word1</i> could be the same as <i>word2</i>.</p>\n\n<p>Given a list of words and two words <i>word1</i> and <i>word2</i>, return the shortest distance between these two words in the list.</p>\n\n<p><i>word1</i> and <i>word2</i> may be the same and they represent two individual words in the list.</p>\n<p>For example,<br>\nAssume that words = <code>["practice", "makes", "perfect", "coding", "makes"]</code>.\n</p>\n<p>\nGiven <i>word1</i> = <code>“makes”</code>, <i>word2</i> = <code>“coding”</code>, return 1.<br>\nGiven <i>word1</i> = <code>"makes"</code>, <i>word2</i> = <code>"makes"</code>, return 3.\n</p>\n\n<p>\n<b>Note:</b><br>\nYou may assume <i>word1</i> and <i>word2</i> are both in the list.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '246',
    name: 'Strobogrammatic Number ',
    acceptance: '40.1%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).</p>\n<p>Write a function to determine if a number is strobogrammatic. The number is represented as a string.</p>\n<p>For example, the numbers "69", "88", and "818" are all strobogrammatic.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '247',
    name: 'Strobogrammatic Number II ',
    acceptance: '40.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).</p>\n<p>Find all strobogrammatic numbers that are of length = n. </p>\n<p>For example,<br>\nGiven n = 2, return <code>["11","69","88","96"]</code>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '248',
    name: 'Strobogrammatic Number III ',
    acceptance: '32.3%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).</p>\n<p>Write a function to count the total strobogrammatic numbers that exist in the range of low &lt;= num &lt;= high.</p>\n<p>For example,<br>\nGiven low = "50", high = "100", return 3. Because 69, 88, and 96 are three strobogrammatic numbers.\n</p>\n\n<p><b>Note:</b><br>\nBecause the range might be a large number, the <i>low</i> and <i>high</i> numbers are represented as string.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '249',
    name: 'Group Shifted Strings ',
    acceptance: '43.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a string, we can "shift" each of its letter to its successive letter, for example: <code>"abc" -&gt; "bcd"</code>. We can keep "shifting" which forms the sequence:</p>\n<pre>"abc" -&gt; "bcd" -&gt; ... -&gt; "xyz"</pre>\n\n<p>Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.</p>\n\n<p>For example, given: <code>["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"]</code>, <br>\nA solution is:\n</p><pre>[\n  ["abc","bcd","xyz"],\n  ["az","ba"],\n  ["acef"],\n  ["a","z"]\n]</pre><p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Uber'],
  },
  {
    id: '250',
    name: 'Count Univalue Subtrees ',
    acceptance: '43.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a binary tree, count the number of uni-value subtrees.</p>\n<p>A Uni-value subtree means all nodes of the subtree have the same value.</p>\n\n<p>\nFor example:<br>\nGiven binary tree,<br>\n</p><pre>              5\n             / \\\n            1   5\n           / \\   \\\n          5   5   5\n</pre>\n<p></p>\n<p>\nreturn <code>4</code>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '251',
    name: 'Flatten 2D Vector ',
    acceptance: '41.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nImplement an iterator to flatten a 2d vector.\n</p>\n\n<p>For example,<br>\nGiven 2d vector = \n</p><pre>[\n  [1,2],\n  [3],\n  [4,5,6]\n]\n</pre>\n<p></p>\n<p>\nBy calling <i>next</i> repeatedly until <i>hasNext</i> returns false, the order of elements returned by <i>next</i> should be: <code>[1,2,3,4,5,6]</code>.\n</p>\n\n<p>\n<b>Follow up:</b><br>\nAs an added challenge, try to code it using only <a href="http://www.cplusplus.com/reference/iterator/iterator/" target="_blank">iterators in C++</a> or <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html" target="_blank">iterators in Java</a>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Twitter', 'Airbnb', 'Zenefits'],
  },
  {
    id: '252',
    name: 'Meeting Rooms ',
    acceptance: '48.5%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (s<sub>i</sub> &lt; e<sub>i</sub>), determine if a person could attend all meetings.</p>\n\n<p>\nFor example,<br>\nGiven <code>[[0, 30],[5, 10],[15, 20]]</code>,<br>\nreturn <code>false</code>.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1 (Brute Force) [Accepted]</a></li>\n<li><a href="#approach-2-sorting-accepted">Approach #2 (Sorting) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-accepted">Approach #1 (Brute Force) [Accepted]</h4>\n<p>The straight-forward solution is to compare every two meetings in the array, and see if they conflict with each other (i.e. if they overlap). Two meetings overlap if one of them starts while the other is still taking place.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canAttendMeetings</span><span class="o">(</span><span class="n">Interval</span><span class="o">[]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">overlap</span><span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">intervals</span><span class="o">[</span><span class="n">j</span><span class="o">]))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">overlap</span><span class="o">(</span><span class="n">Interval</span> <span class="n">i1</span><span class="o">,</span> <span class="n">Interval</span> <span class="n">i2</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">return</span> <span class="o">((</span><span class="n">i1</span><span class="o">.</span><span class="na">start</span> <span class="o">&gt;=</span> <span class="n">i2</span><span class="o">.</span><span class="na">start</span> <span class="o">&amp;&amp;</span> <span class="n">i1</span><span class="o">.</span><span class="na">start</span> <span class="o">&lt;</span> <span class="n">i2</span><span class="o">.</span><span class="na">end</span><span class="o">)</span>\n         <span class="o">||</span> <span class="o">(</span><span class="n">i2</span><span class="o">.</span><span class="na">start</span> <span class="o">&gt;=</span> <span class="n">i1</span><span class="o">.</span><span class="na">start</span> <span class="o">&amp;&amp;</span> <span class="n">i2</span><span class="o">.</span><span class="na">start</span> <span class="o">&lt;</span> <span class="n">i1</span><span class="o">.</span><span class="na">end</span><span class="o">));</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Overlap Condition</strong></p>\n<p>The overlap condition in the code above can be written in a more concise way. Consider two non-overlapping meetings. The earlier meeting ends before the later meeting begins. Therefore, the <em>minimum</em> end time of the two meetings (which is the end time of the earlier meeting) is smaller than or equal the <em>maximum</em> start time of the two meetings (which is the start time of the later meeting).</p>\n<p align="center"><img alt="Two non-overlapping intervals" src="https://leetcode.com/media/original_images/252_NonOverlappingIntervals.png" title="Odd Even Linked List" width="300px"></p>\n<p align="center"><em>Figure 1. Two non-overlapping intervals.</em></p>\n<p align="center"><img alt="Two overlapping intervals" src="https://leetcode.com/media/original_images/252_OverlappingIntervals.png" title="Odd Even Linked List" width="280px"></p>\n<p align="center"><em>Figure 2. Two overlapping intervals.</em></p>\n<p>So the condition can be rewritten as follows.</p>\n<div class="codehilite"><pre><span></span><span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">overlap</span><span class="o">(</span><span class="n">Interval</span> <span class="n">i1</span><span class="o">,</span> <span class="n">Interval</span> <span class="n">i2</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">return</span> <span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">i1</span><span class="o">.</span><span class="na">end</span><span class="o">,</span> <span class="n">i2</span><span class="o">.</span><span class="na">end</span><span class="o">)</span> <span class="o">&gt;</span>\n            <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">i1</span><span class="o">.</span><span class="na">start</span><span class="o">,</span> <span class="n">i2</span><span class="o">.</span><span class="na">start</span><span class="o">));</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>Because we have two check every meeting with every other meeting, the total run time is <script type="math/tex; mode=display">O(n^2)</script>. No additional space is used, so the space complexity is <script type="math/tex; mode=display">O(1)</script>.</p>\n<hr>\n<h4 id="approach-2-sorting-accepted">Approach #2 (Sorting) [Accepted]</h4>\n<p>The idea here is to sort the meetings by starting time. Then, go through the meetings one by one and make sure that each meeting ends before the next one starts.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canAttendMeetings</span><span class="o">(</span><span class="n">Interval</span><span class="o">[]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;()</span> <span class="o">{</span>\n        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Interval</span> <span class="n">i1</span><span class="o">,</span> <span class="n">Interval</span> <span class="n">i2</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">return</span> <span class="n">i1</span><span class="o">.</span><span class="na">start</span> <span class="o">-</span> <span class="n">i2</span><span class="o">.</span><span class="na">start</span><span class="o">;</span>\n        <span class="o">}</span>        \n    <span class="o">});</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intervals</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">end</span> <span class="o">&gt;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">].</span><span class="na">start</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n \\log n)</script>.\nThe time complexity is dominated by sorting. Once the array has been sorted, only <script type="math/tex; mode=display">O(n)</script> time is taken to go through the array and determine if there is any overlap.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.\nSince no additional space is allocated.</p>\n</li>\n</ul>\n<p>Analysis written by: @noran</p>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '253',
    name: 'Meeting Rooms II ',
    acceptance: '39.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (s<sub>i</sub> &lt; e<sub>i</sub>), find the minimum number of conference rooms required.</p>\n\n<p>\nFor example,<br>\nGiven <code>[[0, 30],[5, 10],[15, 20]]</code>,<br>\nreturn <code>2</code>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Snapchat'],
  },
  {
    id: '254',
    name: 'Factor Combinations ',
    acceptance: '43.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Numbers can be regarded as product of its factors. For example,  </p>\n<pre>8 = 2 x 2 x 2;\n  = 2 x 4.\n</pre>\n<p>Write a function that takes an integer <i>n</i> and return all possible combinations of its factors. \n</p>\n\n<p><b>Note:</b> <br>\n</p><ol>\n<li>You may assume that <i>n</i> is always positive. </li>\n<li>Factors should be greater than 1 and less than <i>n</i>.</li>\n</ol>\n<p></p>\n\n<p><b>Examples: </b><br>\n input: <code>1</code><br>\n output: <br>\n</p><pre>[]\n</pre>\ninput: <code>37</code><br>\n output: <br>\n<pre>[]\n</pre>\n input: <code>12</code><br>\n output:<br>\n<pre>[\n  [2, 6],\n  [2, 2, 3],\n  [3, 4]\n]\n</pre>\n input: <code>32</code><br>\n output:<br>\n<pre>[\n  [2, 16],\n  [2, 2, 8],\n  [2, 2, 2, 4],\n  [2, 2, 2, 2, 2],\n  [2, 4, 4],\n  [4, 8]\n]\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Uber', 'LinkedIn'],
  },
  {
    id: '255',
    name: 'Verify Preorder Sequence in Binary Search Tree ',
    acceptance: '40.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree.</p>\n\n<p>You may assume each number in the sequence is unique.</p>\n\n<p><b>Follow up:</b><br>\nCould you do it using only constant space complexity?</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Zenefits'],
  },
  {
    id: '256',
    name: 'Paint House ',
    acceptance: '46.2%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nThere are a row of <i>n</i> houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n</p>\n<p>\nThe cost of painting each house with a certain color is represented by a <code><i>n</i> x <i>3</i></code> cost matrix. For example, <code>costs[0][0]</code> is the cost of painting house 0 with color red; <code>costs[1][2]</code> is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses.\n</p>\n\n<p><b>Note:</b><br>\nAll costs are positive integers.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '257',
    name: 'Binary Tree Paths',
    acceptance: '40.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a binary tree, return all root-to-leaf paths.\n</p>\n<p>\nFor example, given the following binary tree:\n</p>\n<p>\n</p><pre>   1\n /   \\\n2     3\n \\\n  5\n</pre>\n<p></p>\n<p>\nAll root-to-leaf paths are:\n</p><pre>["1-&gt;2-&gt;5", "1-&gt;3"]</pre>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Apple'],
  },
  {
    id: '258',
    name: 'Add Digits',
    acceptance: '51.5%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a non-negative integer <code>num</code>, repeatedly add all its digits until the result has only one digit. \n</p>\n\n<p>\nFor example:\n</p>\n<p>\nGiven <code>num = 38</code>, the process is like: <code>3 + 8 = 11</code>, <code>1 + 1 = 2</code>. Since <code>2</code> has only one digit, return it.\n</p>\n\n<p><b>Follow up:</b><br>\nCould you do it without any loop/recursion in O(1) runtime?\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft', 'Adobe'],
  },
  {
    id: '259',
    name: '3Sum Smaller ',
    acceptance: '41.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given an array of <i>n</i> integers <i>nums</i> and a <i>target</i>, find the number of index triplets <code>i, j, k</code> with <code>0 &lt;= i &lt; j &lt; k &lt; n</code> that satisfy the condition <code>nums[i] + nums[j] + nums[k] &lt; target</code>.</p>\n\n<p>For example, given <i>nums</i> = <code>[-2, 0, 1, 3]</code>, and <i>target</i> = 2.</p>\n\n<p>Return 2. Because there are two triplets which sums are less than 2:</p>\n<pre>[-2, 0, 1]\n[-2, 0, 3]\n</pre>\n\n<p><b>Follow up:</b><br>\nCould you solve it in <i>O</i>(<i>n</i><sup>2</sup>) runtime?\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute Force) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-binary-search-accepted">Approach #2 (Binary Search) [Accepted]</a></li>\n<li><a href="#approach-3-two-pointers-accepted">Approach #3 (Two Pointers) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute Force) [Time Limit Exceeded]</h4>\n<p>The brute force approach is to find every possible triplets <script type="math/tex; mode=display">(i, j, k)</script> subjected to <script type="math/tex; mode=display">i < j < k</script> and test for the condition.</p>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>.\nThe total number of such triplets is <script type="math/tex; mode=display">\\binom{n}{3}</script>, which is <script type="math/tex; mode=display">\\frac{n!}{(n - 3)! \\times 3!} = \\frac{n \\times (n - 1) \\times (n - 2)}{6}</script>. Therefore, the time complexity of the brute force approach is <script type="math/tex; mode=display">O(n^3)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-binary-search-accepted">Approach #2 (Binary Search) [Accepted]</h4>\n<p>Before we solve this problem, it is helpful to first solve this simpler <em>twoSum</em> version.</p>\n<blockquote>\n<p>Given a <script type="math/tex; mode=display">nums</script> array, find the number of index pairs <script type="math/tex; mode=display">i</script>, <script type="math/tex; mode=display">j</script> with <script type="math/tex; mode=display">0 \\leq i < j < n</script> that satisfy the condition <script type="math/tex; mode=display">nums[i] + nums[j] < target</script>\n</p>\n</blockquote>\n<p>If we sort the array first, then we could apply binary search to find the largest index <script type="math/tex; mode=display">j</script> such that <script type="math/tex; mode=display">nums[i] + nums[j] < target</script> for each <script type="math/tex; mode=display">i</script>. Once we found that largest index <script type="math/tex; mode=display">j</script>, we know there must be <script type="math/tex; mode=display">j-i</script> pairs that satisfy the above condition with <script type="math/tex; mode=display">i</script>\'s value fixed.</p>\n<p>Finally, we can now apply the <em>twoSum</em> solution to <em>threeSum</em> directly by wrapping an outer for-loop around it.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">threeSumSmaller</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>\n    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="n">sum</span> <span class="o">+=</span> <span class="n">twoSumSmaller</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="kt">int</span> <span class="nf">twoSumSmaller</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">startIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">startIndex</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>\n        <span class="n">sum</span> <span class="o">+=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">startIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">startIndex</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>\n        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>\n            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">left</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p>Note that in the above binary search we choose the upper middle element <script type="math/tex; mode=display">(\\frac{left+right+1}{2})</script> instead of the lower middle element <script type="math/tex; mode=display">(\\frac{left+right}{2})</script>. The reason is due to the terminating condition when there are two elements left. If we chose the lower middle element and the condition <script type="math/tex; mode=display">nums[mid] < target</script> evaluates to true, then the loop will never terminate. Choosing the upper middle element will guarantee termination.</p>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2 \\log n)</script>.\nThe <em>binarySearch</em> function takes <script type="math/tex; mode=display">O(\\log n)</script> time, therefore the <em>twoSumSmaller</em> takes <script type="math/tex; mode=display">O(n \\log n)</script> time. The <em>threeSumSmaller</em> wraps with another for-loop, and therefore is <script type="math/tex; mode=display">O(n^2 \\log n)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-two-pointers-accepted">Approach #3 (Two Pointers) [Accepted]</h4>\n<p>Let us try sorting the array first. For example, <script type="math/tex; mode=display">nums = [3,5,2,8,1]</script> becomes <script type="math/tex; mode=display">[1,2,3,5,8]</script>.</p>\n<p>Let us look at an example <script type="math/tex; mode=display">nums = [1,2,3,5,8]</script>, and <script type="math/tex; mode=display">target = 7</script>.</p>\n<div class="codehilite"><pre><span></span><span class="k">[1, 2, 3, 5, 8]</span>\n <span class="err">↑</span>           <span class="err">↑</span>\n<span class="err">left</span>       <span class="err">right</span>\n</pre></div>\n<p>Let us initialize two indices, <script type="math/tex; mode=display">left</script> and <script type="math/tex; mode=display">right</script> pointing to the first and last element respectively.</p>\n<p>When we look at the sum of first and last element, it is <script type="math/tex; mode=display">1 + 8 = 9</script>, which is <script type="math/tex; mode=display">\\geq target</script>. That tells us no index pair will ever contain the index <script type="math/tex; mode=display">right</script>. So the next logical step is to move the right pointer one step to its left.</p>\n<div class="codehilite"><pre><span></span><span class="k">[1, 2, 3, 5, 8]</span>\n <span class="err">↑</span>        <span class="err">↑</span>\n<span class="err">left</span>    <span class="err">right</span>\n</pre></div>\n<p>Now the pair sum is <script type="math/tex; mode=display">1 + 5 = 6</script>, which is <script type="math/tex; mode=display">< target</script>. How many pairs with one of the <script type="math/tex; mode=display">index = left</script> that satisfy the condition? You can tell by the difference between <script type="math/tex; mode=display">right</script> and <script type="math/tex; mode=display">left</script> which is <script type="math/tex; mode=display">3</script>, namely <script type="math/tex; mode=display">(1,2), (1,3),</script> and <script type="math/tex; mode=display">(1,5)</script>. Therefore, we move <script type="math/tex; mode=display">left</script> one step to its right.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">threeSumSmaller</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>\n    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="n">sum</span> <span class="o">+=</span> <span class="n">twoSumSmaller</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="kt">int</span> <span class="nf">twoSumSmaller</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">startIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">startIndex</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">sum</span> <span class="o">+=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">;</span>\n            <span class="n">left</span><span class="o">++;</span>\n        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>\n            <span class="n">right</span><span class="o">--;</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>.\nThe <em>twoSumSmaller</em> function takes <script type="math/tex; mode=display">O(n)</script> time because both <em>left</em> and <em>right</em> traverse at most <em>n</em> steps. Therefore, the overall time complexity is <script type="math/tex; mode=display">O(n^2)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '260',
    name: 'Single Number III',
    acceptance: '52.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array of numbers <code>nums</code>, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.\n</p>\n<p>\nFor example:\n</p>\n<p>\nGiven <code>nums = [1, 2, 1, 3, 2, 5]</code>, return <code>[3, 5]</code>.\n</p>\n<p>\n<b>Note</b>:<br>\n</p><ol>\n<li>The order of the result is not important. So in the above example, <code>[5, 3]</code> is also correct.</li>\n<li>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</li>\n</ol>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '261',
    name: 'Graph Valid Tree ',
    acceptance: '38.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.\n</p>\n\n<p>\nFor example:\n</p>\n<p>\nGiven <code>n = 5</code> and <code>edges = [[0, 1], [0, 2], [0, 3], [1, 4]]</code>, return <code>true</code>.\n</p>\n<p>\nGiven <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]</code>, return <code>false</code>.\n</p>\n\n<p>\n<b>Note</b>: you can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in <code>edges</code>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Zenefits'],
  },
  {
    id: '262',
    name: 'Trips and Users',
    acceptance: '18.4%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nThe <code>Trips</code> table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are both foreign keys to the Users_Id at the <code>Users</code> table. Status is an ENUM type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’).</p>\n\n<pre>+----+-----------+-----------+---------+--------------------+----------+\n| Id | Client_Id | Driver_Id | City_Id |        Status      |Request_at|\n+----+-----------+-----------+---------+--------------------+----------+\n| 1  |     1     |    10     |    1    |     completed      |2013-10-01|\n| 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01|\n| 3  |     3     |    12     |    6    |     completed      |2013-10-01|\n| 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01|\n| 5  |     1     |    10     |    1    |     completed      |2013-10-02|\n| 6  |     2     |    11     |    6    |     completed      |2013-10-02|\n| 7  |     3     |    12     |    6    |     completed      |2013-10-02|\n| 8  |     2     |    12     |    12   |     completed      |2013-10-03|\n| 9  |     3     |    10     |    12   |     completed      |2013-10-03| \n| 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03|\n+----+-----------+-----------+---------+--------------------+----------+\n</pre>\n\n<p>\nThe <code>Users</code> table holds all users. Each user has an unique Users_Id, and Role is an ENUM type of (‘client’, ‘driver’, ‘partner’).</p>\n<pre>+----------+--------+--------+\n| Users_Id | Banned |  Role  |\n+----------+--------+--------+\n|    1     |   No   | client |\n|    2     |   Yes  | client |\n|    3     |   No   | client |\n|    4     |   No   | client |\n|    10    |   No   | driver |\n|    11    |   No   | driver |\n|    12    |   No   | driver |\n|    13    |   No   | driver |\n+----------+--------+--------+\n</pre>\n\n<p>Write a SQL query to find the cancellation rate of requests made by unbanned clients between <b>Oct 1, 2013</b> and <b>Oct 3, 2013</b>. For the above tables, your SQL query should return the following rows with the cancellation rate being rounded to <i>two</i> decimal places.</p>\n<pre>+------------+-------------------+\n|     Day    | Cancellation Rate |\n+------------+-------------------+\n| 2013-10-01 |       0.33        |\n| 2013-10-02 |       0.00        |\n| 2013-10-03 |       0.50        |\n+------------+-------------------+\n</pre>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/cak1erlizhou">@cak1erlizhou</a> for contributing this question, writing the problem description and adding part of the test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Uber'],
  },
  {
    id: '263',
    name: 'Ugly Number',
    acceptance: '39.5%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nWrite a program to check whether a given number is an ugly number.\n</p>\n\n<p>\nUgly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>6, 8</code> are ugly while <code>14</code> is not ugly since it includes another prime factor <code>7</code>.\n</p>\n\n<p>\nNote that <code>1</code> is typically treated as an ugly number.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '264',
    name: 'Ugly Number II',
    acceptance: '33.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nWrite a program to find the <code>n</code>-th ugly number.\n</p>\n\n<p>\nUgly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.\n</p>\n\n<p>\nNote that <code>1</code> is typically treated as an ugly number, and <i>n</i> <b>does not exceed 1690</b>.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '265',
    name: 'Paint House II ',
    acceptance: '38.2%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nThere are a row of <i>n</i> houses, each house can be painted with one of the <i>k</i> colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n</p>\n<p>\nThe cost of painting each house with a certain color is represented by a <code><i>n</i> x <i>k</i></code> cost matrix. For example, <code>costs[0][0]</code> is the cost of painting house 0 with color 0; <code>costs[1][2]</code> is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses.\n</p>\n\n<p><b>Note:</b><br>\nAll costs are positive integers.</p>\n\n<p><b>Follow up:</b><br>\nCould you solve it in <i>O</i>(<i>nk</i>) runtime?</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook'],
  },
  {
    id: '266',
    name: 'Palindrome Permutation ',
    acceptance: '57.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a string, determine if a permutation of the string could form a palindrome.</p>\n\n<p>For example,<br>\n<code>"code"</code> -&gt; False, <code>"aab"</code> -&gt; True, <code>"carerac"</code> -&gt; True.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-using-hashmap-accepted">Approach #2 Using HashMap [Accepted]</a></li>\n<li><a href="#approach-3-using-array-accepted">Approach #3 Using Array [Accepted]</a></li>\n<li><a href="#approach-4-single-pass-accepted">Approach #4 Single Pass [Accepted]:</a></li>\n<li><a href="#approach-5-using-set-accepted">Approach #5 Using Set [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</h4>\n<p>If a string with an even length is a palindrome, every character in the string must always occur an even number of times. If the string with an odd length is a palindrome, every character except one of the characters must always occur an even number of times. Thus, in case of a palindrome, the number of characters with odd number of occurences can\'t exceed 1(1 in case of odd length and 0 in case of even length).</p>\n<p>Based on the above observation, we can find the solution for the given problem. The given string could contain atmost all the ASCII characters from 0 to 127. Thus, we iterate over all the characters from 0 to 127. For every character chosen, we again iterate over the given string <script type="math/tex; mode=display">s</script> and find the number of occurences, <script type="math/tex; mode=display">ch</script>, of the current character in <script type="math/tex; mode=display">s</script>. We also keep a track of the number of characters in the given string <script type="math/tex; mode=display">s</script> with odd number of occurences in a variable <script type="math/tex; mode=display">count</script>.</p>\n<p>If, for any character currently considered, its corresponding count, <script type="math/tex; mode=display">ch</script>, happens to be odd, we increment the value of <script type="math/tex; mode=display">count</script>, to reflect the same. In case of even value of <script type="math/tex; mode=display">ch</script> for any character, the <script type="math/tex; mode=display">count</script> remains unchanged.</p>\n<p>If, for any character, the <script type="math/tex; mode=display">count</script> becomes greater than 1, it indicates that the given string <script type="math/tex; mode=display">s</script> can\'t lead to the formation of a palindromic permutation based on the reasoning discussed above. But, if the value of <script type="math/tex; mode=display">count</script> remains lesser than 2 even when all the possible characters have been considered, it indicates that a palindromic permutation can be formed from the given string <script type="math/tex; mode=display">s</script>.</p>\n<iframe frameborder="0" height="309" name="2GTcGjDw" src="https://leetcode.com/playground/2GTcGjDw/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(128*n)</script>. We iterate constant number of times(128) over the string <script type="math/tex; mode=display">s</script> of length <script type="math/tex; mode=display">n</script> giving a time complexity of <script type="math/tex; mode=display">128n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-hashmap-accepted">Approach #2 Using HashMap [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>From the discussion above, we know that to solve the given problem, we need to count the number of characters with odd number of occurences in the given string <script type="math/tex; mode=display">s</script>. To do so, we can also make use of a hashmap, <script type="math/tex; mode=display">map</script>. This <script type="math/tex; mode=display">map</script> takes the form <script type="math/tex; mode=display">(character_i, number of occurences of character_i)</script>.</p>\n<p>We traverse over the given string <script type="math/tex; mode=display">s</script>. For every new character found in <script type="math/tex; mode=display">s</script>, we create a new entry in the <script type="math/tex; mode=display">map</script> for this character with the number of occurences as 1. Whenever we find the same character again, we update the number of occurences appropriately. </p>\n<p>At the end, we traverse over the <script type="math/tex; mode=display">map</script> created and find the number of characters with odd number of occurences. If this <script type="math/tex; mode=display">count</script> happens to exceed 1 at any step,  we conclude that a palindromic permutation isn\'t possible for the string <script type="math/tex; mode=display">s</script>. But, if we can reach the end of the string with <script type="math/tex; mode=display">count</script> lesser than 2, we conclude that a palindromic permutation is possible for <script type="math/tex; mode=display">s</script>.</p>\n<p>The following animation illustrates the process.</p>\n<p>!?!../Documents/266_Palindrome_Permutation.json:1000,563!?!</p>\n<iframe frameborder="0" height="292" name="QedxyvpM" src="https://leetcode.com/playground/QedxyvpM/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We traverse over the given string <script type="math/tex; mode=display">s</script> with <script type="math/tex; mode=display">n</script> characters once. We also traverse over the <script type="math/tex; mode=display">map</script> which can grow upto a size of <script type="math/tex; mode=display">n</script> in case all characters in <script type="math/tex; mode=display">s</script> are distinct.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The hashmap can grow upto a size of <script type="math/tex; mode=display">n</script>, in case all the characters in <script type="math/tex; mode=display">s</script> are distinct.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-array-accepted">Approach #3 Using Array [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of making use of the inbuilt Hashmap, we can make use of an array as a hashmap. For this, we make use of an array <script type="math/tex; mode=display">map</script> with length 128. Each index of this <script type="math/tex; mode=display">map</script> corresponds to one of the 128 ASCII characters possible.</p>\n<p>We traverse over the string <script type="math/tex; mode=display">s</script> and put in the number of occurences of each character in this <script type="math/tex; mode=display">map</script> appropriately as done in the last case. Later on, we find the number of characters with odd number of occurences to determine if a palindromic permutation is possible for the string <script type="math/tex; mode=display">s</script> or not as done in previous approaches.</p>\n<iframe frameborder="0" height="275" name="pvhRBZgk" src="https://leetcode.com/playground/pvhRBZgk/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We traverse once over the string <script type="math/tex; mode=display">s</script> of length <script type="math/tex; mode=display">n</script>. Then, we traverse over the <script type="math/tex; mode=display">map</script> of length 128(constant).</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used for <script type="math/tex; mode=display">map</script> of size 128.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-single-pass-accepted">Approach #4 Single Pass [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of first traversing over the string <script type="math/tex; mode=display">s</script> for finding the number of occurences of each element and then determining the <script type="math/tex; mode=display">count</script> of characters with odd number of occurences in <script type="math/tex; mode=display">s</script>, we can determine the value of <script type="math/tex; mode=display">count</script> on the fly while traversing over <script type="math/tex; mode=display">s</script>.</p>\n<p>For this, we traverse over <script type="math/tex; mode=display">s</script> and update the number of occurences of the character just encountered in the <script type="math/tex; mode=display">map</script>. But, whevenever we update any entry in <script type="math/tex; mode=display">map</script>, we also check if its value becomes even or odd. We start of with a <script type="math/tex; mode=display">count</script> value of 0. If the value  of the entry just updated in <script type="math/tex; mode=display">map</script> happens to be odd, we increment the value of <script type="math/tex; mode=display">count</script> to indicate that one more character with odd number of occurences has been found. But, if this entry happens to be even, we decrement the value of <script type="math/tex; mode=display">count</script> to indicate that the number of characters with odd number of occurences has reduced by one. </p>\n<p>But, in this case, we need to traverse till the end of the string to determine the final result, unlike the last approaches, where we could stop the traversal over <script type="math/tex; mode=display">map</script> as soon as the <script type="math/tex; mode=display">count</script> exceeded 1. This is because, even if the number of elements with odd number of occurences may seem very large at the current moment, but their occurences could turn out to be even when we traverse further in the string <script type="math/tex; mode=display">s</script>.</p>\n<p>At the end, we again check if the value of <script type="math/tex; mode=display">count</script> is lesser than 2 to conclude that a palindromic permutation is possible for the string <script type="math/tex; mode=display">s</script>.</p>\n<iframe frameborder="0" height="292" name="5AuTxAxU" src="https://leetcode.com/playground/5AuTxAxU/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We traverse over the string <script type="math/tex; mode=display">s</script> of length <script type="math/tex; mode=display">n</script> once only.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(128)</script>. A <script type="math/tex; mode=display">map</script> of constant size(128) is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-using-set-accepted">Approach #5 Using Set [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>Another modification of the last approach could be by making use of a <script type="math/tex; mode=display">set</script> for keeping track of the number of elements with odd number of occurences in <script type="math/tex; mode=display">s</script>. For doing this, we traverse over the characters of the string <script type="math/tex; mode=display">s</script>. Whenver the number of occurences of a character becomes odd, we put its entry in the <script type="math/tex; mode=display">set</script>. Later on, if we find the same element again, lead to its number of occurences as even, we remove its entry from the <script type="math/tex; mode=display">set</script>. Thus, if the element occurs again(indicating an odd number of occurences), its entry won\'t exist in the <script type="math/tex; mode=display">set</script>.</p>\n<p>Based on this idea, when we find a character in the string <script type="math/tex; mode=display">s</script> that isn\'t present in the <script type="math/tex; mode=display">set</script>(indicating an odd number of occurences currently for this character), we put its corresponding entry in the <script type="math/tex; mode=display">set</script>. If we find a character that is already present in the <script type="math/tex; mode=display">set</script>(indicating an even number of occurences currently for this character), we remove its corresponding entry from the <script type="math/tex; mode=display">set</script>.</p>\n<p>At the end, the size of <script type="math/tex; mode=display">set</script> indicates the number of elements with odd number of occurences in <script type="math/tex; mode=display">s</script>. If it is lesser than 2, a palindromic permutation of the string <script type="math/tex; mode=display">s</script> is possible, otherwise not.</p>\n<p>Below code is inspired by <a href="http://leetcode.com/stefanpochmann">@StefanPochmann</a></p>\n<iframe frameborder="0" height="241" name="PwqWXcwG" src="https://leetcode.com/playground/PwqWXcwG/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We traverse over the string <script type="math/tex; mode=display">s</script> of length <script type="math/tex; mode=display">n</script> once only.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The <script type="math/tex; mode=display">set</script> can grow upto a maximum size of <script type="math/tex; mode=display">n</script> in case of all distinct elements.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google', 'Bloomberg', 'Uber'],
  },
  {
    id: '267',
    name: 'Palindrome Permutation II ',
    acceptance: '32.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a string <code>s</code>, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.\n</p>\n<p>\nFor example:\n</p>\n<p>\nGiven <code>s = "aabb"</code>, return <code>["abba", "baab"]</code>.\n</p>\n<p>\nGiven <code>s = "abc"</code>, return <code>[]</code>.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-backtracking-accepted">Approach #2 Backtracking [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The simplest solution is generate every possible permutation of the given string <script type="math/tex; mode=display">s</script> and check if the generated permutation is a palindrome. After this, the palindromic permuations can be added to a <script type="math/tex; mode=display">set</script> in order to eliminate the duplicates. At the end, we can return an array comprised of the elements of this <script type="math/tex; mode=display">set</script> as the resultant array.</p>\n<p>Let\'s look at the way these permutations are generated. We make use of a recursive function <code>permute</code> which  takes the index of the current element <script type="math/tex; mode=display">current_index</script> as one of the arguments. Then, it swaps the current element with every other element in the array, lying towards its right, so as to generate a new ordering of the array elements. After the swapping has been done, it makes another call to <code>permute</code> but this time with the index of the next element in the array. While returning back, we reverse the swapping done in the current function call. Thus, when we reach the end of the array, a new ordering of the array\'s elements is generated.</p>\n<p>The animation below depicts the ways the permutations are generated.</p>\n<p>!?!../Documents/561_Array.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="6Ryph5jp" src="https://leetcode.com/playground/6Ryph5jp/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O((n+1)!)</script>. A total of <script type="math/tex; mode=display">n!</script> permutations are possible. For every permutation generated, we need to check if it is a palindrome, each of which requires <script type="math/tex; mode=display">O(n)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of the recursion tree can go upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-backtracking-accepted">Approach #2 Backtracking [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>It might be possible that no palindromic permutation could be possible for the given string <script type="math/tex; mode=display">s</script>. Thus, it is useless to generate the permutations in such a case. Taking this idea, firstly we check if a palindromic permutation is possible for <script type="math/tex; mode=display">s</script>. If yes, then only we proceed further with generating the permutations. To check this, we make use of a hashmap <script type="math/tex; mode=display">map</script> which stores the number of occurences of each character(out of 128 ASCII characters possible). If the number of characters with odd number of occurences exceeds 1, it indicates that no palindromic permutation is possible for <script type="math/tex; mode=display">s</script>. To look at this checking process in detail, look at Approach 4 of the <a href="https://leetcode.com/articles/palindrome-permutation">article</a> for Palindrome Permutation.</p>\n<p>Once we are sure that a palindromic permutation is possible for <script type="math/tex; mode=display">s</script>, we go for the generation of the required permutations. But, instead of wildly generating all the permutations, we can include some smartness in the generation of permutations i.e. we can generate only those permutations which are already palindromes.</p>\n<p>One idea to to do so is to generate only the first half of the palindromic string and to append its reverse string to itself to generate the full length palindromic string.</p>\n<p>Based on this idea, by making use of the number of occurences of the characters in <script type="math/tex; mode=display">s</script> stored in <script type="math/tex; mode=display">map</script>, we create a string <script type="math/tex; mode=display">st</script>  which contains all the characters of <script type="math/tex; mode=display">s</script> but with the number of occurences of these characters in <script type="math/tex; mode=display">st</script> reduced to half their original number of occurences in <script type="math/tex; mode=display">s</script>.</p>\n<p>Thus, now we can generate all the permutations of this string <script type="math/tex; mode=display">st</script> and append the reverse of this permuted string to itself to create the palindromic permutations of <script type="math/tex; mode=display">s</script>.</p>\n<p>In case of a string <script type="math/tex; mode=display">s</script> with odd length, whose palindromic permutations are possible, one of the characters in <script type="math/tex; mode=display">s</script> must be occuring an odd number of times. We keep a track of this character, <script type="math/tex; mode=display">ch</script>, and it is kept separte from the string <script type="math/tex; mode=display">st</script>. We again generate the permutations for <script type="math/tex; mode=display">st</script> similarly and append the reverse of the generated permutation to itself, but we also place the character <script type="math/tex; mode=display">ch</script> at the middle of the generated string. </p>\n<p>In this way, only the required palindromic permutations will be generated. Even if we go with the above idea, a lot of duplicate strings will be generated.</p>\n<p>In order to avoid generating duplicate palindromic permutations in the first place itself, as much as possible, we can make use of this idea. As discussed in the last approach, we swap the current element with all the elements lying towards its right to generate the permutations. Before swapping, we can check if the elements being swapped are equal. If so, the permutations generated even after swapping the two will be duplicates(redundant). Thus, we need not proceed further in such a case.</p>\n<p>See this animation for a clearer understanding.</p>\n<p>!?!../Documents/267_Palindrome_Permutation_II.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="Nfi5WWm2" src="https://leetcode.com/playground/Nfi5WWm2/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big((\\frac{n}{2}+1)!\\big)</script>. Atmost <script type="math/tex; mode=display">\\frac{n}{2}!</script> permutations need to be generated in the worst case. Further, for each permutation generated, <code>string.reverse()</code> function will take <script type="math/tex; mode=display">n/4</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of recursion tree can go upto <script type="math/tex; mode=display">n/2</script> in the worst case.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '268',
    name: 'Missing Number',
    acceptance: '44.4%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array containing <i>n</i> distinct numbers taken from <code>0, 1, 2, ..., n</code>, find the one that is missing from the array.\n</p>\n\n<p><b>Example 1</b>\n</p><pre><b>Input:</b> [3,0,1]\n<b>Output:</b> 2\n</pre>\n<p></p>\n\n<p><b>Example 2</b>\n</p><pre><b>Input:</b> [9,6,4,2,3,5,7,0,1]\n<b>Output:</b> 8\n</pre>\n<p></p>\n\n<br>\n<p>\n<b>Note</b>:<br>\nYour algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-sorting-accepted">Approach #1 Sorting [Accepted]</a></li>\n<li><a href="#approach-2-hashset-accepted">Approach #2 HashSet [Accepted]</a></li>\n<li><a href="#approach-3-bit-manipulation-accepted">Approach #3 Bit Manipulation [Accepted]</a></li>\n<li><a href="#approach-4-gauss-formula-accepted">Approach #4 Gauss\' Formula [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-sorting-accepted">Approach #1 Sorting [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If <code>nums</code> were in order, it would be easy to see which number is missing.</p>\n<p><strong>Algorithm</strong></p>\n<p>First, we sort <code>nums</code>. Then, we check the two special cases that can be\nhandled in constant time - ensuring that 0 is at the beginning and that <script type="math/tex; mode=display">n</script>\nis at the end. Given that those assumptions hold, the missing number must\nsomewhere between (but not including) 0 and <script type="math/tex; mode=display">n</script>. To find it, we ensure that\nthe number we expect to be at each index is indeed there. Because we handled\nthe edge cases, this is simply the previous number plus 1. Thus, as soon as\nwe find an unexpected number, we can simply return the expected number.</p>\n<iframe frameborder="0" height="480" name="k9GaBbiy" src="https://leetcode.com/playground/k9GaBbiy/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nlgn)</script>\n</p>\n<p>The only elements of the algorithm that have asymptotically nonconstant\ntime complexity are the main <code>for</code> loop (which runs in <script type="math/tex; mode=display">O(n)</script> time), and\nthe <code>sort</code> invocation (which runs in <script type="math/tex; mode=display">O(nlgn)</script> time for Python and Java).\nTherefore, the runtime is dominated by <code>sort</code>, and the entire runtime is\n<script type="math/tex; mode=display">O(nlgn)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script> (or <script type="math/tex; mode=display">O(n)</script>)</p>\n<p>In the sample code, we sorted <code>nums</code> in place, allowing us to avoid\nallocating additional space. If modifying <code>nums</code> is forbidden, we can\nallocate an <script type="math/tex; mode=display">O(n)</script> size copy and sort that instead.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-hashset-accepted">Approach #2 HashSet [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>A brute force method for solving this problem would be to simply check for\nthe presence of each number that we expect to be present. The naive\nimplementation might use a linear scan of the array to check for containment,\nbut we can use a <code>HashSet</code> to get constant time containment queries and\noverall linear runtime.</p>\n<p><strong>Algorithm</strong></p>\n<p>This algorithm is almost identical to the brute force approach, except we\nfirst insert each element of <code>nums</code> into a set, allowing us to later query\nfor containment in <script type="math/tex; mode=display">O(1)</script> time.</p>\n<iframe frameborder="0" height="293" name="Pn2pJK6y" src="https://leetcode.com/playground/Pn2pJK6y/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>Because the set allows for <script type="math/tex; mode=display">O(1)</script> containment queries, the main loop\nruns in <script type="math/tex; mode=display">O(n)</script> time. Creating <code>num_set</code> costs <script type="math/tex; mode=display">O(n)</script> time, as each set insertion\nruns in amortized <script type="math/tex; mode=display">O(1)</script> time, so the overall runtime is <script type="math/tex; mode=display">O(n + n) = O(n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p><code>nums</code> contains <script type="math/tex; mode=display">n-1</script> distinct elements, so it costs <script type="math/tex; mode=display">O(n)</script> space to\nstore a set containing all of them.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-bit-manipulation-accepted">Approach #3 Bit Manipulation [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can harness the fact that XOR is its own inverse to find the missing\nelement in linear time.</p>\n<p><strong>Algorithm</strong></p>\n<p>Because we know that <code>nums</code> contains <script type="math/tex; mode=display">n</script> numbers and that it is missing\nexactly one number on the range <script type="math/tex; mode=display">[0..n-1]</script>, we know that <script type="math/tex; mode=display">n</script> definitely\nreplaces the missing number in <code>nums</code>. Therefore, if we initialize an integer\nto <script type="math/tex; mode=display">n</script> and XOR it with every index and value, we will be left with the\nmissing number. Consider the following example (the values have been sorted\nfor intuitive convenience, but need not be):</p>\n<p></p><table>\n<tbody><tr>\n<th>Index</th>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n</tr>\n<tr>\n<th>Value</th>\n<td>0</td>\n<td>1</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody></table> <p></p>\n<p>\n<script type="math/tex; mode=display">\n\\begin{align}\n    missing &= 4 \\wedge (0 \\wedge 0) \\wedge (1 \\wedge 1) \\wedge (2 \\wedge 3) \\wedge (3 \\wedge 4) \\\\\n            &= (4 \\wedge 4) \\wedge (0 \\wedge 0) \\wedge (1 \\wedge 1) \\wedge (3 \\wedge 3) \\wedge 2 \\\\\n            &= 0 \\wedge 0 \\wedge 0 \\wedge 0 \\wedge 2 \\\\ \n            &= 2\n\\end{align}\n</script>\n</p>\n<iframe frameborder="0" height="208" name="kpQGEsFG" src="https://leetcode.com/playground/kpQGEsFG/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>Assuming that XOR is a constant-time operation, this algorithm does\nconstant work on <script type="math/tex; mode=display">n</script> iterations, so the runtime is overall linear.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n<p>This algorithm allocates only constant additional space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-gauss-formula-accepted">Approach #4 Gauss\' Formula [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>One of the most well-known stories in mathematics is of a young Gauss, forced\nto find the sum of the first 100 natural numbers by a lazy teacher. Rather\nthan add the numbers by hand, he deduced a <a href="https://brilliant.org/wiki/sum-of-n-n2-or-n3/">closed-form\nexpression</a> for the sum, or so\nthe story goes. You can see the formula below:</p>\n<p>\n<script type="math/tex; mode=display">\n    \\sum_{i=0}^{n}i = \\frac{n(n+1)}{2}\n</script>\n</p>\n<p><strong>Algorithm</strong></p>\n<p>We can compute the sum of <code>nums</code> in linear time, and by Gauss\' formula, we\ncan compute the sum of the first <script type="math/tex; mode=display">n</script> natural numbers in constant time. Therefore,\nthe number that is missing is simply the result of Gauss\' formula minus the sum of <code>nums</code>,\nas <code>nums</code> consists of the first <script type="math/tex; mode=display">n</script> natural numbers minus some number.</p>\n<iframe frameborder="0" height="191" name="EZoHRZgg" src="https://leetcode.com/playground/EZoHRZgg/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>Although Gauss\' formula can be computed in <script type="math/tex; mode=display">O(1)</script> time, summing <code>nums</code>\ncosts us <script type="math/tex; mode=display">O(n)</script> time, so the algorithm is overall linear. Because we have\nno information about <em>which</em> number is missing, an adversary could always\ndesign an input for which any algorithm that examines fewer than <script type="math/tex; mode=display">n</script>\nnumbers fails. Therefore, this solution is asymptotically optimal.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n<p>This approach only pushes a few integers around, so it has constant\nmemory usage.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/emptyset">@emptyset</a></p>\n</div>\n          ',
    tags: ['Microsoft', 'Bloomberg'],
  },
  {
    id: '269',
    name: 'Alien Dictionary ',
    acceptance: '25.5%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nThere is a new alien language which uses the latin alphabet. \nHowever, the order among letters are unknown to you. \nYou receive a list of <b>non-empty</b> words from the dictionary, where <b>words are sorted lexicographically by the rules of this new language</b>.\nDerive the order of letters in this language.\n</p>\n\n<p>\n<b>Example 1:</b><br>\nGiven the following words in dictionary,\n</p><pre>[\n  "wrt",\n  "wrf",\n  "er",\n  "ett",\n  "rftt"\n]\n</pre>\n<p></p>\n<p>\nThe correct order is: <code>"wertf"</code>.</p>\n\n<p>\n<b>Example 2:</b><br>\nGiven the following words in dictionary,\n</p><pre>[\n  "z",\n  "x"\n]\n</pre>\n<p></p>\n<p>\nThe correct order is: <code>"zx"</code>.</p>\n\n<p>\n<b>Example 3:</b><br>\nGiven the following words in dictionary,\n</p><pre>[\n  "z",\n  "x",\n  "z"\n]\n</pre>\n<p></p>\n<p>\nThe order is invalid, so return <code>""</code>.</p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>You may assume all letters are in lowercase.</li>\n<li>You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.</li>\n<li>If the order is invalid, return an empty string.</li>\n<li>There may be multiple valid order of letters, return any one of them is fine.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Twitter', 'Snapchat', 'Airbnb', 'Pocket Gems'],
  },
  {
    id: '270',
    name: 'Closest Binary Search Tree Value ',
    acceptance: '40.2%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.\n</p>\n<p><b>Note:</b><br>\n</p><ul>\n<li>Given target value is a floating point.</li>\n<li>You are guaranteed to have only one unique value in the BST that is closest to the target.</li>\n</ul><p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Microsoft', 'Snapchat'],
  },
  {
    id: '271',
    name: 'Encode and Decode Strings ',
    acceptance: '26.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nDesign an algorithm to encode <b>a list of strings</b> to <b>a string</b>. The encoded string is then sent over the network and is decoded back to the original list of strings.</p>\n\n<p>\nMachine 1 (sender) has the function:\n</p><pre>string encode(vector&lt;string&gt; strs) {\n  // ... your code\n  return encoded_string;\n}</pre>\n\nMachine 2 (receiver) has the function:\n<pre>vector&lt;string&gt; decode(string s) {\n  //... your code\n  return strs;\n}</pre>\n<p></p>\n\n<p>\nSo Machine 1 does:\n</p><pre>string encoded_string = encode(strs);</pre>\n<p></p>\n\n<p>\nand Machine 2 does:\n</p><pre>vector&lt;string&gt; strs2 = decode(encoded_string);</pre>\n<p></p>\n\n<p>\n<code>strs2</code> in Machine 2 should be the same as <code>strs</code> in Machine 1.\n</p>\n\n<p>Implement the <code>encode</code> and <code>decode</code> methods.\n</p>\n\n<p><b>Note:</b><br>\n</p><ul>\n<li>The string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters.</li>\n<li>Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.</li>\n<li>Do not rely on any library method such as <code>eval</code> or serialize methods. You should implement your own encode/decode algorithm.</li>\n</ul><p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '272',
    name: 'Closest Binary Search Tree Value II ',
    acceptance: '39.5%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a non-empty binary search tree and a target value, find <i>k</i> values in the BST that are closest to the target.\n</p>\n<p><b>Note:</b><br>\n</p><ul>\n<li>Given target value is a floating point.</li>\n<li>You may assume <i>k</i> is always valid, that is: <i>k</i> ≤ total nodes.</li>\n<li>You are guaranteed to have only one unique set of <i>k</i> values in the BST that are closest to the target.</li>\n</ul><p></p>\n<p><b>Follow up:</b><br>\nAssume that the BST is balanced, could you solve it in less than <i>O</i>(<i>n</i>) runtime (where <i>n</i> = total nodes)?\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '273',
    name: 'Integer to English Words',
    acceptance: '22.5%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nConvert a non-negative integer to its english words representation. Given input is guaranteed to be less than 2<sup>31</sup> - 1.\n</p>\n\n<p>For example,<br>\n</p><pre>123 -&gt; "One Hundred Twenty Three"\n12345 -&gt; "Twelve Thousand Three Hundred Forty Five"\n1234567 -&gt; "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"</pre><p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft'],
  },
  {
    id: '274',
    name: 'H-Index',
    acceptance: '33.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher\'s h-index.\n</p>\n\n<p>\nAccording to the <a href="https://en.wikipedia.org/wiki/H-index" target="_blank">definition of h-index on Wikipedia</a>: "A scientist has index <i>h</i> if <i>h</i> of his/her <i>N</i> papers have <b>at least</b> <i>h</i> citations each, and the other <i>N − h</i> papers have <b>no more than</b> <i>h</i> citations each."\n</p>\n\n<p>\nFor example, given <code>citations = [3, 0, 6, 1, 5]</code>, which means the researcher has <code>5</code> papers in total and each of them had received <code>3, 0, 6, 1, 5</code> citations respectively. Since the researcher has <code>3</code> papers with <b>at least</b> <code>3</code> citations each and the remaining two with <b>no more than</b> <code>3</code> citations each, his h-index is <code>3</code>.\n</p>\n\n<p>\n<b>Note</b>: If there are several possible values for <code>h</code>, the maximum one is taken as the h-index.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-sorting-accepted">Approach #1 (Sorting) [Accepted]</a></li>\n<li><a href="#approach-2-counting-accepted">Approach #2 (Counting) [Accepted]</a></li>\n</ul>\n</li>\n<li><a href="#further-thoughts">Further Thoughts</a></li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This article is for intermediate readers. It introduces the following ideas:\nComparison Sort and Counting Sort.</p>\n<h2 id="solution">Solution</h2>\n<h4 id="approach-1-sorting-accepted">Approach #1 (Sorting) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Think geometrically. Imagine plotting a histogram where the <script type="math/tex; mode=display">y</script>-axis represents the number of citations for each paper. After sorting in <em>descending</em> order, <script type="math/tex; mode=display">h</script>-index is the length of the largest <strong>square</strong> in the histogram.</p>\n<p align="center"><img alt="h-index" src="https://leetcode.com/articles/Figures/274_H_index.svg" width="539px"></p>\n<p align="center"><em>Figure 1. <script type="math/tex; mode=display">h</script>-index from a plot of decreasing citations for papers</em></p>\n<p><strong>Algorithm</strong></p>\n<p>To find such a square length, we first sort the citations array in <em>descending</em> order.\nAfter sorting, if <script type="math/tex; mode=display">\\mathrm{citations}[i] \\gt i</script>, then papers <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">i</script> all have at least <script type="math/tex; mode=display">i + 1</script> citations.</p>\n<p>Thus, to find <script type="math/tex; mode=display">h</script>-index, we search for the largest <script type="math/tex; mode=display">i</script> (let\'s call it <script type="math/tex; mode=display">i\'</script>) such that</p>\n<p>\n<script type="math/tex; mode=display">\n\\mathrm{citations}[i] \\gt i\n</script>\n</p>\n<p>and therefore the <script type="math/tex; mode=display">h</script>-index is <script type="math/tex; mode=display">i\' + 1</script>.</p>\n<p>For example:</p>\n<table>\n<thead>\n<tr>\n<th align="center">\n<script type="math/tex; mode=display">i</script>\n</th>\n<th align="center">0</th>\n<th align="center">1</th>\n<th align="center">2</th>\n<th align="center">3</th>\n<th align="center">4</th>\n<th align="center">5</th>\n<th align="center">6</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">sorted citations</td>\n<td align="center">10</td>\n<td align="center">9</td>\n<td align="center">5</td>\n<td align="center">3</td>\n<td align="center">3</td>\n<td align="center">2</td>\n<td align="center">1</td>\n</tr>\n<tr>\n<td align="center">\n<script type="math/tex; mode=display">\\mathrm{citations}[i] \\gt i</script>?</td>\n<td align="center">true</td>\n<td align="center">true</td>\n<td align="center">true</td>\n<td align="center">false</td>\n<td align="center">false</td>\n<td align="center">false</td>\n<td align="center">false</td>\n</tr>\n</tbody>\n</table>\n<p>In this example, we know that the largest <script type="math/tex; mode=display">i</script> with <script type="math/tex; mode=display">\\mathrm{citations}[i] \\gt i</script> is <script type="math/tex; mode=display">i\'=2</script>. Thus</p>\n<p>\n<script type="math/tex; mode=display">\nh = i\' + 1 = 3\n</script>\n</p>\n<p>Because <script type="math/tex; mode=display">\\mathrm{citations}[i\'] \\gt i\'</script>, <script type="math/tex; mode=display">i\' + 1</script> papers (from paper 0 to paper <script type="math/tex; mode=display">i\'</script>) have citations at least <script type="math/tex; mode=display">i\' + 1</script> and <script type="math/tex; mode=display">n - i\' - 1</script> papers (from paper <script type="math/tex; mode=display">i\' + 1</script> to paper <script type="math/tex; mode=display">n - 1</script>) have citations no more than <script type="math/tex; mode=display">i\' + 1</script>. By the definition of <script type="math/tex; mode=display">h</script>-index, <script type="math/tex; mode=display">h = i\' + 1</script>.</p>\n<p>It is also possible to find <script type="math/tex; mode=display">i\'</script> through binary search after sorting. However, since comparison sorting has a time complexity of <script type="math/tex; mode=display">O(n \\log n)</script> which dominates the performance of entire algorithm (linear search is <script type="math/tex; mode=display">O(n)</script>). Using a binary search (<script type="math/tex; mode=display">O(\\log n)</script>) instead of linear search won\'t change the asymptotic time complexity.</p>\n<p>Also note that, we deduced the algorithm in descending for simplicity. Usually the sort function provided by default is in ascending order. The same principles applies to both ascending order and descending order. In the case of ascending order, we just scan it from backward.</p>\n<iframe frameborder="0" height="259" name="wJ3A9AXC" src="https://leetcode.com/playground/wJ3A9AXC/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n\\log n)</script>. Comparison sorting dominates the time complexity.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Most libraries using <code>heap sort</code> which costs <script type="math/tex; mode=display">O(1)</script> extra space in the worst case.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-counting-accepted">Approach #2 (Counting) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Comparison sorting algorithm has a lower bound of <script type="math/tex; mode=display">O(n\\log n)</script>. To achieve better performance, we need non-comparison based sorting algorithms.</p>\n<p><strong>Algorithm</strong></p>\n<p>From <a href="#approach-1-sorting-accepted">Approach #1</a>, we sort the citations to find the h-index. However, it is well known that comparison sorting algorithms such as <code>heapsort</code>, <code>mergesort</code> and <code>quicksort</code> have a lower bound of <script type="math/tex; mode=display">O(n\\log n)</script>. The most commonly used non-comparison sorting is <code>counting sort</code>.</p>\n<blockquote>\n<p>Counting sort operates by counting the number of objects that have each distinct key value, and using arithmetic on those tallies to determine the positions of each key value in the output sequence. Its running time is linear in the number of items and the difference between the maximum and minimum keys, so it is only suitable for direct use in situations where the variation in keys is not significantly greater than the number of items.</p>\n<p>---by Wikipedia</p>\n</blockquote>\n<p>However, in our problem, the keys are the citations of each paper which can be much larger than the number of papers <script type="math/tex; mode=display">n</script>. It seems that we cannot use <code>counting sort</code>. The trick here is the following observation:</p>\n<blockquote>\n<p>Any citation larger than <script type="math/tex; mode=display">n</script> can be replaced by <script type="math/tex; mode=display">n</script> and the <script type="math/tex; mode=display">h</script>-index will not change after the replacement</p>\n</blockquote>\n<p>The reason is that <script type="math/tex; mode=display">h</script>-index is upper bounded by total number of papers <script type="math/tex; mode=display">n</script>, i.e.</p>\n<p>\n<script type="math/tex; mode=display">\nh \\leq n\n</script>\n</p>\n<p>In the diagram, replacing citations greater than <script type="math/tex; mode=display">n</script> with <script type="math/tex; mode=display">n</script> is equivalent to cutting off the area where <script type="math/tex; mode=display">y > n</script>.</p>\n<p align="center"><img alt="h-index cut off" src="https://leetcode.com/articles/Figures/274_H_index_2.svg" width="539px"></p>\n<p align="center"><em>Figure 2. cutting off the area with citations more than <script type="math/tex; mode=display">n</script></em></p>\n<p>Apparently, cutting that area off will not change the largest <strong>square</strong> and the <script type="math/tex; mode=display">h</script>-index.</p>\n<p>After we have the counts, we can get a sorted citations by traversing the counts array. And the rest is the same as <a href="#approach-1-sorting-accepted">Approach #1</a>.</p>\n<p>But we can do even better. The idea is that we don\'t even need to get sorted citations. We can find the <script type="math/tex; mode=display">h</script>-index by using the paper counts directly.</p>\n<p>To explain this, let\'s look at the following example:</p>\n<p>\n<script type="math/tex; mode=display">\n\\mathrm{citations} = [1, 3, 2, 3, 100]\n</script>\n</p>\n<p>The counting results are:</p>\n<table>\n<thead>\n<tr>\n<th align="center">\n<script type="math/tex; mode=display">k</script>\n</th>\n<th align="center">0</th>\n<th align="center">1</th>\n<th align="center">2</th>\n<th align="center">3</th>\n<th align="center">4</th>\n<th align="center">5</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">count</td>\n<td align="center">0</td>\n<td align="center">1</td>\n<td align="center">1</td>\n<td align="center">2</td>\n<td align="center">0</td>\n<td align="center">1</td>\n</tr>\n<tr>\n<td align="center">\n<script type="math/tex; mode=display">s_k</script>\n</td>\n<td align="center">5</td>\n<td align="center">5</td>\n<td align="center">4</td>\n<td align="center">3</td>\n<td align="center">1</td>\n<td align="center">1</td>\n</tr>\n</tbody>\n</table>\n<p>The value <script type="math/tex; mode=display">s_k</script> is defined as "the sum of all counts with citation <script type="math/tex; mode=display">\\geq k</script>" or "the number of papers having, at least, <script type="math/tex; mode=display">k</script> citations". By definition of the h-index, the largest <script type="math/tex; mode=display">k</script> with <script type="math/tex; mode=display">k \\leq s_k</script> is our answer.</p>\n<p>After replacing <script type="math/tex; mode=display">100</script> with <script type="math/tex; mode=display">n = 5</script>, we have <script type="math/tex; mode=display">\\mathrm{citations} = [1, 3, 2, 3, 5]</script>. Now, we count the number of papers for each citation number <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">5</script>. The counts are <script type="math/tex; mode=display">[0, 1, 1, 2, 0, 1]</script>. The first <script type="math/tex; mode=display">k</script> from right to left (<script type="math/tex; mode=display">5</script> down to <script type="math/tex; mode=display">0</script>) that have <script type="math/tex; mode=display">k \\leq s</script> is the <script type="math/tex; mode=display">h</script>-index <script type="math/tex; mode=display">3</script>.</p>\n<p>Since we can calculate <script type="math/tex; mode=display">s_k</script> on the fly when traverse the count array, we only need one pass through the count array which only costs <script type="math/tex; mode=display">O(n)</script> time.</p>\n<iframe frameborder="0" height="293" name="4ZajNz22" src="https://leetcode.com/playground/4ZajNz22/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. There are two steps. The counting part is <script type="math/tex; mode=display">O(n)</script> since we traverse the <code>citations</code> array once and only once. The second part of finding the <script type="math/tex; mode=display">h</script>-index is also <script type="math/tex; mode=display">O(n)</script> since we traverse the <code>papers</code> array at most once. Thus, the entire algorithm is <script type="math/tex; mode=display">O(n)</script>\n</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. We use <script type="math/tex; mode=display">O(n)</script> auxiliary space to store the counts.</p>\n</li>\n</ul>\n<h2 id="further-thoughts">Further Thoughts</h2>\n<blockquote>\n<p>Is it possible to have multiple <script type="math/tex; mode=display">h</script>-values?</p>\n</blockquote>\n<p>The answer is <strong>NO</strong>. One can find this intuitively from Figure 1. The dashed line <script type="math/tex; mode=display">y = x</script> crosses the histogram once and only once, because the sorted bars are monotonic. It can also be proven from the definition of the <script type="math/tex; mode=display">h</script>-index.</p>\n</div>\n          ',
    tags: ['Google', 'Facebook', 'Bloomberg'],
  },
  {
    id: '275',
    name: 'H-Index II',
    acceptance: '34.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\n<b>Follow up</b> for <a href="/problems/h-index/" target="_blank">H-Index</a>: What if the <code>citations</code> array is sorted in ascending order? Could you optimize your algorithm?\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook'],
  },
  {
    id: '276',
    name: 'Paint Fence ',
    acceptance: '34.8%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nThere is a fence with n posts, each post can be painted with one of the k colors.</p>\n<p>You have to paint all the posts such that no more than two adjacent fence posts have the same color. </p>\n<p>Return the total number of ways you can paint the fence. </p>\n\n<p><b>Note:</b><br>\nn and k are non-negative integers. </p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '277',
    name: 'Find the Celebrity ',
    acceptance: '35.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nSuppose you are at a party with <code>n</code> people (labeled from <code>0</code> to <code>n - 1</code>) and among them, there may exist one celebrity. The definition of a celebrity is that all the other <code>n - 1</code> people know him/her but he/she does not know any of them.\n</p>\n\n<p>\nNow you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).\n</p>\n\n<p>\nYou are given a helper function <code>bool knows(a, b)</code> which tells you whether A knows B. Implement a function <code>int findCelebrity(n)</code>, your function should minimize the number of calls to <code>knows</code>.\n</p>\n\n<p>\n<b>Note</b>: There will be exactly one celebrity if he/she is in the party. Return the celebrity\'s label if there is a celebrity in the party. If there is no celebrity, return <code>-1</code>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'LinkedIn'],
  },
  {
    id: '278',
    name: 'First Bad Version',
    acceptance: '25.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. \n</p>\n\n<p>\nSuppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.\n</p>\n\n<p>\nYou are given an API <code>bool isBadVersion(version)</code> which will return whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-linear-scan-time-limit-exceeded">Approach #1 (Linear Scan) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-binary-search-accepted">Approach #2 (Binary Search) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This is a very simple problem. There is a subtle trap that you may fall into if you are not careful. Other than that, it is a direct application of a very famous algorithm.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-linear-scan-time-limit-exceeded">Approach #1 (Linear Scan) [Time Limit Exceeded]</h4>\n<p>The straight forward way is to brute force it by doing a linear scan.</p>\n<iframe frameborder="0" height="190" name="Ezb8JYsL" src="https://leetcode.com/playground/Ezb8JYsL/shared" width="100%"></iframe>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nAssume that <script type="math/tex; mode=display">isBadVersion(version)</script> takes constant time to check if a <em>version</em> is bad. It takes at most <script type="math/tex; mode=display">n - 1</script> checks, therefore the overall time complexity is <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-binary-search-accepted">Approach #2 (Binary Search) [Accepted]</h4>\n<p>It is not difficult to see that this could be solved using a classic algorithm - Binary search. Let us see how the search space could be halved each time below.</p>\n<div class="codehilite"><pre><span></span>Scenario #1: isBadVersion(mid) =&gt; false\n\n 1 2 3 4 5 6 7 8 9\n G G G G G G B B B       G = Good, B = Bad\n |       |       |\nleft    mid    right\n</pre></div>\n<p>Let us look at the first scenario above where <script type="math/tex; mode=display">isBadVersion(mid) \\Rightarrow  false</script>. We know that all versions preceding and including <script type="math/tex; mode=display">mid</script> are all good. So we set <script type="math/tex; mode=display">left = mid + 1</script> to indicate that the new search space is the interval <script type="math/tex; mode=display">[mid + 1, right]</script> (inclusive).</p>\n<div class="codehilite"><pre><span></span>Scenario #2: isBadVersion(mid) =&gt; true\n\n 1 2 3 4 5 6 7 8 9\n G G G B B B B B B       G = Good, B = Bad\n |       |       |\nleft    mid    right\n</pre></div>\n<p>The only scenario left is where <script type="math/tex; mode=display">isBadVersion(mid) \\Rightarrow true</script>. This tells us that <script type="math/tex; mode=display">mid</script> may or may not be the first bad version, but we can tell for sure that all versions after <script type="math/tex; mode=display">mid</script> can be discarded. Therefore we set <script type="math/tex; mode=display">right = mid</script> as the new search space of interval <script type="math/tex; mode=display">[left,mid]</script> (inclusive).</p>\n<p>In our case, we indicate <script type="math/tex; mode=display">left</script> and <script type="math/tex; mode=display">right</script> as the boundary of our search space (both inclusive). This is why we initialize <script type="math/tex; mode=display">left = 1</script> and <script type="math/tex; mode=display">right = n </script>. How about the terminating condition? We could guess that <script type="math/tex; mode=display">left</script> and <script type="math/tex; mode=display">right</script> eventually both meet and it must be the first bad version, but how could you tell for sure?</p>\n<p>The formal way is to <a href="http://www.cs.cornell.edu/courses/cs211/2006sp/Lectures/L06-Induction/binary_search.html">prove by induction</a>, which you can read up yourself if you are interested. Here is a helpful tip to quickly prove the correctness of your binary search algorithm\nduring an interview. We just need to test an input of size 2. Check if it reduces the search space to a single element (which must be the answer) for both of the scenarios above. If not, your algorithm will never terminate.</p>\n<p>If you are setting <script type="math/tex; mode=display">mid = \\frac{left + right}{2}</script>, you have to be very careful. Unless you are using a language that does not overflow such as <a href="https://www.reddit.com/r/Python/comments/36xu5z/can_integer_operations_overflow_in_python/">Python</a>, <script type="math/tex; mode=display">left + right</script> could overflow. One way to fix this is to use <script type="math/tex; mode=display">left + \\frac{right - left}{2}</script> instead.</p>\n<p>If you fall into this subtle overflow bug, you are not alone. Even Jon Bentley\'s own implementation of binary search had this <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm#Implementation_issues">overflow bug</a> and remained undetected for over twenty years.</p>\n<iframe frameborder="0" height="275" name="VQBrosDg" src="https://leetcode.com/playground/VQBrosDg/shared" width="100%"></iframe>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(\\log n)</script>.\nThe search space is halved each time, so the time complexity is <script type="math/tex; mode=display">O(\\log n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '279',
    name: 'Perfect Squares',
    acceptance: '37.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a positive integer <i>n</i>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <i>n</i>.\n</p>\n\n<p>\nFor example, given <i>n</i> = <code>12</code>, return <code>3</code> because <code>12 = 4 + 4 + 4</code>; given <i>n</i> = <code>13</code>, return <code>2</code> because <code>13 = 4 + 9</code>.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '280',
    name: 'Wiggle Sort ',
    acceptance: '58.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an unsorted array <code>nums</code>, reorder it <b>in-place</b> such that <code>nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]...</code>.\n</p>\n<p>\nFor example, given <code>nums = [3, 5, 2, 1, 6, 4]</code>, one possible answer is <code>[1, 6, 2, 5, 3, 4]</code>.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-sorting-accepted">Approach #1 (Sorting) [Accepted]</a></li>\n<li><a href="#approach-2-one-pass-swap-accepted">Approach #2 (One-pass Swap) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-sorting-accepted">Approach #1 (Sorting) [Accepted]</h4>\n<p>The obvious solution is to just sort the array first, then swap elements pair-wise starting from the second element. For example:</p>\n<div class="codehilite"><pre><span></span>   [1, 2, 3, 4, 5, 6]\n       ↑  ↑  ↑  ↑\n       swap  swap\n\n=&gt; [1, 3, 2, 5, 4, 6]\n</pre></div>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">wiggleSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n    <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>\n    <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n \\log n)</script>.\nThe entire algorithm is dominated by the sorting step, which costs <script type="math/tex; mode=display">O(n \\log n)</script> time to sort <script type="math/tex; mode=display">n</script> elements.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Space depends on the sorting implementation which, usually, costs <script type="math/tex; mode=display">O(1)</script> auxiliary space if <code>heapsort</code> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-one-pass-swap-accepted">Approach #2 (One-pass Swap) [Accepted]</h4>\n<p>Intuitively, we should be able to reorder it in one-pass. As we iterate through the array, we compare the current element to its next element and if the order is incorrect, we swap them.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">wiggleSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">boolean</span> <span class="n">less</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">less</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>\n                <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n            <span class="o">}</span>\n        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>\n                <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="n">less</span> <span class="o">=</span> <span class="o">!</span><span class="n">less</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p>We could shorten the code further by compacting the condition to a single line. Also observe the boolean value of <code>less</code> actually depends on whether the index is even or odd.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">wiggleSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(((</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span>\n                <span class="o">||</span> <span class="o">((</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]))</span> <span class="o">{</span>\n            <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p>Here is another amazing solution by @StefanPochmann who came up with <a href="https://leetcode.com/discuss/57113/java-o-n-solution?show=57192#a57192">originally here</a>.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">wiggleSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">((</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]))</span> <span class="o">{</span>\n            <span class="n">swap</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nIn the worst case we swap at most <script type="math/tex; mode=display">n \\over 2</script> times. An example input is <code>[2,1,3,1,4,1]</code>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '281',
    name: 'Zigzag Iterator ',
    acceptance: '51.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven two 1d vectors, implement an iterator to return their elements alternately.\n</p>\n\n<p>For example, given two 1d vectors:\n</p><pre>v1 = [1, 2]\nv2 = [3, 4, 5, 6]\n</pre>\n<p></p>\n<p>\nBy calling <i>next</i> repeatedly until <i>hasNext</i> returns <code>false</code>, the order of elements returned by <i>next</i> should be: <code>[1, 3, 2, 4, 5, 6]</code>.\n</p>\n\n<p>\n<b>Follow up</b>: What if you are given <code>k</code> 1d vectors? How well can your code be extended to such cases?</p>\n\n<p>\n<b><u>Clarification for the follow up question - <font color="red">Update (2015-09-18):</font></u></b><br>\nThe "Zigzag" order is not clearly defined and is ambiguous for <code>k &gt; 2</code> cases. If "Zigzag" does not look right to you, replace "Zigzag" with "Cyclic". For example, given the following input:\n</p><pre>[1,2,3]\n[4,5,6,7]\n[8,9]\n</pre>\nIt should return <code>[1,4,8,2,5,9,3,6,7]</code>.\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '282',
    name: 'Expression Add Operators',
    acceptance: '30.4%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a string that contains only digits <code>0-9</code> and a target value, return all possibilities to add <b>binary</b> operators (not unary) <code>+</code>, <code>-</code>, or <code>*</code> between the digits so they evaluate to the target value.\n</p>\n<p>\nExamples: <br>\n</p><pre>"123", 6 -&gt; ["1+2+3", "1*2*3"] \n"232", 8 -&gt; ["2*3+2", "2+3*2"]\n"105", 5 -&gt; ["1*0+5","10-5"]\n"00", 0 -&gt; ["0+0", "0-0", "0*0"]\n"3456237490", 9191 -&gt; []\n</pre>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/davidtan1890">@davidtan1890</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook'],
  },
  {
    id: '283',
    name: 'Move Zeroes',
    acceptance: '50.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array <code>nums</code>, write a function to move all <code>0</code>\'s to the end of it while maintaining the relative order of the non-zero elements.\n</p>\n\n<p>\nFor example, given <code>nums  = [0, 1, 0, 3, 12]</code>, after calling your function, <code>nums</code> should be <code>[1, 3, 12, 0, 0]</code>.\n</p>\n\n<p>\n<b>Note</b>:<br>\n</p><ol>\n<li>You must do this <b>in-place</b> without making a copy of the array.</li>\n<li>Minimize the total number of operations.</li>\n</ol>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-space-sub-optimal-accepted">Approach #1 (Space Sub-Optimal) [Accepted]</a></li>\n<li><a href="#approach-2-space-optimal-operation-sub-optimal-accepted">Approach #2 (Space Optimal, Operation Sub-Optimal) [Accepted]</a></li>\n<li><a href="#approach-3-optimal-accepted">Approach #3 (Optimal) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<p>This question comes under a broad category of "Array Transformation". This category is the meat of tech interviews. Mostly because arrays are such a simple and easy to use data structure. Traversal or representation doesn\'t require any boilerplate code and most of your code will look like the Pseudocode itself.</p>\n<p>The 2 requirements of the question are:</p>\n<ol>\n<li>\n<p>Move all the 0\'s to the end of array.</p>\n</li>\n<li>\n<p>All the non-zero elements must retain their original order.</p>\n</li>\n</ol>\n<p>It\'s good to realize here that both the requirements are mutually exclusive, i.e., you can solve the individual sub-problems and then combine them for the final solution.</p>\n<h4 id="approach-1-space-sub-optimal-accepted">Approach #1 (Space Sub-Optimal) [Accepted]</h4>\n<p><strong>C++</strong></p>\n<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">moveZeroes</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>\n    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>\n\n    <span class="c1">// Count the zeroes</span>\n    <span class="kt">int</span> <span class="n">numZeroes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>\n    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>\n        <span class="n">numZeroes</span> <span class="o">+=</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>\n    <span class="p">}</span>\n\n    <span class="c1">// Make all the non-zero elements retain their original order.</span>\n    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>\n    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>\n        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>\n            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>\n        <span class="p">}</span>\n    <span class="p">}</span>\n\n    <span class="c1">// Move all zeroes to the end</span>\n    <span class="k">while</span> <span class="p">(</span><span class="n">numZeroes</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>\n        <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>\n    <span class="p">}</span>\n\n    <span class="c1">// Combine the result</span>\n    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>\n        <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>\n    <span class="p">}</span>\n<span class="p">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>Space Complexity : <script type="math/tex; mode=display">O(n)</script>. Since we are creating the "ans" array to store results.</p>\n<p>Time Complexity: <script type="math/tex; mode=display">O(n)</script>. However, the total number of operations are sub-optimal. We can achieve the same result in less number of operations.</p>\n<p>If asked in an interview, the above solution would be a good start. You can explain the interviewer(not code) the above and build your base for the next Optimal Solution.</p>\n<hr>\n<h4 id="approach-2-space-optimal-operation-sub-optimal-accepted">Approach #2 (Space Optimal, Operation Sub-Optimal) [Accepted]</h4>\n<p>This approach works the same way as above, i.e. , first fulfills one requirement and then another. The catch? It does it in a clever way. The above problem can also be stated in alternate way, " Bring all the non 0 elements to the front of array keeping their relative order same".</p>\n<p>This is a 2 pointer approach. The fast pointer which is denoted by variable "cur" does the job of processing new elements. If the newly found element is not a 0, we record it just after the last found non-0 element. The position of last found non-0 element is denoted by the slow pointer "lastNonZeroFoundAt" variable. As we keep finding new non-0 elements, we just overwrite them at the "lastNonZeroFoundAt + 1" \'th index. This overwrite will not result in any loss of data because we already processed what was there(if it were non-0,it already is now written at it\'s corresponding index,or if it were 0 it will be handled later in time).</p>\n<p>After the "cur" index reaches the end of array, we now know that all the non-0 elements have been moved to beginning of array in their original order. Now comes the time to fulfil other requirement, "Move all 0\'s to the end". We now simply need to fill all the indexes after the "lastNonZeroFoundAt" index with 0.</p>\n<p><strong>C++</strong></p>\n<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">moveZeroes</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>\n    <span class="kt">int</span> <span class="n">lastNonZeroFoundAt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>\n    <span class="c1">// If the current element is not 0, then we need to</span>\n    <span class="c1">// append it just in front of last non 0 element we found. </span>\n    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>\n        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>\n            <span class="n">nums</span><span class="p">[</span><span class="n">lastNonZeroFoundAt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>\n        <span class="p">}</span>\n    <span class="p">}</span>\n    <span class="c1">// After we have finished processing new elements,</span>\n    <span class="c1">// all the non-zero elements are already at beginning of array.</span>\n    <span class="c1">// We just need to fill remaining array with 0\'s.</span>\n    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lastNonZeroFoundAt</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>\n        <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>\n    <span class="p">}</span>\n<span class="p">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>Space Complexity : <script type="math/tex; mode=display">O(1)</script>. Only constant space is used.</p>\n<p>Time Complexity: <script type="math/tex; mode=display">O(n)</script>. However, the total number of operations are still sub-optimal. The total operations (array writes) that code does is <script type="math/tex; mode=display">n</script> (Total number of elements).</p>\n<hr>\n<h4 id="approach-3-optimal-accepted">Approach #3 (Optimal) [Accepted]</h4>\n<p>The total number of operations of the previous approach is sub-optimal. For example, the array which has all (except last) leading zeroes: [0, 0, 0, ..., 0, 1].How many write operations to the array? For the previous approach, it writes 0\'s <script type="math/tex; mode=display">n-1</script> times, which is not necessary. We could have instead written just once. How?\n..... \nBy only fixing the non-0 element,i.e., 1.</p>\n<p>The optimal approach is again a subtle extension of above solution. A simple realization is if the current element is non-0, its\' correct position can at best be it\'s current position or a position earlier. If it\'s the latter one, the current position will be eventually occupied by a non-0 ,or a 0, which lies at a index greater than \'cur\' index. We fill the current position by 0 right away,so that unlike the previous solution, we don\'t need to come back here in next iteration.</p>\n<p>In other words, the code will maintain the following invariant:</p>\n<blockquote>\n<ol>\n<li>\n<p>All elements before the slow pointer (lastNonZeroFoundAt) are non-zeroes.</p>\n</li>\n<li>\n<p>All elements between the current and slow pointer are zeroes.</p>\n</li>\n</ol>\n</blockquote>\n<p>Therefore, when we encounter a non-zero element, we need to swap elements pointed by current and slow pointer, then advance both pointers. If it\'s zero element, we just advance current pointer.</p>\n<p>With this invariant in-place, it\'s easy to see that the algorithm will work.</p>\n<p><strong>C++</strong></p>\n<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">moveZeroes</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>\n    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">lastNonZeroFoundAt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cur</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">cur</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>\n        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>\n            <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">lastNonZeroFoundAt</span><span class="o">++</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">cur</span><span class="p">]);</span>\n        <span class="p">}</span>\n    <span class="p">}</span>\n<span class="p">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>Space Complexity : <script type="math/tex; mode=display">O(1)</script>. Only constant space is used.</p>\n<p>Time Complexity: <script type="math/tex; mode=display">O(n)</script>. However, the total number of operations are optimal. The total operations (array writes) that code does is Number of non-0 elements.This gives us a much better best-case (when most of the elements are 0) complexity than last solution. However, the worst-case (when all elements are non-0) complexity for both the algorithms is same.</p>\n<p>Analysis written by: @spandan.pathak</p>\n</div>\n          ',
    tags: ['Facebook', 'Bloomberg'],
  },
  {
    id: '284',
    name: 'Peeking Iterator',
    acceptance: '35.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given an Iterator class interface with methods: <code>next()</code> and <code>hasNext()</code>, design and implement a PeekingIterator that support the <code>peek()</code> operation -- it essentially peek() at the element that will be returned by the next call to next().</p>\n\n<hr>\n<p>Here is an example. Assume that the iterator is initialized to the beginning of the list: <code>[1, 2, 3]</code>.</p>\n\n<p>Call <code>next()</code> gets you 1, the first element in the list.</p>\n\n<p>Now you call <code>peek()</code> and it returns 2, the next element. Calling <code>next()</code> after that <i><b>still</b></i> return 2.</p>\n\n<p>You call <code>next()</code> the final time and it returns 3, the last element. Calling <code>hasNext()</code> after that should return false.</p>\n\n<p>\n<b>Follow up</b>: How would you extend your design to be generic and work with all types, not just integer?</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/porker2008">@porker2008</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Apple', 'Yahoo'],
  },
  {
    id: '285',
    name: 'Inorder Successor in BST ',
    acceptance: '36.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a binary search tree and a node in it, find the in-order successor of that node in the BST.\n</p>\n\n<p>\n<b>Note</b>: If the given node has no in-order successor in the tree, return <code>null</code>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Microsoft', 'Pocket Gems'],
  },
  {
    id: '286',
    name: 'Walls and Gates ',
    acceptance: '45.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nYou are given a <i>m x n</i> 2D grid initialized with these three possible values.</p>\n\n<ol>\n<li><code>-1</code> - A wall or an obstacle.</li>\n<li><code>0</code> - A gate.</li>\n<li><code>INF</code> - Infinity means an empty room. We use the value <code>2<sup>31</sup> - 1 = 2147483647</code> to represent <code>INF</code> as you may assume that the distance to a gate is less than <code>2147483647</code>.</li>\n</ol>\n\n<p>\nFill each empty room with the distance to its <i>nearest</i> gate. If it is impossible to reach a gate, it should be filled with <code>INF</code>.</p>\n\n<p>\nFor example, given the 2D grid:<br>\n</p><pre>INF  -1  0  INF\nINF INF INF  -1\nINF  -1 INF  -1\n  0  -1 INF INF</pre>\n<p></p>\n\n<p>\nAfter running your function, the 2D grid should be:<br>\n</p><pre>  3  -1   0   1\n  2   2   1  -1\n  1  -1   2  -1\n  0  -1   3   4</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute Force) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-breadth-first-search-accepted">Approach #2 (Breadth-first Search) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute Force) [Time Limit Exceeded]</h4>\n<p>The brute force approach is simple, we just implement a breadth-first search from each empty room to its nearest gate.</p>\n<p>While we are doing the search, we use a 2D array called <code>distance</code> to keep track of the distance from the starting point. It also implicitly tell us whether a position had been visited so it won\'t be inserted into the queue again.</p>\n<div class="codehilite"><pre><span></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">EMPTY</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>\n<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">GATE</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">WALL</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>\n<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">DIRECTIONS</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>\n        <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span>  <span class="mi">0</span><span class="o">},</span>\n        <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span>  <span class="mi">0</span><span class="o">},</span>\n        <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span>  <span class="mi">1</span><span class="o">},</span>\n        <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">}</span>\n<span class="o">);</span>\n\n<span class="kd">public</span> <span class="kt">void</span> <span class="nf">wallsAndGates</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">rooms</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">rooms</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">rooms</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">row</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">rooms</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">col</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">rooms</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">==</span> <span class="n">EMPTY</span><span class="o">)</span> <span class="o">{</span>\n                <span class="n">rooms</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">=</span> <span class="n">distanceToNearestGate</span><span class="o">(</span><span class="n">rooms</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">);</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="kt">int</span> <span class="nf">distanceToNearestGate</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">rooms</span><span class="o">,</span> <span class="kt">int</span> <span class="n">startRow</span><span class="o">,</span> <span class="kt">int</span> <span class="n">startCol</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">rooms</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">rooms</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>\n    <span class="kt">int</span><span class="o">[][]</span> <span class="n">distance</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>\n    <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>\n    <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">startRow</span><span class="o">,</span> <span class="n">startCol</span> <span class="o">});</span>\n    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>\n        <span class="kt">int</span><span class="o">[]</span> <span class="n">point</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>\n        <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">point</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>\n        <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">point</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">direction</span> <span class="o">:</span> <span class="n">DIRECTIONS</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">row</span> <span class="o">+</span> <span class="n">direction</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>\n            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="n">direction</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">||</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">rooms</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">==</span> <span class="n">WALL</span>\n                    <span class="o">||</span> <span class="n">distance</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n                <span class="k">continue</span><span class="o">;</span>\n            <span class="o">}</span>\n            <span class="n">distance</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="n">distance</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">rooms</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">==</span> <span class="n">GATE</span><span class="o">)</span> <span class="o">{</span>\n                <span class="k">return</span> <span class="n">distance</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">];</span>\n            <span class="o">}</span>\n            <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">r</span><span class="o">,</span> <span class="n">c</span> <span class="o">});</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m^2n^2)</script>.\nFor each point in the <script type="math/tex; mode=display">m \\times n</script> size grid, the gate could be at most <script type="math/tex; mode=display">m \\times n</script> steps away.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>.\nThe space complexity depends on the queue\'s size. Since we won\'t insert points that have been visited before into the queue, we insert at most <script type="math/tex; mode=display">m \\times n</script> points into the queue.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-breadth-first-search-accepted">Approach #2 (Breadth-first Search) [Accepted]</h4>\n<p>Instead of searching from an empty room to the gates, how about searching the other way round? In other words, we initiate breadth-first search (BFS) from all gates at the same time. Since BFS guarantees that we search all rooms of distance <em>d</em> before searching rooms of distance <em>d</em> + 1, the distance to an empty room must be the shortest.</p>\n<div class="codehilite"><pre><span></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">EMPTY</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>\n<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">GATE</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">DIRECTIONS</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>\n        <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span>  <span class="mi">0</span><span class="o">},</span>\n        <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span>  <span class="mi">0</span><span class="o">},</span>\n        <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span>  <span class="mi">1</span><span class="o">},</span>\n        <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">}</span>\n<span class="o">);</span>\n\n<span class="kd">public</span> <span class="kt">void</span> <span class="nf">wallsAndGates</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">rooms</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">rooms</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">rooms</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>\n    <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">row</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">col</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">rooms</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">==</span> <span class="n">GATE</span><span class="o">)</span> <span class="o">{</span>\n                <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">row</span><span class="o">,</span> <span class="n">col</span> <span class="o">});</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>\n        <span class="kt">int</span><span class="o">[]</span> <span class="n">point</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>\n        <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">point</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>\n        <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">point</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">direction</span> <span class="o">:</span> <span class="n">DIRECTIONS</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">row</span> <span class="o">+</span> <span class="n">direction</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>\n            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="n">direction</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">||</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">rooms</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">!=</span> <span class="n">EMPTY</span><span class="o">)</span> <span class="o">{</span>\n                <span class="k">continue</span><span class="o">;</span>\n            <span class="o">}</span>\n            <span class="n">rooms</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="n">rooms</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n            <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">r</span><span class="o">,</span> <span class="n">c</span> <span class="o">});</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(mn)</script>.</p>\n<p>If you are having difficulty to derive the time complexity, start simple.</p>\n<p>Let us start with the case with only one gate. The breadth-first search takes at most <script type="math/tex; mode=display">m \\times n</script> steps to reach all rooms, therefore the time complexity is <script type="math/tex; mode=display">O(mn)</script>. But what if you are doing breadth-first search from <script type="math/tex; mode=display">k</script> gates?</p>\n<p>Once we set a room\'s distance, we are basically marking it as visited, which means each room is visited at most once. Therefore, the time complexity does not depend on the number of gates and is <script type="math/tex; mode=display">O(mn)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>.\nThe space complexity depends on the queue\'s size. We insert at most <script type="math/tex; mode=display">m \\times n</script> points into the queue.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: ['Google', 'Facebook'],
  },
  {
    id: '287',
    name: 'Find the Duplicate Number',
    acceptance: '43.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array <i>nums</i> containing <i>n</i> + 1 integers where each integer is between 1 and <i>n</i> (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\n</p>\n\n<p>\n<b>Note:</b><br>\n</p><ol>\n<li>You <b>must not</b> modify the array (assume the array is read only).</li>\n<li>You must use only constant, <i>O</i>(1) extra space.</li>\n<li>Your runtime complexity should be less than <code>O(n<sup>2</sup>)</code>.</li>\n<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>\n</ol>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#note">Note</a></li>\n<li><a href="#proof">Proof</a></li>\n<li><a href="#approach-1-sorting-accepted">Approach #1 Sorting [Accepted]</a></li>\n<li><a href="#approach-2-set-accepted">Approach #2 Set [Accepted]</a></li>\n<li><a href="#approach-3-floyds-tortoise-and-hare-cycle-detection-accepted">Approach #3 Floyd\'s Tortoise and Hare (Cycle Detection) [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="note">Note</h4>\n<p>The first two approaches mentioned do not satisfy the constraints given in\nthe prompt, but they are solutions that you might be likely to come up with\nduring a technical interview. As an interviewer, I personally would <em>not</em>\nexpect someone to come up with the cycle detection solution unless they have\nheard it before.</p>\n<h4 id="proof">Proof</h4>\n<p>Proving that at least one duplicate must exist in <code>nums</code> is simple\napplication of the\n<a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">pigeonhole principle</a>.\nHere, each number in <code>nums</code> is a "pigeon" and each distinct number that can\nappear in <code>nums</code> is a "pigeonhole". Because there are <script type="math/tex; mode=display">n+1</script> numbers are\n<script type="math/tex; mode=display">n</script> distinct possible numbers, the pigeonhole principle implies that at\nleast one of the numbers is duplicated.</p>\n<h4 id="approach-1-sorting-accepted">Approach #1 Sorting [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If the numbers are sorted, then any duplicate numbers will be adjacent in the\nsorted array.</p>\n<p><strong>Algorithm</strong></p>\n<p>Given the intuition, the algorithm follows fairly simply. First, we sort the\narray, and then we compare each element to the previous element. Because\nthere is exactly one duplicated element in the array, we know that the array\nis of at least length 2, and we can return the duplicate element as soon as\nwe find it.</p>\n<iframe frameborder="0" height="259" name="bQGYqfgj" src="https://leetcode.com/playground/bQGYqfgj/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nlgn)</script>\n</p>\n<p>The <code>sort</code> invocation costs <script type="math/tex; mode=display">O(nlgn)</script> time in Python and Java, so it\ndominates the subsequent linear scan.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script> (or <script type="math/tex; mode=display">O(n)</script>)</p>\n<p>Here, we sort <code>nums</code> in place, so the memory footprint is constant. If we\ncannot modify the input array, then we must allocate linear space for a\ncopy of <code>nums</code> and sort that instead.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-set-accepted">Approach #2 Set [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we store each element as we iterate over the array, we can simply check\neach element as we iterate over the array.</p>\n<p><strong>Algorithm</strong></p>\n<p>In order to achieve linear time complexity, we need to be able to insert\nelements into a data structure (and look them up) in constant time. A <code>Set</code>\nsatisfies these constraints nicely, so we iterate over the array and insert\neach element into <code>seen</code>. Before inserting it, we check whether it is already\nthere. If it is, then we found our duplicate, so we return it.</p>\n<iframe frameborder="0" height="276" name="jP4YUkB7" src="https://leetcode.com/playground/jP4YUkB7/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p><code>Set</code> in both Python and Java rely on underlying hash tables, so\ninsertion and lookup have amortized constant time complexities. The\nalgorithm is therefore linear, as it consists of a <code>for</code> loop that\nperforms constant work <script type="math/tex; mode=display">n</script> times.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>In the worst case, the duplicate element appears twice, with one of its\nappearances at array index <script type="math/tex; mode=display">n-1</script>. In this case, <code>seen</code> will contain\n<script type="math/tex; mode=display">n-1</script> distinct values, and will therefore occupy <script type="math/tex; mode=display">O(n)</script> space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-floyds-tortoise-and-hare-cycle-detection-accepted">Approach #3 Floyd\'s Tortoise and Hare (Cycle Detection) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we interpret <code>nums</code> such that for each pair of index <script type="math/tex; mode=display">i</script> and value\n<script type="math/tex; mode=display">v_i</script>, the "next" value <script type="math/tex; mode=display">v_j</script> is at index <script type="math/tex; mode=display">v_i</script>, we can reduce this\nproblem to cycle detection. See the solution to\n<a href="https://leetcode.com/problems/linked-list-cycle-ii/solution/">Linked List Cycle II</a>\nfor more details.</p>\n<p><strong>Algorithm</strong></p>\n<p>First off, we can easily show that the constraints of the problem imply that\na cycle <em>must</em> exist. Because each number in <code>nums</code> is between <script type="math/tex; mode=display">1</script> and\n<script type="math/tex; mode=display">n</script>, it will necessarily point to an index that exists. Therefore, the list\ncan be traversed infinitely, which implies that there is a cycle.\nAdditionally, because <script type="math/tex; mode=display">0</script> cannot appear as a value in <code>nums</code>, <code>nums[0]</code>\ncannot be part of the cycle. Therefore, traversing the array in this manner\nfrom <code>nums[0]</code> is equivalent to traversing a cyclic linked list. Given this,\nthe problem can be solved just like\n<a href="https://leetcode.com/problems/linked-list-cycle-ii/">Linked List Cycle II</a>.</p>\n<p>To see the algorithm in action, check out the animation below:</p>\n<p>!?!../Documents/287_Find_the_Duplicate_Number.json:1280,720!?!</p>\n<iframe frameborder="0" height="412" name="RMBz6AQR" src="https://leetcode.com/playground/RMBz6AQR/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>For detailed analysis, refer to \n<a href="https://leetcode.com/problems/linked-list-cycle-ii/solution/#approach-2-floyds-tortoise-and-hare-accepted">Linked List Cycle II</a>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n<p>For detailed analysis, refer to \n<a href="https://leetcode.com/problems/linked-list-cycle-ii/solution/#approach-2-floyds-tortoise-and-hare-accepted">Linked List Cycle II</a>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis and solutions written by: <a href="https://leetcode.com/emptyset">@emptyset</a></p>\n</div>\n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '288',
    name: 'Unique Word Abbreviation ',
    acceptance: '17.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>An abbreviation of a word follows the form &lt;first letter&gt;&lt;number&gt;&lt;last letter&gt;. Below are some examples of word abbreviations:\n</p><pre>a) it                      --&gt; it    (no abbreviation)\n\n     1\nb) d|o|g                   --&gt; d1g\n\n              1    1  1\n     1---5----0----5--8\nc) i|nternationalizatio|n  --&gt; i18n\n\n              1\n     1---5----0\nd) l|ocalizatio|n          --&gt; l10n\n</pre>\n\n<p>Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word\'s abbreviation is unique if no <i>other</i> word from the dictionary has the same abbreviation.</p>\n\n<p>Example: <br>\n</p><pre>Given dictionary = [ "deer", "door", "cake", "card" ]\n\nisUnique("dear") -&gt; <code>false</code>\nisUnique("cart") -&gt; <code>true</code>\nisUnique("cane") -&gt; <code>false</code>\nisUnique("make") -&gt; <code>true</code>\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force">Approach #1 (Brute Force)</a></li>\n<li><a href="#approach-2-hash-table-accepted">Approach #2 (Hash Table) [Accepted]</a></li>\n<li><a href="#approach-3-hash-table-accepted">Approach #3 (Hash Table) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This problem has a low acceptance rate for a reason. The logic in <code>isUnique</code> can be a little tricky to get right due to the number of cases you need to consider. We highly recommend that you practice this similar but easier problem first - <a href="https://leetcode.com/problems/two-sum-iii-data-structure-design/">Two Sum III - Data structure design</a>.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force">Approach #1 (Brute Force)</h4>\n<p>Let us begin by storing the dictionary first in the constructor. To determine if a word\'s abbreviation is unique with respect to a word in the dictionary, we check if all the following conditions are met:</p>\n<ol>\n<li><a name="condition-1"></a>They are not the same word.</li>\n<li>They both have equal lengths.</li>\n<li>They both share the same first and last letter.</li>\n</ol>\n<p>Note that <a href="#condition-1">Condition #1</a> is implicit because from the problem statement:</p>\n<blockquote>\n<p>A word\'s abbreviation is unique if no <strong><em>other</em></strong> word from the dictionary has the same abbreviation.</p>\n</blockquote>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ValidWordAbbr</span> <span class="o">{</span>\n    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span><span class="o">[]</span> <span class="n">dict</span><span class="o">;</span>\n\n    <span class="kd">public</span> <span class="nf">ValidWordAbbr</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">dictionary</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">dict</span> <span class="o">=</span> <span class="n">dictionary</span><span class="o">;</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isUnique</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">dict</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">{</span>\n                <span class="k">continue</span><span class="o">;</span>\n            <span class="o">}</span>\n            <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">n</span>\n                <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>\n                <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>\n                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n)</script> for each <code>isUnique</code> call.\nAssume that <script type="math/tex; mode=display">n</script> is the number of words in the dictionary, each <code>isUnique</code> call takes <script type="math/tex; mode=display">O(n)</script> time.</li>\n</ul>\n<hr>\n<h4 id="approach-2-hash-table-accepted">Approach #2 (Hash Table) [Accepted]</h4>\n<p>Note that <code>isUnique</code> is called repeatedly for the same set of words in the dictionary each time. We should pre-process the dictionary to speed it up.</p>\n<p>Ideally, a hash table supports constant time look up. What should the key-value pair be?</p>\n<p>Well, the idea is to <em>group</em> the words that fall under the same abbreviation together. For the value, we use a Set instead of a List to guarantee uniqueness.</p>\n<p>The logic in <code>isUnique(word)</code> is tricky. You need to consider the following cases:</p>\n<ol>\n<li>Does the word\'s abbreviation exists in the dictionary? If not, then it must be unique.</li>\n<li>If above is yes, then it can only be unique if the grouping of the abbreviation contains no other words except <em>word</em>.</li>\n</ol>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ValidWordAbbr</span> <span class="o">{</span>\n    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">abbrDict</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>\n\n    <span class="kd">public</span> <span class="nf">ValidWordAbbr</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">dictionary</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">dictionary</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">String</span> <span class="n">abbr</span> <span class="o">=</span> <span class="n">toAbbr</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>\n            <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="n">abbrDict</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">abbr</span><span class="o">)</span>\n                <span class="o">?</span> <span class="n">abbrDict</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">abbr</span><span class="o">)</span> <span class="o">:</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span>\n            <span class="n">words</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>\n            <span class="n">abbrDict</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">abbr</span><span class="o">,</span> <span class="n">words</span><span class="o">);</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isUnique</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">String</span> <span class="n">abbr</span> <span class="o">=</span> <span class="n">toAbbr</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>\n        <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="n">abbrDict</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">abbr</span><span class="o">);</span>\n        <span class="k">return</span> <span class="n">words</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">words</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">words</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">word</span><span class="o">));</span>\n    <span class="o">}</span>\n\n    <span class="kd">private</span> <span class="n">String</span> <span class="nf">toAbbr</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">return</span> <span class="n">s</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<hr>\n<h4 id="approach-3-hash-table-accepted">Approach #3 (Hash Table) [Accepted]</h4>\n<p>Let us consider another approach using a counter as the table\'s value. For example, assume the dictionary = <code>["door", "deer"]</code>, we have the mapping of <code>{"d2r" -&gt; 2}</code>. However, this mapping alone is not enough, because we need to consider whether the word exists in the dictionary. This can be easily overcome by inserting the entire dictionary into a set.</p>\n<p>When an abbreviation\'s counter exceeds one, we know this abbreviation must not be unique because at least two different words share the same abbreviation. Therefore, we can further simplify the counter to just a boolean.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ValidWordAbbr</span> <span class="o">{</span>\n    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">abbrDict</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>\n    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">dict</span><span class="o">;</span>\n\n    <span class="kd">public</span> <span class="nf">ValidWordAbbr</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">dictionary</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">dict</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">dictionary</span><span class="o">));</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">dict</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">String</span> <span class="n">abbr</span> <span class="o">=</span> <span class="n">toAbbr</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>\n            <span class="n">abbrDict</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">abbr</span><span class="o">,</span> <span class="o">!</span><span class="n">abbrDict</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">abbr</span><span class="o">));</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isUnique</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">String</span> <span class="n">abbr</span> <span class="o">=</span> <span class="n">toAbbr</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>\n        <span class="n">Boolean</span> <span class="n">hasAbbr</span> <span class="o">=</span> <span class="n">abbrDict</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">abbr</span><span class="o">);</span>\n        <span class="k">return</span> <span class="n">hasAbbr</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">hasAbbr</span> <span class="o">&amp;&amp;</span> <span class="n">dict</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">word</span><span class="o">));</span>\n    <span class="o">}</span>\n\n    <span class="kd">private</span> <span class="n">String</span> <span class="nf">toAbbr</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">return</span> <span class="n">s</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script> pre-processing, <script type="math/tex; mode=display">O(1)</script> for each <code>isUnique</code> call.\nBoth <a href="#approach-2">Approach #2</a> and <a href="#approach-3">Approach #3</a> above take <script type="math/tex; mode=display">O(n)</script> pre-processing time in the constructor. This is totally worth it if <code>isUnique</code> is called repeatedly.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>.\nWe traded the extra <script type="math/tex; mode=display">O(n)</script> space storing the table to reduce the time complexity in <code>isUnique</code>.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '289',
    name: 'Game of Life',
    acceptance: '37.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nAccording to the <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank">Wikipedia\'s article</a>: "The <b>Game of Life</b>, also known simply as <b>Life</b>, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."\n</p>\n\n<p>\nGiven a <i>board</i> with <i>m</i> by <i>n</i> cells, each cell has an initial state <i>live</i> (1) or <i>dead</i> (0). Each cell interacts with its <a href="https://en.wikipedia.org/wiki/Moore_neighborhood" target="_blank">eight neighbors</a> (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n</p>\n\n<p>\n</p><ol>\n<li>Any live cell with fewer than two live neighbors dies, as if caused by under-population.</li>\n<li>Any live cell with two or three live neighbors lives on to the next generation.</li>\n<li>Any live cell with more than three live neighbors dies, as if by over-population..</li>\n<li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li>\n</ol>\n<p></p>\n\n<p>\nWrite a function to compute the next state (after one update) of the board given its current state.</p>\n\n<p>\n<b>Follow up</b>: <br>\n</p><ol>\n<li>Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.</li>\n<li>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</li>\n</ol>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Snapchat', 'Dropbox', 'Two Sigma'],
  },
  {
    id: '290',
    name: 'Word Pattern',
    acceptance: '33.3%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a <code>pattern</code> and a string <code>str</code>, find if <code>str</code> follows the same pattern.</p>\n<p> Here <b>follow</b> means a full match, such that there is a bijection between a letter in <code>pattern</code> and a <b>non-empty</b> word in <code>str</code>.</p>\n<p>\n<b>Examples:</b><br>\n</p><ol>\n<li>pattern = <code>"abba"</code>, str = <code>"dog cat cat dog"</code> should return true.</li>\n<li>pattern = <code>"abba"</code>, str = <code>"dog cat cat fish"</code> should return false.</li>\n<li>pattern = <code>"aaaa"</code>, str = <code>"dog cat cat dog"</code> should return false.</li>\n<li>pattern = <code>"abba"</code>, str = <code>"dog dog dog dog"</code> should return false.</li>\n</ol>\n<p></p>\n\n<p>\n<b>Notes:</b><br>\nYou may assume <code>pattern</code> contains only lowercase letters, and <code>str</code> contains lowercase letters separated by a single space.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/minglotus6">@minglotus6</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Uber', 'Dropbox'],
  },
  {
    id: '291',
    name: 'Word Pattern II ',
    acceptance: '38.1%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given a <code>pattern</code> and a string <code>str</code>, find if <code>str</code> follows the same pattern.</p>\n<p> Here <b>follow</b> means a full match, such that there is a bijection between a letter in <code>pattern</code> and a <b>non-empty</b> substring in <code>str</code>.</p>\n<p>\n<b>Examples:</b><br>\n</p><ol>\n<li>pattern = <code>"abab"</code>, str = <code>"redblueredblue"</code> should return true.</li>\n<li>pattern = <code>"aaaa"</code>, str = <code>"asdasdasdasd"</code> should return true.</li>\n<li>pattern = <code>"aabb"</code>, str = <code>"xyzabcxzyabc"</code> should return false.</li>\n</ol>\n<p></p>\n\n<p>\n<b>Notes:</b><br>\nYou may assume both <code>pattern</code> and <code>str</code> contains only lowercase letters.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Uber', 'Dropbox'],
  },
  {
    id: '292',
    name: 'Nim Game',
    acceptance: '55.3%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nYou are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.\n</p>\n\n<p>\nBoth of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.\n</p>\n\n<p>\nFor example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<h2 id="solution">Solution</h2>\n<p>You can <em>always</em> win a Nim game if the number of stones <script type="math/tex; mode=display">n</script> in the pile is not divisible by <script type="math/tex; mode=display">4</script>.</p>\n<p><strong>Reasoning</strong></p>\n<p>Let us think of the small cases. It is clear that if there are only one, two, or three stones in the pile, and it is your turn, you can win the game by taking all of them. Like the problem description says, if there are exactly four stones in the pile, you will lose. Because no matter how many you take, you will leave some stones behind for your opponent to take and win the game. So in order to win, you have to ensure that you never reach the situation where there are exactly four stones on the pile on your turn.</p>\n<p>Similarly, if there are five, six, or seven stones you can win by taking just enough to leave four stones for your opponent so that they lose. But if there are eight stones on the pile, you will inevitably lose, because regardless whether you pick one, two or three stones from the pile, your opponent can pick three, two or one stone to ensure that, again, four stones will be left to you on your turn.</p>\n<p>It is obvious that the same pattern repeats itself for <script type="math/tex; mode=display">n=4,8,12,16,\\dots</script>, basically all multiples of <script type="math/tex; mode=display">4</script>.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canWinNim</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">return</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">);</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>Time complexity is <script type="math/tex; mode=display">O(1)</script>, since only one check is performed. No additional space is used, so space complexity is also <script type="math/tex; mode=display">O(1)</script>.</p>\n<p><strong>References</strong></p>\n<p><a href="https://www.cs.umd.edu/~gordon/ysp/nim.pdf">Lecture on Nim Games</a> from University of Maryland: MATH 199: Math, Game Theory and the Theory of Games, Summer 2006.</p>\n<p>Analysis written by: @noran</p>\n</div>\n          ',
    tags: ['Adobe'],
  },
  {
    id: '293',
    name: 'Flip Game ',
    acceptance: '56.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nYou are playing the following Flip Game with your friend: Given a string that contains only these two characters: <code>+</code> and <code>-</code>, you and your friend take turns to flip two <b>consecutive</b> <code>"++"</code> into <code>"--"</code>. The game ends when a person can no longer make a move and therefore the other person will be the winner.\n</p>\n\n<p>\nWrite a function to compute all possible states of the string after one valid move.\n</p>\n\n<p>\nFor example, given <code>s = "++++"</code>, after one move, it may become one of the following states:\n</p><pre>[\n  "--++",\n  "+--+",\n  "++--"\n]\n</pre>\n<p></p>\n\n<p>\nIf there is no valid move, return an empty list <code>[]</code>.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '294',
    name: 'Flip Game II ',
    acceptance: '46.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nYou are playing the following Flip Game with your friend: Given a string that contains only these two characters: <code>+</code> and <code>-</code>, you and your friend take turns to flip two <b>consecutive</b> <code>"++"</code> into <code>"--"</code>. The game ends when a person can no longer make a move and therefore the other person will be the winner.\n</p>\n\n<p>\nWrite a function to determine if the starting player can guarantee a win.\n</p>\n\n<p>\nFor example, given <code>s = "++++"</code>, return true. The starting player can guarantee a win by flipping the middle <code>"++"</code> to become <code>"+--+"</code>.\n</p>\n\n<p><b>Follow up:</b><br>\nDerive your algorithm\'s runtime complexity.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '295',
    name: 'Find Median from Data Stream',
    acceptance: '28.3%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>\nExamples: <br>\n<p><code>[2,3,4]</code> , the median is <code>3</code></p>\n<p><code>[2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code> </p>\n\n<p>\nDesign a data structure that supports the following two operations:\n</p>\n<ul>\n<li>void addNum(int num) - Add a integer number from the data stream to the data structure.</li>\n<li>double findMedian() - Return the median of all elements so far.</li>\n</ul>\n\n<p>\nFor example:</p>\n<pre>addNum(1)\naddNum(2)\nfindMedian() -&gt; 1.5\naddNum(3) \nfindMedian() -&gt; 2\n</pre>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/Louis1992">@Louis1992</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-simple-sorting-time-limit-exceeded">Approach #1 Simple Sorting [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-insertion-sort-time-limit-exceeded">Approach #2 Insertion Sort [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-two-heaps-accepted">Approach #3 Two Heaps! [Accepted]</a></li>\n<li><a href="#approach-4-multiset-and-two-pointers-accepted">Approach #4 Multiset and Two Pointers [Accepted]</a></li>\n<li><a href="#further-thoughts">Further Thoughts</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-simple-sorting-time-limit-exceeded">Approach #1 Simple Sorting [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>Do what the question says.</p>\n<p><strong>Algorithm</strong></p>\n<p>Store the numbers in a resize-able container. Every time you need to output the median, sort the container and output the median.</p>\n<iframe frameborder="0" height="377" name="4f383Thu" src="https://leetcode.com/playground/4f383Thu/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O(n \\cdot log(n)) + O(1) \\simeq O(n \\cdot log(n))</script>.</p>\n<ul>\n<li>Adding a number takes amortized <script type="math/tex; mode=display">O(1)</script> time for a container with an efficient resizing scheme.</li>\n<li>Finding the median is primarily dependent on the sorting that takes place. This takes <script type="math/tex; mode=display">O(n \\cdot log(n))</script> time for a standard comparative sort.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(n)</script> linear space to hold input in a container. No extra space other than that needed (since sorting can usually be done in-place).</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-insertion-sort-time-limit-exceeded">Approach #2 Insertion Sort [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>Keeping our input container always sorted (i.e. maintaining the sorted nature of the container as an <em>invariant</em>).</p>\n<p><strong>Algorithm</strong></p>\n<p>Which algorithm allows a number to be added to a sorted list of numbers and yet keeps the entire list sorted? Well, for one, <strong>insertion sort!</strong></p>\n<p>We assume that the current list is already sorted. When a new number comes, we have to add it to the list while maintaining the sorted nature of the list. This is achieved easily by finding the correct place to insert the incoming number, using a <strong>binary search</strong> (remember, the list is <em>always sorted</em>). Once the position is found, we need to shift all higher elements by one space to make room for the incoming number.</p>\n<p>This method would work well when the amount of insertion queries is lesser or about the same as the amount of median finding queries.</p>\n<iframe frameborder="0" height="394" name="k7RdqeEJ" src="https://leetcode.com/playground/k7RdqeEJ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O(n) + O(log(n)) \\approx O(n)</script>.</p>\n<ul>\n<li>Binary Search takes <script type="math/tex; mode=display">O(log(n))</script> time to find correct insertion position.</li>\n<li>Insertion can take up to <script type="math/tex; mode=display">O(n)</script> time since elements have to be shifted inside the container to make room for the new element.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>Pop quiz:</strong> Can we use a <em>linear</em> search instead of a <em>binary</em> search to find insertion position, without incurring any significant runtime penalty?</p>\n</blockquote>\n<ul>\n<li>Space complexity: <script type="math/tex; mode=display">O(n)</script> linear space to hold input in a container.</li>\n</ul>\n<hr>\n<h4 id="approach-3-two-heaps-accepted">Approach #3 Two Heaps! [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>The above two approaches gave us some valuable insights on how to tackle this problem. Concretely, one can infer two things:</p>\n<ol>\n<li>If we could maintain direct access to median elements at all times, then finding the median would take a constant amount of time.</li>\n<li>If we could find a reasonably fast way of adding numbers to our containers, additional penalties incurred could be lessened.</li>\n</ol>\n<p>But perhaps the most important insight, which is not readily observable, is the fact that we <em>only</em> need a consistent way to access the median elements. Keeping the <em>entire</em> input sorted is <strong>not a requirement.</strong></p>\n<blockquote>\n<p>Well, if only there were a data structure which could handle our needs.</p>\n</blockquote>\n<p>As it turns out there are two data structures for the job:</p>\n<ul>\n<li>Heaps (or Priority Queues <sup id="fnref:note-1"><a class="footnote-ref" href="#fn:note-1" rel="footnote">1</a></sup>)</li>\n<li>Self-balancing Binary Search Trees (we\'ll talk more about them in <a href="#approach-4-multiset-and-two-pointers-accepted">Approach #4</a>)</li>\n</ul>\n<p>Heaps are a natural ingredient for this dish! Adding elements to them take logarithmic order of time. They also give direct access to the maximal/minimal elements in a group.</p>\n<p>If we could maintain <em>two</em> heaps in the following way:</p>\n<ul>\n<li>A max-heap to store the smaller half of the input numbers</li>\n<li>A min-heap to store the larger half of the input numbers</li>\n</ul>\n<p>This gives access to median values in the input: they comprise the top of the heaps!</p>\n<p><strong>Wait, what? How?</strong></p>\n<p>If the following conditions are met:</p>\n<ol>\n<li>Both the heaps are balanced (or nearly balanced)</li>\n<li>The max-heap contains all the smaller numbers while the min-heap contains all the larger numbers</li>\n</ol>\n<p>then we can say that:</p>\n<ol>\n<li>All the numbers in the max-heap are smaller or equal to the top element of the max-heap (let\'s call it <script type="math/tex; mode=display">x</script>)</li>\n<li>All the numbers in the min-heap are larger or equal to the top element of the min-heap (let\'s call it <script type="math/tex; mode=display">y</script>)</li>\n</ol>\n<p>Then <script type="math/tex; mode=display">x</script> and/or <script type="math/tex; mode=display">y</script> are smaller than (or equal to) almost half of the elements and larger than (or equal to) the other half. That is <em>the</em> definition of <strong>median</strong> elements.</p>\n<p>This leads us to a huge point of pain in this approach: <strong>balancing the two heaps!</strong></p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>Two priority queues:</p>\n<ol>\n<li>A max-heap <code>lo</code> to store the smaller half of the numbers</li>\n<li>A min-heap <code>hi</code> to store the larger half of the numbers</li>\n</ol>\n</li>\n<li>\n<p>The max-heap <code>lo</code> is allowed to store, at worst, one more element more than the min-heap <code>hi</code>. Hence if we have processed <script type="math/tex; mode=display">k</script> elements:</p>\n<ul>\n<li>If <script type="math/tex; mode=display">k = 2*n + 1 \\quad (\\forall \\, n \\in \\mathbb{Z})</script>, then <code>lo</code> is allowed to hold <script type="math/tex; mode=display">n+1</script> elements, while <code>hi</code> can hold <script type="math/tex; mode=display">n</script> elements.</li>\n<li>If <script type="math/tex; mode=display">k = 2*n \\quad (\\forall \\, n \\in \\mathbb{Z})</script>, then both heaps are balanced and hold <script type="math/tex; mode=display">n</script> elements each.</li>\n</ul>\n<p>This gives us the nice property that when the heaps are perfectly balanced, the median can be derived from the tops of both heaps. Otherwise, the top of the max-heap <code>lo</code> holds the legitimate median.</p>\n</li>\n<li>\n<p>Adding a number <code>num</code>:</p>\n<ul>\n<li>Add <code>num</code> to max-heap <code>lo</code>. Since <code>lo</code> received a new element, we must do a balancing step for <code>hi</code>. So remove the largest element from <code>lo</code> and offer it to <code>hi</code>.</li>\n<li>The min-heap <code>hi</code> might end holding more elements than the max-heap <code>lo</code>, after the previous operation. We fix that by removing the smallest element from <code>hi</code> and offering it to <code>lo</code>.</li>\n</ul>\n<p>The above step ensures that we do not disturb the nice little size property we just mentioned.</p>\n</li>\n</ul>\n<p>A little example will clear this up! Say we take input from the stream <code>[41, 35, 62, 5, 97, 108]</code>. The run-though of the algorithm looks like this:</p>\n<div class="codehilite"><pre><span></span>Adding number <span class="m">41</span>\nMaxHeap lo<span class="o">:</span> <span class="p">[</span><span class="m">41</span><span class="p">]</span>           <span class="o">//</span> MaxHeap stores the largest value at the top <span class="p">(</span>index <span class="m">0</span><span class="p">)</span>\nMinHeap hi<span class="o">:</span> <span class="p">[]</span>             <span class="o">//</span> MinHeap stores the smallest value at the top <span class="p">(</span>index <span class="m">0</span><span class="p">)</span>\nMedian is <span class="m">41</span>\n<span class="o">=======================</span>\nAdding number <span class="m">35</span>\nMaxHeap lo<span class="o">:</span> <span class="p">[</span><span class="m">35</span><span class="p">]</span>\nMinHeap hi<span class="o">:</span> <span class="p">[</span><span class="m">41</span><span class="p">]</span>\nMedian is <span class="m">38</span>\n<span class="o">=======================</span>\nAdding number <span class="m">62</span>\nMaxHeap lo<span class="o">:</span> <span class="p">[</span><span class="m">41</span><span class="p">,</span> <span class="m">35</span><span class="p">]</span>\nMinHeap hi<span class="o">:</span> <span class="p">[</span><span class="m">62</span><span class="p">]</span>\nMedian is <span class="m">41</span>\n<span class="o">=======================</span>\nAdding number <span class="m">4</span>\nMaxHeap lo<span class="o">:</span> <span class="p">[</span><span class="m">35</span><span class="p">,</span> <span class="m">4</span><span class="p">]</span>\nMinHeap hi<span class="o">:</span> <span class="p">[</span><span class="m">41</span><span class="p">,</span> <span class="m">62</span><span class="p">]</span>\nMedian is <span class="m">38</span>\n<span class="o">=======================</span>\nAdding number <span class="m">97</span>\nMaxHeap lo<span class="o">:</span> <span class="p">[</span><span class="m">41</span><span class="p">,</span> <span class="m">35</span><span class="p">,</span> <span class="m">4</span><span class="p">]</span>\nMinHeap hi<span class="o">:</span> <span class="p">[</span><span class="m">62</span><span class="p">,</span> <span class="m">97</span><span class="p">]</span>\nMedian is <span class="m">41</span>\n<span class="o">=======================</span>\nAdding number <span class="m">108</span>\nMaxHeap lo<span class="o">:</span> <span class="p">[</span><span class="m">41</span><span class="p">,</span> <span class="m">35</span><span class="p">,</span> <span class="m">4</span><span class="p">]</span>\nMinHeap hi<span class="o">:</span> <span class="p">[</span><span class="m">62</span><span class="p">,</span> <span class="m">97</span><span class="p">,</span> <span class="m">108</span><span class="p">]</span>\nMedian is <span class="m">51.5</span>\n</pre></div>\n<iframe frameborder="0" height="479" name="asbkCdUD" src="https://leetcode.com/playground/asbkCdUD/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O(5 * log(n)) + O(1) \\approx O(log(n))</script>.</p>\n<ul>\n<li>At worst, there are three heap insertions and two heap deletions from the top. Each of these takes about <script type="math/tex; mode=display">O(log(n))</script> time.</li>\n<li>Finding the mean takes constant <script type="math/tex; mode=display">O(1)</script> time since the tops of heaps are directly accessible.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(n)</script> linear space to hold input in containers.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-multiset-and-two-pointers-accepted">Approach #4 Multiset and Two Pointers [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Self-balancing Binary Search Trees (like an <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL Tree</a>) have some <em>very</em> interesting properties. They maintain the tree\'s height to a logarithmic bound. Thus inserting a new element has reasonably good time performance. The median <strong>always</strong> winds up in the root of the tree and/or one of its children. Solving this problem using the same approach as <a href="#approach-3-two-heaps-accepted">Approach #3</a> but using a Self-balancing BST seems like a good choice. Except the fact that implementing such a tree is not trivial and prone to errors.</p>\n<p><em>Why reinvent the wheel?</em> Most languages implement a <code>multiset</code> class which emulates such behavior. The only problem remains keeping track of the median elements. That is easily solved with <strong>pointers!</strong> <sup id="fnref:note-2"><a class="footnote-ref" href="#fn:note-2" rel="footnote">2</a></sup></p>\n<p>We maintain two pointers: one for the lower median element and the other for the higher median element. When the total number of elements is odd, both the pointers point to the same median element (since there is only one median in this case). When the number of elements is even, the pointers point to two consecutive elements, whose mean is the representative median of the input.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>Two iterators/pointers <code>lo_median</code> and <code>hi_median</code>, which iterate over the <code>data</code> multiset.</p>\n</li>\n<li>\n<p>While adding a number <code>num</code>, three cases arise:</p>\n<ol>\n<li>The container is currently <strong>empty.</strong> Hence we simply insert <code>num</code> and set both pointers to point to this element.</li>\n<li>\n<p>The container currently holds an <strong>odd</strong> number of elements. This means that both the pointers currently point to the same element.</p>\n<ul>\n<li>If <code>num</code> is not equal to the current median element, then <code>num</code> goes on either side of it. Whichever side it goes, the size of that part increases and hence the corresponding pointer is updated. For example, if <code>num</code> is less than the median element, the size of the lesser half of input increases by <script type="math/tex; mode=display">1</script> on inserting <code>num</code>. Thus it makes sense to decrement <code>lo_median</code>.</li>\n<li>If <code>num</code> is equal to the current median element, then the action taken is dependent on how <code>num</code> is inserted into <code>data</code>. <strong>NOTE:</strong> In our given C++ code example, <code>std::multiset::insert</code> inserts an element <em>after</em> all elements of equal value. Hence we increment <code>hi_median</code>.</li>\n</ul>\n</li>\n<li>\n<p>The container currently holds an <strong>even</strong> number of elements. This means that the pointers currently point to consecutive elements.</p>\n<ul>\n<li>If <code>num</code> is a number between both median elements, then <code>num</code> becomes the new median. Both pointers must point to it.</li>\n<li>Otherwise, <code>num</code> increases the size of either the lesser or higher half of the input. We update the pointers accordingly. It is important to remember that both the pointers <strong><em>must</em></strong> point to the same element now.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>Finding the median is easy! It is simply the <strong>mean</strong> of the elements pointed to by the two pointers <code>lo_median</code> and <code>hi_median</code>.</p>\n</li>\n</ul>\n<iframe frameborder="0" height="515" name="NJ4LimHc" src="https://leetcode.com/playground/NJ4LimHc/shared" width="100%"></iframe>\n<p>A much shorter (but harder to understand), <strong><em>one</em></strong> <em>pointer</em> version <sup id="fnref:note-3"><a class="footnote-ref" href="#fn:note-3" rel="footnote">3</a></sup> of this solution is given below:</p>\n<iframe frameborder="0" height="515" name="ZAJQwdQE" src="https://leetcode.com/playground/ZAJQwdQE/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O(log(n)) + O(1) \\approx O(log(n))</script>.</p>\n<ul>\n<li>Inserting a number takes <script type="math/tex; mode=display">O(log(n))</script> time for a standard <code>multiset</code> scheme. <sup id="fnref:note-4"><a class="footnote-ref" href="#fn:note-4" rel="footnote">4</a></sup></li>\n<li>Finding the mean takes constant <script type="math/tex; mode=display">O(1)</script> time since the median elements are directly accessible from the two pointers.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(n)</script> linear space to hold input in container.</p>\n</li>\n</ul>\n<hr>\n<h4 id="further-thoughts">Further Thoughts</h4>\n<p>There are so many ways around this problem, that frankly, it is scary. Here are a few more that I came across:</p>\n<ul>\n<li>\n<p><strong>Buckets!</strong> If the numbers in the stream are statistically distributed, then it is easier to keep track of buckets where the median would land, than the entire array. Once you know the correct bucket, simply sort it find the median. If the bucket size is significantly smaller than the size of input processed, this results in huge time saving. <a href="https://leetcode.com/mitbbs8080/">@mitbbs8080</a> has an interesting implementation <a href="https://discuss.leetcode.com/post/32180">here.</a></p>\n</li>\n<li>\n<p><strong>Reservoir Sampling.</strong> Following along the lines of using buckets: if the stream is statistically distributed, you can rely on Reservoir Sampling. Basically, if you could maintain just one good bucket (or <em>reservoir</em>) which could hold a representative sample of the entire stream, you could estimate the median of the entire stream from just this one bucket. This means good time and memory performance. Reservoir Sampling lets you do just that. Determining a <strong>"good"</strong> size for your reservoir? <em>Now, that\'s a whole other challenge.</em> A good explanation for this can be found in <a href="https://stackoverflow.com/a/10693752/2844164">this StackOverflow answer.</a></p>\n</li>\n<li>\n<p><strong>Segment Trees</strong> are a great data structure if you need to do a lot of insertions or a lot of read queries over a limited range of input values. They allow us to do all such operations <em>fast</em> and in roughly the <em>same amount of time</em>, <strong>always.</strong> The only problem is that they are far from trivial to implement. Take a look at my <a href="https://leetcode.com/articles/recursive-approach-segment-trees-range-sum-queries-lazy-propagation/">introductory article on Segment Trees</a> if you are interested.</p>\n</li>\n<li>\n<p><strong>Order Statistic Trees</strong> are data structures which seem to be tailor-made for this problem. They have all the nice features of a BST, but also let you find the <script type="math/tex; mode=display">k^{th}</script> order element stored in the tree. They are a pain to implement and no standard interview would require you to code these up. But they are fun to use if they are already implemented in the language of your choice. <sup id="fnref:note-5"><a class="footnote-ref" href="#fn:note-5" rel="footnote">5</a></sup></p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by <a href="https://leetcode.com/babhishek21">@babhishek21</a>.</p>\n<div class="footnote">\n<hr>\n<ol>\n<li id="fn:note-1">\n<p>Priority Queues queue out elements based on a predefined priority. They are an abstract concept and can, as such, be implemented in many different ways. Heaps are an efficient way to implement Priority Queues.&nbsp;<a class="footnote-backref" href="#fnref:note-1" rev="footnote" title="Jump back to footnote 1 in the text">↩</a></p>\n</li>\n<li id="fn:note-2">\n<p>Shout-out to <a href="https://leetcode.com/pharese/">@pharese</a> for this approach.&nbsp;<a class="footnote-backref" href="#fnref:note-2" rev="footnote" title="Jump back to footnote 2 in the text">↩</a></p>\n</li>\n<li id="fn:note-3">\n<p>Inspired from <a href="https://discuss.leetcode.com/topic/74963/o-n-log-k-c-using-multiset-and-updating-middle-iterator/">this post</a> by <a href="https://leetcode.com/stefanpochmann">@StefanPochmann</a>.&nbsp;<a class="footnote-backref" href="#fnref:note-3" rev="footnote" title="Jump back to footnote 3 in the text">↩</a></p>\n</li>\n<li id="fn:note-4">\n<p><a href="http://en.cppreference.com/w/cpp/container/multiset/insert">Hinting</a> can reduce that to amortized constant <script type="math/tex; mode=display">O(1)</script> time.&nbsp;<a class="footnote-backref" href="#fnref:note-4" rev="footnote" title="Jump back to footnote 4 in the text">↩</a></p>\n</li>\n<li id="fn:note-5">\n<p><a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/policy_based_data_structures_test.html"><strong>GNU</strong> <code>libstdc++</code></a> users are in luck! Take a look at <a href="https://stackoverflow.com/a/11228573/2844164">this StackOverflow answer.</a>&nbsp;<a class="footnote-backref" href="#fnref:note-5" rev="footnote" title="Jump back to footnote 5 in the text">↩</a></p>\n</li>\n</ol>\n</div>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '296',
    name: 'Best Meeting Point ',
    acceptance: '52.1%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using <a href="http://en.wikipedia.org/wiki/Taxicab_geometry" target="_blank">Manhattan Distance</a>, where distance(p1, p2) = <code>|p2.x - p1.x| + |p2.y - p1.y|</code>.</p>\n\n<p>For example, given three people living at <code>(0,0)</code>, <code>(0,4)</code>, and <code>(2,2)</code>:</p>\n\n<pre>1 - 0 - 0 - 0 - 1\n|   |   |   |   |\n0 - 0 - 0 - 0 - 0\n|   |   |   |   |\n0 - 0 - 1 - 0 - 0</pre>\n\n<p>The point <code>(0,2)</code> is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-breadth-first-search-time-limit-exceeded">Approach #1 (Breadth-first Search) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-manhattan-distance-formula-time-limit-exceeded">Approach #2 (Manhattan Distance Formula) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-sorting-accepted">Approach #3 (Sorting) [Accepted]</a></li>\n<li><a href="#approach-4-collect-coordinates-in-sorted-order-accepted">Approach #4 (Collect Coordinates in Sorted Order) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-breadth-first-search-time-limit-exceeded">Approach #1 (Breadth-first Search) [Time Limit Exceeded]</h4>\n<p>A brute force approach is to evaluate all possible meeting points in the grid. We could apply breadth-first search originating from each of the point.</p>\n<p>While inserting a point into the queue, we need to record the distance of that point from the meeting point.  Also, we need an extra <code>visited</code> table to record which point had already been visited to avoid being inserted into the queue again.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">minTotalDistance</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">minDistance</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">row</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">col</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">search</span><span class="o">(</span><span class="n">grid</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">);</span>\n            <span class="n">minDistance</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="n">minDistance</span><span class="o">);</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">minDistance</span><span class="o">;</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="kt">int</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>\n    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>\n    <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>\n    <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>\n    <span class="kt">int</span> <span class="n">totalDistance</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>\n        <span class="n">Point</span> <span class="n">point</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>\n        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="na">row</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="na">col</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="na">distance</span><span class="o">;</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">||</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">visited</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">])</span> <span class="o">{</span>\n            <span class="k">continue</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">totalDistance</span> <span class="o">+=</span> <span class="n">d</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="n">visited</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>\n        <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>\n        <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>\n        <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>\n        <span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">c</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="o">));</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">totalDistance</span><span class="o">;</span>\n<span class="o">}</span>\n\n<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">row</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">col</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">distance</span><span class="o">;</span>\n    <span class="kd">public</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">,</span> <span class="kt">int</span> <span class="n">distance</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">this</span><span class="o">.</span><span class="na">row</span> <span class="o">=</span> <span class="n">row</span><span class="o">;</span>\n        <span class="k">this</span><span class="o">.</span><span class="na">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">;</span>\n        <span class="k">this</span><span class="o">.</span><span class="na">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m^2n^2)</script>.\nFor each point in the <script type="math/tex; mode=display">m \\times n</script> size grid, the breadth-first search takes at most <script type="math/tex; mode=display">m \\times n</script> steps to reach all points. Therefore the time complexity is <script type="math/tex; mode=display">O(m^2n^2)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>.\nThe <code>visited</code> table consists of <script type="math/tex; mode=display">m \\times n</script> elements map to each point in the grid. We insert at most <script type="math/tex; mode=display">m \\times n</script> points into the queue.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-manhattan-distance-formula-time-limit-exceeded">Approach #2 (Manhattan Distance Formula) [Time Limit Exceeded]</h4>\n<p>You may notice that breadth-first search is unnecessary. You can just calculate the Manhattan distance using the formula:</p>\n<p>\n<script type="math/tex; mode=display">\ndistance(p1, p2) = \\left | p2.x - p1.x \\right | + \\left | p2.y - p1.y \\right |\n</script>\n</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">minTotalDistance</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">List</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">points</span> <span class="o">=</span> <span class="n">getAllPoints</span><span class="o">(</span><span class="n">grid</span><span class="o">);</span>\n    <span class="kt">int</span> <span class="n">minDistance</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">row</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">col</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">calculateDistance</span><span class="o">(</span><span class="n">points</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">);</span>\n            <span class="n">minDistance</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="n">minDistance</span><span class="o">);</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">minDistance</span><span class="o">;</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="kt">int</span> <span class="nf">calculateDistance</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">points</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="n">Point</span> <span class="n">point</span> <span class="o">:</span> <span class="n">points</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">distance</span> <span class="o">+=</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">point</span><span class="o">.</span><span class="na">row</span> <span class="o">-</span> <span class="n">row</span><span class="o">)</span> <span class="o">+</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">point</span><span class="o">.</span><span class="na">col</span> <span class="o">-</span> <span class="n">col</span><span class="o">);</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">distance</span><span class="o">;</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="nf">getAllPoints</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">List</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">points</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">row</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">col</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>\n                <span class="n">points</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">));</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">points</span><span class="o">;</span>\n<span class="o">}</span>\n\n<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">row</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">col</span><span class="o">;</span>\n    <span class="kd">public</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">this</span><span class="o">.</span><span class="na">row</span> <span class="o">=</span> <span class="n">row</span><span class="o">;</span>\n        <span class="k">this</span><span class="o">.</span><span class="na">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m^2n^2)</script>.\nAssume that <script type="math/tex; mode=display">k</script> is the total number of houses. For each point in the <script type="math/tex; mode=display">m \\times n</script> size grid, we calculate the manhattan distance in <script type="math/tex; mode=display">O(k)</script>. Therefore the time complexity is <script type="math/tex; mode=display">O(mnk)</script>. But do note that there could be up to <script type="math/tex; mode=display">m \\times n</script> houses, making the worst case time complexity to be <script type="math/tex; mode=display">O(m^2n^2)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-sorting-accepted">Approach #3 (Sorting) [Accepted]</h4>\n<p>Finding the best meeting point in a 2D grid seems difficult. Let us take a step back and solve the 1D case which is much simpler. Notice that the Manhattan distance is the sum of two independent variables. Therefore, once we solve the 1D case, we can solve the 2D case as two independent 1D problems.</p>\n<p>Let us look at some 1D examples below:</p>\n<div class="codehilite"><pre><span></span>Case #1: 1-0-0-0-1\n\nCase #2: 0-1-0-1-0\n</pre></div>\n<p>We know the best meeting point must locate somewhere between the left-most and right-most point. For the above two cases, we would select the center point at <script type="math/tex; mode=display">x = 2</script> as the best meeting point. How about choosing the mean of all points as the meeting point?</p>\n<p>Consider this case:</p>\n<div class="codehilite"><pre><span></span>Case #3: 1-0-0-0-0-0-0-1-1\n</pre></div>\n<p>Using the mean gives us <script type="math/tex; mode=display">\\bar{x} = \\frac{0 + 7 + 8}{3} = 5</script> as the meeting point. The total distance is <script type="math/tex; mode=display">10</script>.</p>\n<p>But the best meeting point should be at <script type="math/tex; mode=display">x = 7</script> and the total distance is <script type="math/tex; mode=display">8</script>.</p>\n<p>You may argue that the mean is <em>close</em> to the optimal point. But imagine a larger case with many 1\'s congregating on the right side and just a single 1 on the left-most side. Using the mean as the meeting point would be far from optimal.</p>\n<p>Besides mean, what is a better way to represent the distribution of points? Would median be a better representation? Indeed. In fact, the median <em>must</em> be the optimal meeting point.</p>\n<div class="codehilite"><pre><span></span>Case #4: 1-1-0-0-1\n</pre></div>\n<p>To see why this is so, let us look at case #4 above and choose the median <script type="math/tex; mode=display">x = 1</script> as our initial meeting point. Assume that the total distance traveled is <em>d</em>. Note that we have equal number of points distributed to its left and to its right. Now let us move one step to its right where <script type="math/tex; mode=display">x = 2</script> and notice how the distance changes accordingly.</p>\n<p>Since there are two points to the left of <script type="math/tex; mode=display">x = 2</script>, we add <script type="math/tex; mode=display">2 * (+1)</script> to <em>d</em>. And <em>d</em> is offset by –1 since there is one point to the right. This means the distance had overall increased by 1.</p>\n<p>Therefore, it is clear that:</p>\n<blockquote>\n<p>As long as there is equal number of points to the left and right of the meeting point, the total distance is minimized.</p>\n</blockquote>\n<div class="codehilite"><pre><span></span>Case #5: 1-1-0-0-1-1\n</pre></div>\n<p>One may think that the optimal meeting point must fall on one of the 1\'s. This is true for cases with odd number of 1\'s, but not necessarily true when there are even number of 1\'s, just like case #5 does. You can choose any of the <script type="math/tex; mode=display">x = 1</script> to <script type="math/tex; mode=display">x = 4</script> points and the total distance is minimized. Why?</p>\n<p>The implementation is direct. First we collect both the row and column coordinates, sort them and select their middle elements. Then we calculate the total distance as the sum of two independent 1D problems.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">minTotalDistance</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">rows</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>\n    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cols</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">row</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">col</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>\n                <span class="n">rows</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">row</span><span class="o">);</span>\n                <span class="n">cols</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">col</span><span class="o">);</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">rows</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">rows</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">/</span> <span class="mi">2</span><span class="o">);</span>\n    <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">cols</span><span class="o">);</span>\n    <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">cols</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">/</span> <span class="mi">2</span><span class="o">);</span>\n    <span class="k">return</span> <span class="n">minDistance1D</span><span class="o">(</span><span class="n">rows</span><span class="o">,</span> <span class="n">row</span><span class="o">)</span> <span class="o">+</span> <span class="n">minDistance1D</span><span class="o">(</span><span class="n">cols</span><span class="o">,</span> <span class="n">col</span><span class="o">);</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="kt">int</span> <span class="nf">minDistance1D</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">points</span><span class="o">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">point</span> <span class="o">:</span> <span class="n">points</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">distance</span> <span class="o">+=</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">point</span> <span class="o">-</span> <span class="n">origin</span><span class="o">);</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">distance</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p>Note that in the code above we do not need to sort <em>rows</em>, why?</p>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(mn \\log mn)</script>.\nSince there could be at most <script type="math/tex; mode=display">m \\times n</script> points, therefore the time complexity is <script type="math/tex; mode=display">O(mn \\log mn)</script> due to sorting.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-collect-coordinates-in-sorted-order-accepted">Approach #4 (Collect Coordinates in Sorted Order) [Accepted]</h4>\n<p>We could use the <a href="https://en.wikipedia.org/wiki/Selection_algorithm">Selection algorithm</a> to select the median in <script type="math/tex; mode=display">O(mn)</script> time, but there is an easier way. Notice that we can collect both the row and column coordinates in sorted order.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">minTotalDistance</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">collectRows</span><span class="o">(</span><span class="n">grid</span><span class="o">);</span>\n    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">collectCols</span><span class="o">(</span><span class="n">grid</span><span class="o">);</span>\n    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">rows</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">rows</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">/</span> <span class="mi">2</span><span class="o">);</span>\n    <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">cols</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">/</span> <span class="mi">2</span><span class="o">);</span>\n    <span class="k">return</span> <span class="n">minDistance1D</span><span class="o">(</span><span class="n">rows</span><span class="o">,</span> <span class="n">row</span><span class="o">)</span> <span class="o">+</span> <span class="n">minDistance1D</span><span class="o">(</span><span class="n">cols</span><span class="o">,</span> <span class="n">col</span><span class="o">);</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="kt">int</span> <span class="nf">minDistance1D</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">points</span><span class="o">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">point</span> <span class="o">:</span> <span class="n">points</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">distance</span> <span class="o">+=</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">point</span> <span class="o">-</span> <span class="n">origin</span><span class="o">);</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">distance</span><span class="o">;</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">collectRows</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">rows</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">row</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">col</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>\n                <span class="n">rows</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">row</span><span class="o">);</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">rows</span><span class="o">;</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">collectCols</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cols</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">col</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">row</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">grid</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>\n                <span class="n">cols</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">col</span><span class="o">);</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">cols</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><br>\nYou can calculate the distance without knowing the median using a two pointer approach. This neat approach is inspired by <a href="https://leetcode.com/discuss/65336/14ms-java-solution">@larrywang2014\'s solution</a>.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">minTotalDistance</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">collectRows</span><span class="o">(</span><span class="n">grid</span><span class="o">);</span>\n    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">collectCols</span><span class="o">(</span><span class="n">grid</span><span class="o">);</span>\n    <span class="k">return</span> <span class="n">minDistance1D</span><span class="o">(</span><span class="n">rows</span><span class="o">)</span> <span class="o">+</span> <span class="n">minDistance1D</span><span class="o">(</span><span class="n">cols</span><span class="o">);</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="kt">int</span> <span class="nf">minDistance1D</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">points</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">distance</span> <span class="o">+=</span> <span class="n">points</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">-</span> <span class="n">points</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>\n        <span class="n">i</span><span class="o">++;</span>\n        <span class="n">j</span><span class="o">--;</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">distance</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(mn)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: ['Twitter'],
  },
  {
    id: '297',
    name: 'Serialize and Deserialize Binary Tree',
    acceptance: '34.1%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. </p>\n\n<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>\n\n<p>\nFor example, you may serialize the following tree\n</p><pre>    1\n   / \\\n  2   3\n     / \\\n    4   5\n</pre>\nas <code>"[1,2,3,null,null,4,5]"</code>, just the same as <a href="https://leetcode.com/faq/#binary-tree">how LeetCode OJ serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\n<p></p>\n\n<p>\n<b>Note:</b> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/Louis1992">@Louis1992</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Microsoft', 'Amazon', 'Bloomberg', 'Uber', 'LinkedIn', 'Yahoo'],
  },
  {
    id: '298',
    name: 'Binary Tree Longest Consecutive Sequence ',
    acceptance: '41.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a binary tree, find the length of the longest consecutive sequence path.\n</p><p>\n</p><p>\nThe path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path need to be from parent to child (cannot be the reverse).\n</p>\n\n<p>\nFor example,<br>\n</p><pre>   1\n    \\\n     3\n    / \\\n   2   4\n        \\\n         5\n</pre>\nLongest consecutive sequence path is <code>3-4-5</code>, so return <code>3</code>. \n<pre>   2\n    \\\n     3\n    / \n   2    \n  / \n 1\n</pre>\nLongest consecutive sequence path is <code>2-3</code>,not<code>3-2-1</code>, so return <code>2</code>.\n\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-top-down-depth-first-search-accepted">Approach #1 (Top Down Depth-first Search) [Accepted]</a></li>\n<li><a href="#approach-2-bottom-up-depth-first-search-accepted">Approach #2 (Bottom Up Depth-first Search) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-top-down-depth-first-search-accepted">Approach #1 (Top Down Depth-first Search) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>A top down approach is similar to an in-order traversal. We use a variable <code>length</code> to store the current consecutive path length and pass it down the tree. As we traverse, we compare the current node with its parent node to determine if it is consecutive. If not, we reset the length.</p>\n<div class="codehilite"><pre><span></span><span class="kd">private</span> <span class="kt">int</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n<span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestConsecutive</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>\n    <span class="k">return</span> <span class="n">maxLength</span><span class="o">;</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">p</span><span class="o">,</span> <span class="n">TreeNode</span> <span class="n">parent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>\n    <span class="n">length</span> <span class="o">=</span> <span class="o">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">parent</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">?</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="o">;</span>\n    <span class="n">maxLength</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLength</span><span class="o">,</span> <span class="n">length</span><span class="o">);</span>\n    <span class="n">dfs</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">length</span><span class="o">);</span>\n    <span class="n">dfs</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">length</span><span class="o">);</span>\n<span class="o">}</span>\n</pre></div>\n<p>@lightmark presents <a href="https://leetcode.com/discuss/66486/short-and-simple-c-solution">a neat approach</a> without storing the maxLength as a global variable.</p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestConsecutive</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">return</span> <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">p</span><span class="o">,</span> <span class="n">TreeNode</span> <span class="n">parent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">length</span><span class="o">;</span>\n    <span class="n">length</span> <span class="o">=</span> <span class="o">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">parent</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">?</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="o">;</span>\n    <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">length</span><span class="o">,</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dfs</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">length</span><span class="o">),</span>\n                                     <span class="n">dfs</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">length</span><span class="o">)));</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nThe time complexity is the same as an in-order traversal of a binary tree with <script type="math/tex; mode=display">n</script> nodes.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>.\nThe extra space comes from implicit stack space due to recursion. For a skewed binary tree, the recursion could go up to <script type="math/tex; mode=display">n</script> levels deep.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-bottom-up-depth-first-search-accepted">Approach #2 (Bottom Up Depth-first Search) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The bottom-up approach is similar to a post-order traversal. We return the consecutive path length starting at current node to its parent. Then its parent can examine if its node value can be included in this consecutive path.</p>\n<div class="codehilite"><pre><span></span><span class="kd">private</span> <span class="kt">int</span> <span class="n">maxLength</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n<span class="kd">public</span> <span class="kt">int</span> <span class="nf">longestConsecutive</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">dfs</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>\n    <span class="k">return</span> <span class="n">maxLength</span><span class="o">;</span>\n<span class="o">}</span>\n\n<span class="kd">private</span> <span class="kt">int</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">L</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">L</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">R</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">L</span><span class="o">,</span> <span class="n">R</span><span class="o">);</span>\n    <span class="n">maxLength</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxLength</span><span class="o">,</span> <span class="n">length</span><span class="o">);</span>\n    <span class="k">return</span> <span class="n">length</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>.\nThe time complexity is the same as a post-order traversal in a binary tree, which is <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>.\nThe extra space comes from implicit stack space due to recursion. For a skewed binary tree, the recursion could go up to <script type="math/tex; mode=display">n</script> levels deep.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '299',
    name: 'Bulls and Cows',
    acceptance: '35.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>You are playing the following <a href="https://en.wikipedia.org/wiki/Bulls_and_Cows" target="_blank">Bulls and Cows</a> game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows"). Your friend will use successive guesses and hints to eventually derive the secret number.</p>\n\n<p>\nFor example:\n</p><pre>Secret number:  "1807"\nFriend\'s guess: "7810"\n</pre>\nHint: <code>1</code> bull and <code>3</code> cows. (The bull is <code>8</code>, the cows are <code>0</code>, <code>1</code> and <code>7</code>.)\n<p></p>\n\n<p>Write a function to return a hint according to the secret number and friend\'s guess, use <code>A</code> to indicate the bulls and <code>B</code> to indicate the cows. In the above example, your function should return <code>"1A3B"</code>. </p>\n\n<p>Please note that both secret number and friend\'s guess may contain duplicate digits, for example:\n</p><pre>Secret number:  "1123"\nFriend\'s guess: "0111"\n</pre>\nIn this case, the 1st <code>1</code> in friend\'s guess is a bull, the 2nd or 3rd <code>1</code> is a cow, and your function should return <code>"1A1B"</code>.\n<p></p>\n\n<p>You may assume that the secret number and your friend\'s guess only contain digits, and their lengths are always equal.</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jeantimex">@jeantimex</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '300',
    name: 'Longest Increasing Subsequence',
    acceptance: '38.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an unsorted array of integers, find the length of longest increasing subsequence.\n</p>\n<p>\nFor example,<br>\nGiven <code>[10, 9, 2, 5, 3, 7, 101, 18]</code>,<br>\nThe longest increasing subsequence is <code>[2, 3, 7, 101]</code>, therefore the length is <code>4</code>. Note that there may be more than one LIS combination, it is only necessary for you to return the length.\n</p>\n<p>\nYour algorithm should run in O(<i>n<sup>2</sup></i>) complexity.\n</p>\n\n<p><b>Follow up:</b> Could you improve it to O(<i>n</i> log <i>n</i>) time complexity? </p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/pbrother">@pbrother</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-recursion-with-memorization-memory-limit-exceeded">Approach #2 Recursion with memorization [Memory Limit Exceeded]</a></li>\n<li><a href="#approach-3-dynamic-programming-accepted">Approach #3 Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-4-dynamic-programming-with-binary-searchaccepted">Approach #4 Dynamic Programming with Binary Search[Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The simplest approach is to try to find all increasing subsequences and then returning the maximum length of longest increasing subsequence. In order to\ndo this, we make use of a recursive function <script type="math/tex; mode=display">lengthofLIS</script> which returns the length of the LIS possible from the current element(corresponding to <script type="math/tex; mode=display">curpos</script>)\n onwards(including the current element). Inside each function call, we consider two cases:</p>\n<ol>\n<li>\n<p>The current element is larger than the previous element included in the LIS. In this case, we can include the current element in the LIS. Thus, we find out the\nlength of the LIS obtained by including it. Further, we also find out the length of LIS possible by not including the current element in the LIS. The value returned\nby the current function call is, thus, the maximum out of the two lengths.</p>\n</li>\n<li>\n<p>The current element is smaller than the previous element included in the LIS. In this case, we can\'t include the current element in the LIS. Thus, we find out only\nthe length of the LIS possible by not including the current element in the LIS, which is returned by the current function call.</p>\n</li>\n</ol>\n<iframe frameborder="0" height="394" name="JJmfKUWT" src="https://leetcode.com/playground/JJmfKUWT/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(2^n)</script>. Size of recursion tree will be <script type="math/tex; mode=display">2^n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^2)</script>. <script type="math/tex; mode=display">memo</script> array of size <script type="math/tex; mode=display">n * n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-recursion-with-memorization-memory-limit-exceeded">Approach #2 Recursion with memorization [Memory Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the previous approach, many recursive calls had to made again and again with the same parameters. This redundancy can be eliminated by storing the results obtained for\na particular call in a 2-d memorization array <script type="math/tex; mode=display">memo</script>. <script type="math/tex; mode=display">memo[i][j]</script> represents the length of the LIS possible using <script type="math/tex; mode=display">nums[i]</script> as the previous element considered to\nbe included/not included in the LIS, with <script type="math/tex; mode=display">nums[j]</script> as the current element considered to be included/not included in the LIS. Here, <script type="math/tex; mode=display">nums</script> represents the given array.</p>\n<iframe frameborder="0" height="479" name="3KbbB2JZ" src="https://leetcode.com/playground/3KbbB2JZ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Size of recursion tree can go upto <script type="math/tex; mode=display">n^2</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^2)</script>. <script type="math/tex; mode=display">memo</script> array of <script type="math/tex; mode=display">n*n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-dynamic-programming-accepted">Approach #3 Dynamic Programming [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This method relies on the fact that the longest increasing subsequence possible upto the <script type="math/tex; mode=display">i^{th}</script>  index in a given array is independent of the elements coming\nlater on in the array. Thus, if we know the length of the LIS upto <script type="math/tex; mode=display">i^{th}</script> index, we can figure out the length of the LIS possible by including the <script type="math/tex; mode=display">(i+1)^{th}</script> element\nbased on the elements with indices <script type="math/tex; mode=display">j</script> such that <script type="math/tex; mode=display">0 \\leq j \\leq (i + 1)</script>.</p>\n<p>We make use of a <script type="math/tex; mode=display">dp</script> array to store the required data. <script type="math/tex; mode=display">dp[i]</script> represents the length of the longest increasing subsequence possible considering the array elements upto the <script type="math/tex; mode=display">i^{th}</script>\nindex only ,by necessarily including the <script type="math/tex; mode=display">i^{th}</script> element. In order to find out <script type="math/tex; mode=display">dp[i]</script>, we need to try to append the current element(<script type="math/tex; mode=display">nums[i]</script>) in every possible increasing subsequences upto the <script type="math/tex; mode=display">(i-1)^{th}</script>\nindex(including the <script type="math/tex; mode=display">(i-1)^{th}</script> index), such that the new sequence formed by adding the current element is also an increasing subsequence. Thus, we can easily determine\n<script type="math/tex; mode=display">dp[i]</script> using:  </p>\n<p>\n<script type="math/tex; mode=display">dp[i] = \\text{max}(dp[j]) + 1, \\forall 0\\leq j < i</script>\n</p>\n<p>At the end, the maximum out of all the <script type="math/tex; mode=display">dp[i]</script>\'s to determine the final result.</p>\n<p>\n<script type="math/tex; mode=display">LIS_{length}= \\text{max}(dp[i]), \\forall 0\\leq i < n</script>\n</p>\n<p>The following animation illustrates the method:</p>\n<!--![LIS](https://leetcode.com/articles/Figures/300_LIS1.gif)-->\n<p>!?!../Documents/300_LIS.json:1000,563!?!</p>\n<iframe frameborder="0" height="411" name="LwPDtrvk" src="https://leetcode.com/playground/LwPDtrvk/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Two loops of <script type="math/tex; mode=display">n</script> are there.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-dynamic-programming-with-binary-searchaccepted">Approach #4 Dynamic Programming with Binary Search[Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, we scan the array from left to right. We also make use of a <script type="math/tex; mode=display">dp</script> array initialized with all 0\'s. This <script type="math/tex; mode=display">dp</script> array is meant to store the\nincreasing subsequence formed by including the currently encountered element.\n While traversing the <script type="math/tex; mode=display">nums</script> array, we keep on filling the <script type="math/tex; mode=display">dp</script> array with\nthe elements encountered so far. For the element corresponding to the <script type="math/tex; mode=display">j^{th}</script> index (<script type="math/tex; mode=display">nums[j]</script>),\n we determine its correct position in the <script type="math/tex; mode=display">dp</script> array(say <script type="math/tex; mode=display">i^{th}</script> index) by making use of Binary Search(which can be used since the\n  <script type="math/tex; mode=display">dp</script> array is storing increasing subsequence) and also insert it at the correct position. An important point to be noted is that for Binary Search, we consider\n  only that portion of the <script type="math/tex; mode=display">dp</script> array in which we have made the updations by inserting some elements at their correct positions(which remains always sorted).\n  Thus, only the elements upto the <script type="math/tex; mode=display">i^{th}</script> index\n  in the <script type="math/tex; mode=display">dp</script> array can determine the position of the current element in it.\n  Since, the element enters its correct position(<script type="math/tex; mode=display">i</script>) in an ascending order in the <script type="math/tex; mode=display">dp</script> array, the\n  subsequence formed so far in it is surely an increasing subsequence. Whenever this position index <script type="math/tex; mode=display">i</script> becomes equal to the length of the LIS formed so far(<script type="math/tex; mode=display">len</script>),\n  it means, we need to update the <script type="math/tex; mode=display">len</script> as <script type="math/tex; mode=display">len = len + 1</script>.</p>\n<p>Note: <script type="math/tex; mode=display">dp</script> array does not result in longest increasing subsequence, but length of <script type="math/tex; mode=display">dp</script> array will give you length of LIS.</p>\n<p>Consider the example:</p>\n<p>input: [0, 8, 4, 12, 2]</p>\n<p>dp: [0]</p>\n<p>dp: [0, 8]</p>\n<p>dp: [0, 4]</p>\n<p>dp: [0, 4, 12]</p>\n<p>dp: [0 , 2, 12] which is not the longest increasing subsequence, but length of <script type="math/tex; mode=display">dp</script> array results in length of Longest Increasing Subsequence.</p>\n<iframe frameborder="0" height="343" name="aHs6zyFb" src="https://leetcode.com/playground/aHs6zyFb/shared" width="100%"></iframe>\n<p>Note: Arrays.binarySearch() method returns index of the search key, if it is contained in the array, else it returns (-(insertion point) - 1). The insertion point is the point at which the key would be inserted into the array: the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nlog(n))</script>. Binary search takes <script type="math/tex; mode=display">log(n)</script> time and it is called <script type="math/tex; mode=display">n</script> times.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Microsoft'],
  },
  {
    id: '301',
    name: 'Remove Invalid Parentheses',
    acceptance: '35.6%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.</p>\n\n<p>Note: The input string may contain letters other than the parentheses <code>(</code> and <code>)</code>. \n</p>\n\n<p>\n<b>Examples:</b><br>\n</p><pre>"()())()" -&gt; ["()()()", "(())()"]\n"(a)())()" -&gt; ["(a)()()", "(a())()"]\n")(" -&gt; [""]\n</pre>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/hpplayer">@hpplayer</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook'],
  },
  {
    id: '302',
    name: 'Smallest Rectangle Enclosing Black Pixels ',
    acceptance: '46.2%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>An image is represented by a binary matrix with <code>0</code> as a white pixel and <code>1</code> as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location <code>(x, y)</code> of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.</p>\n\n<p>\nFor example, given the following image:\n</p><pre>[\n  "0010",\n  "0110",\n  "0100"\n]\n</pre>\nand <code>x = 0</code>, <code>y = 2</code>,\n<p></p>\n\n<p>\nReturn <code>6</code>.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-naive-linear-search-accepted">Approach #1 (Naive Linear Search) [Accepted]</a></li>\n<li><a href="#approach-2-dfs-or-bfs-accepted">Approach #2 (DFS or BFS) [Accepted]</a></li>\n<li><a href="#approach-3-binary-search-accepted">Approach #3 (Binary Search) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This article is for intermediate readers. It introduces the following ideas:\nDepth First Search (DFS), Breadth First Search (BFS) and Binary Search</p>\n<h2 id="solution">Solution</h2>\n<h4 id="approach-1-naive-linear-search-accepted">Approach #1 (Naive Linear Search) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Traversal all the pixels. Keep the maximum and minimum values of black pixels coordinates.</p>\n<p><strong>Algorithm</strong></p>\n<p>We keep four boundaries, <code>left</code>, <code>right</code>, <code>top</code> and <code>bottom</code> of the rectangle.\nNote that <code>left</code> and <code>top</code> are inclusive while <code>right</code> and <code>bottom</code> are exclusive.\nWe then traversal all the pixels and update the four boundaries accordingly.</p>\n<p>The recipe is following:</p>\n<ul>\n<li>Initialize left, right, top and bottom</li>\n<li>Loop through all <code>(x, y)</code> coordinates</li>\n<li>if <code>image[x][y]</code> is black<ul>\n<li><code>left = min(left, x)</code></li>\n<li><code>right = max(right, x + 1)</code></li>\n<li><code>top = min(top, y)</code></li>\n<li><code>bottom = max(bottom, y + 1)</code></li>\n</ul>\n</li>\n<li>Return <code>(right - left) * (bottom - top)</code></li>\n</ul>\n<iframe frameborder="0" height="343" name="fn66ntdb" src="https://leetcode.com/playground/fn66ntdb/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(mn)</script>. <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> are the height and width of the image.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. All we need to store are the four boundaries.</p>\n</li>\n</ul>\n<p><strong>Comment</strong>\n<em> One may optimize this algorithm to stop early. But it doesn\'t change the asymptotic performance.\n</em> This naive approach is certainly not the best answer to this problem. However, it gives you a good entry point to tackle the problem. Most of the time the good algorithms come from identifying the repeat calculation a naive approach. And it also sets up a baseline of the time and space complexity, so that one can see whether or not other approaches are better than it.</p>\n<hr>\n<h4 id="approach-2-dfs-or-bfs-accepted">Approach #2 (DFS or BFS) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Explore all the connected black pixel from the given pixel and update the boundaries.</p>\n<p><strong>Algorithm</strong></p>\n<p>The naive approach did not use the condition that all the black pixels are connected and that one of the black pixels is given.</p>\n<p>A simple way to use these facts is to do an exhaustive search starting from the given pixel. Since all the black pixels are connected, DFS or BFS will visit all of them starting from the given black pixel. The idea is similar to what we did for <a href="https://leetcode.com/problems/number-of-islands/">200. Number of Island</a>. Instead of many islands, we have only one island here, and we know one pixel of it.</p>\n<iframe frameborder="0" height="462" name="2Teg4TBb" src="https://leetcode.com/playground/2Teg4TBb/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(E) = O(B) = O(mn)</script>.</li>\n</ul>\n<p>Here <script type="math/tex; mode=display">E</script> is the number of edges in the traversed graph. <script type="math/tex; mode=display">B</script> is the total number of black pixels. Since each pixel have four edges at most, <script type="math/tex; mode=display">O(E) = O(B)</script>. In the worst case, <script type="math/tex; mode=display">O(B) = O(mn)</script>.</p>\n<ul>\n<li>Space complexity : <script type="math/tex; mode=display">O(V) = O(B) = O(mn)</script>.</li>\n</ul>\n<p>The space complexity is <script type="math/tex; mode=display">O(V)</script> where <script type="math/tex; mode=display">V</script> is the number of vertices in the traversed graph. In this problem <script type="math/tex; mode=display">O(V) = O(B)</script>. Again, in the worst case, <script type="math/tex; mode=display">O(B) = O(mn)</script>.</p>\n<p><strong>Comment</strong></p>\n<p>Although this approach is better than naive approach when <script type="math/tex; mode=display">B</script> is much smaller than <script type="math/tex; mode=display">mn</script>, it is asymptotically the same as approach #1 when <script type="math/tex; mode=display">B</script> is comparable to <script type="math/tex; mode=display">mn</script>. And it costs a lot more auxiliary space.</p>\n<hr>\n<h4 id="approach-3-binary-search-accepted">Approach #3 (Binary Search) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Project the 2D image into a 1D array and use binary search to find the boundaries.</p>\n<p><strong>Algorithm</strong></p>\n<p align="center"><img alt="matrix projection" src="https://leetcode.com/articles/Figures/302_matrix_projection.svg" width="539px"></p>\n<p align="center">*Figure 1. Illustration of image projection.</p>\n<p>Suppose we have a <script type="math/tex; mode=display">10 \\times 11</script> image as shown in figure 1, if we project each column of the image into an entry of row vector <code>v</code> with the following rule:</p>\n<ul>\n<li><code>v[i] = 1</code>   if exists <code>x</code> such that <code>image[x][i] = 1</code></li>\n<li><code>v[i] = 0</code>   otherwise</li>\n</ul>\n<p>That is</p>\n<blockquote>\n<p>If a column has any black pixel it\'s projection is black otherwise white.</p>\n</blockquote>\n<p>Similarly, we can do the same for the rows, and project the image into a 1D column vector. The two projected vectors are shown in figure 1.</p>\n<p>Now, we claim the following lemma:</p>\n<p><em>Lemma</em></p>\n<blockquote>\n<p>If there are only one black pixel region, then in a projected 1D array all the black pixels are connected.</p>\n</blockquote>\n<p><em>Proof by contradiction</em></p>\n<blockquote>\n<p>Assume to the contrary that there are disconnected black pixels at <code>i</code> and <code>j</code> where <code>i &lt; j</code> in the 1D projection array. Thus, there exists one column <code>k</code>, <code>k</code> in <code>(i, j)</code> and the column <code>k</code> in the 2D array has no black pixel. Therefore, in the 2D array there exist at least two black pixel regions separated by column <code>k</code> which contradicting the condition of "only one black pixel region".\nTherefore, we conclude that all the black pixels in the 1D projection array are connected.</p>\n</blockquote>\n<p>With this lemma, we have the following algorithm:</p>\n<ul>\n<li>Project the 2D array into a column array and a row array</li>\n<li>Binary search to find <code>left</code> in the row array within <code>[0, y)</code></li>\n<li>Binary search to find <code>right</code> in the row array within <code>[y + 1, n)</code></li>\n<li>Binary search to find <code>top</code> in the column array within <code>[0, x)</code></li>\n<li>Binary search to find <code>bottom</code> in the column array within <code>[x + 1, m)</code></li>\n<li>Return <code>(right - left) * (bottom - top)</code></li>\n</ul>\n<p>However, the projection step cost <script type="math/tex; mode=display">O(mn)</script> time which dominates the entire algorithm.If so, we gain nothing comparing with previous approaches.</p>\n<p>The trick is that we do not need to do the projection step as a preprocess. We can do it on the fly, i.e. "don\'t project the column/row unless needed".</p>\n<p>Recall the binary search algorithm in a 1D array, each time we only check one element, the pivot, to decide which half we go next.</p>\n<p>In a 2D array, we can do something similar. The only difference here is that the element is not a number but a vector. For example, a <code>m</code> by <code>n</code> matrix can be seen as <code>n</code> column vectors.</p>\n<p>In these <code>n</code> elements/vectors, we do a binary search to find <code>left</code> or <code>right</code>. Each time we only check one element/vector, the pivot, to decide which half we go next.\nIn total it checks <script type="math/tex; mode=display">O(\\log n)</script> vectors, and each check is <script type="math/tex; mode=display">O(m)</script> (we simply traverse all the <code>m</code> entries of the pivot vector).</p>\n<p>So it costs <script type="math/tex; mode=display">O(m \\log n)</script> to find <code>left</code> and <code>right</code>.\nSimilarly it costs <script type="math/tex; mode=display">O(n \\log m)</script> to find <code>top</code> and <code>bottom</code>. The entire algorithm has a time complexity of <script type="math/tex; mode=display">O(m \\log n + n \\log m)</script>\n</p>\n<iframe frameborder="0" height="515" name="LqsadPsh" src="https://leetcode.com/playground/LqsadPsh/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(m \\log n + n \\log m)</script>.</li>\n</ul>\n<p>Here, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> are the height and width of the image. We embedded a linear search for every iteration of binary search. See previous sections for details.</p>\n<ul>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</li>\n</ul>\n<p>Both binary search and linear search used only constant extra space.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '303',
    name: 'Range Sum Query - Immutable',
    acceptance: '31.1%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given an integer array <i>nums</i>, find the sum of the elements between indices <i>i</i> and <i>j</i> (<i>i</i> ≤ <i>j</i>), inclusive.</p>\n\n<p><b>Example:</b><br>\n</p><pre>Given nums = [-2, 0, 3, -5, 2, -1]\n\nsumRange(0, 2) -&gt; 1\nsumRange(2, 5) -&gt; -1\nsumRange(0, 5) -&gt; -3\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>You may assume that the array does not change.</li>\n<li>There are many calls to <i>sumRange</i> function.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute Force) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-caching-accepted">Approach #2 (Caching) [Accepted]</a></li>\n<li><a href="#approach-3-caching-accepted">Approach #3 (Caching) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute Force) [Time Limit Exceeded]</h4>\n<p>Each time <em>sumRange</em> is called, we use a for loop to sum each individual element from index <script type="math/tex; mode=display">i</script> to <script type="math/tex; mode=display">j</script>.</p>\n<div class="codehilite"><pre><span></span><span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">data</span><span class="o">;</span>\n\n<span class="kd">public</span> <span class="nf">NumArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">data</span> <span class="o">=</span> <span class="n">nums</span><span class="o">;</span>\n<span class="o">}</span>\n\n<span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="n">sum</span> <span class="o">+=</span> <span class="n">data</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis:</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script> time per query.\nEach <em>sumRange</em> query takes <script type="math/tex; mode=display">O(n)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Note that <code>data</code> is a <em>reference</em> to <code>nums</code> and is not a copy of it.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-caching-accepted">Approach #2 (Caching) [Accepted]</h4>\n<p>Imagine that <em>sumRange</em> is called one thousand times with the exact same arguments. How could we speed that up?</p>\n<p>We could trade in extra space for speed. By pre-computing all range sum possibilities and store its results in a hash table, we can speed up the query to constant time.</p>\n<div class="codehilite"><pre><span></span><span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Pair</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>\n\n<span class="kd">public</span> <span class="nf">NumArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>\n            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">Pair</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">),</span> <span class="n">sum</span><span class="o">);</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n\n<span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Pair</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">));</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script> time per query, <script type="math/tex; mode=display">O(n^2)</script> time pre-computation.\nThe pre-computation done in the constructor takes <script type="math/tex; mode=display">O(n^2)</script> time. Each <em>sumRange</em> query\'s time complexity is <script type="math/tex; mode=display">O(1)</script> as the hash table\'s look up operation is constant time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^2)</script>.\nThe extra space required is <script type="math/tex; mode=display">O(n^2)</script> as there are <script type="math/tex; mode=display">n</script> candidates for both <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-caching-accepted">Approach #3 (Caching) [Accepted]</h4>\n<p>The above approach takes a lot of space, could we optimize it?</p>\n<p>Imagine that we pre-compute the cummulative sum from index <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">k</script>. Could we use this information to derive <script type="math/tex; mode=display">Sum(i, j)</script>?</p>\n<p>Let us define <script type="math/tex; mode=display">sum[k]</script> as the cumulative sum for <script type="math/tex; mode=display">nums[0 \\cdots k-1]</script> (inclusive):</p>\n<p>\n<script type="math/tex; mode=display">\nsum[k] = \\left\\{ \\begin{array}{rl} \\sum_{i=0}^{k-1}nums[i] & , k > 0 \\\\ 0 &, k = 0 \\end{array} \\right.\n</script>\n</p>\n<p>Now, we can calculate <em>sumRange</em> as following:</p>\n<p>\n<script type="math/tex; mode=display">\nsumRange(i, j) = sum[j + 1] - sum[i]\n</script>\n</p>\n<div class="codehilite"><pre><span></span><span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">sum</span><span class="o">;</span>\n\n<span class="kd">public</span> <span class="nf">NumArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">sum</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="n">sum</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">sum</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n\n<span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">return</span> <span class="n">sum</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">sum</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n<span class="o">}</span>\n</pre></div>\n<p>Notice in the code above we inserted a dummy 0 as the first element in the <em>sum</em> array. This trick saves us from an extra conditional check in <em>sumRange</em> function.</p>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script> time per query, <script type="math/tex; mode=display">O(n)</script> time pre-computation.\nSince the cumulative sum is cached, each <em>sumRange</em> query can be calculated in <script type="math/tex; mode=display">O(1)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: ['Palantir'],
  },
  {
    id: '304',
    name: 'Range Sum Query 2D - Immutable',
    acceptance: '26.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a 2D matrix <i>matrix</i>, find the sum of the elements inside the rectangle defined by its upper left corner (<i>row</i>1, <i>col</i>1) and lower right corner (<i>row</i>2, <i>col</i>2).</p>\n\n<p>\n<img src="/static/images/courses/range_sum_query_2d.png" border="0" alt="Range Sum Query 2D"><br>\n<small>The above rectangle (with the red border) is defined by (row1, col1) = <b>(2, 1)</b> and (row2, col2) = <b>(4, 3)</b>, which contains sum = <b>8</b>.</small>\n</p>\n\n<p><b>Example:</b><br>\n</p><pre>Given matrix = [\n  [3, 0, 1, 4, 2],\n  [5, 6, 3, 2, 1],\n  [1, 2, 0, 1, 5],\n  [4, 1, 0, 1, 7],\n  [1, 0, 3, 0, 5]\n]\n\nsumRegion(2, 1, 4, 3) -&gt; 8\nsumRegion(1, 1, 2, 2) -&gt; 11\nsumRegion(1, 2, 2, 4) -&gt; 12\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>You may assume that the matrix does not change.</li>\n<li>There are many calls to <i>sumRegion</i> function.</li>\n<li>You may assume that <i>row</i>1 ≤ <i>row</i>2 and <i>col</i>1 ≤ <i>col</i>2.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute Force) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-caching-memory-limit-exceeded">Approach #2 (Caching) [Memory Limit Exceeded]</a></li>\n<li><a href="#approach-3-caching-rows-accepted">Approach #3 (Caching Rows) [Accepted]</a></li>\n<li><a href="#approach-4-caching-smarter-accepted">Approach #4 (Caching Smarter) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute Force) [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Each time <em>sumRegion</em> is called, we use a double for loop to sum all elements from <script type="math/tex; mode=display">(row1, col1) \\rightarrow (row2, col2)</script>.</p>\n<div class="codehilite"><pre><span></span><span class="kd">private</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">data</span><span class="o">;</span>\n\n<span class="kd">public</span> <span class="nf">NumMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">data</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">;</span>\n<span class="o">}</span>\n\n<span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRegion</span><span class="o">(</span><span class="kt">int</span> <span class="n">row1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col2</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">row1</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">row2</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">col1</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">col2</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="n">sum</span> <span class="o">+=</span> <span class="n">data</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">];</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(mn)</script> time per query.\nAssume that <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> represents the number of rows and columns respectively, each <em>sumRegion</em> query can go through at most <script type="math/tex; mode=display">m \\times n</script> elements.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Note that <code>data</code> is a <em>reference</em> to <code>matrix</code> and is not a copy of it.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-caching-memory-limit-exceeded">Approach #2 (Caching) [Memory Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>Since <em>sumRegion</em> could be called many times, we definitely need to do some pre-processing.</p>\n<p><strong>Algorithm</strong></p>\n<p>We could trade in extra space for speed by pre-calculating all possible rectangular region sum and store them in a hash table. Each <em>sumRegion</em> query now takes only constant time complexity.</p>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script> time per query, <script type="math/tex; mode=display">O(m^2n^2)</script> time pre-computation.\nEach <em>sumRegion</em> query takes <script type="math/tex; mode=display">O(1)</script> time as the hash table lookup\'s time complexity is constant. The pre-computation will take <script type="math/tex; mode=display">O(m^2n^2)</script> time as there are a total of <script type="math/tex; mode=display">m^2 \\times n^2</script> possibilities need to be cached.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m^2n^2)</script>.\nSince there are <script type="math/tex; mode=display">mn</script> different possibilities for both top left and bottom right points of the rectangular region, the extra space required is <script type="math/tex; mode=display">O(m^2n^2)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-caching-rows-accepted">Approach #3 (Caching Rows) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Remember from the <a href="https://leetcode.com/course/chapters/leetcode-101/range-sum-query-immutable/">1D version</a> where we used a cumulative sum array? Could we apply that directly to solve this 2D version?</p>\n<p><strong>Algorithm</strong></p>\n<p>Try to see the 2D matrix as <script type="math/tex; mode=display">m</script> rows of 1D arrays. To find the region sum, we just accumulate the sum in the region row by row.</p>\n<div class="codehilite"><pre><span></span><span class="kd">private</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span><span class="o">;</span>\n\n<span class="kd">public</span> <span class="nf">NumMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>\n    <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="n">dp</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">];</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n\n<span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRegion</span><span class="o">(</span><span class="kt">int</span> <span class="n">row1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col2</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">row1</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;=</span> <span class="n">row2</span><span class="o">;</span> <span class="n">row</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="n">sum</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">dp</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col1</span><span class="o">];</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m)</script> time per query, <script type="math/tex; mode=display">O(mn)</script> time pre-computation.\nThe pre-computation in the constructor takes <script type="math/tex; mode=display">O(mn)</script> time. The <em>sumRegion</em> query takes <script type="math/tex; mode=display">O(m)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>.\nThe algorithm uses <script type="math/tex; mode=display">O(mn)</script> space to store the cumulative sum of all rows.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-caching-smarter-accepted">Approach #4 (Caching Smarter) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We used a cumulative sum array in the <a href="https://leetcode.com/course/chapters/leetcode-101/range-sum-query-immutable/">1D version</a>. We notice that the cumulative sum is computed with respect to the origin at index 0. Extending this analogy to the 2D case, we could pre-compute a cumulative region sum with respect to the origin at <script type="math/tex; mode=display">(0, 0)</script>.</p>\n<p><img alt="Sum OD" src="https://leetcode.com/static/images/courses/sum_od.png"><br>\n<small>Sum(OD) is the cumulative region sum with respect to the origin at (0, 0).</small><br></p>\n<p>How do we derive <script type="math/tex; mode=display">Sum(ABCD)</script> using the pre-computed cumulative region sum?</p>\n<p><img alt="Sum OB" src="https://leetcode.com/static/images/courses/sum_ob.png"><br>\n<small>Sum(OB) is the cumulative region sum on top of the rectangle.</small><br></p>\n<p><img alt="Sum OC" src="https://leetcode.com/static/images/courses/sum_oc.png"><br>\n<small>Sum(OC) is the cumulative region sum to the left of the rectangle.</small></p>\n<p><img alt="Sum OA" src="https://leetcode.com/static/images/courses/sum_oa.png"><br>\n<small>Sum(OA) is the cumulative region sum to the top left corner of the rectangle.</small></p>\n<p>Note that the region <script type="math/tex; mode=display">Sum(OA)</script> is covered twice by both <script type="math/tex; mode=display">Sum(OB)</script> and <script type="math/tex; mode=display">Sum(OC)</script>. We could use the principle of inclusion-exclusion to calculate <script type="math/tex; mode=display">Sum(ABCD)</script> as following:</p>\n<p>\n<script type="math/tex; mode=display">\nSum(ABCD) = Sum(OD) - Sum(OB) - Sum(OC) + Sum(OA)\n</script>\n</p>\n<div class="codehilite"><pre><span></span><span class="kd">private</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span><span class="o">;</span>\n\n<span class="kd">public</span> <span class="nf">NumMatrix</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>\n    <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">r</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">c</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="n">dp</span><span class="o">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">-</span> <span class="n">dp</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">];</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n\n<span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRegion</span><span class="o">(</span><span class="kt">int</span> <span class="n">row1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col2</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">row2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">col2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">dp</span><span class="o">[</span><span class="n">row1</span><span class="o">][</span><span class="n">col2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">dp</span><span class="o">[</span><span class="n">row2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">col1</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">row1</span><span class="o">][</span><span class="n">col1</span><span class="o">];</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script> time per query, <script type="math/tex; mode=display">O(mn)</script> time pre-computation.\nThe pre-computation in the constructor takes <script type="math/tex; mode=display">O(mn)</script> time. Each <em>sumRegion</em> query takes <script type="math/tex; mode=display">O(1)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>.\nThe algorithm uses <script type="math/tex; mode=display">O(mn)</script> space to store the cumulative region sum.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: [],
  },
  {
    id: '305',
    name: 'Number of Islands II ',
    acceptance: '39.5%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>A 2d grid map of <code>m</code> rows and <code>n</code> columns is initially filled with water.\nWe may perform an <i>addLand</i> operation which turns the water at position (row, col) into a land.\nGiven a list of positions to operate, <b>count the number of islands after each <i>addLand</i> operation</b>.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\nYou may assume all four edges of the grid are all surrounded by water.</p>\n\n<p><b>Example:</b></p>\n<p>Given <code>m = 3, n = 3</code>, <code>positions = [[0,0], [0,1], [1,2], [2,1]]</code>.<br>\nInitially, the 2d grid <code>grid</code> is filled with water. (Assume 0 represents water and 1 represents land).</p>\n<pre>0 0 0\n0 0 0\n0 0 0\n</pre>\n<p>Operation #1: addLand(0, 0) turns the water at grid[0][0] into a land.</p>\n<pre>1 0 0\n0 0 0   Number of islands = 1\n0 0 0\n</pre>\n<p>Operation #2: addLand(0, 1) turns the water at grid[0][1] into a land.</p>\n<pre>1 1 0\n0 0 0   Number of islands = 1\n0 0 0\n</pre>\n<p>Operation #3: addLand(1, 2) turns the water at grid[1][2] into a land.</p>\n<pre>1 1 0\n0 0 1   Number of islands = 2\n0 0 0\n</pre>\n<p>Operation #4: addLand(2, 1) turns the water at grid[2][1] into a land.</p>\n<pre>1 1 0\n0 0 1   Number of islands = 3\n0 1 0\n</pre>\n<p>We return the result as an array: <code>[1, 1, 2, 3]</code></p>\n\n<p><b>Challenge:</b></p>\n<p>Can you do it in time complexity O(k log mn), where k is the length of the <code>positions</code>?</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '306',
    name: 'Additive Number',
    acceptance: '27.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Additive number is a string whose digits can form additive sequence.</p>\n\n<p>A valid additive sequence should contain <b>at least</b> three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p>\n\n<p>\nFor example:<br>\n<code>"112358"</code> is an additive number because the digits can form an additive sequence: <code>1, 1, 2, 3, 5, 8</code>.\n</p><pre>1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8</pre>\n<code>"199100199"</code> is also an additive number, the additive sequence is: <code>1, 99, 100, 199</code>.\n<pre>1 + 99 = 100, 99 + 100 = 199</pre>\n<p></p>\n\n<p>\n<b>Note:</b> Numbers in the additive sequence <b>cannot</b> have leading zeros, so sequence <code>1, 2, 03</code> or <code>1, 02, 3</code> is invalid.\n</p>\n\n<p>Given a string containing only digits <code>\'0\'-\'9\'</code>, write a function to determine if it\'s an additive number.</p>\n\n<p>\n<b>Follow up:</b><br>\nHow would you handle overflow for very large input integers?\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jeantimex">@jeantimex</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Epic Systems'],
  },
  {
    id: '307',
    name: 'Range Sum Query - Mutable',
    acceptance: '21.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given an integer array <i>nums</i>, find the sum of the elements between indices <i>i</i> and <i>j</i> (<i>i</i> ≤ <i>j</i>), inclusive.</p>\n\nThe <i>update(i, val)</i> function modifies <i>nums</i> by updating the element at index <i>i</i> to <i>val</i>.\n\n<p><b>Example:</b><br>\n</p><pre>Given nums = [1, 3, 5]\n\nsumRange(0, 2) -&gt; 9\nupdate(1, 2)\nsumRange(0, 2) -&gt; 8\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The array is only modifiable by the <i>update</i> function.</li>\n<li>You may assume the number of calls to <i>update</i> and <i>sumRange</i> function is distributed evenly.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-naive-time-limit-exceeded">Approach #1 (Naive) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-sqrt-decomposition-accepted">Approach #2 (Sqrt decomposition) [Accepted]</a></li>\n<li><a href="#approach-3-segment-tree-accepted">Approach #3 (Segment tree) [Accepted]</a><ul>\n<li><a href="#1-build-segment-tree">1. Build segment tree</a></li>\n<li><a href="#2-update-segment-tree">2. Update segment tree</a></li>\n<li><a href="#3-range-sum-query">3. Range Sum Query</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href="#further-thoughts">Further Thoughts</a></li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This article is for intermediate level readers. It introduces the following concepts:\nRange sum query, Sqrt decomposition, Segment tree.</p>\n<h2 id="solution">Solution</h2>\n<h4 id="approach-1-naive-time-limit-exceeded">Approach #1 (Naive) [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>A trivial solution for Range Sum Query - <code>RSQ(i, j)</code> is to iterate the array from index <script type="math/tex; mode=display">i</script> to <script type="math/tex; mode=display">j</script> and sum each element.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">;</span>\n<span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="o">;</span> <span class="n">l</span><span class="o">++)</span> <span class="o">{</span>\n        <span class="n">sum</span> <span class="o">+=</span> <span class="n">data</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>\n<span class="o">}</span>\n\n<span class="kd">public</span> <span class="kt">int</span> <span class="nf">update</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>\n<span class="o">}</span>\n<span class="c1">// Time Limit Exceeded</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script> - range sum query, <script type="math/tex; mode=display">O(1)</script> - update query</p>\n<p>For range sum query we access each element from the array for constant time and in the worst case we access <script type="math/tex; mode=display">n</script> elements. Therefore time complexity is <script type="math/tex; mode=display">O(n)</script>. Time complexity of update query is <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<h4 id="approach-2-sqrt-decomposition-accepted">Approach #2 (Sqrt decomposition) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>The idea is to  split the array in blocks with length of <script type="math/tex; mode=display">\\sqrt{n}</script>. Then we calculate the sum of each block and store it in auxiliary memory <code>b</code>.\nTo query <code>RSQ(i, j)</code>, we will add the sums of all the blocks lying inside and those that partially overlap with range <script type="math/tex; mode=display">[i \\ldots j]</script>.</p>\n<p><strong>Algorithm</strong></p>\n<p align="center"><img alt="Range sum query using SQRT decomposition" src="https://leetcode.com/media/original_images/307_RSQ_Sqrt.png" width="539px"></p>\n<p align="center"><em>Figure 1. Range sum query using SQRT decomposition.</em></p>\n<p>In the example above, the array <code>nums</code>\'s length is <code>9</code>, which is split into blocks of size <script type="math/tex; mode=display">\\sqrt{9}</script>. To get <code>RSQ(1, 7)</code> we add <code>b[1]</code>.  It stores the sum of <code>range [3, 5]</code> and partially sums from <code>block 0</code>  and <code>block 2</code>, which are overlapping boundary blocks.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">b</span><span class="o">;</span>\n<span class="kd">private</span> <span class="kt">int</span> <span class="n">len</span><span class="o">;</span>\n<span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">;</span>\n\n<span class="kd">public</span> <span class="nf">NumArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">this</span><span class="o">.</span><span class="na">nums</span> <span class="o">=</span> <span class="n">nums</span><span class="o">;</span>\n    <span class="kt">double</span> <span class="n">l</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>\n    <span class="n">len</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">Math</span><span class="o">.</span><span class="na">ceil</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="n">l</span><span class="o">);</span>\n    <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="o">[</span><span class="n">len</span><span class="o">];</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>\n        <span class="n">b</span><span class="o">[</span><span class="n">i</span> <span class="o">/</span> <span class="n">len</span><span class="o">]</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n<span class="o">}</span>\n\n<span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">startBlock</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="n">len</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">endBlock</span> <span class="o">=</span> <span class="n">j</span> <span class="o">/</span> <span class="n">len</span><span class="o">;</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">startBlock</span> <span class="o">==</span> <span class="n">endBlock</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>\n            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>\n    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="o">(</span><span class="n">startBlock</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>\n            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">startBlock</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">endBlock</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>\n            <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">endBlock</span> <span class="o">*</span> <span class="n">len</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span>\n            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>\n<span class="o">}</span>\n\n<span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">b_l</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="n">len</span><span class="o">;</span>\n    <span class="n">b</span><span class="o">[</span><span class="n">b_l</span><span class="o">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">[</span><span class="n">b_l</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">val</span><span class="o">;</span>\n    <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>\n<span class="o">}</span>\n<span class="c1">// Accepted</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script> - preprocessing, <script type="math/tex; mode=display">O(\\sqrt{n})</script> - range sum query, <script type="math/tex; mode=display">O(1)</script> - update query</p>\n<p>For range sum query in the worst-case scenario we have to sum approximately <script type="math/tex; mode=display">3 \\sqrt{n}</script> elements. In this case the range includes <script type="math/tex; mode=display">\\sqrt{n} - 2</script> blocks, which total sum costs <script type="math/tex; mode=display">\\sqrt{n} - 2</script> operations. In addition to this we have to add the sum of the two boundary blocks. This takes another <script type="math/tex; mode=display">2 (\\sqrt{n} - 1)</script> operations. The total amount of operations is around <script type="math/tex; mode=display">3 \\sqrt{n}</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(\\sqrt{n})</script>.</p>\n<p>We need additional <script type="math/tex; mode=display">\\sqrt{n}</script> memory to store all block sums.</p>\n</li>\n</ul>\n<h4 id="approach-3-segment-tree-accepted">Approach #3 (Segment tree) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Segment tree is a very flexible data structure, because it is used to solve numerous range query problems like finding minimum, maximum, sum, greatest common divisor, least common denominator in array in logarithmic time.</p>\n<p align="center"><img alt="Illustration of Segment tree" src="https://leetcode.com/media/original_images/307_RSQ_SegmentTree.png" width="539px"></p>\n<p align="center"><em>Figure 2. Illustration of Segment tree.</em></p>\n<p>The segment tree for array <script type="math/tex; mode=display">a[0, 1, \\ldots ,n-1]</script> is a binary tree in which each node contains <strong>aggregate</strong> information (min, max, sum, etc.) for a subrange <script type="math/tex; mode=display">[i \\ldots j]</script> of the array, as its left and right child hold information for range <script type="math/tex; mode=display">[i \\ldots \\frac{i+j}{2}]</script> and <script type="math/tex; mode=display">[\\frac{i + j}{2} + 1, j]</script>.</p>\n<p>Segment tree could be implemented using either an array or a tree. For an array implementation, if the element at index <script type="math/tex; mode=display">i</script> is not a leaf, its left and right child are stored at index <script type="math/tex; mode=display">2i</script> and <script type="math/tex; mode=display">2i + 1</script> respectively.</p>\n<p>In the example above (Figure 2), every leaf node contains the initial array elements <code>{2,4,5,7,8,9}</code>. The internal nodes contain the sum of the corresponding elements in range - <code>(11)</code> for the elements from index 0 to index 2. The root <code>(35)</code> being the sum  of its children <code>(6)</code>;<code>(29)</code>, holds the total sum of the entire array.</p>\n<p>Segment Tree can be broken down to the three following steps:</p>\n<ol>\n<li>Pre-processing step which builds the segment tree from a given array.</li>\n<li>Update the segment tree when an element is modified.</li>\n<li>Calculate the Range Sum Query using the segment tree.</li>\n</ol>\n<h5 id="1-build-segment-tree">1. Build segment tree</h5>\n<p>We will use a very effective bottom-up approach to build segment tree. We already know from the above that if some node <script type="math/tex; mode=display">p</script> holds the sum of <script type="math/tex; mode=display">[i \\ldots j]</script> range, its left and right children hold the sum for range <script type="math/tex; mode=display">[i \\ldots \\frac{i + j}{2}]</script> and <script type="math/tex; mode=display">[\\frac{i + j}{2} + 1, j]</script> respectively.</p>\n<p>Therefore to find the sum of node <script type="math/tex; mode=display">p</script>, we need to calculate the sum of its right and left child in advance.</p>\n<p>We begin from the leaves, initialize them with input array elements <script type="math/tex; mode=display">a[0, 1, \\ldots, n-1]</script>. Then we move upward to the higher level to calculate the parents\' sum till we get to the root of the segment tree.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kt">int</span><span class="o">[]</span> <span class="n">tree</span><span class="o">;</span>\n<span class="kt">int</span> <span class="n">n</span><span class="o">;</span>\n<span class="kd">public</span> <span class="nf">NumArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>\n        <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="o">];</span>\n        <span class="n">buildTree</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n<span class="kd">private</span> <span class="kt">void</span> <span class="nf">buildTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++,</span>  <span class="n">j</span><span class="o">++)</span>\n        <span class="n">tree</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>\n    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span>\n        <span class="n">tree</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">tree</span><span class="o">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="n">tree</span><span class="o">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>Time complexity is  <script type="math/tex; mode=display">O(n)</script>, because we calculate the sum of one node during each iteration of the for loop. There are approximately <script type="math/tex; mode=display">2n</script> nodes in a segment tree.</p>\n<p>This could be proved in the following way: Segmented tree for array with <script type="math/tex; mode=display">n</script> elements has <script type="math/tex; mode=display">n</script> leaves (the array elements itself). The number of nodes in each level is half the number in the level below.</p>\n<p>So if we sum the number by level we will get:</p>\n<p>\n<script type="math/tex; mode=display">\nn + n/2  + n/4 + n/8 + \\ldots + 1 \\approx 2n\n</script>\n</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>.</p>\n<p>We used <script type="math/tex; mode=display">2n</script> extra space to store the segment tree.</p>\n</li>\n</ul>\n<h5 id="2-update-segment-tree">2. Update segment tree</h5>\n<p>When we update the array at some index <script type="math/tex; mode=display">i</script> we need to rebuild the segment tree, because there are tree nodes which contain the sum of the modified element. Again we will use a bottom-up approach. We update the leaf node that stores <script type="math/tex; mode=display">a[i]</script>. From there we will follow the path up to the root updating the value of each parent as a sum of its children values.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="kt">int</span> <span class="n">pos</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">pos</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>\n    <span class="n">tree</span><span class="o">[</span><span class="n">pos</span><span class="o">]</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">pos</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">pos</span><span class="o">;</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">pos</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">right</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>\n            <span class="n">left</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="c1">// parent is updated after child is updated</span>\n        <span class="n">tree</span><span class="o">[</span><span class="n">pos</span> <span class="o">/</span> <span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">tree</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">+</span> <span class="n">tree</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>\n        <span class="n">pos</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(\\log n)</script>.</p>\n<p>Algorithm  has <script type="math/tex; mode=display">O(\\log n)</script> time complexity, because there are a few tree nodes with range that include  <script type="math/tex; mode=display">i</script>th array element, one on each level. There are <script type="math/tex; mode=display">\\log(n)</script>  levels.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<h5 id="3-range-sum-query">3. Range Sum Query</h5>\n<p>We can find range sum query  <script type="math/tex; mode=display">[L, R]</script> using segment tree in the following way:</p>\n<p>Algorithm hold loop invariant:</p>\n<p>\n<script type="math/tex; mode=display">l \\le r</script> and sum of <script type="math/tex; mode=display">[L \\ldots l]</script> and <script type="math/tex; mode=display">[r \\ldots R]</script> has been calculated, where <script type="math/tex; mode=display">l</script> and <script type="math/tex; mode=display">r</script> are the left and right boundary of calculated sum.\nInitially we set <script type="math/tex; mode=display">l</script> with left leaf <script type="math/tex; mode=display">L</script> and <script type="math/tex; mode=display">r</script> with right leaf <script type="math/tex; mode=display">R</script>.\nRange <script type="math/tex; mode=display">[l, r]</script> shrinks on each iteration till range borders meets after approximately <script type="math/tex; mode=display">\\log n</script> iterations of the algorithm</p>\n<ul>\n<li>Loop till <script type="math/tex; mode=display">l \\le r</script>\n<ul>\n<li>Check if <script type="math/tex; mode=display">l</script> is right child of its parent <script type="math/tex; mode=display">P</script>\n<ul>\n<li>\n<script type="math/tex; mode=display">l</script> is right child of <script type="math/tex; mode=display">P</script>. Then <script type="math/tex; mode=display">P</script> contains sum of range of <script type="math/tex; mode=display">l</script> and another  child which is outside the range <script type="math/tex; mode=display">[l, r]</script> and we don\'t need parent <script type="math/tex; mode=display">P</script> sum. Add <script type="math/tex; mode=display">l</script> to <script type="math/tex; mode=display">sum</script> without its parent <script type="math/tex; mode=display">P</script> and set <script type="math/tex; mode=display">l</script> to point to the right of <script type="math/tex; mode=display">P</script> on the upper level.</li>\n<li>\n<script type="math/tex; mode=display">l</script> is not right child of <script type="math/tex; mode=display">P</script>. Then parent <script type="math/tex; mode=display">P</script> contains sum of range which lies in <script type="math/tex; mode=display">[l, r]</script>. Add <script type="math/tex; mode=display">P</script> to <script type="math/tex; mode=display">sum</script> and set <script type="math/tex; mode=display">l</script> to point to the parent of <script type="math/tex; mode=display">P</script>\n</li>\n</ul>\n</li>\n<li>Check if <script type="math/tex; mode=display">r</script> is left child of its parent <script type="math/tex; mode=display">P</script>\n<ul>\n<li>\n<script type="math/tex; mode=display">r</script> is left child of <script type="math/tex; mode=display">P</script>. Then <script type="math/tex; mode=display">P</script> contains sum of range of <script type="math/tex; mode=display">r</script> and another  child which is outside the range <script type="math/tex; mode=display">[l, r]</script> and we don\'t need parent <script type="math/tex; mode=display">P</script> sum. Add <script type="math/tex; mode=display">r</script>  to <script type="math/tex; mode=display">sum</script> without its parent <script type="math/tex; mode=display">P</script> and set <script type="math/tex; mode=display">r</script> to point to the left of <script type="math/tex; mode=display">P</script> on the upper level.</li>\n<li>\n<script type="math/tex; mode=display">r</script> is not left child of <script type="math/tex; mode=display">P</script>. Then parent <script type="math/tex; mode=display">P</script> contains sum of range which lies in <script type="math/tex; mode=display">[l, r]</script>. Add <script type="math/tex; mode=display">P</script> to <script type="math/tex; mode=display">sum</script> and set <script type="math/tex; mode=display">r</script> to point to the parent of <script type="math/tex; mode=display">P</script>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">sumRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>\n    <span class="c1">// get leaf with value \'l\'</span>\n    <span class="n">l</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>\n    <span class="c1">// get leaf with value \'r\'</span>\n    <span class="n">r</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">((</span><span class="n">l</span> <span class="o">%</span> <span class="mi">2</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>\n           <span class="n">sum</span> <span class="o">+=</span> <span class="n">tree</span><span class="o">[</span><span class="n">l</span><span class="o">];</span>\n           <span class="n">l</span><span class="o">++;</span>\n        <span class="o">}</span>\n        <span class="k">if</span> <span class="o">((</span><span class="n">r</span> <span class="o">%</span> <span class="mi">2</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n           <span class="n">sum</span> <span class="o">+=</span> <span class="n">tree</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>\n           <span class="n">r</span><span class="o">--;</span>\n        <span class="o">}</span>\n        <span class="n">l</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">;</span>\n        <span class="n">r</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(\\log n)</script>\n</p>\n<p>Time complexity is <script type="math/tex; mode=display">O(\\log n)</script> because on each iteration of the algorithm we move one level up, either to the parent of the  current node or to the next sibling of parent to the left or right direction till the two boundaries meet. In the worst-case scenario this happens at the root after <script type="math/tex; mode=display">\\log n</script> iterations of the algorithm.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<h2 id="further-thoughts">Further Thoughts</h2>\n<p>The iterative version of Segment Trees was introduced in this article. A more intuitive, recursive version of Segment Trees to solve this problem is discussed <a href="https://leetcode.com/articles/recursive-approach-segment-trees-range-sum-queries-lazy-propagation/">here</a>. The concept of Lazy Propagation is also introduced there.</p>\n<p>There is an alternative solution of the problem using Binary Indexed Tree. It is faster and simpler to code.\nYou can find it <a href="https://leetcode.com/discuss/74222/java-using-binary-indexed-tree-with-clear-explanation">here</a>.</p>\n<p>Analysis written by: @elmirap.</p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '308',
    name: 'Range Sum Query 2D - Mutable ',
    acceptance: '24.5%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given a 2D matrix <i>matrix</i>, find the sum of the elements inside the rectangle defined by its upper left corner (<i>row</i>1, <i>col</i>1) and lower right corner (<i>row</i>2, <i>col</i>2).</p>\n\n<p>\n<img src="/static/images/courses/range_sum_query_2d.png" border="0" alt="Range Sum Query 2D"><br>\n<small>The above rectangle (with the red border) is defined by (row1, col1) = <b>(2, 1)</b> and (row2, col2) = <b>(4, 3)</b>, which contains sum = <b>8</b>.</small>\n</p>\n\n<p><b>Example:</b><br>\n</p><pre>Given matrix = [\n  [3, 0, 1, 4, 2],\n  [5, 6, 3, 2, 1],\n  [1, 2, 0, 1, 5],\n  [4, 1, 0, 1, 7],\n  [1, 0, 3, 0, 5]\n]\n\nsumRegion(2, 1, 4, 3) -&gt; 8\nupdate(3, 2, 2)\nsumRegion(2, 1, 4, 3) -&gt; 10\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The matrix is only modifiable by the <i>update</i> function.</li>\n<li>You may assume the number of calls to <i>update</i> and <i>sumRegion</i> function is distributed evenly.</li>\n<li>You may assume that <i>row</i>1 ≤ <i>row</i>2 and <i>col</i>1 ≤ <i>col</i>2.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '309',
    name: 'Best Time to Buy and Sell Stock with Cooldown',
    acceptance: '41.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Say you have an array for which the <i>i</i><sup>th</sup> element is the price of a given stock on day <i>i</i>.</p>\n\n<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like\n(ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>\n\n<ul>\n    <li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>\n    <li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li>\n</ul>\n\n<p><b>Example:</b><br></p>\n<pre>prices = [1, 2, 3, 0, 2]\nmaxProfit = 3\ntransactions = [buy, sell, cooldown, buy, sell]\n</pre>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '310',
    name: 'Minimum Height Trees',
    acceptance: '28.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\n    For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs).\n    Given such a graph, write a function to find all the MHTs and return a list of their root labels.\n</p>\n\n<p>\n    <b>Format</b><br>\n    The graph contains <code>n</code> nodes which are labeled from <code>0</code> to <code>n - 1</code>.\n    You will be given the number <code>n</code> and a list of undirected <code>edges</code> (each edge is a pair of labels).\n</p>\n<p> \nYou can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are\n    undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in\n    <code>edges</code>.\n</p>\n<p>\n    <b>Example 1:</b>\n</p>\n<p>\n    Given <code>n = 4</code>, <code>edges = [[1, 0], [1, 2], [1, 3]]</code>\n</p>\n\n<pre>        0\n        |\n        1\n       / \\\n      2   3\n</pre>\n<p>\n    return <code> [1]</code>\n</p>\n\n<p>\n    <b>Example 2:</b>\n</p>\n<p>\n    Given <code>n = 6</code>, <code>edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</code>\n</p>\n<pre>     0  1  2\n      \\ | /\n        3\n        |\n        4\n        |\n        5\n</pre>\n<p>\n    return <code> [3, 4]</code>\n</p>\n\n<p>\n    <b>Note</b>:\n</p>\n<p>\n    (1) According to the <a href="https://en.wikipedia.org/wiki/Tree_(graph_theory)" target="_blank">definition\n    of tree on Wikipedia</a>: “a tree is an undirected graph in which any two vertices are connected by\n    <i>exactly</i> one path. In other words, any connected graph without simple cycles is a tree.”\n</p>\n<p>\n    (2) The height of a rooted tree is the number of edges on the longest downward path between the root and a\n    leaf.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '311',
    name: 'Sparse Matrix Multiplication ',
    acceptance: '52.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given two <a href="https://en.wikipedia.org/wiki/Sparse_matrix" target="_blank">sparse matrices</a> <b>A</b> and <b>B</b>, return the result of <b>AB</b>.</p>\n\n<p>You may assume that <b>A</b>\'s column number is equal to <b>B</b>\'s row number.</p>\n\n<p><b>Example:</b></p>\n\n<pre><b>A</b> = [\n  [ 1, 0, 0],\n  [-1, 0, 3]\n]\n\n<b>B</b> = [\n  [ 7, 0, 0 ],\n  [ 0, 0, 0 ],\n  [ 0, 0, 1 ]\n]\n\n\n     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |\n<b>AB</b> = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |\n                  | 0 0 1 |\n</pre>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'LinkedIn'],
  },
  {
    id: '312',
    name: 'Burst Balloons',
    acceptance: '43.2%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\n    Given <code>n</code> balloons, indexed from <code>0</code> to <code>n-1</code>. Each balloon is painted with a\n    number on it represented by array <code>nums</code>.\n\n    You are asked to burst all the balloons. If the you burst\n    balloon <code>i</code> you will get <code>nums[left] * nums[i] * nums[right]</code> coins. Here <code>left</code>\n    and <code>right</code> are adjacent indices of <code>i</code>. After the burst, the <code>left</code> and <code>right</code>\n    then becomes adjacent.\n</p>\n<p>\n    Find the maximum coins you can collect by bursting the balloons wisely.\n</p>\n<p>\n    <b>Note:</b> <br>\n    (1) You may imagine <code>nums[-1] = nums[n] = 1</code>. They are not real therefore you can not burst them.<br>\n    (2) 0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100\n</p>\n\n\n<p>\n    <b>Example:</b>\n</p>\n<p>\n    Given <code>[3, 1, 5, 8]</code>\n</p>\n<p>\n    Return <code>167</code>\n</p>\n<pre>    nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []\n   coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167\n</pre>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Snapchat'],
  },
  {
    id: '313',
    name: 'Super Ugly Number',
    acceptance: '38.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\n    Write a program to find the n<sup>th</sup> super ugly number.\n</p>\n\n<p>\n    Super ugly numbers are positive numbers whose all prime factors are in the given prime list\n    <code>primes</code> of size <code>k</code>. For example, <code>[1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]\n</code> is the sequence of the first 12 super ugly numbers given <code>primes</code>\n    = <code>[2, 7, 13, 19]</code> of size 4.\n</p>\n\n<p>\n    <b>Note:</b><br>\n    (1) <code>1</code> is a super ugly number for any given <code>primes</code>.<br>\n    (2) The given numbers in <code>primes</code> are in ascending order.<br>\n    (3) 0 &lt; <code>k</code> ≤ 100, 0 &lt; <code>n</code> ≤ 10<sup>6</sup>, 0 &lt; <code>primes[i]</code> &lt; 1000.<br>\n    (4) The n<sup>th</sup> super ugly number is guaranteed to fit in a 32-bit signed integer.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '314',
    name: 'Binary Tree Vertical Order Traversal ',
    acceptance: '37.5%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given a binary tree, return the <i>vertical order</i> traversal of its nodes' values. (ie, from top to bottom, column by column).</p>\n<p>If two nodes are in the same row and column, the order should be from <b>left to right</b>.</p>\n<p>\n<b>Examples:</b><br></p>\n<p>\n</p><ol>\n<li>Given binary tree <code>[3,9,20,null,null,15,7]</code>,<br>\n<pre>   3\n  /\\\n /  \\\n 9  20\n    /\\\n   /  \\\n  15   7\n</pre>\n<p></p>\n<p>\nreturn its vertical order traversal as:<br>\n</p><pre>[\n  [9],\n  [3,15],\n  [20],\n  [7]\n]\n</pre>\n</li>\n\n<li>Given binary tree <code>[3,9,8,4,0,1,7]</code>,<br>\n<pre>     3\n    /\\\n   /  \\\n   9   8\n  /\\  /\\\n /  \\/  \\\n 4  01   7\n</pre>\n<p></p>\n<p>\nreturn its vertical order traversal as:<br>\n</p><pre>[\n  [4],\n  [9],\n  [3,0,1],\n  [8],\n  [7]\n]\n</pre>\n</li>\n\n<li>Given binary tree <code>[3,9,8,4,0,1,7,null,null,null,2,5]</code> (0's right child is 2 and 1's left child is 5),<br>\n<pre>     3\n    /\\\n   /  \\\n   9   8\n  /\\  /\\\n /  \\/  \\\n 4  01   7\n    /\\\n   /  \\\n   5   2\n</pre>\n<p></p>\n<p>\nreturn its vertical order traversal as:<br>\n</p><pre>[\n  [4],\n  [9,5],\n  [3,0,1],\n  [8,2],\n  [7]\n]\n</pre>\n</li>\n</ol>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Snapchat'],
  },
  {
    id: '315',
    name: 'Count of Smaller Numbers After Self',
    acceptance: '34.8%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nYou are given an integer array <i>nums</i> and you have to return a new <i>counts</i> array.\nThe <i>counts</i> array has the property where <code>counts[i]</code> is \nthe number of smaller elements to the right of <code>nums[i]</code>.\n</p>\n\n<p><b>Example:</b></p>\n\n<pre>Given <i>nums</i> = [5, 2, 6, 1]\n\nTo the right of 5 there are <b>2</b> smaller elements (2 and 1).\nTo the right of 2 there is only <b>1</b> smaller element (1).\nTo the right of 6 there is <b>1</b> smaller element (1).\nTo the right of 1 there is <b>0</b> smaller element.\n</pre>\n\n<p>\nReturn the array <code>[2, 1, 1, 0]</code>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '316',
    name: 'Remove Duplicate Letters',
    acceptance: '30.0%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\n</p>\n\n<p>\n<b>Example:</b><br>\n</p>\n<p>\nGiven <code>"bcabc"</code><br>\nReturn <code>"abc"</code>\n</p>\n<p>\nGiven <code>"cbacdcbc"</code><br>\nReturn <code>"acdb"</code>\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '317',
    name: 'Shortest Distance from All Buildings ',
    acceptance: '34.5%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>You want to build a house on an <i>empty</i> land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values <b>0</b>, <b>1</b> or <b>2</b>, where:</p>\n<ul>\n<li>Each <b>0</b> marks an empty land which you can pass by freely.</li>\n<li>Each <b>1</b> marks a building which you cannot pass through.</li>\n<li>Each <b>2</b> marks an obstacle which you cannot pass through.</li>\n</ul>\n\n<p>For example, given three buildings at <code>(0,0)</code>, <code>(0,4)</code>, <code>(2,2)</code>, and an obstacle at <code>(0,2)</code>:</p>\n\n<pre>1 - 0 - 2 - 0 - 1\n|   |   |   |   |\n0 - 0 - 0 - 0 - 0\n|   |   |   |   |\n0 - 0 - 1 - 0 - 0</pre>\n\n<p>The point <code>(1,2)</code> is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.</p>\n\n<p><b>Note:</b><br>\nThere will be at least one building. If it is not possible to build such house according to the above rules, return -1.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Zenefits'],
  },
  {
    id: '318',
    name: 'Maximum Product of Word Lengths',
    acceptance: '45.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\n    Given a string array <code>words</code>, find the maximum value of <code>length(word[i]) * length(word[j])</code> where the two words do not share common letters.\n    You may assume that each word will contain only lower case letters.\n    If no such two words exist, return 0.\n</p>\n\n<p>\n    <b>Example 1:</b><br>\n</p>\n<p>\n    Given <code>["abcw", "baz", "foo", "bar", "xtfn", "abcdef"]</code><br>\n    Return <code>16</code><br>\n    The two words can be <code>"abcw", "xtfn"</code>.\n</p>\n<p>\n    <b>Example 2:</b><br>\n</p>\n<p>\n    Given <code>["a", "ab", "abc", "d", "cd", "bcd", "abcd"]</code><br>\n    Return <code>4</code><br>\n    The two words can be <code>"ab", "cd"</code>.\n</p>\n<p>\n    <b>Example 3:</b><br>\n</p>\n<p>\n    Given <code>["a", "aa", "aaa", "aaaa"]</code><br>\n    Return <code>0</code><br>\n    No such pair of words.    \n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '319',
    name: 'Bulb Switcher',
    acceptance: '42.7%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nThere are <i>n</i> bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the <i>i</i>th round, you toggle every <i>i</i> bulb. For the <i>n</i>th round, you only toggle the last bulb.\n\nFind how many bulbs are on after <i>n</i> rounds.\n</p>\n\n<p>\n<b>Example:</b><br></p>\n<pre>Given <i>n</i> = 3. <br>\nAt first, the three bulbs are <b>[off, off, off]</b>.\nAfter first round, the three bulbs are <b>[on, on, on]</b>.\nAfter second round, the three bulbs are <b>[on, off, on]</b>.\nAfter third round, the three bulbs are <b>[on, off, off]</b>. <br>\nSo you should return 1, because there is only one bulb is on.\n</pre>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '320',
    name: 'Generalized Abbreviation ',
    acceptance: '45.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Write a function to generate the generalized abbreviations of a word.</p>\n\n<p>\n    <b>Example:</b><br>\n</p>\n<p>Given word = <code>"word"</code>, return the following list (order does not matter):<br>\n</p><pre>["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-backtracking-accepted">Approach #1 (Backtracking) [Accepted]</a></li>\n<li><a href="#approach-2-bit-manipulation-accepted">Approach #2 (Bit Manipulation) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This article is for intermediate readers. It introduces the following ideas:\nBacktracking and Bit Manipulation</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-backtracking-accepted">Approach #1 (Backtracking) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>How many abbreviations are there for a word of length <script type="math/tex; mode=display">n</script>? The answer is <script type="math/tex; mode=display">2^n</script> because each character can either be abbreviated or not, resulting in different abbreviations.</p>\n<p><strong>Algorithm</strong></p>\n<p>The backtracking algorithm enumerates a set of partial candidates that, in principle, could be completed in several choices to give all the possible solutions to the problem. The completion is done incrementally, by extending the candidate in many steps. Abstractly, the partial candidates can be seen as nodes of a tree, the potential search tree. Each partial candidate is the parent of the candidates that derives from it by an extension step; the leaves of the tree are the partial candidates that cannot be extended any further.</p>\n<p>In our problem, the partial candidates are incomplete abbreviations that can be extended by one of the two choices:</p>\n<ol>\n<li>keep the next character;</li>\n<li>abbreviate the next character.</li>\n</ol>\n<p>We extend the potential candidate in a depth-first manner. We backtrack when we reach a leaf node in the search tree. All the leaves in the search tree are valid abbreviations and shall be put into a shared list which will be returned at the end.</p>\n<iframe frameborder="0" height="496" name="DZ7F6eEQ" src="https://leetcode.com/playground/DZ7F6eEQ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n 2^n)</script>. For each call to <code>backtrack</code>, it either returns without branching, or it branches into two recursive calls. All these recursive calls form a complete binary recursion tree with <script type="math/tex; mode=display">2^n</script> leaves and <script type="math/tex; mode=display">2^n - 1</script> inner nodes. For each leaf node, it needs <script type="math/tex; mode=display">O(n)</script> time for converting builder to String; for each internal node, it needs only constant time. Thus, the total time complexity is dominated by the leaves. In total that is <script type="math/tex; mode=display">O(n2^n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. If the return list doesn\'t count, we only need <script type="math/tex; mode=display">O(n)</script> auxiliary space to store the characters in <code>StringBuilder</code> and the <script type="math/tex; mode=display">O(n)</script> space used by system stack. In a recursive program, the space of system stack is linear to the maximum recursion depth which is <script type="math/tex; mode=display">n</script> in our problem.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-bit-manipulation-accepted">Approach #2 (Bit Manipulation) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we use <script type="math/tex; mode=display">0</script> to represent a character that is not abbreviated and <script type="math/tex; mode=display">1</script> to represent one that is. Then each abbreviation is mapped to an <script type="math/tex; mode=display">n</script> bit binary number and vice versa.</p>\n<p><strong>Algorithm</strong></p>\n<p>To generate all the <script type="math/tex; mode=display">2^n</script> abbreviation with non-repetition and non-omission, we need to follow rules. In approach #1, the rules are coded in the backtracking process.\nHere we introduce another way.</p>\n<p>From the intuition section, each abbreviation has a one to one relationship to a <script type="math/tex; mode=display">n</script> bit binary number <script type="math/tex; mode=display">x</script>. We can use these numbers as blueprints to build the corresponding abbreviations.</p>\n<p>For example:</p>\n<p>Given word = <code>"word"</code> and x = <code>0b0011</code></p>\n<p>Which means <code>\'w\'</code> and <code>\'o\'</code> are kept, <code>\'r\'</code> and <code>\'d\'</code> are abbreviated. Therefore, the result is "wo2".</p>\n<p>Thus, for a number <script type="math/tex; mode=display">x</script>, we just need to scan it bit by bit as if it is an array so that we know which character should be kept and which should be abbreviated.</p>\n<p>To scan a number <script type="math/tex; mode=display">x</script> bit by bit, one could extract its last bit by <code>b = x &amp; 1</code> and shift <script type="math/tex; mode=display">x</script> one bit to the right, i.e. <code>x &gt;&gt;= 1</code>.\nDoing this repeatedly, one will get all the <script type="math/tex; mode=display">n</script> bits of <script type="math/tex; mode=display">x</script> from last bit to first bit.</p>\n<iframe frameborder="0" height="513" name="s3sJrrGq" src="https://leetcode.com/playground/s3sJrrGq/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n 2^n)</script>. Building one abbreviation from the number <script type="math/tex; mode=display">x</script>, we need scan all the <script type="math/tex; mode=display">n</script> bits. Besides the <code>StringBuilder::toString</code> function is also linear. Thus, to generate all the <script type="math/tex; mode=display">2^n</script>, it costs <script type="math/tex; mode=display">O(n 2^n)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. If the return list doesn\'t count, we only need <script type="math/tex; mode=display">O(n)</script> auxiliary space to store the characters in <code>StringBuilder</code>.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '321',
    name: 'Create Maximum Number',
    acceptance: '24.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\n    Given two arrays of length <code>m</code> and <code>n</code> with digits <code>0-9</code> representing two numbers.\n    Create the maximum number of length <code>k &lt;= m + n</code> from digits of the two. The relative order of the digits\n    from the same array must be preserved. Return an array of the <code>k</code> digits. You should try to optimize your time and space complexity.\n</p>\n\n<p>\n    <b>Example 1:</b><br>\n</p>\n<p>\n    nums1 = <code>[3, 4, 6, 5]</code><br>\n    nums2 = <code>[9, 1, 2, 5, 8, 3]</code><br>\n    k = <code>5</code><br>\n    return <code>[9, 8, 6, 5, 3]</code>\n</p>\n<p>\n    <b>Example 2:</b><br>\n</p>\n<p>\n    nums1 = <code>[6, 7]</code><br>\n    nums2 = <code>[6, 0, 4]</code><br>\n    k = <code>5</code><br>\n    return <code>[6, 7, 6, 0, 4]</code>\n</p>\n<p>\n    <b>Example 3:</b><br>\n</p>\n<p>\n    nums1 = <code>[3, 9]</code><br>\n    nums2 = <code>[8, 9]</code><br>\n    k = <code>3</code><br>\n    return <code>[9, 8, 9]</code>\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '322',
    name: 'Coin Change',
    acceptance: '26.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nYou are given coins of different denominations and a total amount of money <i>amount</i>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.\n</p>\n\n<p>\n<b>Example 1:</b><br>\ncoins = <code>[1, 2, 5]</code>, amount = <code>11</code><br>\nreturn <code>3</code> (11 = 5 + 5 + 1)\n</p>\n\n<p>\n<b>Example 2:</b><br>\ncoins = <code>[2]</code>, amount = <code>3</code><br>\nreturn <code>-1</code>.\n</p>\n\n<p>\n<b>Note</b>:<br>\nYou may assume that you have an infinite number of each kind of coin.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute force) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-dynamic-programming-top-down-accepted">Approach #2 (Dynamic programming - Top down) [Accepted]</a></li>\n<li><a href="#approach-3-dynamic-programming-bottom-up-accepted">Approach #3 (Dynamic programming - Bottom up) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This article is for intermediate users. It introduces the following ideas:\nBacktracking, Dynamic programming.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 (Brute force) [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>The problem could be modeled as the following optimization problem :\n<script type="math/tex; mode=display">\n\\min_{x} \\sum_{i=0}^{n - 1} x_i \\\\\n\\text{subject to} \\sum_{i=0}^{n - 1} x_i*c_i = S\n</script>\n</p>\n<p>, where <script type="math/tex; mode=display">S</script> is the amount,    <script type="math/tex; mode=display">c_i</script> is the coin denominations, <script type="math/tex; mode=display">x_i</script>  is the number of coins with denominations <script type="math/tex; mode=display">c_i</script> used in change of amount <script type="math/tex; mode=display">S</script>. We could easily see that <script type="math/tex; mode=display">x_i = [{0, \\frac{S}{c_i}}]</script>.</p>\n<p>A trivial solution is to enumerate all subsets of coin frequencies <script type="math/tex; mode=display">[x_0\\dots\\ x_{n - 1}]</script>  that satisfy the constraints above, compute their sums and return the minimum among them.</p>\n<p><strong>Algorithm</strong></p>\n<p>To apply this idea, the algorithm uses backtracking technique to generate all combinations of coin frequencies <script type="math/tex; mode=display">[x_0\\dots\\ x_{n-1}]</script> in the range <script type="math/tex">[{0, \\frac{S}{c_i}}]</script> which satisfy the constraints above. It makes a sum of the combinations and returns their minimum or <script type="math/tex; mode=display">-1</script> in case there is no acceptable combination.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>    \n\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">coinChange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">return</span> <span class="n">coinChange</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">coins</span><span class="o">,</span> <span class="n">amount</span><span class="o">);</span>\n    <span class="o">}</span>\n\n    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">coinChange</span><span class="o">(</span><span class="kt">int</span> <span class="n">idxCoin</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>\n            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">idxCoin</span> <span class="o">&lt;</span> <span class="n">coins</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">maxVal</span> <span class="o">=</span> <span class="n">amount</span><span class="o">/</span><span class="n">coins</span><span class="o">[</span><span class="n">idxCoin</span><span class="o">];</span>\n            <span class="kt">int</span> <span class="n">minCost</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">maxVal</span><span class="o">;</span> <span class="n">x</span><span class="o">++)</span> <span class="o">{</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">&gt;=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">coins</span><span class="o">[</span><span class="n">idxCoin</span><span class="o">])</span> <span class="o">{</span>\n                    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">coinChange</span><span class="o">(</span><span class="n">idxCoin</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">coins</span><span class="o">,</span> <span class="n">amount</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">coins</span><span class="o">[</span><span class="n">idxCoin</span><span class="o">]);</span>\n                    <span class="k">if</span> <span class="o">(</span><span class="n">res</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>\n                        <span class="n">minCost</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minCost</span><span class="o">,</span> <span class="n">res</span> <span class="o">+</span> <span class="n">x</span><span class="o">);</span>\n                <span class="o">}</span>                    \n            <span class="o">}</span>           \n            <span class="k">return</span> <span class="o">(</span><span class="n">minCost</span> <span class="o">==</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)?</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span> <span class="n">minCost</span><span class="o">;</span>\n        <span class="o">}</span>        \n        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>\n    <span class="o">}</span>  \n<span class="o">}</span>\n\n<span class="c1">// Time Limit Exceeded</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(S^n)</script>. In the worst case, complexity is exponential in the number of the coins <script type="math/tex; mode=display">n</script>. The reason is that every coin denomination <script type="math/tex; mode=display">c_i</script> could have at most <script type="math/tex; mode=display">\\frac{S}{c_i}</script> values. Therefore the number of possible combinations is :</li>\n</ul>\n<p>\n<script type="math/tex; mode=display">\n\\frac{S}{c_1}*\\frac{S}{c_2}*\\frac{S}{c_3}\\ldots\\frac{S}{c_n} = \\frac{S^{n}}{{c_1}*{c_2}*{c_3}\\ldots{c_n}}\n</script>\n</p>\n<ul>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>.\nIn the worst case the maximum depth of recursion is <script type="math/tex; mode=display">n</script>. Therefore we need <script type="math/tex; mode=display">O( n)</script> space used by the system recursive stack.</li>\n</ul>\n<hr>\n<h4 id="approach-2-dynamic-programming-top-down-accepted">Approach #2 (Dynamic programming - Top down) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Could we improve the exponential solution above? Definitely! The problem could be solved with polynomial time using Dynamic programming technique. First, let\'s define:</p>\n<blockquote>\n<p>\n<script type="math/tex; mode=display">F(S)</script> - minimum number of coins needed to make change for amount <script type="math/tex; mode=display">S</script> using coin denominations <script type="math/tex; mode=display">[{c_0\\ldots c_{n-1}}]</script>\n</p>\n</blockquote>\n<p>We note that this problem has an optimal substructure property, which is the key piece in solving any Dynamic Programming problems. In other words, the optimal solution can be constructed from optimal solutions of its subproblems.\nHow to split the problem into subproblems? Let\'s assume that we know <script type="math/tex; mode=display">F(S)</script> where some change <script type="math/tex; mode=display">val_1, val_2, \\ldots</script> for <script type="math/tex; mode=display">S</script> which is optimal and the last coin\'s denomination is <script type="math/tex; mode=display">C</script>.\nThen the following equation should be true because of optimal substructure of the problem:</p>\n<p>\n<script type="math/tex; mode=display">\nF(S) = F(S - C) + 1\n</script>\n</p>\n<p>But we don\'t know which is the denomination of the last coin <script type="math/tex; mode=display">C</script>. We compute  <script type="math/tex; mode=display">F(S - c_i)</script> for each possible denomination <script type="math/tex; mode=display">c_0, c_1, c_2 \\ldots c_{n -1}</script> and choose the minimum among them. The following recurrence relation holds:</p>\n<p>\n<script type="math/tex; mode=display">\nF(S) = \\min_{i=0 ... n-1} { F(S - c_i) } + 1 \\\\\n\\text{subject to} \\ \\  S-c_i \\geq 0 \\\\\n</script>\n</p>\n<p>\n<script type="math/tex; mode=display">\nF(S) = 0 \\ , \\text{when} \\ S = 0 \\\\\nF(S) = -1 \\ , \\text{when} \\ n = 0\n</script>\n</p>\n<p align="center"><img alt="Recursion tree for finding coin change of amount 6 with coin denominations {1,2,3}." src="https://leetcode.com/media/original_images/322_coin_change_tree.png" width="100%"></p>\n<p>In the recursion tree above, we could see that a lot of subproblems were calculated multiple times.  For example the problem <script type="math/tex; mode=display">F(1)</script> was calculated <script type="math/tex; mode=display">13</script> times. Therefore we should cache the solutions to the subproblems in a table and access them in constant time when necessary</p>\n<p><strong>Algorithm</strong></p>\n<p>The idea of the algorithm is to build the solution of the problem from top to bottom. It applies the idea described above. It use backtracking and cut the partial solutions in the recursive tree, which doesn\'t lead to a viable solution. Тhis happens when we try to make a change of a coin with a value greater than the amount <em><script type="math/tex; mode=display">S</script></em>. To improve  time complexity we should store the solutions of the already calculated subproblems in a table.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">coinChange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>        \n        <span class="k">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">return</span> <span class="n">coinChange</span><span class="o">(</span><span class="n">coins</span><span class="o">,</span> <span class="n">amount</span><span class="o">,</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">amount</span><span class="o">]);</span>\n    <span class="o">}</span>\n\n    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">coinChange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">rem</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">rem</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">rem</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">rem</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">count</span><span class="o">[</span><span class="n">rem</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>\n        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">coin</span> <span class="o">:</span> <span class="n">coins</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">coinChange</span><span class="o">(</span><span class="n">coins</span><span class="o">,</span> <span class="n">rem</span> <span class="o">-</span> <span class="n">coin</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">res</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="n">min</span><span class="o">)</span>\n                <span class="n">min</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">res</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="n">count</span><span class="o">[</span><span class="n">rem</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">min</span> <span class="o">==</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">min</span><span class="o">;</span>\n        <span class="k">return</span> <span class="n">count</span><span class="o">[</span><span class="n">rem</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(S*n)</script>. where S is the amount, n is denomination count.\nIn the worst case the recursive tree of the algorithm has height of <script type="math/tex; mode=display">S</script> and the algorithm  solves only <script type="math/tex; mode=display">S</script> subproblems because it caches precalculated solutions in a table. Each subproblem is computed with  <script type="math/tex; mode=display">n</script> iterations, one by coin denomination. Therefore there is <script type="math/tex; mode=display">O(S*n)</script> time complexity.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(S)</script>, where <script type="math/tex; mode=display">S</script> is the amount to change\nWe use extra space for the memoization table.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-dynamic-programming-bottom-up-accepted">Approach #3 (Dynamic programming - Bottom up) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>For the iterative solution, we think in bottom-up manner. Before calculating <em><script type="math/tex; mode=display">F(i)</script></em>, we have to compute all minimum counts for amounts up to <script type="math/tex; mode=display">i</script>. On each iteration <script type="math/tex; mode=display">i</script> of the algorithm <em><script type="math/tex; mode=display">F(i)</script></em> is computed as <script type="math/tex; mode=display">\\min_{j=0 \\ldots n-1}{F(i -c_j)} + 1</script>\n</p>\n<p align="center"><img alt="Bottom-up approach using a table to build up the solution to F6." src="https://leetcode.com/media/original_images/322_coin_change_table.png" width="539px"></p>\n<p>In the example above you can see that:</p>\n<p>\n<script type="math/tex; mode=display">\n\\begin{align}\nF(3) &= \\min\\{{F(3- c_1), F(3-c_2), F(3-c_3)}\\} + 1 \\\\\n&= \\min\\{{F(3- 1), F(3-2), F(3-3)}\\} + 1 \\\\\n&= \\min\\{{F(2), F(1), F(0)}\\} + 1 \\\\\n&= \\min\\{{1, 1, 0}\\} + 1 \\\\\n&= 1\n\\end{align}\n</script>\n</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">coinChange</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">coins</span><span class="o">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>             \n        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>  \n        <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>  \n        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>   \n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">amount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">coins</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">coins</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>\n                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">coins</span><span class="o">[</span><span class="n">j</span><span class="o">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n                <span class="o">}</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">amount</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">amount</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">dp</span><span class="o">[</span><span class="n">amount</span><span class="o">];</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(S*n)</script>.\nOn each step the algorithm finds the next <em><script type="math/tex; mode=display">F(i)</script></em> in <script type="math/tex; mode=display">n</script> iterations, where <script type="math/tex; mode=display">1\\leq i \\leq S</script>. Therefore in total the iterations are <script type="math/tex; mode=display">S*n</script>.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(S)</script>.\nWe use extra space for the memoization table.</li>\n</ul>\n<p>Analysis written by: @elmirap.</p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '323',
    name: 'Number of Connected Components in an Undirected Graph ',
    acceptance: '48.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.\n</p>\n\n<p>\n    <b>Example 1:</b><br>\n</p>\n<pre>     0          3\n     |          |\n     1 --- 2    4\n</pre>\n<p>\n    Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [3, 4]]</code>, return <code>2</code>.\n</p>\n<p>\n    <b>Example 2:</b><br>\n</p>\n<pre>     0           4\n     |           |\n     1 --- 2 --- 3\n</pre>\n<p>\n    Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [2, 3], [3, 4]]</code>, return <code>1</code>.\n</p>\n\n<p>\n<b>Note:</b><br>\nYou can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in <code>edges</code>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Twitter'],
  },
  {
    id: '324',
    name: 'Wiggle Sort II',
    acceptance: '26.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\n    Given an unsorted array <code>nums</code>, reorder it such that\n    <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.\n</p>\n\n<p>\n    <b>Example:</b><br>\n    (1) Given <code>nums = [1, 5, 1, 1, 6, 4]</code>, one possible answer is <code>[1, 4, 1, 5, 1, 6]</code>. <br>\n    (2) Given <code>nums = [1, 3, 2, 2, 3, 1]</code>, one possible answer is <code>[2, 3, 1, 3, 1, 2]</code>.\n</p>\n\n<p>\n    <b>Note:</b><br>\n    You may assume all input has valid answer.\n</p>\n\n<p>\n    <b>Follow Up:</b><br>\n    Can you do it in O(n) time and/or in-place with O(1) extra space?\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '325',
    name: 'Maximum Size Subarray Sum Equals k ',
    acceptance: '43.1%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nGiven an array <i>nums</i> and a target value <i>k</i>, find the maximum length of a subarray that sums to <i>k</i>. If there isn't one, return 0 instead.\n</p>\n\n<p>\n    <b>Note:</b><br>\nThe sum of the entire <i>nums</i> array is guaranteed to fit within the 32-bit signed integer range.\n</p>\n\n<p>\n    <b>Example 1:</b><br>\n</p>\n<p>\nGiven <i>nums</i> = <code>[1, -1, 5, -2, 3]</code>, <i>k</i> = <code>3</code>,<br>\nreturn <code>4</code>. (because the subarray <code>[1, -1, 5, -2]</code> sums to 3 and is the longest)\n</p>\n\n<p>\n    <b>Example 2:</b><br>\n</p>\n<p>\nGiven <i>nums</i> = <code>[-2, -1, 2, 1]</code>, <i>k</i> = <code>1</code>,<br>\nreturn <code>2</code>. (because the subarray <code>[-1, 2]</code> sums to 1 and is the longest)\n</p>\n\n<p>\n    <b>Follow Up:</b><br>\n    Can you do it in O(<i>n</i>) time?\n</p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook', 'Palantir'],
  },
  {
    id: '326',
    name: 'Power of Three',
    acceptance: '40.5%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\n    Given an integer, write a function to determine if it is a power of three.\n</p>\n<p>\n    <b>Follow up:</b><br>\n    Could you do it without using any loop / recursion?\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-loop-iteration-accepted">Approach #1 Loop Iteration [Accepted]</a></li>\n<li><a href="#approach-2-base-conversion-accepted">Approach #2 Base Conversion [Accepted]</a></li>\n<li><a href="#approach-3-mathematics-accepted">Approach #3 Mathematics [Accepted]</a></li>\n<li><a href="#approach-4-integer-limitations-accepted">Approach #4 Integer Limitations [Accepted]</a></li>\n</ul>\n</li>\n<li><a href="#performance-measurements">Performance Measurements</a></li>\n<li><a href="#conclusion">Conclusion</a></li>\n<li><a href="#references">References</a></li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<p>In this article we will look into ways of speeding up simple computations and why that is useful in practice.</p>\n<hr>\n<h4 id="approach-1-loop-iteration-accepted">Approach #1 Loop Iteration [Accepted]</h4>\n<p>One simple way of finding out if a number <code>n</code> is a power of a number <code>b</code> is to keep dividing <code>n</code> by <code>b</code> as long as the remainder is <strong>0</strong>. This is because we can write</p>\n<p>\n<script type="math/tex; mode=display">\n\\begin{align*}\nn &= b^x \\\\\nn &= b \\times b \\times \\ldots \\times b\n\\end{align*}\n</script>\n</p>\n<p>Hence it should be possible to divide <code>n</code> by <code>b</code> <code>x</code> times, every time with a remainder of <strong>0</strong> and the end result to be <strong>1</strong>.</p>\n<iframe frameborder="0" height="275" name="oqtKkauN" src="https://leetcode.com/playground/oqtKkauN/shared" width="100%"></iframe>\n<p>Notice that we need a guard to check that <code>n != 0</code>, otherwise the while loop will never finish. For negative numbers, the algorithm does not make sense, so we will include this guard as well.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(log_b(n))</script>. In our case that is <script type="math/tex; mode=display">O(log_3n)</script>. The number of divisions is given by that logarithm.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. We are not using any additional memory.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-base-conversion-accepted">Approach #2 Base Conversion [Accepted]</h4>\n<p>In Base 10, all powers of 10 start with the digit <strong>1</strong> and then are followed only by <strong>0</strong> (e.g. 10, 100, 1000). This is true for other bases and their respective powers. For instance in <em>base 2</em>, the representations of <script type="math/tex; mode=display">10_2</script>, <script type="math/tex; mode=display">100_2</script> and <script type="math/tex; mode=display">1000_2</script> are <script type="math/tex; mode=display">2_{10}</script>, <script type="math/tex; mode=display">4_{10}</script> and <script type="math/tex; mode=display">8_{10}</script> respectively. Therefore if we convert our number to base 3 and the representation is of the form 100...0, then the number is a power of 3.</p>\n<p><strong>Proof</strong></p>\n<p>Given the base 3 representation of a number as the array <code>s</code>, with the least significant digit on index 0, the formula for converting from base <strong>3</strong> to base <strong>10</strong> is:</p>\n<p>\n<script type="math/tex; mode=display">\n\\sum_{i=0}^{len(s) - 1} s[i] * 3^{i}\n</script>\n</p>\n<p>Therefore, having just one digit of <strong>1</strong> and everything else <strong>0</strong> means the number is a power of 3.</p>\n<p><strong>Implementation</strong></p>\n<p>All we need to do is convert <sup>[4]</sup> the number to <em>base 3</em> and check if it is written as a leading <strong>1</strong> followed by all <strong>0</strong>.</p>\n<p>A couple of built-in Java functions will help us along the way.</p>\n<iframe frameborder="0" height="71" name="JHQszU9Y" src="https://leetcode.com/playground/JHQszU9Y/shared" width="100%"></iframe>\n<p>The code above converts <code>number</code> into base <code>base</code> and returns the result as a <code>String</code>. For example, <code>Integer.toString(5, 2) == "101"</code> and <code>Integer.toString(5, 3) == "12"</code>.</p>\n<iframe frameborder="0" height="71" name="whcADo6Z" src="https://leetcode.com/playground/whcADo6Z/shared" width="100%"></iframe>\n<p>The code above checks if a certain <strong>Regular Expression</strong><sup>[2]</sup> pattern exists inside a string. For instance the above will return true if the substring "123" exists inside the string <code>myString</code>.</p>\n<iframe frameborder="0" height="71" name="dQUs9bjm" src="https://leetcode.com/playground/dQUs9bjm/shared" width="100%"></iframe>\n<p>We will use the regular expression above for checking if the string starts with <strong>1</strong> <code>^1</code>, is followed by zero or more <strong>0</strong>s <code>0*</code> and contains nothing else <code>$</code>.</p>\n<iframe frameborder="0" height="139" name="NhaMEsdz" src="https://leetcode.com/playground/NhaMEsdz/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(log_3n)</script>.</p>\n<p>Assumptions:</p>\n<ul>\n<li><code>Integer.toString()</code> - Base conversion is generally implemented as a repeated division. The complexity of  should be similar to our approach #1: <script type="math/tex; mode=display">O(log_3n)</script>.</li>\n<li><code>String.matches()</code> - Method iterates over the entire string. The number of digits in the base 3 representation of <code>n</code> is <script type="math/tex; mode=display">O(log_3n)</script>.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(log_3n)</script>.</p>\n<p>We are using two additional variables,</p>\n<ul>\n<li>The string of the base 3 representation of the number (size <script type="math/tex; mode=display">log_3n</script>)</li>\n<li>The string of the regular expression (constant size)</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-mathematics-accepted">Approach #3 Mathematics [Accepted]</h4>\n<p>We can use mathematics as follows</p>\n<p>\n<script type="math/tex; mode=display">\nn = 3^i \\\\\ni = log_3(n) \\\\\ni = \\frac{log_b(n)}{log_b(3)}\n</script>\n</p>\n<p><code>n</code> is a power of three if and only if <code>i</code> is an integer. In Java, we check if a number is an integer by taking the decimal part (using <code>% 1</code>) and checking if it is 0.</p>\n<iframe frameborder="0" height="139" name="rfdsFHXp" src="https://leetcode.com/playground/rfdsFHXp/shared" width="100%"></iframe>\n<p><strong>Common pitfalls</strong></p>\n<p>This solution is problematic because we start using <code>double</code>s, which means we are subject to precision errors. This means, we should never use <code>==</code> when comparing <code>double</code>s. That is because the result of <code>Math.log10(n) / Math.log10(3)</code> could be <code>5.0000001</code> or <code>4.9999999</code>. This effect can be observed by using the function <code>Math.log()</code> instead of <code>Math.log10()</code>.</p>\n<p>In order to fix that, we need to compare the result against an <code>epsilon</code>.</p>\n<iframe frameborder="0" height="71" name="NsNRPhpt" src="https://leetcode.com/playground/NsNRPhpt/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">Unknown</script> The expensive operation here is <code>Math.log</code>, which upper bounds the time complexity of our algorithm. The implementation is dependent on the language we are using and the compiler<sup>[3]</sup></p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. We are not using any additional memory. The <code>epsilon</code> variable can be inlined.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-integer-limitations-accepted">Approach #4 Integer Limitations [Accepted]</h4>\n<p>An important piece of information can be deduced from the function signature</p>\n<iframe frameborder="0" height="71" name="9YvN5pNn" src="https://leetcode.com/playground/9YvN5pNn/shared" width="100%"></iframe>\n<p>In particular, <code>n</code> is of type <code>int</code>. In Java, this means it is a 4 byte, signed integer [ref]. The maximum value of this data type is <strong>2147483647</strong>. Three ways of calculating this value are</p>\n<ul>\n<li><a href="https://stackoverflow.com/questions/15004944/max-value-of-integer">Google</a></li>\n<li><code>System.out.println(Integer.MAX_VALUE);</code></li>\n<li>MaxInt = <script type="math/tex; mode=display">\\frac{ 2^{32} }{2} - 1</script> since we use 32 bits to represent the number, half of the range is used for negative numbers and 0 is part of the positive numbers</li>\n</ul>\n<p>Knowing the limitation of <code>n</code>, we can now deduce that the maximum value of <code>n</code> that is also a power of three is <strong>1162261467</strong>. We calculate this as:</p>\n<p>\n<script type="math/tex; mode=display">\n3^{\\lfloor{}log_3{MaxInt}\\rfloor{}} = 3^{\\lfloor{}19.56\\rfloor{}} = 3^{19} = 1162261467\n</script>\n</p>\n<p>Therefore, the possible values of <code>n</code> where we should return <code>true</code> are <script type="math/tex; mode=display">3^0</script>, <script type="math/tex; mode=display">3^1</script> ... <script type="math/tex; mode=display">3^{19}</script>. Since 3 is a prime number, the only divisors of <script type="math/tex; mode=display">3^{19}</script> are <script type="math/tex; mode=display">3^0</script>, <script type="math/tex; mode=display">3^1</script> ... <script type="math/tex; mode=display">3^{19}</script>, therefore all we need to do is divide <script type="math/tex; mode=display">3^{19}</script> by <code>n</code>. A remainder of <strong>0</strong> means <code>n</code> is a divisor of <script type="math/tex; mode=display">3^{19}</script> and therefore a power of three.</p>\n<iframe frameborder="0" height="139" name="nFdyeL8J" src="https://leetcode.com/playground/nFdyeL8J/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script>. We are only doing one operation.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. We are not using any additional memory.</p>\n</li>\n</ul>\n<h2 id="performance-measurements">Performance Measurements</h2>\n<p>Single runs of the function make it is hard to accurately measure the difference of the two solutions. On LeetCode, on the <em>Accepted Solutions Runtime Distribution</em> page, all solutions being between <code>15 ms</code> and <code>20 ms</code>. For completeness, we have proposed the following benchmark to see how the two solutions differ.</p>\n<p><strong>Java Benchmark Code</strong>\n<iframe frameborder="0" height="173" name="DrxGaCVC" src="https://leetcode.com/playground/DrxGaCVC/shared" width="100%"></iframe></p>\n<p>In the table below, the values are in seconds.</p>\n<table>\n<thead>\n<tr>\n<th align="center">Iterations</th>\n<th align="center">\n<script type="math/tex; mode=display">10^6</script>\n</th>\n<th align="center">\n<script type="math/tex; mode=display">10^7</script>\n</th>\n<th align="center">\n<script type="math/tex; mode=display">10^8</script>\n</th>\n<th align="center">\n<script type="math/tex; mode=display">10^9</script>\n</th>\n<th align="center">\n<script type="math/tex; mode=display">Maxint</script>\n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">Java Approach #1 (Naive)</td>\n<td align="center">0.04</td>\n<td align="center">0.07</td>\n<td align="center">0.30</td>\n<td align="center">2.47</td>\n<td align="center">5.26</td>\n</tr>\n<tr>\n<td align="center">Java Approach #2 (Strings)</td>\n<td align="center">0.68</td>\n<td align="center">4.02</td>\n<td align="center">38.90</td>\n<td align="center">409.16</td>\n<td align="center">893.89</td>\n</tr>\n<tr>\n<td align="center">Java Approach #3 (Logarithms)</td>\n<td align="center">0.09</td>\n<td align="center">0.50</td>\n<td align="center">4.59</td>\n<td align="center">45.53</td>\n<td align="center">97.50</td>\n</tr>\n<tr>\n<td align="center">Java Approach #4 (Fast)</td>\n<td align="center">0.04</td>\n<td align="center">0.06</td>\n<td align="center">0.08</td>\n<td align="center">0.41</td>\n<td align="center">0.78</td>\n</tr>\n</tbody>\n</table>\n<p>As we can see, for small values of N, the difference is not noticeable, but as we do more iterations and the values of <code>n</code> passed to <code>isPowerOfThree()</code> grow, we see significant boosts in performance for Approach #4.</p>\n<h2 id="conclusion">Conclusion</h2>\n<p>Simple optimizations like this might seem negligible, but historically, when computation power was an issue, it allowed certain computer programs (such as Quake 3<sup>[1]</sup>) possible.</p>\n<h2 id="references">References</h2>\n<ul>\n<li>[1] <a href="https://en.wikipedia.org/wiki/Fast_inverse_square_root">https://en.wikipedia.org/wiki/Fast_inverse_square_root</a></li>\n<li>[2] <a href="https://en.wikipedia.org/wiki/Regular_expression">https://en.wikipedia.org/wiki/Regular_expression</a></li>\n<li>[3] <a href="http://developer.classpath.org/doc/java/lang/StrictMath-source.html">http://developer.classpath.org/doc/java/lang/StrictMath-source.html</a></li>\n<li>[4] <a href="http://www.cut-the-knot.org/recurrence/conversion.shtml">http://www.cut-the-knot.org/recurrence/conversion.shtml</a></li>\n</ul>\n<p>Analysis written by: <a href="http://andrei.cioara.me">@aicioara</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '327',
    name: 'Count of Range Sum',
    acceptance: '30.3%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\n    Given an integer array <code>nums</code>, return the number of range sums that lie in <code>[lower, upper]</code> inclusive.<br>\n\n    Range sum <code>S(i, j)</code> is defined as the sum of the elements in <code>nums</code> between indices <code>i</code> and \n    <code>j</code> (<code>i</code> ≤ <code>j</code>), inclusive.\n</p>\n\n<p>\n    <b>Note:</b><br>\n    A naive algorithm of <i>O</i>(<i>n</i><sup>2</sup>) is trivial. You MUST do better than that.\n</p>\n<p>\n    <b>Example:</b><br>\n    Given <i>nums</i> = <code>[-2, 5, -1]</code>, <i>lower</i> = <code>-2</code>, <i>upper</i> = <code>2</code>,<br>\n    Return <code>3</code>.<br>\n    The three ranges are : <code>[0, 0]</code>, <code>[2, 2]</code>, <code>[0, 2]</code> and their respective sums are: <code>-2, -1, 2</code>.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '328',
    name: 'Odd Even Linked List',
    acceptance: '44.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>\n\n<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p><p>\n\n</p><p>\n<b>Example:</b><br>\nGiven <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>,<br>\nreturn <code>1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</code>.\n</p>\n<p>\n<b>Note:</b><br>\nThe relative order inside both the even and odd groups should remain as it was in the input. <br>\nThe first node is considered odd, the second node even and so on ...\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/DjangoUnchained">@DjangoUnchained</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<h2 id="solution">Solution</h2>\n<p><strong>Intuition</strong></p>\n<p>Put the odd nodes in a linked list and the even nodes in another. Then link the evenList to the tail of the oddList.</p>\n<p><strong>Algorithm</strong></p>\n<p>The solution is very intuitive. But it is not trivial to write a concise and bug-free code.</p>\n<p>A well-formed <code>LinkedList</code> need two pointers head and tail to support operations at both ends. The variables <code>head</code> and <code>odd</code> are the head pointer and tail pointer of one <code>LinkedList</code> we call oddList; the variables <code>evenHead</code> and <code>even</code> are the head pointer and tail pointer of another <code>LinkedList</code> we call evenList. The algorithm traverses the original LinkedList and put the odd nodes into the oddList and the even nodes into the evenList. To traverse a LinkedList we need at least one pointer as an iterator for the current node. But here the pointers <code>odd</code> and <code>even</code> not only serve as the tail pointers but also act as the iterators of the original list.</p>\n<p>The best way of solving any linked list problem is to visualize it either in your mind or on a piece of paper. An illustration of our algorithm is following:</p>\n<p align="center"><img alt="Illustration of odd even linked list" src="https://leetcode.com/articles/Figures/328_Odd_Even.svg" title="Odd Even Linked List" width="539px"></p>\n<p align="center"><em>Figure 1. Step by step example of the odd and even linked list.</em></p>\n<iframe frameborder="0" height="293" name="hwsGSV9j" src="https://leetcode.com/playground/hwsGSV9j/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. There are total <script type="math/tex; mode=display">n</script> nodes and we visit each node once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. All we need is the four pointers.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: [],
  },
  {
    id: '329',
    name: 'Longest Increasing Path in a Matrix',
    acceptance: '36.9%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given an integer matrix, find the length of the longest increasing path.</p>\n\n<p>\nFrom each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>\n\n<p>\n<b>Example 1:</b>\n</p><pre>nums = [\n  [<font color="red">9</font>,9,4],\n  [<font color="red">6</font>,6,8],\n  [<font color="red">2</font>,<font color="red">1</font>,1]\n]\n</pre>\n<p></p>\n\n<p>\nReturn <code>4</code><br>\n\nThe longest increasing path is <code>[1, 2, 6, 9]</code>.</p>\n\n<p>\n<b>Example 2:</b>\n</p><pre>nums = [\n  [<font color="red">3</font>,<font color="red">4</font>,<font color="red">5</font>],\n  [3,2,<font color="red">6</font>],\n  [2,2,1]\n]\n</pre>\n<p></p>\n\n<p>\nReturn <code>4</code><br>\n\nThe longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-naive-dfs-time-limit-exceeded">Approach #1 (Naive DFS) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-dfs-memoization-accepted">Approach #2 (DFS + Memoization) [Accepted]</a></li>\n<li><a href="#approach-3-peeling-onion-accepted">Approach #3 (Peeling Onion) [Accepted]</a></li>\n</ul>\n</li>\n<li><a href="#remarks">Remarks</a></li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This article is for advanced readers. It introduces the following ideas:\nDepth First Search (DFS), Memoization, Dynamic programming, Topological Sorting. It explains the relation between dynamic programming and topological sorting.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-naive-dfs-time-limit-exceeded">Approach #1 (Naive DFS) [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>DFS can find the longest increasing path starting from any cell. We can do this for all the cells.</p>\n<p><strong>Algorithm</strong></p>\n<p>Each cell can be seen as a vertex in a graph <script type="math/tex; mode=display">G</script>. If two adjacent cells have value <script type="math/tex; mode=display">a < b</script>, i.e. increasing then we have a directed edge <script type="math/tex; mode=display">(a, b)</script>. The problem then becomes:</p>\n<blockquote>\n<p>Search the longest path in the directed graph <script type="math/tex; mode=display">G</script>.</p>\n</blockquote>\n<p>Naively, we can use DFS or BFS to visit all the cells connected starting from a root. We update the maximum length of the path during search and find the answer when it finished.</p>\n<p>Usually, in DFS or BFS, we can employ a set <code>visited</code> to prevent the cells from duplicate visits. We will introduce a better algorithm based on this in the next section.</p>\n<iframe frameborder="0" height="515" name="fTW4zmop" src="https://leetcode.com/playground/fTW4zmop/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(2^{m+n})</script>. The search is repeated for each valid increasing path. In the worst case we can have <script type="math/tex; mode=display">O(2^{m+n})</script> calls. For example:</li>\n</ul>\n<iframe frameborder="0" height="173" name="dVdd7KB8" src="https://leetcode.com/playground/dVdd7KB8/shared" width="100%"></iframe>\n<ul>\n<li>Space complexity : <script type="math/tex; mode=display">O(mn)</script>. For each DFS we need <script type="math/tex; mode=display">O(h)</script> space used by the system stack, where <script type="math/tex; mode=display">h</script> is the maximum depth of the recursion. In the worst case, <script type="math/tex; mode=display">O(h) = O(mn)</script>.</li>\n</ul>\n<hr>\n<h4 id="approach-2-dfs-memoization-accepted">Approach #2 (DFS + Memoization) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Cache the results for the recursion so that any subproblem will be calculated only once.</p>\n<p><strong>Algorithm</strong></p>\n<p>From previous analysis, we know that there are many duplicate calculations in the naive approach.</p>\n<p>One optimization is that we can use a set to prevent the repeat visit in one DFS search. This optimization will reduce the time complexity for each DFS to <script type="math/tex; mode=display">O(mn)</script> and the total algorithm to <script type="math/tex; mode=display">O(m^2n^2)</script>.</p>\n<p>Here, we will introduce more powerful optimization, Memoization.</p>\n<blockquote>\n<p>In computing, memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.</p>\n</blockquote>\n<p>In our problem, we recursively call <code>dfs(x, y)</code> for many times. But if we already know all the results for the four adjacent cells, we only need constant time. During our search if the result for a cell is not calculated, we calculate and cache it; otherwise, we get it from the cache directly.</p>\n<iframe frameborder="0" height="513" name="k7MmgcpJ" src="https://leetcode.com/playground/k7MmgcpJ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(mn)</script>. Each vertex/cell will be calculated once and only once, and each edge will be visited once and only once. The total time complexity is then <script type="math/tex; mode=display">O(V+E)</script>. <script type="math/tex; mode=display">V</script> is the total number of vertices and <script type="math/tex; mode=display">E</script> is the total number of edges. In our problem, <script type="math/tex; mode=display">O(V) = O(mn)</script>, <script type="math/tex; mode=display">O(E) = O(4V) = O(mn)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>. The cache dominates the space complexity.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-peeling-onion-accepted">Approach #3 (Peeling Onion) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>The result of each cell only related to the result of its neighbors. Can we use dynamic programming?</p>\n<p><strong>Algorithm</strong></p>\n<p>If we define the longest increasing path starting from cell <script type="math/tex; mode=display">(i, j)</script> as a function</p>\n<p>\n<script type="math/tex; mode=display">\nf(i, j)\n</script>\n</p>\n<p>then we have the following transition function</p>\n<p>\n<script type="math/tex; mode=display">\nf(i, j) = max\\{f(x, y)| (x, y)~\\mathrm{is~a~neighbor~of} (i, j)~\\mathrm{and} ~\\mathrm{matrix}[x][y] \\gt \\mathrm{matrix}[i][j]\\} + 1\n</script>\n</p>\n<p>This formula is the same as used in the previous approaches. With such transition function, one may think that it is possible to use dynamic programming to deduce all the results without employing DFS!</p>\n<p>That is right with one thing missing: we don\'t have the dependency list.</p>\n<p>For dynamic programming to work, if problem B depends on the result of problem A, then we must make sure that problem A is calculated before problem B. Such order is natural and obvious for many problems. For example the famous Fibonacci sequence:</p>\n<p>\n<script type="math/tex; mode=display">\nF(0) = 1, F(1) = 1, F(n) = F(n - 1) + F(n - 2)\n</script>\n</p>\n<p>The subproblem <script type="math/tex; mode=display">F(n)</script> depends on its two predecessors. Therefore, the natural order from 0 to n is the correct order. The dependent is always behind the dependee.</p>\n<p>The terminology of such dependency order is "Topological order" or "Topological sorting":</p>\n<blockquote>\n<p>Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge <script type="math/tex; mode=display">(u, v)</script>, vertex <script type="math/tex; mode=display">u</script> comes before <script type="math/tex; mode=display">v</script> in the ordering.</p>\n</blockquote>\n<p>In our problem, the topological order is not natural. Without the value in the matrix, we couldn\'t know the dependency relation of any two neighbors A and B. We have to perform the topological sort explicitly  as a preprocess. After that, we can solve the problem dynamically using our transition function following the stored topological order.</p>\n<p>There are several ways to perform the topological sorting. Here we employ one of them called "Peeling Onion".</p>\n<p>The idea is that in a DAG, we will have some vertex who doesn\'t depend on others which we call "leaves". We put these leaves in a list (their internal ordering does matter), and then we remove them from the DAG. After the removal, there will be new leaves. We do the same repeatedly as if we are peeling an onion layer by layer. In the end, the list will have a valid topological ordering of our vertices.</p>\n<p>In out problem, since we want the longest path in the DAG, which equals to the total number of layers of the "onion". Thus, we can count the number of layers during "peeling" and return the counts in the end without invoking dynamic programming.</p>\n<iframe frameborder="0" height="515" name="z5UXQnGD" src="https://leetcode.com/playground/z5UXQnGD/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(mn)</script>. The the topological sort is <script type="math/tex; mode=display">O(V+E) = O(mn)</script>.\nHere, <script type="math/tex; mode=display">V</script> is the total number of vertices and <script type="math/tex; mode=display">E</script> is the total number of edges. In our problem, <script type="math/tex; mode=display">O(V) = O(mn)</script>, <script type="math/tex; mode=display">O(E) = O(4V) = O(mn)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>. We need to store the out degrees and each level of leaves.</p>\n</li>\n</ul>\n<hr>\n<h2 id="remarks">Remarks</h2>\n<ul>\n<li>Memoization: for a problem with massive duplicate calls, cache the results.</li>\n<li>Dynamic programming requires the subproblem solved in topological order. In many problems, it coincides the natural order. For those who doesn\'t, one need perform topological sorting first. Therefore, for those problems with complex topology (like this one), search with memorization is usually an easier and better choice.</li>\n</ul>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '330',
    name: 'Patching Array',
    acceptance: '32.4%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given a sorted positive integer array <i>nums</i> and an integer <i>n</i>, add/patch elements to the array such that any number in range <code>[1, n]</code> inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.\n</p>\n\n<p><strong>Example 1:</strong><br>\n<i>nums</i> = <code>[1, 3]</code>, <i>n</i> = <code>6</code><br>\nReturn <code>1</code>.</p>\n\n<p>Combinations of <i>nums</i> are <code>[1], [3], [1,3]</code>, which form possible sums of: <code>1, 3, 4</code>.<br>\nNow if we add/patch <code>2</code> to <i>nums</i>, the combinations are: <code>[1], [2], [3], [1,3], [2,3], [1,2,3]</code>.<br>\nPossible sums are <code>1, 2, 3, 4, 5, 6</code>, which now covers the range <code>[1, 6]</code>.<br>\nSo we only need <code>1</code> patch.</p>\n\n<p><strong>Example 2:</strong><br>\n<i>nums</i> = <code>[1, 5, 10]</code>, <i>n</i> = <code>20</code><br>\nReturn <code>2</code>.<br>\nThe two patches can be <code>[2, 4]</code>.</p>\n\n<p><strong>Example 3:</strong><br>\n<i>nums</i> = <code>[1, 2, 2]</code>, <i>n</i> = <code>5</code><br>\nReturn <code>0</code>.<br>\n\n</p><p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<h2 id="solution">Solution</h2>\n<p><strong>Intuition</strong></p>\n<p>For any missing number, if we want to cover it, we have to add at least one number smaller or equal to that number. Otherwise, it will not be covered.\nImagine you want to give someone change of <script type="math/tex; mode=display">x</script> cents, and you don\'t have enough coins. You will need to ask for coin less than or equal to <script type="math/tex; mode=display">x</script>.</p>\n<p><strong>Algorithm</strong></p>\n<p>Suppose <code>miss</code> is the smallest missing number, then we know that <code>[1, miss)</code> (left-closed, right-open) is already covered . In order to cover <code>miss</code>, we have to add something smaller than or equal to <code>miss</code>. Otherwise, there is no way we can cover it.</p>\n<p>For example, you have any array <code>nums = [1,2,3,8]</code> and <code>n = 16</code>. The numbers already covered is in the ranges <code>[1, 6]</code> and <code>[8, 14]</code>. In other words, <code>7, 15, 16</code> are missing. If you add patches larger than <code>7</code>, then <code>7</code> is still missing.</p>\n<p>Suppose the number we added is <script type="math/tex; mode=display">x</script> then, the ranges <code>[1, miss)</code> and <code>[x, x + miss)</code> are both covered. And since we know that <code>x &lt;= miss</code>, the two ranges will cover the range <code>[1, x + miss)</code>. We want to choose <script type="math/tex; mode=display">x</script> as large as possible so that the range can cover as large as possible. Therefore, the best option is <code>x = miss</code>.</p>\n<p>After we covered <code>miss</code>, we can recalculate the coverage and see what\'s the new smallest missing number. We then patch that number. We do this repeatedly until no missing number.  </p>\n<p>Here is the recipe of this greedy algorithm:</p>\n<ul>\n<li>Initialize the range <code>[1, miss)</code> = <code>[1, 1)</code> = empty</li>\n<li>While n is not covered yet</li>\n<li>if the current element <code>nums[i]</code> is less than or equal to <code>miss</code><ul>\n<li>extends the range to <code>[1, miss + nums[i])</code></li>\n<li>increase <code>i</code> by 1</li>\n</ul>\n</li>\n<li>otherwise<ul>\n<li>patch the array with <code>miss</code>, extends the range to <code>[1, miss + miss)</code></li>\n<li>increase the number of patches</li>\n</ul>\n</li>\n<li>Return the number of patches  </li>\n</ul>\n<p><strong>Example:</strong></p>\n<p><code>nums = [1,2,3,8]</code> and <code>n = 80</code></p>\n<table>\n<thead>\n<tr>\n<th align="center">iteration</th>\n<th align="center"><code>miss</code></th>\n<th align="center">covered range</th>\n<th align="center"><code>i</code></th>\n<th align="center"><code>nums[i]</code></th>\n<th align="center">patches</th>\n<th>comment</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align="center">0</td>\n<td align="center">1</td>\n<td align="center">[1, 1)</td>\n<td align="center">0</td>\n<td align="center">1</td>\n<td align="center">0</td>\n<td></td>\n</tr>\n<tr>\n<td align="center">1</td>\n<td align="center">2</td>\n<td align="center">[1, 2)</td>\n<td align="center">1</td>\n<td align="center">2</td>\n<td align="center">0</td>\n<td></td>\n</tr>\n<tr>\n<td align="center">2</td>\n<td align="center">4</td>\n<td align="center">[1, 4)</td>\n<td align="center">2</td>\n<td align="center">3</td>\n<td align="center">0</td>\n<td></td>\n</tr>\n<tr>\n<td align="center">3</td>\n<td align="center">7</td>\n<td align="center">[1, 7)</td>\n<td align="center">3</td>\n<td align="center">8</td>\n<td align="center">0</td>\n<td></td>\n</tr>\n<tr>\n<td align="center">4</td>\n<td align="center">14</td>\n<td align="center">[1, 14)</td>\n<td align="center">3</td>\n<td align="center">8</td>\n<td align="center">1</td>\n<td>patch 7</td>\n</tr>\n<tr>\n<td align="center">5</td>\n<td align="center">22</td>\n<td align="center">[1, 22)</td>\n<td align="center">4</td>\n<td align="center">none</td>\n<td align="center">1</td>\n<td></td>\n</tr>\n<tr>\n<td align="center">6</td>\n<td align="center">44</td>\n<td align="center">[1, 44)</td>\n<td align="center">4</td>\n<td align="center">none</td>\n<td align="center">2</td>\n<td>patch 22</td>\n</tr>\n<tr>\n<td align="center">7</td>\n<td align="center">88</td>\n<td align="center">[1, 88)</td>\n<td align="center">4</td>\n<td align="center">none</td>\n<td align="center">3</td>\n<td>patch 44</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Correctness</strong></p>\n<p>One may ask how do you know this is correct? In this section, we will prove that the greedy algorithm always gives the smallest possible number of patches:</p>\n<p><em>Lemma</em></p>\n<blockquote>\n<p>If the greedy algorithm needs to patch <script type="math/tex; mode=display">k</script> numbers to cover <script type="math/tex; mode=display">[1, n]</script>, it is impossible to patch less than <script type="math/tex; mode=display">k</script> numbers to do the same.</p>\n</blockquote>\n<p><em>Proof by contradiction</em></p>\n<p>For a given number <script type="math/tex; mode=display">n</script> and array <script type="math/tex; mode=display">\\mathrm{nums}</script>, suppose the <script type="math/tex; mode=display">k</script> patches found by greedy algorithm is <script type="math/tex; mode=display">X_1 \\lt X_2 \\lt \\ldots \\lt X_k \\leq n</script>. If there is another set of patches <script type="math/tex; mode=display">Y_1 \\leq Y_2 \\leq \\ldots \\leq Y_{k\'} \\leq n</script>, with <script type="math/tex; mode=display">k\' \\lt k</script>, then we have <script type="math/tex; mode=display">Y_1 \\leq X_1</script>, otherwise <script type="math/tex; mode=display">X_1</script> is not covered. And since adding <script type="math/tex; mode=display">X_1</script> cannot cover <script type="math/tex; mode=display">X_2</script> which means the sum of all the elements including <script type="math/tex; mode=display">X_1</script> is smaller than <script type="math/tex; mode=display">X_2</script>. Thus adding <script type="math/tex; mode=display">Y_1</script> will also not cover <script type="math/tex; mode=display">X_2</script>. And so we have:</p>\n<p>\n<script type="math/tex; mode=display">\nY_2 \\leq X_2\n</script>\n</p>\n<p>otherwise <script type="math/tex; mode=display">X_2</script> will not be covered and so on so forth.</p>\n<p>\n<script type="math/tex; mode=display">\nY_i \\leq X_i, i = 1, 2, \\ldots k\'\n</script>\n</p>\n<p>Finally, we can see that since <script type="math/tex; mode=display">X_1, X_2, \\ldots X_{k\'}</script> is not enough to cover <script type="math/tex; mode=display">X_k</script>, therefore <script type="math/tex; mode=display">Y_1, Y_2, \\ldots, Y_{k\'}</script> is also not enough to cover <script type="math/tex; mode=display">X_k \\leq n</script>. This contradicts the fact that <script type="math/tex; mode=display">Y_1 \\leq Y_2 \\leq \\ldots \\leq Y_{k\'} \\leq n</script> covers <script type="math/tex; mode=display">[1, n]</script>. <strong>This completes the proof.</strong></p>\n<p>Thus, the greedy algorithm will always return the fewest patches possible. Even through for particular cases, there could be many different ways to patch. But none of them will have fewer patches than the greedy algorithm does.</p>\n<iframe frameborder="0" height="309" name="mWaJh5cz" src="https://leetcode.com/playground/mWaJh5cz/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m + \\log n)</script>. In each iteration, we either increase the index <code>i</code> or we double the variable <code>miss</code>. The total number of increment for index <code>i</code> is <script type="math/tex; mode=display">m</script> and the total number of doubling <code>miss</code> is <script type="math/tex; mode=display">\\log n</script>\n</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. We only need three variables, <code>patches</code>, <code>i</code> and <code>miss</code>.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '331',
    name: 'Verify Preorder Serialization of a Binary Tree',
    acceptance: '36.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node\'s value. If it is a null node, we record using a sentinel value such as <code>#</code>.</p>\n\n<pre>     _9_\n    /   \\\n   3     2\n  / \\   / \\\n 4   1  #  6\n/ \\ / \\   / \\\n# # # #   # #\n</pre>\n\n<p>For example, the above binary tree can be serialized to the string <code>"9,3,4,#,#,1,#,#,2,#,6,#,#"</code>, where <code>#</code> represents a null node.\n</p>\n\n<p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.</p>\n\n<p>Each comma separated value in the string must be either an integer or a character <code>\'#\'</code> representing <code>null</code> pointer.</p>\n\n<p>You may assume that the input format is always valid, for example it could never contain two consecutive commas such as <code>"1,,3"</code>.</p>\n\n<p><strong>Example 1:</strong><br>\n<code>"9,3,4,#,#,1,#,#,2,#,6,#,#"</code><br>\nReturn <code>true</code></p>\n<p><strong>Example 2:</strong><br>\n<code>"1,#"</code><br>\nReturn <code>false</code></p>\n<p><strong>Example 3:</strong><br>\n<code>"9,#,#,1"</code><br>\nReturn <code>false</code></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '332',
    name: 'Reconstruct Itinerary',
    acceptance: '29.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a list of airline tickets represented by pairs of departure and arrival airports <code>[from, to]</code>, reconstruct the itinerary in order. All of the tickets belong to a man who departs from <code>JFK</code>. Thus, the itinerary must begin with <code>JFK</code>.\n</p>\n<p>\n<b>Note:</b><br>\n</p><ol>\n<li>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary <code>["JFK", "LGA"]</code> has a smaller lexical order than <code>["JFK", "LGB"]</code>.</li>\n<li>All airports are represented by three capital letters (IATA code).</li>\n<li>You may assume all tickets form at least one valid itinerary.</li>\n</ol>\n<p></p>\n\n<p>\n    <b>Example 1:</b><br>\n    <code>tickets</code> = <code>[["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]</code><br>\n    Return <code>["JFK", "MUC", "LHR", "SFO", "SJC"]</code>.<br>\n</p>\n<p>\n    <b>Example 2:</b><br>\n    <code>tickets</code> = <code>[["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]</code><br>\n    Return <code>["JFK","ATL","JFK","SFO","ATL","SFO"]</code>.<br>\n    Another possible reconstruction is <code>["JFK","SFO","ATL","JFK","ATL","SFO"]</code>. But it is larger in lexical order.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '333',
    name: 'Largest BST Subtree ',
    acceptance: '30.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a binary tree, find the largest subtree which is a Binary Search Tree (BST), where largest means subtree with largest number of nodes in it.</p>\n<p><b>Note:</b><br>\nA subtree must include all of its descendants.<br>\nHere\'s an example:<br>\n</p><pre>    10\n    / \\\n   <font color="red">5</font>  15\n  <font color="red">/ \\</font>   \\ \n <font color="red">1   8</font>   7\n</pre>\nThe Largest BST Subtree in this case is the highlighted one. <br>\nThe return value is the subtree\'s size, which is 3. \n<p></p>\n\n<p>\n<b>Follow up:</b><br>\nCan you figure out ways to solve it with O(n) time complexity?\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft'],
  },
  {
    id: '334',
    name: 'Increasing Triplet Subsequence',
    acceptance: '39.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.\n</p>\n<p>\nFormally the function should:<br>\n</p><blockquote>Return true if there exists <i>i, j, k </i> <br>\nsuch that <i>arr[i]</i> &lt; <i>arr[j]</i> &lt; <i>arr[k]</i> given 0 ≤ <i>i</i> &lt; <i>j</i> &lt; <i>k</i> ≤ <i>n</i>-1 \nelse return false.\n</blockquote>\n<p></p>\n<p>\nYour algorithm should run in O(<i>n</i>) time complexity and O(<i>1</i>) space complexity.\n</p>\n<p>\n<b>Examples:</b><br>\nGiven <code>[1, 2, 3, 4, 5]</code>,<br>\nreturn <code>true</code>.\n</p>\n<p>\nGiven <code>[5, 4, 3, 2, 1]</code>,<br>\nreturn <code>false</code>.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/DjangoUnchained">@DjangoUnchained</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook'],
  },
  {
    id: '335',
    name: 'Self Crossing',
    acceptance: '25.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\n    You are given an array <i>x</i> of <code>n</code> positive numbers. You start at point <code>(0,0)</code> and moves <code>x[0]</code> metres to the north, then <code>x[1]</code> metres to the west,\n    <code>x[2]</code> metres to the south,\n    <code>x[3]</code> metres to the east and so on. In other words, after each move your direction changes\n    counter-clockwise.\n</p>\n<p>\n    Write a one-pass algorithm with <code>O(1)</code> extra space to determine, if your path crosses itself, or not.\n</p>\n\n<p>\n<b>Example 1:</b><br>\n</p><pre>Given <i>x</i> = <code>[2, 1, 1, 2]</code>,\n?????\n?   ?\n???????&gt;\n    ?\n\nReturn <b>true</b> (self crossing)\n</pre>\n<p></p>\n\n<p>\n<b>Example 2:</b><br>\n</p><pre>Given <i>x</i> = <code>[1, 2, 3, 4]</code>,\n????????\n?      ?\n?\n?\n?????????????&gt;\n\nReturn <b>false</b> (not self crossing)\n</pre>\n<p></p>\n\n<p>\n<b>Example 3:</b><br>\n</p><pre>Given <i>x</i> = <code>[1, 1, 1, 1]</code>,\n?????\n?   ?\n?????&gt;\n\nReturn <b>true</b> (self crossing)\n</pre>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '336',
    name: 'Palindrome Pairs',
    acceptance: '26.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\n    Given a list of <b>unique</b> words, find all pairs of <b><i>distinct</i></b> indices <code>(i, j)</code> in the given list, so that the concatenation of the two words, i.e. <code>words[i] + words[j]</code> is a palindrome.\n</p>\n\n<p>\n    <b>Example 1:</b><br>\n    Given <code>words</code> = <code>["bat", "tab", "cat"]</code><br>\n    Return <code>[[0, 1], [1, 0]]</code><br>\n    The palindromes are <code>["battab", "tabbat"]</code><br>\n</p>\n<p>\n    <b>Example 2:</b><br>\n    Given <code>words</code> = <code>["abcd", "dcba", "lls", "s", "sssll"]</code><br>\n    Return <code>[[0, 1], [1, 0], [3, 2], [2, 4]]</code><br>\n    The palindromes are <code>["dcbaabcd", "abcddcba", "slls", "llssssll"]</code><br>\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Airbnb'],
  },
  {
    id: '337',
    name: 'House Robber III',
    acceptance: '44.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nThe thief has found himself a new place for his thievery again. There is only one entrance to this area, called the "root." Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that "all houses in this place forms a binary tree". It will automatically contact the police if two directly-linked houses were broken into on the same night.\n</p>\n\n<p>\nDetermine the maximum amount of money the thief can rob tonight without alerting the police.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre>     <font color="red">3</font>\n    / \\\n   2   3\n    \\   \\ \n     <font color="red">3   1</font>\n</pre>\nMaximum amount of money the thief can rob = <font color="red">3</font> + <font color="red">3</font> + <font color="red">1</font> = <b>7</b>.\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre>     3\n    / \\\n   <font color="red">4</font>   <font color="red">5</font>\n  / \\   \\ \n 1   3   1\n</pre>\nMaximum amount of money the thief can rob = <font color="red">4</font> + <font color="red">5</font> = <b>9</b>.\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/dietpepsi">@dietpepsi</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Uber'],
  },
  {
    id: '338',
    name: 'Counting Bits',
    acceptance: '61.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a non negative integer number <b>num</b>. For every numbers <b>i</b> in the range <b>0 ≤ i ≤ num</b> calculate the number of 1\'s in their binary representation and return them as an array.\n</p>\n<p>\n<b>Example:</b><br>\nFor <code>num = 5</code> you should return <code>[0,1,1,2,1,2]</code>.\n</p>\n<p>\n<b>Follow up:</b>\n</p><ul>\n<li>It is very easy to come up with a solution with run time <b>O(n*sizeof(integer))</b>. But can you do it in linear time <b>O(n)</b> /possibly in a single pass?</li>\n<li>Space complexity should be <b>O(n)</b>.</li>\n<li>Can you do it like a boss? Do it without using any builtin function like <b>__builtin_popcount</b>  in c++ or in any other language.</li>\n</ul>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/syedee">@ syedee </a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solutions">Solutions</a><ul>\n<li><a href="#approach-1-pop-count-accepted">Approach #1 Pop Count [Accepted]</a></li>\n<li><a href="#approach-2-dp-most-significant-bit-accepted">Approach #2 DP + Most Significant Bit [Accepted]</a></li>\n<li><a href="#approach-3-dp-least-significant-bit-accepted">Approach #3 DP + Least Significant Bit [Accepted]</a></li>\n<li><a href="#approach-4-dp-last-set-bit-accepted">Approach #4 DP + Last Set Bit [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This article is for intermediate readers. It relates to the following ideas:\nPop Count, Most Significant Bit, Least Significant Bit, Last Set Bit and Dynamic Programming.</p>\n<h2 id="solutions">Solutions</h2>\n<hr>\n<h4 id="approach-1-pop-count-accepted">Approach #1 Pop Count [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Solve the problem for one number and applies that for all.</p>\n<p><strong>Algorithm</strong></p>\n<p>This problem can be seen as a follow-up of the <a href="https://leetcode.com/problems/number-of-1-bits/">Problem 191 The number of 1 bits</a>. It counts the bits for an unsigned integer. The number is often called pop count or <a href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming weight</a>. See the editorial of <a href="https://leetcode.com/problems/number-of-1-bits/">Problem 191 The number of 1 bits</a> for a detailed explanation of different approaches.</p>\n<p>Now we just take that for granted. And suppose we have the function <code>int popcount(int x)</code> which will return the count of the bits for a given non-negative integer. We just loop through the numbers in range <code>[0, num]</code> and put the results in a list.</p>\n<iframe frameborder="0" height="292" name="huXmPZY7" src="https://leetcode.com/playground/huXmPZY7/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nk)</script>. For each integer <script type="math/tex; mode=display">x</script>, we need <script type="math/tex; mode=display">O(k)</script> operations where <script type="math/tex; mode=display">k</script> is the number of bits in <script type="math/tex; mode=display">x</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. We need <script type="math/tex; mode=display">O(n)</script> space to store the count results. If we exclude that, it costs only constant space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-dp-most-significant-bit-accepted">Approach #2 DP + Most Significant Bit [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Use previous count results to generate the count for a new integer.</p>\n<p><strong>Algorithm</strong></p>\n<p>Suppose we have an integer:</p>\n<p>\n<script type="math/tex; mode=display">\nx = (1001011101)_2 = (605)_{10}\n</script>\n</p>\n<p>and we already calculated and stored all the results of <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">x - 1</script>.</p>\n<p>Then we know that <script type="math/tex; mode=display">x</script> is differ by one bit with a number we already calculated:</p>\n<p>\n<script type="math/tex; mode=display">\nx\' = (1011101)_2 = (93)_{10}\n</script>\n</p>\n<p>They are different only in the most significant bit.</p>\n<p>Let\'s exam the range <script type="math/tex; mode=display">[0, 3]</script> in the binary form:</p>\n<p>\n<script type="math/tex; mode=display">\n(0) = (0)_2\n</script>\n</p>\n<p>\n<script type="math/tex; mode=display">\n(1) = (1)_2\n</script>\n</p>\n<p>\n<script type="math/tex; mode=display">\n(2) = (10)_2\n</script>\n</p>\n<p>\n<script type="math/tex; mode=display">\n(3) = (11)_2\n</script>\n</p>\n<p>One can see that the binary form of 2 and 3 can be generated by adding 1 bit in front of 0 and 1. Thus, they are different only by 1 regarding pop count.</p>\n<p>Similarly, we can generate the results for <script type="math/tex; mode=display">[4, 7]</script> using <script type="math/tex; mode=display">[0, 3]</script> as blueprints.</p>\n<p>In general, we have the following transition function for popcount <script type="math/tex; mode=display">P(x)</script>:</p>\n<p>\n<script type="math/tex; mode=display">\nP(x + b) = P(x) + 1, b = 2^m > x\n</script>\n</p>\n<p>With this transition function, we can then apply Dynamic Programming to generate all the pop counts starting from <script type="math/tex; mode=display">0</script>.</p>\n<div class="codehilite"><pre><span></span>public class Solution {\n    public int[] countBits(int num) {\n        int[] ans = new int[num + 1];\n        int i = 0, b = 1;\n        // [0, b) is calculated\n        while (b &lt;= num) {\n            // generate [b, 2b) or [b, num) from [0, b)\n            while(i &lt; b &amp;&amp; i + b &lt;= num){\n                ans[i + b] = ans[i] + 1;\n                ++i;\n            }\n            i = 0;   // reset i\n            b &lt;&lt;= 1; // b = 2b\n        }\n        return ans;\n    }\n}\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. For each integer <script type="math/tex; mode=display">x</script> we need constant operations which do not depend on the number of bits in <script type="math/tex; mode=display">x</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. We need <script type="math/tex; mode=display">O(n)</script> space to store the count results. If we exclude that, it costs only constant space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-dp-least-significant-bit-accepted">Approach #3 DP + Least Significant Bit [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can have different transition functions, as long as <script type="math/tex; mode=display">x\'</script> is smaller than <script type="math/tex; mode=display">x</script> and their pop counts have a function.</p>\n<p><strong>Algorithm</strong></p>\n<p>Following the same principle of the previous approach, we can also have a transition function by playing with the least significant bit.</p>\n<p>Let look at the relation between <script type="math/tex; mode=display">x</script> and <script type="math/tex; mode=display">x\' = x / 2</script>\n</p>\n<p>\n<script type="math/tex; mode=display">\nx = (1001011101)_2 = (605)_{10}\n</script>\n</p>\n<p>\n<script type="math/tex; mode=display">\nx\' = (100101110)_2 = (302)_{10}\n</script>\n</p>\n<p>We can see that <script type="math/tex; mode=display">x\'</script> is differ than <script type="math/tex; mode=display">x</script> by one bit, because <script type="math/tex; mode=display">x\'</script> can be considered as the result of removing the least significant bit of <script type="math/tex; mode=display">x</script>.</p>\n<p>Thus, we have the following transition function of pop count <script type="math/tex; mode=display">P(x)</script>:</p>\n<p>\n<script type="math/tex; mode=display">\nP(x) = P(x / 2) + (x \\mod 2)\n</script>\n</p>\n<iframe frameborder="0" height="190" name="bDREyCKV" src="https://leetcode.com/playground/bDREyCKV/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. For each integer <script type="math/tex; mode=display">x</script> we need constant operations which do not depend on the number of bits in <script type="math/tex; mode=display">x</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>.  Same as approach #2.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-dp-last-set-bit-accepted">Approach #4 DP + Last Set Bit [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>With the same logic as previous approaches, we can also manipulate the last set bit.</p>\n<p>Last set bit is the rightmost set bit. Setting that bit to zero with the bit trick, <code>x &amp;= x - 1</code>, leads to the following transition function:</p>\n<p>\n<script type="math/tex; mode=display">\nP(x) = P(x \\mathrel{\\&} (x - 1)) + 1;\n</script>\n</p>\n<iframe frameborder="0" height="190" name="Bj47Y4ha" src="https://leetcode.com/playground/Bj47Y4ha/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Same as approach #3.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Same as approach #3.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: [],
  },
  {
    id: '339',
    name: 'Nested List Weight Sum ',
    acceptance: '63.1%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p>\n\n<p>Each element is either an integer, or a list -- whose elements may also be integers or other lists.</p>\n\n<p><b>Example 1:</b><br>\nGiven the list <code>[[1,1],2,[1,1]]</code>, return <b>10</b>. (four 1's at depth 2, one 2 at depth 1)</p>\n\n<p><b>Example 2:</b><br>\nGiven the list <code>[1,[4,[6]]]</code>, return <b>27</b>. (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27)\n</p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#depth-first-traversal-accepted">Depth-first Traversal [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>This is a very simple recursion problem and is a nice introduction to Depth-first Search (DFS).</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="depth-first-traversal-accepted">Depth-first Traversal [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Because the input is nested, it is natural to think about the problem in a recursive way. We go through the list of nested integers one by one, keeping track of the current depth <script type="math/tex; mode=display">d</script>. If a nested integer is an integer <script type="math/tex; mode=display">n</script>, we calculate its sum as <script type="math/tex; mode=display">n\\times d</script>. If the nested integer is a list, we calculate the sum of this list recursively using the same process but with depth <script type="math/tex; mode=display">d+1</script>.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="cm">/**</span>\n<span class="cm"> * // This is the interface that allows for creating nested lists.</span>\n<span class="cm"> * // You should not implement it, or speculate about its implementation</span>\n<span class="cm"> * public interface NestedInteger {</span>\n<span class="cm"> *</span>\n<span class="cm"> *     // @return true if this NestedInteger holds a single integer,</span>\n<span class="cm"> *     // rather than a nested list.</span>\n<span class="cm"> *     public boolean isInteger();</span>\n<span class="cm"> *</span>\n<span class="cm"> *     // @return the single integer that this NestedInteger holds,</span>\n<span class="cm"> *     // if it holds a single integer</span>\n<span class="cm"> *     // Return null if this NestedInteger holds a nested list</span>\n<span class="cm"> *     public Integer getInteger();</span>\n<span class="cm"> *</span>\n<span class="cm"> *     // @return the nested list that this NestedInteger holds,</span>\n<span class="cm"> *     // if it holds a nested list</span>\n<span class="cm"> *     // Return null if this NestedInteger holds a single integer</span>\n<span class="cm"> *     public List&lt;NestedInteger&gt; getList();</span>\n<span class="cm"> * }</span>\n<span class="cm"> */</span>\n<span class="kd">public</span> <span class="kt">int</span> <span class="nf">depthSum</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">NestedInteger</span><span class="o">&gt;</span> <span class="n">nestedList</span><span class="o">)</span> <span class="o">{</span>\n    <span class="k">return</span> <span class="n">depthSum</span><span class="o">(</span><span class="n">nestedList</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>\n<span class="o">}</span>\n\n<span class="kd">public</span> <span class="kt">int</span> <span class="nf">depthSum</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">NestedInteger</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="k">for</span> <span class="o">(</span><span class="n">NestedInteger</span> <span class="n">n</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">isInteger</span><span class="o">())</span> <span class="o">{</span>\n            <span class="n">sum</span> <span class="o">+=</span> <span class="n">n</span><span class="o">.</span><span class="na">getInteger</span><span class="o">()</span> <span class="o">*</span> <span class="n">depth</span><span class="o">;</span>\n        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>\n            <span class="n">sum</span> <span class="o">+=</span> <span class="n">depthSum</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">getList</span><span class="o">(),</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>The algorithm takes <script type="math/tex; mode=display">O(N)</script> time, where <script type="math/tex; mode=display">N</script> is the total number of nested elements in the input list. For example, the list <code>[ [[[[1]]]], 2 ]</code> contains <script type="math/tex; mode=display">4</script> nested lists and <script type="math/tex; mode=display">2</script> nested integers (<script type="math/tex; mode=display">1</script> and <script type="math/tex; mode=display">2</script>), so <script type="math/tex; mode=display">N=6</script>.</p>\n<p>In terms of space, at most <script type="math/tex; mode=display">O(D)</script> recursive calls are placed on the stack, where <script type="math/tex; mode=display">D</script> is the maximum level of nesting in the input. For example, <script type="math/tex; mode=display">D=2</script> for the input <code>[[1,1],2,[1,1]]</code>, and <script type="math/tex; mode=display">D=3</script> for the input <code>[1,[4,[6]]]</code>.</p>\n<p>Analysis written by: @noran</p>\n</div>\n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '340',
    name: 'Longest Substring with At Most K Distinct Characters ',
    acceptance: '39.3%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a string, find the length of the longest substring T that contains at most <i>k</i> distinct characters.\n</p>\n\n<p>\nFor example,\n\nGiven s = <code>“eceba”</code> and k = 2,\n</p>\n\n<p>\nT is "ece" which its length is 3.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'AppDynamics', 'Coupang'],
  },
  {
    id: '341',
    name: 'Flatten Nested List Iterator',
    acceptance: '42.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a nested list of integers, implement an iterator to flatten it.</p>\n\n<p>Each element is either an integer, or a list -- whose elements may also be integers or other lists.</p>\n\n<p><b>Example 1:</b><br>\nGiven the list <code>[[1,1],2,[1,1]]</code>,\n</p><p>\nBy calling <i>next</i> repeatedly until <i>hasNext</i> returns false, the order of elements returned by <i>next</i> should be: <code>[1,1,2,1,1]</code>.\n</p>\n<p></p>\n\n<p><b>Example 2:</b><br>\nGiven the list <code>[1,[4,[6]]]</code>,\n</p><p>\nBy calling <i>next</i> repeatedly until <i>hasNext</i> returns false, the order of elements returned by <i>next</i> should be: <code>[1,4,6]</code>.\n</p>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Twitter'],
  },
  {
    id: '342',
    name: 'Power of Four',
    acceptance: '38.8%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an integer (signed 32 bits), write a function to check whether it is a power of 4.\n</p>\n<p><b>Example:</b><br>\nGiven num = 16, return true.\nGiven num = 5, return false.\n</p>\n<p>\n<b>Follow up</b>: Could you solve it without loops/recursion?\n</p>\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/yukuairoy">@yukuairoy </a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Two Sigma'],
  },
  {
    id: '343',
    name: 'Integer Break',
    acceptance: '46.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a positive integer <i>n</i>, break it into the sum of <b>at least</b> two positive integers and maximize the product of those integers. Return the maximum product you can get.\n</p>\n\n<p>\nFor example, given <i>n</i> = 2, return 1 (2 = 1 + 1); given <i>n</i> = 10, return 36 (10 = 3 + 3 + 4).\n</p>\n\n<p>\n<b>Note</b>: You may assume that <i>n</i> is not less than 2 and not larger than 58.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '344',
    name: 'Reverse String',
    acceptance: '59.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Write a function that takes a string as input and returns the string reversed.</p>\n\n<p>\n<b>Example:</b><br>\nGiven s = "hello", return "olleh".\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '345',
    name: 'Reverse Vowels of a String',
    acceptance: '38.8%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Write a function that takes a string as input and reverse only the vowels of a string.</p>\n\n<p>\n<b>Example 1:</b><br>\nGiven s = "hello", return "holle".\n</p>\n\n<p>\n<b>Example 2:</b><br>\nGiven s = "leetcode", return "leotcede".\n</p>\n\n<p>\n<b>Note:</b><br>\nThe vowels does not include the letter "y".\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '346',
    name: 'Moving Average from Data Stream ',
    acceptance: '59.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.</p>\n\n<p>For example,<br>\n</p><pre>MovingAverage m = new MovingAverage(3);\nm.next(1) = 1\nm.next(10) = (1 + 10) / 2\nm.next(3) = (1 + 10 + 3) / 3\nm.next(5) = (10 + 3 + 5) / 3\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '347',
    name: 'Top K Frequent Elements',
    acceptance: '48.9%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nGiven a non-empty array of integers, return the <b><i>k</i></b> most frequent elements.</p>\n\n<p>For example,<br>\nGiven <code>[1,1,1,2,2,3]</code> and k = 2, return <code>[1,2]</code>.\n</p>\n\n<p><b>Note: </b><br>\n</p><ul>\n<li>You may assume <i>k</i> is always valid, 1 ≤ <i>k</i> ≤ number of unique elements.</li>\n<li>Your algorithm's time complexity <b>must be</b> better than O(<i>n</i> log <i>n</i>), where <i>n</i> is the array's size.</li>\n</ul><p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Yelp', 'Pocket Gems'],
  },
  {
    id: '348',
    name: 'Design Tic-Tac-Toe ',
    acceptance: '45.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Design a Tic-tac-toe game that is played between two players on a <i>n</i> x <i>n</i> grid.\n</p>\n\n<p>You may assume the following rules:\n</p><ol>\n<li>A move is guaranteed to be valid and is placed on an empty block.</li>\n<li>Once a winning condition is reached, no more moves is allowed.</li>\n<li>A player who succeeds in placing <i>n</i> of their marks in a horizontal, vertical, or diagonal row wins the game.</li>\n</ol>\n<p></p>\n\n<p><b>Example:</b><br>\n</p><pre>Given <i>n</i> = 3, assume that player 1 is "X" and player 2 is "O" in the board.\n\nTicTacToe toe = new TicTacToe(3);\n\ntoe.move(0, 0, 1); -&gt; Returns 0 (no one wins)\n|X| | |\n| | | |    // Player 1 makes a move at (0, 0).\n| | | |\n\ntoe.move(0, 2, 2); -&gt; Returns 0 (no one wins)\n|X| |O|\n| | | |    // Player 2 makes a move at (0, 2).\n| | | |\n\ntoe.move(2, 2, 1); -&gt; Returns 0 (no one wins)\n|X| |O|\n| | | |    // Player 1 makes a move at (2, 2).\n| | |X|\n\ntoe.move(1, 1, 2); -&gt; Returns 0 (no one wins)\n|X| |O|\n| |O| |    // Player 2 makes a move at (1, 1).\n| | |X|\n\ntoe.move(2, 0, 1); -&gt; Returns 0 (no one wins)\n|X| |O|\n| |O| |    // Player 1 makes a move at (2, 0).\n|X| |X|\n\ntoe.move(1, 0, 2); -&gt; Returns 0 (no one wins)\n|X| |O|\n|O|O| |    // Player 2 makes a move at (1, 0).\n|X| |X|\n\ntoe.move(2, 1, 1); -&gt; Returns 1 (player 1 wins)\n|X| |O|\n|O|O| |    // Player 1 makes a move at (2, 1).\n|X|X|X|\n</pre>\n<p></p>\n\n<p><b>Follow up:</b><br>\nCould you do better than O(<i>n</i><sup>2</sup>) per <code>move()</code> operation?\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Microsoft'],
  },
  {
    id: '349',
    name: 'Intersection of Two Arrays',
    acceptance: '47.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven two arrays, write a function to compute their intersection.\n</p>\n\n<p><b>Example:</b><br>\nGiven <i>nums1</i> = <code>[1, 2, 2, 1]</code>, <i>nums2</i> = <code>[2, 2]</code>, return <code>[2]</code>.\n</p>\n\n<p><b>Note:</b><br>\n</p><ul>\n<li>Each element in the result must be unique.</li>\n<li>The result can be in any order.</li>\n</ul>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Two Sigma'],
  },
  {
    id: '350',
    name: 'Intersection of Two Arrays II',
    acceptance: '44.8%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>\nGiven two arrays, write a function to compute their intersection.\n</p>\n\n<p><b>Example:</b><br>\nGiven <i>nums1</i> = <code>[1, 2, 2, 1]</code>, <i>nums2</i> = <code>[2, 2]</code>, return <code>[2, 2]</code>.\n</p>\n\n<p><b>Note:</b><br>\n</p><ul>\n<li>Each element in the result should appear as many times as it shows in both arrays.</li>\n<li>The result can be in any order.</li>\n</ul>\n<p></p>\n\n<p><b>Follow up:</b><br>\n</p><ul>\n<li>What if the given array is already sorted? How would you optimize your algorithm?</li>\n<li>What if <i>nums1</i>'s size is small compared to <i>nums2</i>'s size? Which algorithm is better?</li>\n<li>What if elements of <i>nums2</i> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>\n</ul>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '351',
    name: 'Android Unlock Patterns ',
    acceptance: '44.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an Android <b>3x3</b> key lock screen and two integers <b>m</b> and <b>n</b>, where  1 ≤ m ≤ n ≤ 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of <b>m</b> keys and maximum <b>n</b> keys.</p>\n\n<p><b>Rules for a valid pattern:</b><br>\n</p><ol>\n<li>Each pattern must connect at least <b>m</b> keys and at most <b>n</b> keys.</li>\n<li>All the keys must be distinct.</li>\n<li>If the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern. No jumps through non selected key is allowed.</li>\n<li>The order of keys used matters.</li>\n</ol>\n<p></p>\n\n<img src="https://leetcode.com/static/images/problemset/android-unlock.png">\n\n<p><b>Explanation:</b><br>\n\n</p><pre>| 1 | 2 | 3 |\n| 4 | 5 | 6 |\n| 7 | 8 | 9 |</pre>\n<p></p>\n\n<p>\n<b>Invalid move:</b> <code>4 - 1 - 3 - 6 </code><br>\n\nLine  1 - 3 passes through key 2 which had not been selected in the pattern.</p>\n\n<p><b>Invalid move:</b> <code>4 - 1 - 9 - 2</code><br>\n\nLine  1 - 9 passes through key 5 which had not been selected in the pattern.</p>\n\n<p><b>Valid move:</b> <code>2 - 4 - 1 - 3 - 6</code><br>\n\nLine 1 - 3 is valid because it passes through key 2, which had been selected in the pattern</p>\n\n<p><b>Valid move:</b> <code>6 - 5 - 4 - 1 - 9 - 2</code><br>\n\nLine 1 - 9 is valid because it passes through key 5, which had been selected in the pattern.</p>\n\n<p><b>Example:</b><br>\nGiven <b>m</b> = 1, <b>n</b> = 1, return 9.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://discuss.leetcode.com/user/elmirap">@elmirap</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-backtracking-accepted">Approach #1: (Backtracking) [Accepted]</a></li>\n</ul>\n</li>\n<li><a href="#further-thoughts">Further Thoughts</a></li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>After Android launched its "unlock pattern" system to protect our smart phones from unauthorized access, the most common question that comes to one\'s mind is: How secure exactly are these patterns? The current article gives an answer to this question, as presenting an algorithm, which computes the number of all valid pattern combinations. It is intended for intermediate users and introduces the following ideas:\nBacktracking, Arrays.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-backtracking-accepted">Approach #1: (Backtracking) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The algorithm uses backtracking technique to enumerate all possible <script type="math/tex; mode=display">k</script> combinations of numbers <script type="math/tex; mode=display">[1\\dots\\ 9]</script> where <script type="math/tex; mode=display">m \\leq k \\leq n</script>. During the generation of the recursive solution tree, the algorithm cuts all the branches  which lead to patterns which doesn\'t satisfy the rules and counts only the valid patterns.\nIn order to compute a valid pattern, the algorithm performs the following steps:</p>\n<ul>\n<li>\n<p>Select a digit <script type="math/tex; mode=display">i</script> which is not used in the pattern till this moment. This is done with the help of a <script type="math/tex; mode=display">used</script> array which stores all available digits.</p>\n</li>\n<li>\n<p>We need to keep last inserted digit <script type="math/tex; mode=display">last</script>. The algorithm makes a check whether one of the following conditions is valid.</p>\n<ul>\n<li>\n<p>There is a knight move (as in chess)  from <script type="math/tex; mode=display">last</script> towards <script type="math/tex; mode=display">i</script> or <script type="math/tex; mode=display">last</script> and <script type="math/tex; mode=display">i</script> are adjacent digits in a row, in a column. In this case the sum of both digits should be an odd number.</p>\n</li>\n<li>\n<p>The middle element <script type="math/tex; mode=display">mid</script> in the line which connects <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">last</script> was previously selected. In case <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">last</script> are positioned at both ends of the diagonal, digit <script type="math/tex; mode=display">mid</script> = 5 should be previously selected.</p>\n</li>\n<li>\n<p>\n<script type="math/tex; mode=display">last</script> and <script type="math/tex; mode=display">i</script> are adjacent digits in a diagonal</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>In case one of the conditions above is satisfied, digit <script type="math/tex; mode=display">i</script> becomes part of partially generated valid pattern and the algorithm continues with the next candidate digit till the pattern is fully generated. Then it counts it.\nIn case none of the conditions are satisfied, the algorithm rejects the current digit <script type="math/tex; mode=display">i</script>, backtracks and continues to search for other valid digits among the unused ones.</p>\n<p align="center"><img alt="Android unlock pattern recursive solution tree" src="https://leetcode.com/media/original_images/351_Android.png" width="80%"></p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n\n    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">used</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">9</span><span class="o">];</span>\n\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numberOfPatterns</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>         \n        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">len</span><span class="o">++)</span> <span class="o">{</span>                \n            <span class="n">res</span> <span class="o">+=</span> <span class="n">calcPatterns</span><span class="o">(-</span><span class="mi">1</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>                   \n                <span class="n">used</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>\n            <span class="o">}</span>            \n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>\n    <span class="o">}</span>\n\n    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isValid</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="kt">int</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">used</span><span class="o">[</span><span class="n">index</span><span class="o">])</span>\n            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n        <span class="c1">// first digit of the pattern    </span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">last</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>\n            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n        <span class="c1">// knight moves or adjacent cells (in a row or in a column)        </span>\n        <span class="k">if</span> <span class="o">((</span><span class="n">index</span> <span class="o">+</span> <span class="n">last</span><span class="o">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>\n            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n        <span class="c1">// indexes are at both end of the diagonals for example 0,0, and 8,8          </span>\n        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">index</span> <span class="o">+</span> <span class="n">last</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">mid</span> <span class="o">==</span> <span class="mi">4</span><span class="o">)</span>\n            <span class="k">return</span> <span class="n">used</span><span class="o">[</span><span class="n">mid</span><span class="o">];</span>\n        <span class="c1">// adjacent cells on diagonal  - for example 0,0 and 1,0 or 2,0 and //1,1</span>\n        <span class="k">if</span> <span class="o">((</span><span class="n">index</span><span class="o">%</span><span class="mi">3</span> <span class="o">!=</span> <span class="n">last</span><span class="o">%</span><span class="mi">3</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">index</span><span class="o">/</span><span class="mi">3</span> <span class="o">!=</span> <span class="n">last</span><span class="o">/</span><span class="mi">3</span><span class="o">))</span> <span class="o">{</span>\n            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="c1">// all other cells which are not adjacent</span>\n        <span class="k">return</span> <span class="n">used</span><span class="o">[</span><span class="n">mid</span><span class="o">];</span>\n    <span class="o">}</span>\n\n    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">calcPatterns</span><span class="o">(</span><span class="kt">int</span> <span class="n">last</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>\n            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>    \n        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">isValid</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">last</span><span class="o">))</span> <span class="o">{</span>\n                <span class="n">used</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>\n                <span class="n">sum</span> <span class="o">+=</span> <span class="n">calcPatterns</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>\n                <span class="n">used</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>                    \n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O( n!)</script>, where <script type="math/tex; mode=display">n</script> is maximum pattern length</p>\n<p>The algorithm computes each pattern once and no element can appear in the pattern twice. The time complexity is proportional to the number of the computed patterns. One upper bound of the number of all possible combinations is :</p>\n</li>\n</ul>\n<p>\n<script type="math/tex; mode=display">\n\\ \\sum_{i=m}^{n} {_9}P_i = \\ \\sum_{i=m}^{n} \\frac{9!}{(9 - i)!}\n</script>\n</p>\n<ul>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>, where <script type="math/tex; mode=display">n</script> is maximum pattern length\nIn the worst case the maximum depth of recursion is <script type="math/tex; mode=display">n</script>. Therefore we need <script type="math/tex; mode=display">O( n)</script> space used by the system recursive stack</li>\n</ul>\n<h2 id="further-thoughts">Further Thoughts</h2>\n<p>The algorithm above could be optimized if we consider the symmetry property of the problem. We notice that the number of valid patterns with first digit 1, 3, 7, 9 are the same. A similar observation is true for patterns which starts with digit 2, 4, 6, 8.  Hence we only  need to calculate one among each group and multiply by 4.</p>\n<p>You can find the optimized solution <a href="https://leetcode.com/discuss/104500/java-solution-with-clear-explanations-and-optimization-81ms">here</a>.</p>\n<p>Analysis written by: @elmirap.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '352',
    name: 'Data Stream as Disjoint Intervals',
    acceptance: '40.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given a data stream input of non-negative integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>, ..., summarize the numbers seen so far as a list of disjoint intervals.</p>\n\n<p>For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be:</p>\n<pre>[1, 1]\n[1, 1], [3, 3]\n[1, 1], [3, 3], [7, 7]\n[1, 3], [7, 7]\n[1, 3], [6, 7]\n</pre>\n\n<p><b>Follow up:</b><br>\nWhat if there are lots of merges and the number of disjoint intervals are small compared to the data stream\'s size?\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://discuss.leetcode.com/user/yunhong">@yunhong</a> for adding this problem and creating most of the test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '353',
    name: 'Design Snake Game ',
    acceptance: '27.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Design a <a href="https://en.wikipedia.org/wiki/Snake_(video_game)" target="_blank">Snake game</a> that is played on a device with screen size = <i>width</i> x <i>height</i>. <a href="http://patorjk.com/games/snake/" target="_blank">Play the game online</a> if you are not familiar with the game.</p>\n\n<p>The snake is initially positioned at the top left corner (0,0) with length = 1 unit.</p>\n\n<p>You are given a list of food\'s positions in row-column order. When a snake eats the food, its length and the game\'s score both increase by 1.</p>\n\n<p>Each food appears one by one on the screen. For example, the second food will not appear until the first food was eaten by the snake.</p>\n\n<p>When a food does appear on the screen, it is guaranteed that it will not appear on a block occupied by the snake.</p>\n\n<p>\n<b>Example:</b><br>\n</p><pre>Given width = 3, height = 2, and food = [[1,2],[0,1]].\n\nSnake snake = new Snake(width, height, food);\n\nInitially the snake appears at position (0,0) and the food at (1,2).\n\n|S| | |\n| | |F|\n\nsnake.move("R"); -&gt; Returns 0\n\n| |S| |\n| | |F|\n\nsnake.move("D"); -&gt; Returns 0\n\n| | | |\n| |S|F|\n\nsnake.move("R"); -&gt; Returns 1 (Snake eats the first food and right after that, the second food appears at (0,1) )\n\n| |F| |\n| |S|S|\n\nsnake.move("U"); -&gt; Returns 1\n\n| |F|S|\n| | |S|\n\nsnake.move("L"); -&gt; Returns 2 (Snake eats the second food)\n\n| |S|S|\n| | |S|\n\nsnake.move("U"); -&gt; Returns -1 (Game over because snake collides with border)\n\n</pre>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://discuss.leetcode.com/user/elmirap">@elmirap</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '354',
    name: 'Russian Doll Envelopes',
    acceptance: '32.4%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>You have a number of envelopes with widths and heights given as a pair of integers <code>(w, h)</code>. One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.</p>\n\n<p>\nWhat is the maximum number of envelopes can you Russian doll? (put one inside other)\n</p>\n\n<p><b>Example:</b><br>\nGiven envelopes = <code>[[5,4],[6,4],[6,7],[2,3]]</code>, the maximum number of envelopes you can Russian doll is <code>3</code> ([2,3] =&gt; [5,4] =&gt; [6,7]).\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '355',
    name: 'Design Twitter',
    acceptance: '25.7%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:</p>\n\n<p>\n</p><ol>\n<li><b>postTweet(userId, tweetId)</b>: Compose a new tweet.</li>\n<li><b>getNewsFeed(userId)</b>: Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.</li>\n<li><b>follow(followerId, followeeId)</b>: Follower follows a followee.</li>\n<li><b>unfollow(followerId, followeeId)</b>: Follower unfollows a followee.</li>\n</ol>\n<p></p>\n\n<p><b>Example:</b>\n</p><pre>Twitter twitter = new Twitter();\n\n// User 1 posts a new tweet (id = 5).\ntwitter.postTweet(1, 5);\n\n// User 1's news feed should return a list with 1 tweet id -&gt; [5].\ntwitter.getNewsFeed(1);\n\n// User 1 follows user 2.\ntwitter.follow(1, 2);\n\n// User 2 posts a new tweet (id = 6).\ntwitter.postTweet(2, 6);\n\n// User 1's news feed should return a list with 2 tweet ids -&gt; [6, 5].\n// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.getNewsFeed(1);\n\n// User 1 unfollows user 2.\ntwitter.unfollow(1, 2);\n\n// User 1's news feed should return a list with 1 tweet id -&gt; [5],\n// since user 1 is no longer following user 2.\ntwitter.getNewsFeed(1);\n</pre>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Amazon', 'Twitter'],
  },
  {
    id: '356',
    name: 'Line Reflection ',
    acceptance: '30.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points.</p>\n\n<p>\n    <b>Example 1:</b><br>\n</p>\n<p>\nGiven <i>points</i> = <code>[[1,1],[-1,1]]</code>, return <code>true</code>.\n</p>\n\n<p>\n    <b>Example 2:</b><br>\n</p>\n<p>\nGiven <i>points</i> = <code>[[1,1],[-1,-1]]</code>, return <code>false</code>.\n</p>\n\n<p><b>Follow up:</b><br>\nCould you do better than O(<i>n</i><sup>2</sup>)?\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://discuss.leetcode.com/user/memoryless">@memoryless</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '357',
    name: 'Count Numbers with Unique Digits',
    acceptance: '46.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a <b>non-negative</b> integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10<sup>n</sup>.</p>\n\n<p>\n    <b>Example:</b><br>\nGiven n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding <code>[11,22,33,44,55,66,77,88,99]</code>)\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://discuss.leetcode.com/user/memoryless">@memoryless</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '358',
    name: 'Rearrange String k Distance Apart ',
    acceptance: '31.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a non-empty string <b>s</b> and an integer <b>k</b>, rearrange the string such that the same characters are at least distance <b>k</b> from each other.\n</p>\n<p>\nAll input strings are given in lowercase letters. If it is not possible to rearrange the string, return an empty string <code>""</code>.\n</p>\n<p><b>Example 1:</b><br>\n</p><pre>s = "aabbcc", k = 3\n\nResult: "abcabc"\n\nThe same letters are at least distance 3 from each other.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre>s = "aaabc", k = 3 \n\nAnswer: ""\n\nIt is not possible to rearrange the string.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre>s = "aaadbbcc", k = 2\n\nAnswer: "abacabcd"\n\nAnother possible answer is: "abcabcda"\n\nThe same letters are at least distance 2 from each other.\n</pre>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://discuss.leetcode.com/user/elmirap">@elmirap</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '359',
    name: 'Logger Rate Limiter ',
    acceptance: '60.2%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Design a logger system that receive stream of messages along with its timestamps, each message should be printed if and only if it is <b>not printed in the last 10 seconds</b>.</p>\n\n<p>Given a message and a timestamp (in seconds granularity), return true if the message should be printed in the given timestamp, otherwise returns false.</p>\n\n<p>It is possible that several messages arrive roughly at the same time.</p>\n\n<p><b>Example:</b>\n</p><pre>Logger logger = new Logger();\n\n// logging string "foo" at timestamp 1\nlogger.shouldPrintMessage(1, "foo"); returns true; \n\n// logging string "bar" at timestamp 2\nlogger.shouldPrintMessage(2,"bar"); returns true;\n\n// logging string "foo" at timestamp 3\nlogger.shouldPrintMessage(3,"foo"); returns false;\n\n// logging string "bar" at timestamp 8\nlogger.shouldPrintMessage(8,"bar"); returns false;\n\n// logging string "foo" at timestamp 10\nlogger.shouldPrintMessage(10,"foo"); returns false;\n\n// logging string "foo" at timestamp 11\nlogger.shouldPrintMessage(11,"foo"); returns true;\n</pre>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://discuss.leetcode.com/user/memoryless">@memoryless</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '360',
    name: 'Sort Transformed Array ',
    acceptance: '44.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a <b>sorted</b> array of integers <i>nums</i> and integer values <i>a</i>, <i>b</i> and <i>c</i>.  Apply a quadratic function of the form f(<i>x</i>) = <i>ax</i><sup>2</sup> + <i>bx</i> + <i>c</i> to each element <i>x</i> in the array. </p>\n\n<p>The returned array must be in <b>sorted order</b>.</p>\n\n<p>Expected time complexity: <b>O(<i>n</i>)</b></p>\n\n<p><b>Example:</b><br>\n</p><pre>nums = [-4, -2, 2, 4], a = 1, b = 3, c = 5,\n\nResult: [3, 9, 15, 33]\n\nnums = [-4, -2, 2, 4], a = -1, b = 3, c = 5\n\nResult: [-23, -5, 1, 7]\n</pre>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://discuss.leetcode.com/user/elmirap">@elmirap</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '361',
    name: 'Bomb Enemy ',
    acceptance: '39.6%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given a 2D grid, each cell is either a wall <code>'W'</code>, an enemy <code>'E'</code> or empty <code>'0'</code> (the number zero), return the maximum enemies you can kill using one bomb.<br> The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed.<br>\n Note that you can only put the bomb at an empty cell. </p>\n\n<p><b>Example:</b><br>\n</p><pre>For the given grid\n\n0 E 0 0\nE 0 W E\n0 E 0 0\n\nreturn 3. (Placing a bomb at (1,1) kills 3 enemies)\n</pre>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href=\"https://discuss.leetcode.com/user/memoryless\">@memoryless</a> for adding this problem and creating all test cases.</p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '362',
    name: 'Design Hit Counter ',
    acceptance: '54.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Design a hit counter which counts the number of hits received in the past 5 minutes.</p>\n\n<p>Each function accepts a timestamp parameter (in seconds granularity) and you may assume that calls are being made to the system in chronological order (ie, the timestamp is monotonically increasing). You may assume that the earliest timestamp starts at 1.</p>\n\n<p>It is possible that several hits arrive roughly at the same time.</p>\n\n<p><b>Example:</b><br>\n</p><pre>HitCounter counter = new HitCounter();\n\n// hit at timestamp 1.\ncounter.hit(1);\n\n// hit at timestamp 2.\ncounter.hit(2);\n\n// hit at timestamp 3.\ncounter.hit(3);\n\n// get hits at timestamp 4, should return 3.\ncounter.getHits(4);\n\n// hit at timestamp 300.\ncounter.hit(300);\n\n// get hits at timestamp 300, should return 4.\ncounter.getHits(300);\n\n// get hits at timestamp 301, should return 3.\ncounter.getHits(301); \n</pre>\n<p></p>\n\n<p><b>Follow up:</b><br>\nWhat if the number of hits per second could be very large? Does your design scale?\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://discuss.leetcode.com/user/elmirap">@elmirap</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Dropbox'],
  },
  {
    id: '363',
    name: 'Max Sum of Rectangle No Larger Than K',
    acceptance: '33.4%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given a non-empty 2D matrix <i>matrix</i> and an integer <i>k</i>, find the max sum of a rectangle in the <i>matrix</i> such that its sum is no larger than <i>k</i>.</p>\n\n<p><b>Example:</b><br>\n</p><pre>Given matrix = [\n  [1,  0, 1],\n  [0, -2, 3]\n]\nk = 2\n</pre>\n<p></p>\n\n<p>The answer is <code>2</code>. Because the sum of rectangle <code>[[0, 1], [-2, 3]]</code> is 2 and 2 is the max number no larger than k (k = 2).</p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The rectangle inside the matrix must have an area &gt; 0.</li>\n<li>What if the number of rows is much larger than the number of columns?</li>\n</ol>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://discuss.leetcode.com/user/fujiaozhu">@fujiaozhu</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '364',
    name: 'Nested List Weight Sum II ',
    acceptance: '53.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p>\n\n<p>Each element is either an integer, or a list -- whose elements may also be integers or other lists.</p>\n\n<p>Different from the <a href="https://leetcode.com/problems/nested-list-weight-sum/">previous question</a> where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.</p>\n\n<p><b>Example 1:</b><br>\nGiven the list <code>[[1,1],2,[1,1]]</code>, return <b>8</b>. (four 1\'s at depth 1, one 2 at depth 2)</p>\n\n<p><b>Example 2:</b><br>\nGiven the list <code>[1,[4,[6]]]</code>, return <b>17</b>. (one 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17)\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '365',
    name: 'Water and Jug Problem',
    acceptance: '27.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>You are given two jugs with capacities <i>x</i> and <i>y</i> litres. There is an infinite amount of water supply available.\nYou need to determine whether it is possible to measure exactly <i>z</i> litres using these two jugs.</p>\n\n<p>If <i>z</i> liters of water is measurable, you must have <i>z</i> liters of water contained within <b>one or both buckets</b> by the end.</p>\n\n<p>\nOperations allowed:\n</p><ul>\n<li>Fill any of the jugs completely with water.</li>\n<li>Empty any of the jugs.</li>\n<li>Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.</li>\n</ul>\n<p></p>\n\n<p><b>Example 1:</b> (From the famous <a href="https://www.youtube.com/watch?v=BVtQNK_ZUJg" target="_blank"><i>"Die Hard"</i> example</a>)\n</p><pre>Input: x = 3, y = 5, z = 4\nOutput: True\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre>Input: x = 2, y = 6, z = 5\nOutput: False\n</pre>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://discuss.leetcode.com/user/vinod23">@vinod23</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft'],
  },
  {
    id: '366',
    name: 'Find Leaves of Binary Tree ',
    acceptance: '60.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a binary tree, collect a tree\'s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.\n</p>\n\n<p>\n<b>Example:</b><br>\nGiven binary tree <br>\n</p><pre>          1\n         / \\\n        2   3\n       / \\     \n      4   5    \n</pre>\n<p></p>\n<p>\nReturns <code>[4, 5, 3], [2], [1]</code>.\n</p>\n\n<p>\n<b>Explanation:</b><br>\n</p><p>\n1. Removing the leaves <code>[4, 5, 3]</code> would result in this tree:\n</p><pre>          1\n         / \n        2          \n</pre>\n<p></p>\n<p>\n2. Now removing the leaf <code>[2]</code> would result in this tree:\n</p><pre>          1          \n</pre>\n<p></p>\n<p>\n3. Now removing the leaf <code>[1]</code> would result in the empty tree:\n</p><pre>          []         \n</pre>\n<p></p>\n<p></p>\n<p>\nReturns <code>[4, 5, 3], [2], [1]</code>.\n</p><p>\n\n</p><p><b>Credits:</b><br>Special thanks to <a href="https://discuss.leetcode.com/user/elmirap">@elmirap</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '367',
    name: 'Valid Perfect Square',
    acceptance: '38.5%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a positive integer <i>num</i>, write a function which returns True if <i>num</i> is a perfect square else False.</p>\n\n<p>\n<b>Note:</b> <b>Do not</b> use any built-in library function such as <code>sqrt</code>.\n</p>\n\n<p><b>Example 1:</b>\n</p><pre>Input: 16\nReturns: True\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre>Input: 14\nReturns: False\n</pre>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://discuss.leetcode.com/user/elmirap">@elmirap</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '368',
    name: 'Largest Divisible Subset',
    acceptance: '33.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a set of <b>distinct</b> positive integers, find the largest subset such that every pair (S<sub>i</sub>, S<sub>j</sub>) of elements in this subset satisfies: S<sub>i</sub> % S<sub>j</sub> = 0 or S<sub>j</sub> % S<sub>i</sub> = 0.\n</p>\n\n<p>If there are multiple solutions, return any subset is fine.\n</p>\n\n<p><b>Example 1:</b>\n</p><pre>nums: [1,2,3]\n\nResult: [1,2] (of course, [1,3] will also be ok)\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre>nums: [1,2,4,8]\n\nResult: [1,2,4,8]\n</pre>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/stomach_ache">@Stomach_ache</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '369',
    name: 'Plus One Linked List ',
    acceptance: '54.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a non-negative integer represented as <b>non-empty</b> a singly linked list of digits, plus one to the integer.</p>\n\n<p>You may assume the integer do not contain any leading zero, except the number 0 itself.</p>\n\n<p>The digits are stored such that the most significant digit is at the head of the list.</p>\n\n<p><b>Example:</b><br>\n</p><pre>Input:\n1-&gt;2-&gt;3\n\nOutput:\n1-&gt;2-&gt;4\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '370',
    name: 'Range Addition ',
    acceptance: '56.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Assume you have an array of length <b><i>n</i></b> initialized with all <b>0</b>\'s and are given <b><i>k</i></b> update operations.</p>\n\n<p>Each operation is represented as a triplet: <b>[startIndex, endIndex, inc]</b> which increments each element of subarray <b>A[startIndex ... endIndex]</b> (startIndex and endIndex inclusive) with <b>inc</b>.</p>\n\n<p>Return the modified array after all <b><i>k</i></b> operations were executed.</p>\n\n<p><b>Example:</b>\n</p><pre>Given:\n\n    length = 5,\n    updates = [\n        [1,  3,  2],\n        [2,  4,  3],\n        [0,  2, -2]\n    ]\n\nOutput:\n\n    [-2, 0, 3, 5, 3]\n</pre>\n<p></p>\n\n<p><b>Explanation:</b>\n</p><pre>Initial state:\n[ 0, 0, 0, 0, 0 ]\n\nAfter applying operation [1, 3, 2]:\n[ 0, 2, 2, 2, 0 ]\n\nAfter applying operation [2, 4, 3]:\n[ 0, 2, 5, 5, 3 ]\n\nAfter applying operation [0, 2, -2]:\n[-2, 0, 3, 5, 3 ]\n</pre>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://discuss.leetcode.com/user/vinod23">@vinod23</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-naive-approach-time-limit-exceeded">Approach #1 Naïve Approach [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-range-caching-accepted">Approach #2 Range Caching [Accepted]</a></li>\n</ul>\n</li>\n<li><a href="#further-thoughts">Further Thoughts</a></li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-naive-approach-time-limit-exceeded">Approach #1 Naïve Approach [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The algorithm is trivial. For each update query, we iterate over the required update range and update each element individually.</p>\n<p><strong>C++</strong></p>\n<p>Each query of <code>updates</code> is a tuple of 3 integers: <script type="math/tex; mode=display">start, end</script> (the start and end indexes for the update range) and <script type="math/tex; mode=display">val</script> (the amount by which each array element in this range must be incremented).</p>\n<div class="codehilite"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">getModifiedArray</span><span class="p">(</span><span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">updates</span><span class="p">)</span>\n<span class="p">{</span>\n    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>\n\n    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">tuple</span> <span class="p">:</span> <span class="n">updates</span><span class="p">)</span> <span class="p">{</span>\n        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end</span> <span class="o">=</span> <span class="n">tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">val</span> <span class="o">=</span> <span class="n">tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>\n\n        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>\n            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>\n        <span class="p">}</span>\n    <span class="p">}</span>\n\n    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>\n<span class="p">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n \\cdot k)</script> (worst case) where <script type="math/tex; mode=display">k</script> is the number of update queries and <script type="math/tex; mode=display">n</script> is the length of the array. Each of the <script type="math/tex; mode=display">k</script> update operations take up <script type="math/tex; mode=display">O(n)</script> time (worst case, when all updates are over the entire range).</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space required.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-range-caching-accepted">Approach #2 Range Caching [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<ul>\n<li>\n<p>There is only one read query on the entire range, and it occurs at the end of all update queries. Additionally, the order of processing update queries is irrelevant.</p>\n</li>\n<li>\n<p>Cumulative sums or <code>partial_sum</code> operations apply the effects of past elements to the future elements in the sequence.</p>\n</li>\n</ul>\n<p><strong>Algorithm</strong></p>\n<p>The algorithm makes use of the above intuition to simply store changes at the <em>borders</em> of the update ranges (instead of processing the entire range). Finally a single post processing operation is carried out over the entire output array.</p>\n<p>The two steps that are required are as follows:</p>\n<ol>\n<li>\n<p>For each update query <script type="math/tex; mode=display">(start, end, val)</script> on the array <script type="math/tex; mode=display">arr</script>, we need to do <em>only</em> two operations:</p>\n<ul>\n<li>Update <script type="math/tex; mode=display">start</script> boundary of the range:</li>\n</ul>\n<p>\n<script type="math/tex; mode=display">\narr_{start} = arr_{start} + val\n</script>\n</p>\n<ul>\n<li>Update just beyond the <script type="math/tex; mode=display">end</script> boundary of the range:</li>\n</ul>\n<p>\n<script type="math/tex; mode=display">\narr_{end+1} = arr_{end+1} - val\n</script>\n</p>\n</li>\n<li>\n<p>Final Transformation. The cumulative sum of the entire array is taken (<code>0</code> - based indexing)</p>\n<p>\n<script type="math/tex; mode=display">\narr_i = arr_i + arr_{i-1} \\quad \\forall \\quad i \\in [1, n)\n</script>\n</p>\n</li>\n</ol>\n<p><strong>C++</strong></p>\n<div class="codehilite"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">getModifiedArray</span><span class="p">(</span><span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">updates</span><span class="p">)</span>\n<span class="p">{</span>\n    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>\n\n    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">tuple</span> <span class="p">:</span> <span class="n">updates</span><span class="p">)</span> <span class="p">{</span>\n        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end</span> <span class="o">=</span> <span class="n">tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">val</span> <span class="o">=</span> <span class="n">tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>\n\n        <span class="n">result</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>\n        <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>\n            <span class="n">result</span><span class="p">[</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">val</span><span class="p">;</span>\n    <span class="p">}</span>\n\n    <span class="c1">// partial_sum applies the following operation (by default) for the parameters {x[0], x[n], y[0]}:</span>\n    <span class="c1">// y[0] = x[0]</span>\n    <span class="c1">// y[1] = y[0] + x[1]</span>\n    <span class="c1">// y[2] = y[1] + x[2]</span>\n    <span class="c1">// ...  ...  ...</span>\n    <span class="c1">// y[n] = y[n-1] + x[n]</span>\n\n    <span class="n">partial_sum</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">result</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>\n\n    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>\n<span class="p">}</span>\n</pre></div>\n<p><strong>Formal Explanation</strong></p>\n<p>For each update query <script type="math/tex; mode=display">(start, end, val)</script> on the array <script type="math/tex; mode=display">arr</script>, the goal is to achieve the result:</p>\n<p>\n<script type="math/tex; mode=display">\narr_i = arr_i + val \\quad \\forall \\quad i \\in [start, end]\n</script>\n</p>\n<p>Applying the final transformation, ensures two things:</p>\n<ol>\n<li>It carries over the <script type="math/tex; mode=display">+val</script> increment over to every element <script type="math/tex; mode=display"> arr_i \\; \\forall \\; i \\ge start </script>.</li>\n<li>It carries over the <script type="math/tex; mode=display">-val</script> increment (equivalently, a <script type="math/tex; mode=display">+val</script> decrement) over to every element <script type="math/tex; mode=display"> arr_j \\; \\forall \\; j \\gt end </script>.</li>\n</ol>\n<p>The net result is that:</p>\n<p>\n<script type="math/tex; mode=display">\n\\begin{align*}\narr_i &= arr_i + val  \\quad && \\forall \\quad i \\in [start, end] \\\\\narr_j &= arr_j + val - val = arr_j  \\quad && \\forall \\quad i \\in (end, length)\n\\end{align*}\n</script>\n</p>\n<p>which meets our end goal. It is easy to see that the updates over a range did not carry over beyond it due to the compensating effect of the <script type="math/tex; mode=display">-val</script> increment over the <script type="math/tex; mode=display">+val</script> increment.</p>\n<p>It is good to note that this works for multiple update queries because the particular binary operations here (namely addition and subtraction):</p>\n<ul>\n<li>\n<p>are <em>closed</em> over the entire domain of <code>Integer</code>s. (A counter example is division which is not closed over all <code>Integer</code>s).</p>\n</li>\n<li>\n<p>are <em>complementary</em> operations. (As a counter example multiplication and division are not always complimentary due to possible loss of precision when dividing <code>Integer</code>s).</p>\n</li>\n</ul>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n + k)</script>. Each of the <script type="math/tex; mode=display">k</script> update operations is done in constant <script type="math/tex; mode=display">O(1)</script> time. The final cumulative sum transformation takes <script type="math/tex; mode=display">O(n)</script> time always.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space required.</p>\n</li>\n</ul>\n<hr>\n<h2 id="further-thoughts">Further Thoughts</h2>\n<p>An extension of this problem is to apply such updates on an array where all elements are <strong>not</strong> the same.</p>\n<p>In this case, the second approach requires that the original configuration must be stored separately before applying the final transformation. This incurs an additional space complexity of <script type="math/tex; mode=display">O(n)</script>.</p>\n<p><a href="https://leetcode.com/StefanPochmann/">@StefanPochmann</a> <a href="https://discuss.leetcode.com/topic/51577/range-addition/2">suggested another method</a> which does not require extra space, but requires an extra linear pass over the entire array. The idea is to apply <em>reverse</em> <code>partial_sum</code> operation on the array (for example, array <script type="math/tex; mode=display">[2, 3, 10, 5]</script> transforms to <script type="math/tex; mode=display">[2, 1, 7, -5]</script>) as an initialization step and then proceed with the second method as usual.</p>\n<hr>\n<p>Another general, more complex version of this problem comprises of multiple read and update queries over <em>ranges</em>. Such problems can be solved quite efficiently with <a href="https://leetcode.com/articles/recursive-approach-segment-trees-range-sum-queries-lazy-propagation/">Segment Trees by applying a popular trick called <strong>Lazy Propogation</strong>.</a></p>\n<p>Analysis written by <a href="https://leetcode.com/babhishek21">@babhishek21</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '371',
    name: 'Sum of Two Integers',
    acceptance: '51.1%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Calculate the sum of two integers <i>a</i> and <i>b</i>, but you are <b>not allowed</b> to use the operator <code>+</code> and <code>-</code>.</p>\n\n<p><b>Example:</b><br>\nGiven <i>a</i> = 1 and <i>b</i> = 2, return 3.\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://discuss.leetcode.com/user/fujiaozhu">@fujiaozhu</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Hulu'],
  },
  {
    id: '372',
    name: 'Super Pow',
    acceptance: '34.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nYour task is to calculate <i>a</i><sup><i>b</i></sup> mod 1337 where <i>a</i> is a positive integer and <i>b</i> is an extremely large positive integer given in the form of an array.\n</p>\n\n<p><b>Example1:</b>\n</p><pre>a = 2\nb = [3]\n\nResult: 8\n</pre>\n<p></p>\n\n<p><b>Example2:</b>\n</p><pre>a = 2\nb = [1,0]\n\nResult: 1024\n</pre>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/stomach_ache">@Stomach_ache</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '373',
    name: 'Find K Pairs with Smallest Sums',
    acceptance: '31.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nYou are given two integer arrays <b>nums1</b> and <b>nums2</b> sorted in ascending order and an integer <b>k</b>. \n</p>\n\n<p>Define a pair <b>(u,v)</b> which consists of one element from the first array and one element from the second array.</p>\n\n<p>Find the k pairs <b>(u<sub>1</sub>,v<sub>1</sub>),(u<sub>2</sub>,v<sub>2</sub>) ...(u<sub>k</sub>,v<sub>k</sub>)</b> with the smallest sums.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre>Given nums1 = [1,7,11], nums2 = [2,4,6],  k = 3\n\nReturn: [1,2],[1,4],[1,6]\n\nThe first 3 pairs are returned from the sequence:\n[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre>Given nums1 = [1,1,2], nums2 = [1,2,3],  k = 2\n\nReturn: [1,1],[1,1]\n\nThe first 2 pairs are returned from the sequence:\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre>Given nums1 = [1,2], nums2 = [3],  k = 3 \n\nReturn: [1,3],[2,3]\n\nAll possible pairs are returned from the sequence:\n[1,3],[2,3]\n</pre>\n<p></p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/elmirap/">@elmirap</a> and <a href="https://leetcode.com/stefanpochmann/">@StefanPochmann</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Uber'],
  },
  {
    id: '374',
    name: 'Guess Number Higher or Lower',
    acceptance: '36.1%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>We are playing the Guess Game. The game is as follows:</p><p> \n\n</p><p>I pick a number from <b>1</b> to <b><i>n</i></b>. You have to guess which number I picked.</p>\n\n<p>Every time you guess wrong, I'll tell you whether the number is higher or lower.</p>\n\n<p>You call a pre-defined API <code>guess(int num)</code> which returns 3 possible results (<code>-1</code>, <code>1</code>, or <code>0</code>):</p>\n<pre>-1 : My number is lower\n 1 : My number is higher\n 0 : Congrats! You got it!\n</pre>\n\n<p><b>Example:</b><br>\n</p><pre>n = 10, I pick 6.\n\nReturn 6.\n</pre>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-binary-search-accepted">Approach #2 Binary Search [Accepted]</a></li>\n<li><a href="#approach-3-ternary-search-accepted">Approach #3 Ternary Search [Accepted]</a></li>\n</ul>\n</li>\n<li><a href="#follow-up">Follow up</a><ul>\n<li><a href="#comparisons-between-binary-search-and-ternary-search">Comparisons between Binary Search and Ternary Search</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>We check every number from 1 to n-1 and pass it to the <script type="math/tex; mode=display">guess</script> function. The number\nfor which a 0 is returned is the required answer.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="cm">/* The guess API is defined in the parent class GuessGame.</span>\n<span class="cm">   @param num, your guess</span>\n<span class="cm">   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span>\n<span class="cm">      int guess(int num); */</span>\n\n<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="kd">extends</span> <span class="n">GuessGame</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">guessNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">guess</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>\n                <span class="k">return</span> <span class="n">i</span><span class="o">;</span>\n        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We scan all the numbers from 1 to n.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space is used.</li>\n</ul>\n<hr>\n<h4 id="approach-2-binary-search-accepted">Approach #2 Binary Search [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can apply Binary Search to find the given number. We start with the mid\nnumber. We pass that number to the <script type="math/tex; mode=display">guess</script> function. If it returns a -1, it implies that the guessed number is larger than the required one. Thus, we use Binary Search for numbers lower than itself. Similarly, if it returns a 1, we use Binary Search\n for numbers higher than itself.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="cm">/* The guess API is defined in the parent class GuessGame.</span>\n<span class="cm">   @param num, your guess</span>\n<span class="cm">   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span>\n<span class="cm">      int guess(int num); */</span>\n\n<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="kd">extends</span> <span class="n">GuessGame</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">guessNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="o">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>\n            <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">guess</span><span class="o">(</span><span class="n">mid</span><span class="o">);</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">res</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>\n                <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>\n            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>\n                <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>\n            <span class="k">else</span>\n                <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O\\big(\\log_2 n\\big)</script>. Binary Search is used.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space is used.</li>\n</ul>\n<hr>\n<h4 id="approach-3-ternary-search-accepted">Approach #3 Ternary Search [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In Binary Search, we choose the middle element as the pivot in splitting. In Ternary Search, we choose two pivots (say <script type="math/tex; mode=display">m1</script> and <script type="math/tex; mode=display">m2</script>) such that the given range is divided into three equal parts. If the required number <script type="math/tex; mode=display">num</script> is less than <script type="math/tex; mode=display">m1</script> then we apply ternary search on the left segment of <script type="math/tex; mode=display">m1</script>. If <script type="math/tex; mode=display">num</script> lies between <script type="math/tex; mode=display">m1</script> and <script type="math/tex; mode=display">m2</script>, we apply ternary search between <script type="math/tex; mode=display">m1</script> and <script type="math/tex; mode=display">m2</script>. Otherwise we will search in the segment right to <script type="math/tex; mode=display">m2</script>.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="cm">/* The guess API is defined in the parent class GuessGame.</span>\n<span class="cm">   @param num, your guess</span>\n<span class="cm">   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span>\n<span class="cm">      int guess(int num); */</span>\n\n<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="kd">extends</span> <span class="n">GuessGame</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">guessNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">mid1</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="o">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="o">)</span> <span class="o">/</span> <span class="mi">3</span><span class="o">;</span>\n            <span class="kt">int</span> <span class="n">mid2</span> <span class="o">=</span> <span class="n">high</span> <span class="o">-</span> <span class="o">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="o">)</span> <span class="o">/</span> <span class="mi">3</span><span class="o">;</span>\n            <span class="kt">int</span> <span class="n">res1</span> <span class="o">=</span> <span class="n">guess</span><span class="o">(</span><span class="n">mid1</span><span class="o">);</span>\n            <span class="kt">int</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">guess</span><span class="o">(</span><span class="n">mid2</span><span class="o">);</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">res1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>\n                <span class="k">return</span> <span class="n">mid1</span><span class="o">;</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">res2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>\n                <span class="k">return</span> <span class="n">mid2</span><span class="o">;</span>\n            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">res1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>\n                <span class="n">high</span> <span class="o">=</span> <span class="n">mid1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>\n            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">res2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>\n                <span class="n">low</span> <span class="o">=</span> <span class="n">mid2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n            <span class="k">else</span> <span class="o">{</span>\n                <span class="n">low</span> <span class="o">=</span> <span class="n">mid1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n                <span class="n">high</span> <span class="o">=</span> <span class="n">mid2</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O\\big(\\log_3 n \\big)</script>. Ternary Search is used.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space is used.</li>\n</ul>\n<hr>\n<h2 id="follow-up">Follow up</h2>\n<p>It seems that ternary search is able to terminate earlier compared to binary search. But why is binary search more widely used?</p>\n<h4 id="comparisons-between-binary-search-and-ternary-search">Comparisons between Binary Search and Ternary Search</h4>\n<p>Ternary Search is worse than Binary Search. The following outlines the recursive formula to count comparisons of Binary Search in the worst case.</p>\n<p>\n<script type="math/tex; mode=display">\n\\begin{align*}\nT(n) &= T\\bigg(\\frac{n}{2} \\ \\bigg) + 2, \\quad T(1) = 1 \\\\\nT\\bigg(\\frac{n}{2} \\ \\bigg) &= T\\bigg(\\frac{n}{2^2} \\ \\bigg) + 2 \\\\\n\\\\\n\\therefore{} \\quad T(n) &= T\\bigg(\\frac{n}{2^2} \\ \\bigg) + 2 \\times 2 \\\\\n&= T\\bigg(\\frac{n}{2^3} \\ \\bigg) + 3 \\times 2 \\\\\n&= \\ldots \\\\\n&= T\\bigg(\\frac{n}{2^{\\log_2 n}} \\ \\bigg) + 2 \\log_2 n \\\\\n&= T(1) + 2 \\log_2 n \\\\\n&= 1 + 2 \\log_2 n\n\\end{align*}\n</script>\n</p>\n<p>The following outlines the recursive formula to count comparisons of Ternary Search in the worst case.</p>\n<p>\n<script type="math/tex; mode=display">\n\\begin{align*}\nT(n) &= T\\bigg(\\frac{n}{3} \\ \\bigg) + 4, \\quad T(1) = 1 \\\\\nT\\bigg(\\frac{n}{3} \\ \\bigg) &= T\\bigg(\\frac{n}{3^2} \\ \\bigg) + 4 \\\\\n\\\\\n\\therefore{} \\quad T(n) &= T\\bigg(\\frac{n}{3^2} \\ \\bigg) + 2 \\times 4 \\\\\n&= T\\bigg(\\frac{n}{3^3} \\ \\bigg) + 3 \\times 4 \\\\\n&= \\ldots \\\\\n&= T\\bigg(\\frac{n}{3^{\\log_3 n}} \\ \\bigg) + 4 \\log_3 n \\\\\n&= T(1) + 4 \\log_3 n \\\\\n&= 1 + 4 \\log_3 n\n\\end{align*}\n</script>\n</p>\n<p>As shown above, the total comparisons in the worst case for ternary and binary search are <script type="math/tex; mode=display">1 + 4 \\log_3 n</script> and <script type="math/tex; mode=display">1 + 2 \\log_2 n</script> comparisons respectively. To determine which is larger, we can just look at the expression <script type="math/tex; mode=display">2 \\log_3 n</script> and <script type="math/tex; mode=display">\\log_2 n</script> . The expression <script type="math/tex; mode=display">2 \\log_3 n</script> can be written as <script type="math/tex; mode=display">\\frac{2}{\\log_2 3} \\times \\log_2 n</script> . Since the value of <script type="math/tex; mode=display">\\frac{2}{\\log_2 3}</script> is greater than one, Ternary Search does more comparisons than Binary Search in the worst case.</p>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '375',
    name: 'Guess Number Higher or Lower II',
    acceptance: '35.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>We are playing the Guess Game. The game is as follows:</p><p> \n\n</p><p>I pick a number from <strong>1</strong> to <strong>n</strong>. You have to guess which number I picked.</p>\n\n<p>Every time you guess wrong, I\'ll tell you whether the number I picked is higher or lower. </p>\n\n<p>However, when you guess a particular number x,  and you guess wrong, you pay <b>$x</b>. You win the game when you guess the number I picked.</p>\n\n<p>\n<b>Example:</b>\n</p><pre>n = 10, I pick 8.\n\nFirst round:  You guess 5, I tell you that it\'s higher. You pay $5.\nSecond round: You guess 7, I tell you that it\'s higher. You pay $7.\nThird round:  You guess 9, I tell you that it\'s lower. You pay $9.\n\nGame over. 8 is the number I picked.\n\nYou end up paying $5 + $7 + $9 = $21.\n</pre>\n<p></p>\n\n<p>Given a particular <strong>n ≥ 1</strong>, find out how much money you need to have to guarantee a <b>win</b>.</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/agave/">@agave</a> and <a href="https://leetcode.com/stefanpochmann/">@StefanPochmann</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-modified-brute-force-time-limit-exceeded">Approach #2 Modified Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-using-dp-accepted">Approach #3 Using DP [Accepted]</a></li>\n<li><a href="#approach-4-better-approach-using-dp-accepted">Approach #4 Better Approach using DP [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>Given a number <script type="math/tex; mode=display">n</script>, we have to find the worst case cost of guessing a number chosen from the range <script type="math/tex; mode=display">(1, n)</script>, assuming that the guesses are made intelligently(minimize the total cost). The cost is incremented by <script type="math/tex; mode=display">i</script> for every wrong guess <script type="math/tex; mode=display">i</script>.</p>\n<p>For example:</p>\n<div class="codehilite"><pre><span></span>n=5\n1 2 3 4 5\n</pre></div>\n<p>If we start with 3 as the initial guess, the next guess would certainly be 4 as in the worst case required number is 5. Total Cost <script type="math/tex; mode=display">= 4+3=7</script>.</p>\n<p>But if we start with 4 as the initial guess, our next guess would be 2 as in the worst case required number is 3 or 1. Total Cost <script type="math/tex; mode=display">=4+2=6</script> which is the minimum cost.</p>\n<div class="codehilite"><pre><span></span>n=8\n1 2 3 4 5 6 7 8\n</pre></div>\n<p>In this case we have to guess 5 followed by 7. Total Cost <script type="math/tex; mode=display">=5+7=12</script>.\nIf we choose 4 as our intial guess. Total Cost <script type="math/tex; mode=display">=4+5+7=16</script>.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>Firstly, we need to be aware of the fact that out of the range <script type="math/tex; mode=display">(1, n)</script>, we have to guess the numbers intelligently in order to minimize the cost. But, along with that we have to take into account the worst case scenario possible, that is we have to assume that the original number chosen is such that it will try to maximize the overall cost.</p>\n<p>In Brute Force, we can pick up any number <script type="math/tex; mode=display">i</script> in the range <script type="math/tex; mode=display">(1, n)</script>. Assuming it is a wrong guess(worst case scenario), we have to minimize the cost of reaching the required number. Now, the required number could be lying either to the right or left of the number picked(<script type="math/tex; mode=display">i</script>). But to cover the possibility of the worst case number chosen, we need to take the maximum cost out of the cost of reaching the worst number out of the right and left segments of <script type="math/tex; mode=display">i</script>. Thus, if we pick up <script type="math/tex; mode=display">i</script> as the pivot, the overall minimum cost for the worst required number will be:</p>\n<p>\n<script type="math/tex; mode=display">\n\\mathrm{cost}(1, n)=i + \\max\\big(\\mathrm{cost}(1,i-1), \\mathrm{cost}(i+1,n)\\big)\n</script>\n</p>\n<p>For every segment, we can further choose another pivot and repeat the same process for calculating the minimum cost.</p>\n<p>By using the above procedure, we found out the cost of reaching the required number starting with <script type="math/tex; mode=display">i</script> as the pivot. In the same way, we iterate over all the numbers in the range <script type="math/tex; mode=display">(1, n)</script>, choosing them as the pivot, calculating the cost of every pivot chosen and thus, we can find the minimum cost out of those.</p>\n<iframe frameborder="0" height="326" name="QW3ndyqL" src="https://leetcode.com/playground/QW3ndyqL/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n!)</script>. We choose a number as pivot and repeat the pivoting process further <script type="math/tex; mode=display">n</script> times <script type="math/tex; mode=display">O(n!)</script>. We repeat the same process for <script type="math/tex; mode=display">n</script> pivots.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Recursion of depth <script type="math/tex; mode=display">n</script> is used.</li>\n</ul>\n<hr>\n<h4 id="approach-2-modified-brute-force-time-limit-exceeded">Approach #2 Modified Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In Brute Force, for numbers in the range <script type="math/tex; mode=display">(i, j)</script>, we picked up every number from <script type="math/tex; mode=display">i</script> to <script type="math/tex; mode=display">j</script> as the pivot and found the maximum cost out of its left and right segments. But an important point to observe is that if we choose any number from the range <script type="math/tex; mode=display">\\big( i,\\frac{i+j}{2} \\big)</script> as the pivot, the right segment(consisting of numbers larger than the picked up pivot) will be longer than the left segment(consisting of numbers smaller than it). Thus, we will always get the maximum cost from its right segment and it will be larger than the minimum cost achievable by choosing some other pivot. Therefore, our objective here is to reduce the larger cost which is coming from the right segment. Thus, it is wise to choose the pivot from the range <script type="math/tex; mode=display">\\big(\\frac{i+j}{2}, j\\big)</script>. In this way the costs of the two segments will be nearer to each other and this will minimize the overall cost.</p>\n<p>Thus, while choosing the pivot instead of iterating from <script type="math/tex; mode=display">i</script> to <script type="math/tex; mode=display">j</script>, we iterate from <script type="math/tex; mode=display">\\frac{i+j}{2}</script> to <script type="math/tex; mode=display">j</script> and find the minimum achievable cost similar to brute force.</p>\n<iframe frameborder="0" height="309" name="juXrfQvD" src="https://leetcode.com/playground/juXrfQvD/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n!)</script>. We choose a number as pivot and repeat the pivoting process further <script type="math/tex; mode=display">n</script> times <script type="math/tex; mode=display">O(n!)</script>. We repeat the same process for <script type="math/tex; mode=display">n</script> pivots.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Recursion of depth <script type="math/tex; mode=display">n</script> is used.</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-dp-accepted">Approach #3 Using DP [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The problem of finding the minimum cost of reaching the destination number choosing <script type="math/tex; mode=display">i</script> as a pivot can be divided into the subproblem of finding the maximum out of the minimum costs of its left and right segments as explained above. For each segment, we can continue the process leading to smaller and smaller subproblems. This leads us to the conclusion that we can use DP for this problem.</p>\n<p>We need to use a <script type="math/tex; mode=display">dp</script> matrix, where <script type="math/tex; mode=display">dp(i, j)</script> refers to the minimum cost of finding the worst number given only the numbers in the range <script type="math/tex; mode=display">(i, j)</script>. Now, we need to know how to fill in the entries of this <script type="math/tex; mode=display">dp</script>. If we are given only a single number <script type="math/tex; mode=display">k</script>, no matter what the number is the cost of finding that number is always 0 since we always hit the number directly without any wrong guess. Thus, firstly, we fill in all the entries of the <script type="math/tex; mode=display">dp</script> which correspond to segments of length 1 i.e. all entries <script type="math/tex; mode=display">dp(k, k)</script> are initialized to 0. Then, in order to find the entries for segments of length 2, we need all the entries for segments of length 1. Thus, in general, to fill in the entries corresponding to segments of length <script type="math/tex; mode=display">len</script>, we need all the entries of length <script type="math/tex; mode=display">len-1</script> and below to be already filled. Thus, we need to fill the entries in the order of their segment lengths. Thus, we fill the entries of <script type="math/tex; mode=display">dp</script> diagonally.</p>\n<p>Now, what criteria do we need to fill up the <script type="math/tex; mode=display">dp</script> matrix? For any entry  <script type="math/tex; mode=display">dp(i, j)</script>, given the current segment length of interest is <script type="math/tex; mode=display">len</script> i.e. if <script type="math/tex; mode=display">len=j-i+1</script>, we assume as if we are available only with the numbers in the range <script type="math/tex; mode=display">(i, j)</script>. To fill in its current entry, we follow the same process as Approach 1, choosing every number as the pivot and finding the minimum cost as:</p>\n<p>\n<script type="math/tex; mode=display">\n\\mathrm{cost}(i, j)=\\mathrm{pivot} + \\max\\big(\\mathrm{cost}(i,\\mathrm{pivot}-1), \\mathrm{cost}(\\mathrm{pivot}+1,n)\\big)\n</script>\n</p>\n<p>But, we have an advantage in terms of calculating the cost here, since we already know the costs for the segments of length smaller than <script type="math/tex; mode=display">len</script> from <script type="math/tex; mode=display">dp</script>. Thus, the dp equation becomes:</p>\n<p>\n<script type="math/tex; mode=display">\n\\mathrm{dp}(i, j) = \\min_{\\mathrm{pivots}(i, j)} \\big[ \\mathrm{pivot} + \\max \\big( \\mathrm{dp}(i,\\mathrm{pivot}-1) , \\mathrm{dp}(\\mathrm{pivot}+1,n) \\big) \\big]\n</script>\n</p>\n<p>where <script type="math/tex; mode=display">\\min_{\\mathrm{pivots}(i, j)}</script> indicates the minimum obtained by considering every number in the range <script type="math/tex; mode=display">(i, j)</script> as the pivot.</p>\n<p>The following animation will make the process more clear for n=5:\n<!--<img alt="Guess Number Higher or Lower" src="https://leetcode.com/media/original_images/375_Guess_Number_Higher_or_Lower.gif" />-->\n!?!../Documents/375_Guess.json:791,552!?!</p>\n<iframe frameborder="0" height="326" name="X99KiHYD" src="https://leetcode.com/playground/X99KiHYD/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. We traverse the complete <script type="math/tex; mode=display">dp</script> matrix once <script type="math/tex; mode=display">(O(n^2))</script>. For every entry we take atmost <script type="math/tex; mode=display">n</script> numbers as pivot.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^2)</script>. <script type="math/tex; mode=display">dp</script> matrix of size <script type="math/tex; mode=display">n^2</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-better-approach-using-dp-accepted">Approach #4 Better Approach using DP [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we chose every possible pivot from the range <script type="math/tex; mode=display">(i, j)</script>. But, as per the argument given in Approach 2, we can choose pivots only from the range <script type="math/tex; mode=display">\\big(i+(len-1)/2,j\\big)</script>, where <script type="math/tex; mode=display">len</script> is the current segment length of interest.\nThus the governing equation is:</p>\n<p>\n<script type="math/tex; mode=display">\n\\mathrm{dp}(i, j)=\\min_{\\mathrm{pivots}\\big(i+\\frac{len-1}{2}, j\\big)}\\big[\\mathrm{pivot} + \\max\\big(\\mathrm{dp}(i,\\mathrm{pivot}-1), \\mathrm{dp}(\\mathrm{pivot}+1,n)\\big)\\big]\n</script>\n</p>\n<p>Thus, we can optimize the Approach 3 to some extent.</p>\n<iframe frameborder="0" height="360" name="vxpg2Chd" src="https://leetcode.com/playground/vxpg2Chd/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. We traverse the complete <script type="math/tex; mode=display">dp</script> matrix once <script type="math/tex; mode=display">(O(n^2))</script>. For every entry we take at most <script type="math/tex; mode=display">n</script> numbers as pivot.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^2)</script>. <script type="math/tex; mode=display">dp</script> matrix of size <script type="math/tex; mode=display">n^2</script> is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '376',
    name: 'Wiggle Subsequence',
    acceptance: '36.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>A sequence of numbers is called a <strong>wiggle sequence</strong> if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. </p>\n\n<p>For example, <code>[1,7,4,9,2,5]</code> is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, <code>[1,4,7,2,5]</code> and <code>[1,7,4,5,5]</code> are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.</p>\n\n<p>Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.</p>\n\n<p><b>Examples:</b><br>\n</p><pre><b>Input:</b> [1,7,4,9,2,5]\n<b>Output:</b> 6\nThe entire sequence is a wiggle sequence.\n\n<b>Input:</b> [1,17,5,10,13,15,10,5,16,8]\n<b>Output:</b> 7\nThere are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].\n\n<b>Input:</b> [1,2,3,4,5,6,7,8,9]\n<b>Output:</b> 2\n</pre>\n<p></p>\n\n<p><b>Follow up:</b><br>\nCan you do it in O(<i>n</i>) time?\n</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/agave/">@agave</a> and <a href="https://leetcode.com/stefanpochmann/">@StefanPochmann</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-dynamic-programming-accepted">Approach #2  Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-3-linear-dynamic-programming-accepted">Approach #3 Linear Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-4-space-optimized-dynamic-programming-accepted">Approach #4 Space-Optimized Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-5-greedy-approach-accepted">Approach #5 Greedy Approach [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>We need to find the length of the longest wiggle subsequence. A wiggle subsequence consists of a subsequence with numbers which appears in alternating ascending / descending order.</p>\n<h2 id="solution">Solution</h2>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>Here, we can find the length of every possible wiggle subsequence and find the maximum length out of them. To implement this, we use a recursive function, <script type="math/tex; mode=display">\\text{calculate}(\\text{nums}, \\text{index}, \\text{isUp})</script> which takes the array <script type="math/tex; mode=display">\\text{nums}</script>, the <script type="math/tex; mode=display">\\text{index}</script> from which we need to find the length of the longest wiggle subsequence, boolean variable <script type="math/tex; mode=display">\\text{isUp}</script> to tell whether we need to find an increasing wiggle or decreasing wiggle respectively. If the function <script type="math/tex; mode=display">\\text{calculate}</script> is called after an increasing wiggle, we need to find the next decreasing wiggle with the same function. If the function <script type="math/tex; mode=display">\\text{calculate}</script> is called after a decreasing wiggle, we need to find the next increasing wiggle with the same function.</p>\n<iframe frameborder="0" height="326" name="JXWefkVB" src="https://leetcode.com/playground/JXWefkVB/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n!)</script>. <script type="math/tex; mode=display">\\text{calculate}()</script> will be called maximum <script type="math/tex; mode=display">n!</script> times.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Recursion of depth <script type="math/tex; mode=display">n</script> is used.</li>\n</ul>\n<hr>\n<h4 id="approach-2-dynamic-programming-accepted">Approach #2  Dynamic Programming [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>To understand this approach, take two arrays for dp named <script type="math/tex; mode=display">up</script> and <script type="math/tex; mode=display">down</script>.</p>\n<p>Whenever we pick up any element of the array to be a part of the wiggle subsequence, that element could be a part of a rising wiggle or a falling wiggle depending upon which element we have taken prior to it.</p>\n<p>\n<script type="math/tex; mode=display">up[i]</script> refers to the length of the longest wiggle subsequence obtained so far considering <script type="math/tex; mode=display">i^{th}</script> element as the last element of the wiggle subsequence and ending with a rising wiggle.</p>\n<p>Similarly, <script type="math/tex; mode=display">down[i]</script> refers to the length of the longest wiggle subsequence obtained so far considering <script type="math/tex; mode=display">i^{th}</script> element as the last element of the wiggle subsequence and ending with a falling wiggle.</p>\n<p>\n<script type="math/tex; mode=display">up[i]</script> will be updated every time we find a rising wiggle ending with the <script type="math/tex; mode=display">i^{th}</script> element. Now, to find <script type="math/tex; mode=display">up[i]</script>, we need to consider the maximum out of all the previous wiggle subsequences ending with a falling wiggle i.e. <script type="math/tex; mode=display">down[j]</script>, for every <script type="math/tex; mode=display">j&lt;i</script> and <script type="math/tex; mode=display">nums[i]&gt;nums[j]</script>. Similarly, <script type="math/tex; mode=display">down[i]</script> will be updated.</p>\n<iframe frameborder="0" height="360" name="5DeX9SiP" src="https://leetcode.com/playground/5DeX9SiP/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Loop inside a loop.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Two arrays of the same length are used for dp.</li>\n</ul>\n<hr>\n<h4 id="approach-3-linear-dynamic-programming-accepted">Approach #3 Linear Dynamic Programming [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Any element in the array could correspond to only one of the three possible states:</p>\n<ol>\n<li>up position, it means <script type="math/tex; mode=display">nums[i] > nums[i-1]</script>\n</li>\n<li>down position, it means <script type="math/tex; mode=display">nums[i] < nums[i-1]</script>\n</li>\n<li>equals to position, <script type="math/tex; mode=display">nums[i] == nums[i-1]</script>\n</li>\n</ol>\n<p>The updates are done as:</p>\n<p>If <script type="math/tex; mode=display">nums[i] > nums[i-1]</script>, that means it wiggles up. The element before it must be a down position. So <script type="math/tex; mode=display">up[i] = down[i-1] + 1</script>, <script type="math/tex; mode=display">down[i]</script> remains the same as <script type="math/tex; mode=display">down[i-1]</script>.\nIf <script type="math/tex; mode=display">nums[i] < nums[i-1]</script>, that means it wiggles down. The element before it must be a up position. So <script type="math/tex; mode=display">down[i] = up[i-1] + 1</script>, <script type="math/tex; mode=display">up[i]</script> remains the same as <script type="math/tex; mode=display">up[i-1]</script>.\nIf <script type="math/tex; mode=display">nums[i] == nums[i-1]</script>, that means it will not change anything becaue it didn\'t wiggle at all. So both <script type="math/tex; mode=display">down[i]</script> and <script type="math/tex; mode=display">up[i]</script> remain the same as <script type="math/tex; mode=display">down[i-1]</script> and <script type="math/tex; mode=display">up[i-1]</script>.</p>\n<p>At the end, we can find the larger out of <script type="math/tex; mode=display">up[length-1]</script> and <script type="math/tex; mode=display">down[length-1]</script> to find the max. wiggle subsequence length, where <script type="math/tex; mode=display">length</script> refers to the number of elements in the given array.</p>\n<p>The process can be illustrated with the following example:</p>\n<!--![Wiggle gif](https://leetcode.com/media/original_images/376_Wiggle_Subsequence.gif)-->\n<p>!?!../Documents/376_Wiggle.json:1000,563!?!</p>\n<iframe frameborder="0" height="428" name="iKGkFpFG" src="https://leetcode.com/playground/iKGkFpFG/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Only one pass over the array length.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Two arrays of the same length are used for dp.</li>\n</ul>\n<hr>\n<h4 id="approach-4-space-optimized-dynamic-programming-accepted">Approach #4 Space-Optimized Dynamic Programming [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This approach relies on the same concept as <a href="https://leetcode.com/articles/wiggle-subsequence/#approach-3-linear-dynamic-programming-accepted">Approach #3</a>. But we can observe that in the DP approach, for updating elements <script type="math/tex; mode=display">up[i]</script> and <script type="math/tex; mode=display">down[i]</script>, we need only the elements <script type="math/tex; mode=display">up[i-1]</script> and <script type="math/tex; mode=display">down[i-1]</script>. Thus, we can save space by not using the whole array, but only the last elements.</p>\n<iframe frameborder="0" height="292" name="hUCEjR4D" src="https://leetcode.com/playground/hUCEjR4D/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Only one pass over the array length.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</li>\n</ul>\n<hr>\n<h4 id="approach-5-greedy-approach-accepted">Approach #5 Greedy Approach [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We need not necessarily need dp to solve this problem. This problem is equivalent to finding the number of alternating max. and min. peaks in the array. Since, if we choose any other intermediate number to be a part of the current wiggle subsequence, the maximum length of that wiggle subsequence will always be less than or equal to the one obtained by choosing only the consecutive max. and min. elements.</p>\n<p>This can be clarified by looking at the following figure:\n<img alt="Wiggle Peaks" src="https://leetcode.com/media/original_images/376_Wiggle_Subsequence.PNG"></p>\n<p>From the above figure, we can see that if we choose <strong>C</strong> instead of <strong>D</strong> as the 2nd point in the wiggle subsequence, we can\'t include the point <strong>E</strong>. Thus, we won\'t obtain the maximum length wiggle subsequence.</p>\n<p>Thus, to solve this problem, we maintain a variable <script type="math/tex; mode=display">\\text{prevdiff}</script>, where <script type="math/tex; mode=display">\\text{prevdiff}</script> is used to indicate whether the current subsequence of numbers lies in an increasing or decreasing wiggle. If <script type="math/tex; mode=display">\\text{prevdiff} > 0</script>, it indicates that we have found the increasing wiggle and are looking for a decreasing wiggle now. Thus, we update the length of the found subsequence when <script type="math/tex; mode=display">\\text{diff}</script> (<script type="math/tex; mode=display">nums[i]-nums[i-1]</script>) becomes negative. Similarly, if <script type="math/tex; mode=display">\\text{prevdiff} < 0</script>, we will update the count when <script type="math/tex; mode=display">\\text{diff}</script> (<script type="math/tex; mode=display">nums[i]-nums[i-1]</script>) becomes positive.</p>\n<p>When the complete array has been traversed, we get the required count, which represents the length of the longest wiggle subsequence.</p>\n<iframe frameborder="0" height="326" name="AqoaR5Ks" src="https://leetcode.com/playground/AqoaR5Ks/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We traverse the given array once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '377',
    name: 'Combination Sum IV',
    acceptance: '42.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p> Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>\n\n<p><b>Example:</b>\n</p><pre><i><b>nums</b></i> = [1, 2, 3]\n<i><b>target</b></i> = 4\n\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n\nNote that different sequences are counted as different combinations.\n\nTherefore the output is <i><b>7</b></i>.\n</pre>\n<p></p>\n\n<p><b>Follow up:</b><br>\nWhat if negative numbers are allowed in the given array?<br>\nHow does it change the problem?<br>\nWhat limitation we need to add to the question to allow negative numbers? </p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/pbrother/">@pbrother</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Snapchat'],
  },
  {
    id: '378',
    name: 'Kth Smallest Element in a Sorted Matrix',
    acceptance: '45.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a <i>n</i> x <i>n</i> matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>\n\n<p>\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\n</p>\n\n<p><b>Example:</b>\n</p><pre>matrix = [\n   [ 1,  5,  9],\n   [10, 11, 13],\n   [12, 13, 15]\n],\nk = 8,\n\nreturn 13.\n</pre>\n<p></p>\n\n<p><b>Note: </b><br>\nYou may assume k is always valid, 1 ≤ k ≤ n<sup>2</sup>.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Twitter'],
  },
  {
    id: '379',
    name: 'Design Phone Directory ',
    acceptance: '34.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Design a Phone Directory which supports the following operations:</p>\n\n<p>\n</p><ol>\n<li><code>get</code>: Provide a number which is not assigned to anyone.</li>\n<li><code>check</code>: Check if a number is available or not.</li>\n<li><code>release</code>: Recycle or release a number.</li>\n</ol>\n<p></p>\n\n<p><b>Example:</b>\n</p><pre>// Init a phone directory containing a total of 3 numbers: 0, 1, and 2.\nPhoneDirectory directory = new PhoneDirectory(3);\n\n// It can return any available phone number. Here we assume it returns 0.\ndirectory.get();\n\n// Assume it returns 1.\ndirectory.get();\n\n// The number 2 is available, so return true.\ndirectory.check(2);\n\n// It returns 2, the only number that is left.\ndirectory.get();\n\n// The number 2 is no longer available, so return false.\ndirectory.check(2);\n\n// Release number 2 back to the pool.\ndirectory.release(2);\n\n// Number 2 is available again, return true.\ndirectory.check(2);\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '380',
    name: 'Insert Delete GetRandom O(1)',
    acceptance: '39.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Design a data structure that supports all following operations in <i>average</i> <b>O(1)</b> time.</p>\n\n<p>\n</p><ol>\n<li><code>insert(val)</code>: Inserts an item val to the set if not already present.</li>\n<li><code>remove(val)</code>: Removes an item val from the set if present.</li>\n<li><code>getRandom</code>: Returns a random element from current set of elements. Each element must have the <b>same probability</b> of being returned.</li>\n</ol>\n<p></p>\n\n<p><b>Example:</b>\n</p><pre>// Init an empty set.\nRandomizedSet randomSet = new RandomizedSet();\n\n// Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomSet.insert(1);\n\n// Returns false as 2 does not exist in the set.\nrandomSet.remove(2);\n\n// Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomSet.insert(2);\n\n// getRandom should return either 1 or 2 randomly.\nrandomSet.getRandom();\n\n// Removes 1 from the set, returns true. Set now contains [2].\nrandomSet.remove(1);\n\n// 2 was already in the set, so return false.\nrandomSet.insert(2);\n\n// Since 2 is the only number in the set, getRandom always return 2.\nrandomSet.getRandom();\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Amazon', 'Uber', 'Twitter', 'Yelp', 'Pocket Gems'],
  },
  {
    id: '381',
    name: 'Insert Delete GetRandom O(1) - Duplicates allowed',
    acceptance: '29.2%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Design a data structure that supports all following operations in <i>average</i> <b>O(1)</b> time.</p>\n<b>Note: Duplicate elements are allowed.</b>\n<p>\n</p><ol>\n<li><code>insert(val)</code>: Inserts an item val to the collection.</li>\n<li><code>remove(val)</code>: Removes an item val from the collection if present.</li>\n<li><code>getRandom</code>: Returns a random element from current collection of elements. The probability of each element being returned is <b>linearly related</b> to the number of same value the collection contains.</li>\n</ol>\n<p></p>\n\n<p><b>Example:</b>\n</p><pre>// Init an empty collection.\nRandomizedCollection collection = new RandomizedCollection();\n\n// Inserts 1 to the collection. Returns true as the collection did not contain 1.\ncollection.insert(1);\n\n// Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].\ncollection.insert(1);\n\n// Inserts 2 to the collection, returns true. Collection now contains [1,1,2].\ncollection.insert(2);\n\n// getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.\ncollection.getRandom();\n\n// Removes 1 from the collection, returns true. Collection now contains [1,2].\ncollection.remove(1);\n\n// getRandom should return 1 and 2 both equally likely.\ncollection.getRandom();\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Yelp'],
  },
  {
    id: '382',
    name: 'Linked List Random Node',
    acceptance: '47.3%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given a singly linked list, return a random node's value from the linked list. Each node must have the <b>same probability</b> of being chosen.</p>\n\n<p><b>Follow up:</b><br>\nWhat if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?\n</p>\n\n<p><b>Example:</b>\n</p><pre>// Init a singly linked list [1,2,3].\nListNode head = new ListNode(1);\nhead.next = new ListNode(2);\nhead.next.next = new ListNode(3);\nSolution solution = new Solution(head);\n\n// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.\nsolution.getRandom();\n</pre>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '383',
    name: 'Ransom Note',
    acceptance: '47.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom \nnote can be constructed from the magazines ; otherwise, it will return false. \n</p>\n<p>\nEach letter in the magazine string can only be used once in your ransom note.\n</p>\n\n<p><b>Note:</b><br>\nYou may assume that both strings contain only lowercase letters.\n</p>\n\n<pre>canConstruct("a", "b") -&gt; false\ncanConstruct("aa", "ab") -&gt; false\ncanConstruct("aa", "aab") -&gt; true\n</pre>\n\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Apple'],
  },
  {
    id: '384',
    name: 'Shuffle an Array',
    acceptance: '47.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Shuffle a set of numbers without duplicates.\n</p>\n\n<p><b>Example:</b>\n</p><pre>// Init an array with set 1, 2, and 3.\nint[] nums = {1,2,3};\nSolution solution = new Solution(nums);\n\n// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\nsolution.shuffle();\n\n// Resets the array back to its original configuration [1,2,3].\nsolution.reset();\n\n// Returns the random shuffling of array [1,2,3].\nsolution.shuffle();\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#initial-thoughts">Initial Thoughts</a></li>\n<li><a href="#approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-fisher-yates-algorithm-accepted">Approach #2 Fisher-Yates Algorithm [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="initial-thoughts">Initial Thoughts</h4>\n<p>Normally I would display more than two approaches, but shuffling is\ndeceptively easy to do <em>almost</em> properly, and the Fisher-Yates algorithm is\nboth the canonical solution and asymptotically optimal.</p>\n<p>A few notes on randomness are necessary before beginning - both approaches\ndisplayed below assume that the languages\' pseudorandom number generators\n(PRNGs) are sufficiently random. The sample code uses the simplest techniques\navailable for getting pseudorandom numbers, but for each possible permutation\nof the array to be truly equally likely, more care must be taken. For\nexample, an array of length <script type="math/tex; mode=display">n</script> has <script type="math/tex; mode=display">n!</script> distinct permutations. Therefore, in\norder to encode all permutations in an integer space, <script type="math/tex; mode=display">\\lceil lg(n!)\\rceil</script>\nbits are necessary, which may not be guaranteed by the default PRNG.</p>\n<h4 id="approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we put each number in a "hat" and draw them out at random, the order in\nwhich we draw them will define a random ordering.</p>\n<p><strong>Algorithm</strong></p>\n<p>The brute force algorithm essentially puts each number in the aforementioned\n"hat", and draws them at random (without replacement) until there are none\nleft. Mechanically, this is performed by copying the contents of <code>array</code> into\na second auxiliary array named <code>aux</code> before overwriting each element of\n<code>array</code> with a randomly selected one from <code>aux</code>. After selecting each random\nelement, it is removed from <code>aux</code> to prevent duplicate draws. The\nimplementation of <code>reset</code> is simple, as we just store the original state of\n<code>nums</code> on construction.</p>\n<p>The correctness of the algorithm follows from the fact that an element\n(without loss of generality) is equally likely to be selected during all\niterations of the <code>for</code> loop. To prove this, observe that the probability of a\nparticular element <script type="math/tex; mode=display">e</script> being chosen on the <script type="math/tex; mode=display">k</script>th iteration (indexed from 0)\nis simply <script type="math/tex; mode=display">P(e</script> being chosen during the <script type="math/tex; mode=display">k</script>th iteration<script type="math/tex; mode=display">)\\cdot P(e</script> not being\nchosen before the <script type="math/tex; mode=display">k</script>th iteration<script type="math/tex; mode=display">)</script>. Given that the array to be shuffled has\n<script type="math/tex; mode=display">n</script> elements, this probability is more concretely stated as the following:</p>\n<p>\n<script type="math/tex; mode=display">\n   \\frac{1}{n-k} \\cdot \\prod_{i=1}^{k} \\frac{n-i}{n-i+1}\n</script>\n</p>\n<p>When expanded (and rearranged), it looks like this (for sufficiently large\n<script type="math/tex; mode=display">k</script>):</p>\n<p>\n<script type="math/tex; mode=display">\n   (\\frac{n-1}{n}\n   \\cdot \\frac{n-2}{n-1}\n   \\cdot (\\ldots)\n   \\cdot \\frac{n-k+1}{n-k+2}\n   \\cdot \\frac{n-k}{n-k+1})\n   \\cdot \\frac{1}{n-k}\n</script>\n</p>\n<p>For the base case (<script type="math/tex; mode=display">k = 0</script>), it is trivial to see that\n<script type="math/tex; mode=display">\\frac{1}{n-k} = \\frac{1}{n}</script>. For <script type="math/tex; mode=display">k > 0</script>, the numerator of each fraction\ncan be cancelled with the denominator of the next, leaving the <script type="math/tex; mode=display">n</script> from the\n0th draw as the only uncancelled denominator. Therefore, no matter on which\ndraw an element is drawn, it is drawn with a <script type="math/tex; mode=display">\\frac{1}{n}</script> chance, so each\narray permutation is equally likely to arise.</p>\n<iframe frameborder="0" height="500" name="FWMsaXQ7" src="https://leetcode.com/playground/FWMsaXQ7/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>\n</p>\n<p>The quadratic time complexity arises from the calls to <code>list.remove</code> (or\n<code>list.pop</code>), which run in linear time. <script type="math/tex; mode=display">n</script> linear list removals occur,\nwhich results in a fairly easy quadratic analysis.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>Because the problem also asks us to implement <code>reset</code>, we must use linear\nadditional space to store the original array. Otherwise, it would be lost\nupon the first call to <code>shuffle</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-fisher-yates-algorithm-accepted">Approach #2 Fisher-Yates Algorithm [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can cut down the time and space complexities of <code>shuffle</code> with a bit of\ncleverness - namely, by swapping elements around within the array itself, we\ncan avoid the linear space cost of the auxiliary array and the linear time\ncost of list modification.</p>\n<p><strong>Algorithm</strong></p>\n<p>The Fisher-Yates algorithm is remarkably similar to the brute force solution.\nOn each iteration of the algorithm, we generate a random integer between the\ncurrent index and the last index of the array. Then, we swap the elements at\nthe current index and the chosen index - this simulates drawing (and\nremoving) the element from the hat, as the next range from which we select a\nrandom index will not include the most recently processed one. One small, yet important\ndetail is that it is possible to swap an element with itself - otherwise, some\narray permutations would be more likely than others. To see this illustrated more\nclearly, consider the animation below:</p>\n<p>!?!../Documents/384_Shuffle_an_Array.json:697,161!?!</p>\n<iframe frameborder="0" height="500" name="ftmztsv8" src="https://leetcode.com/playground/ftmztsv8/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>The Fisher-Yates algorithm runs in linear time, as generating a random\nindex and swapping two values can be done in constant time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>Although we managed to avoid using linear space on the auxiliary array\nfrom the brute force approach, we still need it for <code>reset</code>, so we\'re\nstuck with linear space complexity.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/emptyset">@emptyset</a></p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '385',
    name: 'Mini Parser',
    acceptance: '30.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a nested list of integers represented as a string, implement a parser to deserialize it.</p>\n\n<p>Each element is either an integer, or a list -- whose elements may also be integers or other lists.</p>\n\n<p><b>Note:</b>\nYou may assume that the string is well-formed:\n</p><ul>\n<li>String is non-empty.</li>\n<li>String does not contain white spaces.</li>\n<li>String contains only digits <code>0-9</code>, <code>[</code>, <code>-</code> <code>,</code>, <code>]</code>.</li>\n</ul>\n<p></p>\n\n<p><b>Example 1:</b>\n</p><pre>Given s = "324",\n\nYou should return a NestedInteger object which contains a single integer 324.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre>Given s = "[123,[456,[789]]]",\n\nReturn a NestedInteger object containing a nested list with 2 elements:\n\n1. An integer containing value 123.\n2. A nested list containing two elements:\n    i.  An integer containing value 456.\n    ii. A nested list with one element:\n         a. An integer containing value 789.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Airbnb'],
  },
  {
    id: '386',
    name: 'Lexicographical Numbers',
    acceptance: '42.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an integer <i>n</i>, return 1 - <i>n</i> in lexicographical order.\n</p>\n\n<p>\nFor example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].\n</p>\n\n<p>\nPlease optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '387',
    name: 'First Unique Character in a String',
    acceptance: '47.2%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a string, find the first non-repeating character in it and return it\'s index. If it doesn\'t exist, return -1.\n</p>\n<p><b>Examples:</b>\n</p><pre>s = "leetcode"\nreturn 0.\n\ns = "loveleetcode",\nreturn 2.\n</pre>\n<p></p>\n\n<p>\n<b>Note:</b> You may assume the string contain only lowercase letters.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Microsoft', 'Amazon', 'Bloomberg'],
  },
  {
    id: '388',
    name: 'Longest Absolute File Path',
    acceptance: '37.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Suppose we abstract our file system by a string in the following manner:</p>\n\n<p>The string <code>"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext"</code> represents:</p>\n\n<pre>dir\n    subdir1\n    subdir2\n        file.ext\n</pre>\n\n<p>The directory <code>dir</code> contains an empty sub-directory <code>subdir1</code> and a sub-directory <code>subdir2</code> containing a file <code>file.ext</code>.</p>\n\n<p>The string <code>"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext"</code> represents:</p>\n\n<pre>dir\n    subdir1\n        file1.ext\n        subsubdir1\n    subdir2\n        subsubdir2\n            file2.ext\n</pre>\n\n<p>The directory <code>dir</code> contains two sub-directories <code>subdir1</code> and <code>subdir2</code>. <code>subdir1</code> contains a file <code>file1.ext</code> and an empty second-level sub-directory <code>subsubdir1</code>. <code>subdir2</code> contains a second-level sub-directory <code>subsubdir2</code> containing a file <code>file2.ext</code>.</p>\n\n<p>We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is <code>"dir/subdir2/subsubdir2/file2.ext"</code>, and its length is <code>32</code> (not including the double quotes).</p>\n\n<p>Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return <code>0</code>.</p>\n\n<p><b>Note:</b><br>\n</p><ul>\n<li>The name of a file contains at least a <code>.</code> and an extension.</li>\n<li>The name of a directory or sub-directory will not contain a <code>.</code>.</li>\n</ul>\n<p></p>\n\n<p>Time complexity required: <code>O(n)</code> where <code>n</code> is the size of the input string.</p>\n\n<p>Notice that <code>a/aa/aaa/file1.txt</code> is not the longest file path, if there is another path <code>aaaaaaaaaaaaaaaaaaaaa/sth.png</code>.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '389',
    name: 'Find the Difference',
    acceptance: '51.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven two strings <b><i>s</i></b> and <b><i>t</i></b> which consist of only lowercase letters.</p>\n\n<p>String <b><i>t</i></b> is generated by random shuffling string <b><i>s</i></b> and then add one more letter at a random position.</p>\n\n<p>Find the letter that was added in <b><i>t</i></b>.</p>\n\n<p><b>Example:</b>\n</p><pre>Input:\ns = "abcd"\nt = "abcde"\n\nOutput:\ne\n\nExplanation:\n\'e\' is the letter that was added.\n</pre>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '390',
    name: 'Elimination Game',
    acceptance: '42.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nThere is a list of sorted integers from 1 to <i>n</i>. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.</p>\n\n<p>Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers.</p>\n\n<p>We keep repeating the steps again, alternating left to right and right to left, until a single number remains.</p>\n\n<p>Find the last number that remains starting with a list of length <i>n</i>.</p>\n\n<p><b>Example:</b>\n</p><pre>Input:\nn = 9,\n<u>1</u> 2 <u>3</u> 4 <u>5</u> 6 <u>7</u> 8 <u>9</u>\n2 <u>4</u> 6 <u>8</u>\n<u>2</u> 6\n6\n\nOutput:\n6\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '391',
    name: 'Perfect Rectangle',
    acceptance: '27.2%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven N axis-aligned rectangles where N &gt; 0, determine if they all together form an exact cover of a rectangular region.\n</p>\n\n<p>\nEach rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).\n</p>\n\n<div style="float:right"><img src="https://leetcode.com/static/images/problemset/rectangle_perfect.gif"></div>\n<p><b>Example 1:</b>\n</p><pre>rectangles = [\n  [1,1,3,3],\n  [3,1,4,2],\n  [3,2,4,4],\n  [1,3,2,4],\n  [2,3,3,4]\n]\n\nReturn true. All 5 rectangles together form an exact cover of a rectangular region.\n</pre>\n<p></p>\n\n<div style="clear:both"></div>\n\n<div style="float:right"><img src="https://leetcode.com/static/images/problemset/rectangle_separated.gif"></div>\n<p><b>Example 2:</b>\n</p><pre>rectangles = [\n  [1,1,2,3],\n  [1,3,2,4],\n  [3,1,4,2],\n  [3,2,4,4]\n]\n\nReturn false. Because there is a gap between the two rectangular regions.\n</pre>\n<p></p>\n\n<div style="clear:both"></div>\n\n<div style="float:right"><img src="https://leetcode.com/static/images/problemset/rectangle_hole.gif"></div>\n<p><b>Example 3:</b>\n</p><pre>rectangles = [\n  [1,1,3,3],\n  [3,1,4,2],\n  [1,3,2,4],\n  [3,2,4,4]\n]\n\nReturn false. Because there is a gap in the top center.\n</pre>\n<p></p>\n\n<div style="clear:both"></div>\n\n<div style="float:right"><img src="https://leetcode.com/static/images/problemset/rectangle_intersect.gif"></div>\n<p><b>Example 4:</b>\n</p><pre>rectangles = [\n  [1,1,3,3],\n  [3,1,4,2],\n  [1,3,2,4],\n  [2,2,4,4]\n]\n\nReturn false. Because two of the rectangles overlap with each other.\n</pre>\n<p></p>\n\n<div style="clear:both"></div>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '392',
    name: 'Is Subsequence',
    acceptance: '44.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a string <b>s</b> and a string <b>t</b>, check if <b>s</b> is subsequence of <b>t</b>.\n</p>\n\n<p>\nYou may assume that there is only lower case English letters in both <b>s</b> and <b>t</b>. <b>t</b> is potentially a very long (length ~= 500,000) string, and <b>s</b> is a short string (&lt;=100).\n</p>\n\n<p>\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>"ace"</code> is a subsequence of <code>"abcde"</code> while <code>"aec"</code> is not).\n</p>\n\n<p><b>Example 1:</b><br>\n<b>s</b> = <code>"abc"</code>, <b>t</b> = <code>"ahbgdc"</code>\n</p>\n<p>\nReturn <code>true</code>.\n</p>\n\n<p><b>Example 2:</b><br>\n<b>s</b> = <code>"axc"</code>, <b>t</b> = <code>"ahbgdc"</code>\n</p>\n<p>\nReturn <code>false</code>.\n</p>\n\n<p><b>Follow up:</b><br>\nIf there are lots of incoming S, say S1, S2, ... , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?</p>\n\n<p><b>Credits:</b><br>Special thanks to <a href="https://leetcode.com/pbrother/">@pbrother</a> for adding this problem and creating all test cases.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Pinterest'],
  },
  {
    id: '393',
    name: 'UTF-8 Validation',
    acceptance: '34.6%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>A character in UTF8 can be from <b>1 to 4 bytes</b> long, subjected to the following rules:</p>\n<ol>\n<li>For 1-byte character, the first bit is a 0, followed by its unicode code.</li>\n<li>For n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.</li>\n</ol>\n<p>This is how the UTF-8 encoding would work:</p>\n\n<pre><code>   Char. number range  |        UTF-8 octet sequence\n      (hexadecimal)    |              (binary)\n   --------------------+---------------------------------------------\n   0000 0000-0000 007F | 0xxxxxxx\n   0000 0080-0000 07FF | 110xxxxx 10xxxxxx\n   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n</code></pre>\n<p>\nGiven an array of integers representing the data, return whether it is a valid utf-8 encoding.\n</p>\n<p>\n<b>Note:</b><br>\nThe input is an array of integers. Only the <b>least significant 8 bits</b> of each integer is used to store the data. This means each integer represents only 1 byte of data.\n</p>\n\n<p>\n<b>Example 1:</b>\n</p><pre>data = [197, 130, 1], which represents the octet sequence: <b>11000101 10000010 00000001</b>.\n\nReturn <b>true</b>.\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n</pre>\n<p></p>\n\n<p>\n<b>Example 2:</b>\n</p><pre>data = [235, 140, 4], which represented the octet sequence: <b>11101011 10001100 00000100</b>.\n\nReturn <b>false</b>.\nThe first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\nThe next byte is a continuation byte which starts with 10 and that's correct.\nBut the second continuation byte does not start with 10, so it is invalid.\n</pre>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '394',
    name: 'Decode String',
    acceptance: '41.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an encoded string, return it\'s decoded string.\n</p>\n<p>\nThe encoding rule is: <code>k[encoded_string]</code>, where the <i>encoded_string</i> inside the square brackets is being repeated exactly <i>k</i> times. Note that <i>k</i> is guaranteed to be a positive integer.</p>\n\n<p>\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>\n\n<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <i>k</i>. For example, there won\'t be input like <code>3a</code> or <code>2[4]</code>.\n</p>\n\n<p><b>Examples:</b>\n</p><pre>s = "3[a]2[bc]", return "aaabcbc".\ns = "3[a2[c]]", return "accaccacc".\ns = "2[abc]3[cd]ef", return "abcabccdcdcdef".\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Yelp', 'Coupang'],
  },
  {
    id: '395',
    name: 'Longest Substring with At Least K Repeating Characters',
    acceptance: '35.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nFind the length of the longest substring <b><i>T</i></b> of a given string (consists of lowercase letters only) such that every character in <b><i>T</i></b> appears no less than <i>k</i> times.\n</p>\n\n<p><b>Example 1:</b>\n</p><pre>Input:\ns = "aaabb", k = 3\n\nOutput:\n3\n\nThe longest substring is "aaa", as \'a\' is repeated 3 times.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre>Input:\ns = "ababbc", k = 2\n\nOutput:\n5\n\nThe longest substring is "ababb", as \'a\' is repeated 2 times and \'b\' is repeated 3 times.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Baidu'],
  },
  {
    id: '396',
    name: 'Rotate Function',
    acceptance: '33.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array of integers <code>A</code> and let <i>n</i> to be its length.\n</p>\n\n<p>\nAssume <code>B<sub>k</sub></code> to be an array obtained by rotating the array <code>A</code> <i>k</i> positions clock-wise, we define a "rotation function" <code>F</code> on <code>A</code> as follow:\n</p>\n\n<p>\n<code>F(k) = 0 * B<sub>k</sub>[0] + 1 * B<sub>k</sub>[1] + ... + (n-1) * B<sub>k</sub>[n-1]</code>.</p>\n\n<p>Calculate the maximum value of <code>F(0), F(1), ..., F(n-1)</code>. \n</p>\n\n<p><b>Note:</b><br>\n<i>n</i> is guaranteed to be less than 10<sup>5</sup>.\n</p>\n\n<p><b>Example:</b>\n</p><pre>A = [4, 3, 2, 6]\n\nF(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\nF(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\nF(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\nF(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\n\nSo the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Amazon'],
  },
  {
    id: '397',
    name: 'Integer Replacement',
    acceptance: '30.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a positive integer <i>n</i> and you can do operations as follow:\n</p>\n\n<p>\n</p><ol>\n<li>If <i>n</i> is even, replace <i>n</i> with <code><i>n</i>/2</code>.</li>\n<li>If <i>n</i> is odd, you can replace <i>n</i> with either <code><i>n</i> + 1</code> or <code><i>n</i> - 1</code>.</li>\n</ol>\n<p></p>\n\n<p>\nWhat is the minimum number of replacements needed for <i>n</i> to become 1?\n</p>\n\n<p></p>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b>\n8\n\n<b>Output:</b>\n3\n\n<b>Explanation:</b>\n8 -&gt; 4 -&gt; 2 -&gt; 1\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b>\n7\n\n<b>Output:</b>\n4\n\n<b>Explanation:</b>\n7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1\nor\n7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Baidu'],
  },
  {
    id: '398',
    name: 'Random Pick Index',
    acceptance: '44.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.\n</p>\n\n<p>\n<b>Note:</b><br>\nThe array size can be very large. Solution that uses too much extra space will not pass the judge.\n</p>\n\n<p><b>Example:</b>\n</p><pre>int[] nums = new int[] {1,2,3,3,3};\nSolution solution = new Solution(nums);\n\n// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\nsolution.pick(3);\n\n// pick(1) should return 0. Since in the array only nums[0] is equal to 1.\nsolution.pick(1);\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook'],
  },
  {
    id: '399',
    name: 'Evaluate Division',
    acceptance: '41.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nEquations are given in the format <code>A / B = k</code>, where  <code>A</code> and <code>B</code> are variables represented as strings, and <code>k</code> is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return <code>-1.0</code>.\n</p>\n<p><b>Example:</b><br>\nGiven <code> a / b = 2.0, b / c = 3.0.</code> <br>queries are: <code> a / c = ?,  b / a = ?, a / e = ?,  a / a = ?, x / x = ? .</code> <br>return <code> [6.0, 0.5, -1.0, 1.0, -1.0 ].</code>\n</p>\n<p>\nThe input is: <code> vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries </code>, where <code>equations.size() == values.size()</code>, and the values are positive. This represents the equations. Return <code> vector&lt;double&gt;</code>.\n</p>\n\n<p>According to the example above:\n</p><pre>equations = [ ["a", "b"], ["b", "c"] ],\nvalues = [2.0, 3.0],\nqueries = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ]. </pre>\n<p></p>\n\n<p>\nThe input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '400',
    name: 'Nth Digit',
    acceptance: '30.1%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Find the <i>n</i><sup>th</sup> digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... </p>\n\n<p><b>Note:</b><br>\n<i>n</i> is positive and will fit within the range of a 32-bit signed integer (<i>n</i> &lt; 2<sup>31</sup>).\n</p>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b>\n3\n\n<b>Output:</b>\n3\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b>\n11\n\n<b>Output:</b>\n0\n\n<b>Explanation:</b>\nThe 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '401',
    name: 'Binary Watch',
    acceptance: '44.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>A binary watch has 4 LEDs on the top which represent the <b>hours</b> (<b>0-11</b>), and the 6 LEDs on the bottom represent the <b>minutes</b> (<b>0-59</b>).</p>\n<p>Each LED represents a zero or one, with the least significant bit on the right.</p>\n<img src="https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg" height="300">\n<p>For example, the above binary watch reads "3:25".</p>\n\n<p>Given a non-negative integer <i>n</i> which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p>\n\n<p><b>Example:</b>\n</p><pre>Input: n = 1<br>Return: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ul>\n<li>The order of output does not matter.</li>\n<li>The hour must not contain a leading zero, for example "01:00" is not valid, it should be "1:00".</li>\n<li>The minute must be consist of two digits and may contain a leading zero, for example "10:2" is not valid, it should be "10:02".</li>\n</ul>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '402',
    name: 'Remove K Digits',
    acceptance: '26.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a non-negative integer <i>num</i> represented as a string, remove <i>k</i> digits from the number so that the new number is the smallest possible.\n</p>\n\n<p><b>Note:</b><br>\n</p><ul>\n<li>The length of <i>num</i> is less than 10002 and will be ≥ <i>k</i>.</li>\n<li>The given <i>num</i> does not contain any leading zero.</li>\n</ul>\n\n<p></p>\n\n<p><b>Example 1:</b>\n</p><pre>Input: num = "1432219", k = 3\nOutput: "1219"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre>Input: num = "10200", k = 1\nOutput: "200"\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b>\n</p><pre>Input: num = "10", k = 2\nOutput: "0"\nExplanation: Remove all the digits from the number and it is left with nothing which is 0.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Snapchat'],
  },
  {
    id: '403',
    name: 'Frog Jump',
    acceptance: '32.4%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.</p>\n\n<p>Given a list of stones' positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.\n</p>\n\n<p>If the frog's last jump was <i>k</i> units, then its next jump must be either <i>k</i> - 1, <i>k</i>, or <i>k</i> + 1 units. Note that the frog can only jump in the forward direction.</p>\n\n<p><b>Note:</b>\n</p><ul>\n<li>The number of stones is ≥ 2 and is &lt; 1,100.</li>\n<li>Each stone's position will be a non-negative integer &lt; 2<sup>31</sup>.</li>\n<li>The first stone's position is always 0.</li>\n</ul>\n<p></p>\n\n<p><b>Example 1:</b>\n</p><pre><b>[0,1,3,5,6,8,12,17]</b>\n\nThere are a total of 8 stones.\nThe first stone at the 0th unit, second stone at the 1st unit,\nthird stone at the 3rd unit, and so on...\nThe last stone at the 17th unit.\n\n<b>Return true</b>. The frog can jump to the last stone by jumping \n1 unit to the 2nd stone, then 2 units to the 3rd stone, then \n2 units to the 4th stone, then 3 units to the 6th stone, \n4 units to the 7th stone, and 5 units to the 8th stone.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>[0,1,2,3,4,8,9,11]</b>\n\n<b>Return false</b>. There is no way to jump to the last stone as \nthe gap between the 5th and 6th stone is too large.\n</pre>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-forcetime-limit-exceeded">Approach #2 Better Brute Force[Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-using-memorization-accepted">Approach #3 Using Memorization [Accepted]</a></li>\n<li><a href="#approach-4-using-memorization-with-binary-search-accepted">Approach #4 Using Memorization with Binary Search [Accepted]</a></li>\n<li><a href="#approach-5-using-dynamic-programmingaccepted">Approach #5 Using Dynamic Programming[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>Given a sorted stone array containing the positions at which there are stones in a river. We need to determine whether it is possible or not for a frog to cross the river by stepping over these stones,\nprovided that the frog starts at position 0, and at every step the frog can make a jump of size <script type="math/tex; mode=display">k-1</script>, <script type="math/tex; mode=display">k</script> or <script type="math/tex; mode=display">k+1</script> if the previous jump is of size <script type="math/tex; mode=display">k</script>.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>In the brute force approach, we make use of a recursive function <script type="math/tex; mode=display">canCross</script> which takes the given stone array, the current position and the current <script type="math/tex; mode=display">jumpsize</script> as input\narguments. We start with <script type="math/tex; mode=display">currentPosition=0</script> and <script type="math/tex; mode=display">jumpsize=0</script>. Then for every function call, we start from the <script type="math/tex; mode=display">currentPosition</script> and check if there lies a stone at <script type="math/tex; mode=display">(currentPostion + newjumpsize)</script>, where, the\n<script type="math/tex; mode=display">newjumpsize</script> could be <script type="math/tex; mode=display">jumpsize</script>, <script type="math/tex; mode=display">jumpsize+1</script> or <script type="math/tex; mode=display">jumpsize-1</script>. In order to check whether a stone exists at the specified positions, we check the elements of the array in a linear manner.\nIf a stone exists at any of these positions, we call the recursive function again with the same stone array, the <script type="math/tex; mode=display">currentPosition</script> and\nthe <script type="math/tex; mode=display">newjumpsize</script> as the parameters. If we are able to reach the end of the stone array through any of these calls, we return <script type="math/tex; mode=display">true</script> to indicate the possibility of reaching the end.</p>\n<iframe frameborder="0" height="326" name="SLsn858o" src="https://leetcode.com/playground/SLsn858o/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(3^n)</script>. Recursion tree can grow upto <script type="math/tex; mode=display">3^n</script>.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Recursion of depth <script type="math/tex; mode=display">n</script> is used.</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-forcetime-limit-exceeded">Approach #2 Better Brute Force[Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the previous brute force approach, we need to find if a stone exists at <script type="math/tex; mode=display">(currentPosition + new\njumpsize)</script>, where <script type="math/tex; mode=display">newjumpsize</script> could be either of <script type="math/tex; mode=display">jumpsize-1</script>, <script type="math/tex; mode=display">jumpsize</script> or\n<script type="math/tex; mode=display">jumpsize+1</script>. But in order to check if a stone exists at the specified location, we searched the given array in linearly. To optimize this, we can use binary search to look for the element\nin the given array since it is sorted. Rest of the method remains the same.</p>\n<iframe frameborder="0" height="462" name="xnG53xSp" src="https://leetcode.com/playground/xnG53xSp/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(3^n)</script>. Recursion tree can grow upto <script type="math/tex; mode=display">3^n</script>.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Recursion of depth <script type="math/tex; mode=display">n</script> is used.</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-memorization-accepted">Approach #3 Using Memorization [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Another problem with above approaches is that we can make the same function calls coming through different paths e.g. For a given <script type="math/tex; mode=display">currentIndex</script>, we can call the recursive function\n<script type="math/tex; mode=display">canCross</script> with the <script type="math/tex; mode=display">jumpsize</script>, say <script type="math/tex; mode=display">n</script>. This <script type="math/tex; mode=display">n</script> could be resulting from previous <script type="math/tex; mode=display">jumpsize</script> being <script type="math/tex; mode=display">n-1</script>,<script type="math/tex; mode=display">n</script> or <script type="math/tex; mode=display">n+1</script>. Thus, many redundant function calls could be made\nprolonging the running time. This redundancy can be removed by making use of memorization. We make use of a 2-d <script type="math/tex; mode=display">memo</script> array, initialized by <script type="math/tex; mode=display">-1</script>s, to store the result returned from a function call for\na particular <script type="math/tex; mode=display">currentIndex</script> and <script type="math/tex; mode=display">jumpsize</script>. If the same <script type="math/tex; mode=display">currentIndex</script> and <script type="math/tex; mode=display">jumpsize</script> happens is encountered again, we can return the result directly using the <script type="math/tex; mode=display">memo</script> array. This helps to prune the\nsearch tree to a great extent.</p>\n<iframe frameborder="0" height="479" name="ZauYpsEv" src="https://leetcode.com/playground/ZauYpsEv/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. Memorization will reduce time complexity to <script type="math/tex; mode=display">O(n^3)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^2)</script>. <script type="math/tex; mode=display">memo</script> matrix of size <script type="math/tex; mode=display">n^2</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-memorization-with-binary-search-accepted">Approach #4 Using Memorization with Binary Search [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can optimize the above memorization approach, if we make use of Binary Search to find if a stone\nexists at <script type="math/tex; mode=display">currentPostion + newjumpsize</script> instead of searching linearly.</p>\n<iframe frameborder="0" height="515" name="ApwgcSaM" src="https://leetcode.com/playground/ApwgcSaM/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(n^2 log(n)\\big)</script>. We traverse the complete <script type="math/tex; mode=display">dp</script> matrix once <script type="math/tex; mode=display">(O(n^2))</script>. For every entry we take atmost <script type="math/tex; mode=display">n</script> numbers as pivot.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^2)</script>. <script type="math/tex; mode=display">dp</script> matrix of size <script type="math/tex; mode=display">n^2</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-using-dynamic-programmingaccepted">Approach #5 Using Dynamic Programming[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the DP Approach, we make use of a hashmap <script type="math/tex; mode=display">map</script> which contains <script type="math/tex; mode=display">key:value</script> pairs such that <script type="math/tex; mode=display">key</script> refers to the position at which a stone is present and <script type="math/tex; mode=display">value</script> is a\nset containing the <script type="math/tex; mode=display">jumpsize</script> which can lead to the current stone position. We start by making a hashmap whose <script type="math/tex; mode=display">key</script>s are all the positions at which a stone is present and the <script type="math/tex; mode=display">value</script>s are\nall empty except position 0 whose value contains 0. Then, we start traversing the elements(positions) of the given stone array in sequential order. For the <script type="math/tex; mode=display">currentPosition</script>, for every possible <script type="math/tex; mode=display">jumpsize</script> in the\n<script type="math/tex; mode=display">value</script> set, we check if <script type="math/tex; mode=display">currentPosition + newjumpsize</script> exists in the <script type="math/tex; mode=display">map</script>, where <script type="math/tex; mode=display">newjumpsize</script> can be either <script type="math/tex; mode=display">jumpsize-1</script>, <script type="math/tex; mode=display">jumpsize</script>,\n<script type="math/tex; mode=display">jumpsize+1</script>. If so, we append the corresponding <script type="math/tex; mode=display">value</script> set with <script type="math/tex; mode=display">newjumpsize</script>. We continue in the same manner. If at the end, the <script type="math/tex; mode=display">value</script> set corresponding to the\nlast position is non-empty, we conclude that reaching the end is possible, otherwise, it isn\'t.</p>\n<p>For more understanding see this animation-</p>\n<!--![Frog Jump](https://leetcode.com/articles/Figures/135_FrogJump.gif)-->\n<p>!?!../Documents/403_Frog.json:1000,563!?!</p>\n<iframe frameborder="0" height="377" name="WkNK2fiw" src="https://leetcode.com/playground/WkNK2fiw/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Two nested loops are there.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^2)</script>. <script type="math/tex; mode=display">hashmap</script> size can grow upto <script type="math/tex; mode=display">n^2</script> .</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Snapchat'],
  },
  {
    id: '404',
    name: 'Sum of Left Leaves',
    acceptance: '47.3%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Find the sum of all left leaves in a given binary tree.</p>\n\n<p><b>Example:</b>\n</p><pre>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\nThere are two left leaves in the binary tree, with values <b>9</b> and <b>15</b> respectively. Return <b>24</b>.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook'],
  },
  {
    id: '405',
    name: 'Convert a Number to Hexadecimal',
    acceptance: '41.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an integer, write an algorithm to convert it to hexadecimal. For negative integer, <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank">two’s complement</a> method is used.\n</p>\n\n<p><b>Note:</b>\n</p><ol>\n<li>All letters in hexadecimal (<code>a-f</code>) must be in lowercase.</li>\n<li>The hexadecimal string must not contain extra leading <code>0</code>s. If the number is zero, it is represented by a single zero character <code>\'0\'</code>; otherwise, the first character in the hexadecimal string will not be the zero character.</li>\n<li>The given number is guaranteed to fit within the range of a 32-bit signed integer.</li>\n<li>You <b>must not use <i>any</i> method provided by the library</b> which converts/formats the number to hex directly.</li>\n</ol>\n<p></p>\n\n<p><b>Example 1:</b>\n</p><pre>Input:\n26\n\nOutput:\n"1a"\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre>Input:\n-1\n\nOutput:\n"ffffffff"\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '406',
    name: 'Queue Reconstruction by Height',
    acceptance: '56.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers <code>(h, k)</code>, where <code>h</code> is the height of the person and <code>k</code> is the number of people in front of this person who have a height greater than or equal to <code>h</code>. Write an algorithm to reconstruct the queue.\n</p>\n\n<p><b>Note:</b><br>\nThe number of people is less than 1,100.\n</p>\n\n<br>\n\n<p><b>Example</b>\n</p><pre>Input:\n[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]\n\nOutput:\n[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '407',
    name: 'Trapping Rain Water II',
    acceptance: '37.8%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given an <code>m x n</code> matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.\n</p>\n\n<p><b>Note:</b><br>\nBoth <i>m</i> and <i>n</i> are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.\n</p>\n\n<p><b>Example:</b>\n</p><pre>Given the following 3x6 height map:\n[\n  [1,4,3,1,3,2],\n  [3,2,1,3,2,4],\n  [2,3,3,2,3,1]\n]\n\nReturn 4.\n</pre>\n<p></p>\n\n<p>\n<img src="https://leetcode.com/static/images/problemset/rainwater_empty.png"><br>\nThe above image represents the elevation map <code>[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</code> before the rain.\n</p>\n\n<p>\n<img src="https://leetcode.com/static/images/problemset/rainwater_fill.png"><br>\nAfter the rain, water are trapped between the blocks. The total volume of water trapped is 4.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Twitter'],
  },
  {
    id: '408',
    name: 'Valid Word Abbreviation ',
    acceptance: '28.3%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a <b>non-empty</b> string <code>s</code> and an abbreviation <code>abbr</code>, return whether the string matches with the given abbreviation.\n</p>\n\n<p>A string such as <code>"word"</code> contains only the following valid abbreviations:</p>\n\n<pre>["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]\n</pre>\n\n<p>Notice that only the above abbreviations are valid abbreviations of the string <code>"word"</code>. Any other string is not a valid abbreviation of <code>"word"</code>.</p>\n\n<p><b>Note:</b><br>\nAssume <code>s</code> contains only lowercase letters and <code>abbr</code> contains only lowercase letters and digits.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre>Given <b>s</b> = "internationalization", <b>abbr</b> = "i12iz4n":\n\nReturn true.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre>Given <b>s</b> = "apple", <b>abbr</b> = "a2e":\n\nReturn false.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '409',
    name: 'Longest Palindrome',
    acceptance: '45.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p>\n\n<p>This is case sensitive, for example <code>"Aa"</code> is not considered a palindrome here.</p>\n\n<p><b>Note:</b><br>\nAssume the length of given string will not exceed 1,010.\n</p>\n\n<p><b>Example: </b>\n</p><pre>Input:\n"abccccdd"\n\nOutput:\n7\n\nExplanation:\nOne longest palindrome that can be built is "dccaccd", whose length is 7.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '410',
    name: 'Split Array Largest Sum',
    acceptance: '38.8%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given an array which consists of non-negative integers and an integer <i>m</i>, you can split the array into <i>m</i> non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these <i>m</i> subarrays.\n</p>\n\n<p><b>Note:</b><br>\nIf <i>n</i> is the length of array, assume the following constraints are satisfied:\n</p><ul>\n<li>1 ≤ <i>n</i> ≤ 1000</li>\n<li>1 ≤ <i>m</i> ≤ min(50, <i>n</i>)</li>\n</ul>\n<p></p>\n\n<p><b>Examples: </b>\n</p><pre>Input:\n<b>nums</b> = [7,2,5,10,8]\n<b>m</b> = 2\n\nOutput:\n18\n\nExplanation:\nThere are four ways to split <b>nums</b> into two subarrays.\nThe best way is to split it into <b>[7,2,5]</b> and <b>[10,8]</b>,\nwhere the largest sum among the two subarrays is only 18.\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-dynamic-programming-accepted">Approach #2 Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-3-binary-search-greedy-accepted">Approach #3 Binary Search + Greedy [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>Check all possible splitting plans to find the minimum largest value for subarrays.</p>\n<p><strong>Algorithm</strong></p>\n<p>We can use depth-first search to generate all possible splitting plan. For each element in the array, we can choose to append it to the previous subarray or start a new subarray starting with that element (if the number of subarrays does not exceed <code>m</code>). The sum of the current subarray can be updated at the same time.</p>\n<iframe frameborder="0" height="500" name="2C8sEFce" src="https://leetcode.com/playground/2C8sEFce/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^m)</script>. To split <code>n</code> elements into <code>m</code> parts, we can have <script type="math/tex; mode=display">\\binom{n - 1}{m - 1}</script> different solutions. This is equivalent to <script type="math/tex; mode=display"> n ^ m</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. We only need the space to store the array.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-dynamic-programming-accepted">Approach #2 Dynamic Programming [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>The problem satisfies the non-aftereffect property. We can try to use dynamic programming to solve it.</p>\n<p>The non-aftereffect property means, once the state of a certain stage is determined, it is not affected by the state in the future. In this problem, if we get the largest subarray sum for splitting <code>nums[0..i]</code> into <code>j</code> parts, this value will not be affected by how we split the remaining part of <code>nums</code>.</p>\n<p>To know more about non-aftereffect property, this link may be helpful : <a href="http://www.programering.com/a/MDOzUzMwATM.html">http://www.programering.com/a/MDOzUzMwATM.html</a></p>\n<p><strong>Algorithm</strong></p>\n<p>Let\'s define <code>f[i][j]</code> to be the minimum largest subarray sum for splitting <code>nums[0..i]</code> into <code>j</code> parts.</p>\n<p>Consider the <code>j</code>th subarray. We can split the array from a smaller index <code>k</code> to <code>i</code> to form it. Thus <code>f[i][j]</code> can be derived from <code>max(f[k][j - 1], nums[k + 1] +  ... + nums[i])</code>. For all valid index <code>k</code>, <code>f[i][j]</code> should choose the minimum value of the above formula.</p>\n<p>The final answer should be <code>f[n][m]</code>, where <code>n</code> is the size of the array.</p>\n<p>For corner situations, all the invalid <code>f[i][j]</code> should be assigned with <code>INFINITY</code>, and <code>f[0][0]</code> should be initialized with <code>0</code>.</p>\n<iframe frameborder="0" height="480" name="hwfoZm6N" src="https://leetcode.com/playground/hwfoZm6N/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2 * m)</script>. The total number of states is <script type="math/tex; mode=display">O(n * m)</script>. To compute each state <code>f[i][j]</code>, we need to go through the whole array to find the optimum <code>k</code>. This requires another <script type="math/tex; mode=display">O(n)</script> loop. So the total time complexity is <script type="math/tex; mode=display">O(n ^ 2 * m)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n * m)</script>. The space complexity is equivalent to the number of states, which is <script type="math/tex; mode=display">O(n * m)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-binary-search-greedy-accepted">Approach #3 Binary Search + Greedy [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can easily find a property for the answer:</p>\n<blockquote>\n<p>If we can find a splitting method that ensures the maximum largest subarray sum will not exceed a value  <code>x</code>, then we can also find a splitting method that ensures the maximum largest subarray sum will not exceed any value <code>y</code> that is greater than <code>x</code>.</p>\n</blockquote>\n<p>Lets define this property as <code>F(x)</code> for the value <code>x</code>. <code>F(x)</code> is true means we can find a splitting method that ensures the maximum largest subarray sum will not exceed <code>x</code>.</p>\n<p>From the discussion above, we can find out that for <code>x</code> ranging from <code>-INFINITY</code> to <code>INFINITY</code>, <code>F(x)</code> will start with false, then from a specific value <code>x0</code>, <code>F(x)</code> will turn to true and stay true forever.</p>\n<p>Obviously, the specific value <code>x0</code> is our answer.</p>\n<p><strong>Algorithm</strong></p>\n<p>We can use Binary search to find the value <code>x0</code>. Keeping a value <code>mid = (left + right) / 2</code>. If <code>F(mid)</code> is false, then we will search the range <code>[mid + 1, right]</code>; If <code>F(mid)</code> is true, then we will search <code>[left, mid - 1]</code>.</p>\n<p>For a given <code>x</code>, we can get the answer of <code>F(x)</code> using a greedy approach. Using an accumulator <code>sum</code> to store the sum of the current processing subarray and a counter <code>cnt</code> to count the number of existing subarrays. We will process the elements in the array one by one. For each element <code>num</code>, if <code>sum + num &lt;= x</code>, it means we can add <code>num</code> to the current subarray without exceeding the limit. Otherwise, we need to make a cut here, start a new subarray with the current element <code>num</code>. This leads to an increment in the number of subarrays.</p>\n<p>After we have finished the whole process, we need to compare the value <code>cnt</code> to the size limit of subarrays <code>m</code>. If <code>cnt &lt;= m</code>, it means we can find a splitting method that ensures the maximum largest subarray sum will not exceed <code>x</code>. Otherwise, <code>F(x)</code> should be false.</p>\n<iframe frameborder="0" height="500" name="Q43EfjVB" src="https://leetcode.com/playground/Q43EfjVB/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n * log(sum \\ of \\ array))</script>. The binary search costs <script type="math/tex; mode=display">O(log(sum \\ of \\ array))</script>, where <code>sum of array</code> is the sum of elements in <code>nums</code>. For each computation of <code>F(x)</code>, the time complexity is <script type="math/tex; mode=display">O(n)</script> since we only need to go through the whole array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Same as the Brute Force approach.  We only need the space to store the array.</p>\n</li>\n</ul>\n</div>\n          ',
    tags: ['Facebook', 'Baidu'],
  },
  {
    id: '411',
    name: 'Minimum Unique Word Abbreviation ',
    acceptance: '33.6%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>A string such as <code>"word"</code> contains the following abbreviations:</p>\n\n<pre>["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]\n</pre>\n\n<p>Given a target string and a set of strings in a dictionary, find an abbreviation of this target string with the <b><i>smallest possible</i></b> length such that it does not conflict with abbreviations of the strings in the dictionary. </p>\n\n<p>Each <b>number</b> or letter in the abbreviation is considered length = 1. For example, the abbreviation "a32bc" has length = 4.</p>\n\n<p><b>Note:</b><br>\n</p><ul>\n<li>In the case of multiple answers as shown in the second example below, you may return any one of them.</li>\n<li>Assume length of target string = <b>m</b>, and dictionary size = <b>n</b>. You may assume that <b>m ≤ 21</b>, <b>n ≤ 1000</b>, and <b>log<sub>2</sub>(n) + m ≤ 20</b>.</li>\n</ul>\n<p></p>\n\n<p><b>Examples:</b><br>\n</p><pre>"apple", ["blade"] -&gt; "a4" (because "5" or "4e" conflicts with "blade")\n\n"apple", ["plain", "amber", "blade"] -&gt; "1p3" (other valid answers include "ap3", "a3e", "2p2", "3le", "3l1").\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '412',
    name: 'Fizz Buzz',
    acceptance: '58.3%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Write a program that outputs the string representation of numbers from 1 to <i>n</i>.</p>\n\n<p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>\n\n<p><b>Example:</b>\n</p><pre>n = 15,\n\nReturn:\n[\n    "1",\n    "2",\n    "Fizz",\n    "4",\n    "Buzz",\n    "Fizz",\n    "7",\n    "8",\n    "Fizz",\n    "Buzz",\n    "11",\n    "Fizz",\n    "13",\n    "14",\n    "FizzBuzz"\n]\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '413',
    name: 'Arithmetic Slices',
    acceptance: '54.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>\n\n<p>For example, these are arithmetic sequence:</p>\n<pre>1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9</pre>\n\n<p>The following sequence is not arithmetic.</p> <pre>1, 1, 2, 5, 7</pre> \n<br>\n\n<p>A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.</p>\n\n<p>A slice (P, Q) of array A is called arithmetic if the sequence:<br>\n    A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.</p>\n\n<p>The function should return the number of arithmetic slices in the array A. </p>\n<br>\n\n<p><b>Example:</b>\n</p><pre>A = [1, 2, 3, 4]\n\nreturn: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.\n</pre>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</a></li>\n<li><a href="#approach-3-using-recursion-accepted">Approach #3  Using Recursion [Accepted]</a></li>\n<li><a href="#approach-5-dynamic-programming-accepted">Approach #5 Dynamic Programming [Accepted]:</a></li>\n<li><a href="#approach-5-constant-space-dynamic-programming-accepted">Approach #5 Constant Space Dynamic Programming [Accepted]:</a></li>\n<li><a href="#approach-6-using-formula-accepted">Approach #6 Using Formula [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</h4>\n<p>The most naive solution is to consider every pair of elements(with atleast 1 element between them), so that the range of elements lying between these two elements acts as a slice. Then, we can iterate over every such slice(range) to check if all the consecutive elements within this range have the same difference. For every such range found, we can increment the <script type="math/tex; mode=display">count</script> that is used to keep a track of the required result.</p>\n<iframe frameborder="0" height="343" name="HT3WjgGf" src="https://leetcode.com/playground/HT3WjgGf/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. We iterate over the range formed by every pair of elements. Here, <script type="math/tex; mode=display">n</script> refers to the number of elements in the given array <script type="math/tex; mode=display">A</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we considered every possible range and then iterated over the range to check if the difference between every consercutive element in this range is the same. We can optimize this approach to some extent, by making a small observation. </p>\n<p>We can see, that if we are currently considering the range bound by the elements, let\'s say, <script type="math/tex; mode=display">A[s]</script>(start) and <script type="math/tex; mode=display">A[e]</script>(end), we have checked the consecutive elements in this range to have the same difference. Now, when we move on to the next range between the indices <script type="math/tex; mode=display">s</script> and <script type="math/tex; mode=display">e+1</script>, we again perform a check on all the elements in the range <script type="math/tex; mode=display">s:e</script>, along with one additional pair <script type="math/tex; mode=display">A[e+1]</script> and <script type="math/tex; mode=display">A[e]</script>. We can remove this redundant check in the range <script type="math/tex; mode=display">s:e</script> and just check the last pair to have the same difference as the one used for the previous range(same <script type="math/tex; mode=display">s</script>, incremented <script type="math/tex; mode=display">e</script>).</p>\n<p>Note that if the last range didn\'t constitute an arithmetic slice, the same elements will be a part of the updated range as well. Thus, we can omit the rest of the ranges consisting of the same starting index. The rest of the process remains the same as in the last approach.</p>\n<iframe frameborder="0" height="309" name="NPDEAgTz" src="https://leetcode.com/playground/NPDEAgTz/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Two for loops are used.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-recursion-accepted">Approach #3  Using Recursion [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>By making use of the observation discussed in the last approach, we know, that if a range of elements between the indices <script type="math/tex; mode=display">(i,j)</script> constitute an Arithmetic Slice, and another element <script type="math/tex; mode=display">A[j+1]</script> is included such that <script type="math/tex; mode=display">A[j+1]</script> and <script type="math/tex; mode=display">A[j]</script> have the same difference as that of the previous common difference, the ranges between <script type="math/tex; mode=display">(i,j+1)</script> will constitutes an arithmetic slice. Further, if the original range <script type="math/tex; mode=display">(i,j)</script> doesn\'t form an arithmetic slice, adding new elements to this range won\'t do us any good. Thus, no more arithmetic slices can be obtained by adding new elements to it.</p>\n<p>By making use of this observation, we can develop a recursive solution for the given problem as well. Assume that a <script type="math/tex; mode=display">sum</script> variable is used to store the total number of arithmetic slices in the given array <script type="math/tex; mode=display">A</script>. We make use of a recursive function <code>slices(A,i)</code> which returns the number of Arithmetic Slices in the range <script type="math/tex; mode=display">(k,i)</script>, but which are not a part of any range <script type="math/tex; mode=display">(k,j)</script> such that <script type="math/tex; mode=display">j<i</script>. It also updates <script type="math/tex; mode=display">sum</script> with the number of arithmetic slices(total) in the current range. Thus, <script type="math/tex; mode=display">k</script> refers to  the minimum index such that the range <script type="math/tex; mode=display">(k,i)</script> constitutes a valid arithmetic slice.</p>\n<p>Now, suppose we know the number of arithmetic slices in the range <script type="math/tex; mode=display">(0,i-1)</script> constituted by the elements <script type="math/tex; mode=display">[a_0,a_1,a_2,...a_(i-1)]</script>, to be say <script type="math/tex; mode=display">x</script>. If this range itself is an arithmetic slice, all the consecutive elements have the same difference(equal to say, <script type="math/tex; mode=display">a_(i-1)-a_(i-2)</script>). Now, adding a new element <script type="math/tex; mode=display">a_i</script> to it to extend the range to <script type="math/tex; mode=display">(0,i)</script> will constitute an arithmetic slice only if this new element satisfies <script type="math/tex; mode=display">a_i-a_(i-1)=a_(i-1)-a_(i-2)</script>. Thus, now, the addition of this new element, will lead to an addition of <script type="math/tex; mode=display">ap</script> number of arithmetic slices to the ones obtained in the range <script type="math/tex; mode=display">(0,i-1)</script>. The new arithmetic slices will be the ones constituting the ranges <script type="math/tex; mode=display">(0,i), (1,i), ... (i-2,i)</script>, which are a total of  <script type="math/tex; mode=display">x+1</script> additional arithmetic slices. This is because, apart from the range <script type="math/tex; mode=display">(0,i)</script> the rest of the ranges <script type="math/tex; mode=display">(1,i), (2,i),...(i-2,i)</script> can be mapped to <script type="math/tex; mode=display">(0,i-1), (1,i-1),...(i-3,i-1)</script>, with count equal to <script type="math/tex; mode=display">x</script>. </p>\n<p>Thus, in every call to <code>slices</code>, if the <script type="math/tex; mode=display">i^{th}</script> element has the same common difference with the last element as the previous common difference, we can find the number of new arithmetic slices added by the use of this element, <script type="math/tex; mode=display">ap</script> and also update the <script type="math/tex; mode=display">sum</script> to include this <script type="math/tex; mode=display">ap</script> into it, apart from the count obtained by the smaller ranges. But, if the new element doesn\'t have the same common difference, extra arithmetic slices can\'t be contributed by it and hence, no addition is done to <script type="math/tex; mode=display">sum</script> for the current element. But, of course <script type="math/tex; mode=display">sum</script> will be updated as per the count obtained from the smaller ranges.</p>\n<iframe frameborder="0" height="360" name="WGzuREMw" src="https://leetcode.com/playground/WGzuREMw/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The recursive function is called at most <script type="math/tex; mode=display">n-2</script> times.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of the recursion tree goes upto <script type="math/tex; mode=display">n-2</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-dynamic-programming-accepted">Approach #5 Dynamic Programming [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we start with the full range <script type="math/tex; mode=display">(0,n-1)</script>, where <script type="math/tex; mode=display">n</script> is the number of elements in the given <script type="math/tex; mode=display">A</script> array. We can observe that the result for the range <script type="math/tex; mode=display">(0,i)</script> only depends on the elements in the range <script type="math/tex; mode=display">(0,i)</script> and not on any element beyond this range. Thus, we can make use of Dynamic Programming to solve the given problem.</p>\n<p>We can make use of a 1-D <script type="math/tex; mode=display">dp</script> with number of elements equal to <script type="math/tex; mode=display">n</script>. <script type="math/tex; mode=display">dp[i]</script> is used to store the number of arithmetic slices possible in the range <script type="math/tex; mode=display">(k,i)</script> and not in any range <script type="math/tex; mode=display">(k,j)</script> such that <script type="math/tex; mode=display">j<i</script>. Again, <script type="math/tex; mode=display">k</script> refers to the minimum index possible such that <script type="math/tex; mode=display">(k,j)</script> constitutes a valid Arithmetic Slice.</p>\n<p>Instead of going in the reverse order as in the recursive approach, we can start filling the <script type="math/tex; mode=display">dp</script> in a forward manner. The intuition remains the same as in the last approach. For the <script type="math/tex; mode=display">i^{th}</script> element being considered, we check if this element satsfies the common difference criteria with the previous element. If so, we know the number of new arithmetic slices added will be <script type="math/tex; mode=display">1+dp[i-1]</script> as discussed in the last approach. The <script type="math/tex; mode=display">sum</script> is also updated by the same count to reflect the new arithmetic slices added.  </p>\n<p>The following animation illustrates the <script type="math/tex; mode=display">dp</script> filling process.</p>\n<p>!?!../Documents/413_Arithmetic_Slices.json:1000,563!?!</p>\n<iframe frameborder="0" height="292" name="w8UZ2q6u" src="https://leetcode.com/playground/w8UZ2q6u/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We traverse over the given <script type="math/tex; mode=display">A</script> array with <script type="math/tex; mode=display">n</script> elements once only.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. 1-D <script type="math/tex; mode=display">dp</script> of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-constant-space-dynamic-programming-accepted">Approach #5 Constant Space Dynamic Programming [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we can observe that we only require the element <script type="math/tex; mode=display">dp[i-1]</script> to determine the value to be entered at <script type="math/tex; mode=display">dp[i]</script>. Thus, instead of making use of a 1-D array to store the required data, we can simply keep a track of just the last element. </p>\n<iframe frameborder="0" height="292" name="mGEcWWi3" src="https://leetcode.com/playground/mGEcWWi3/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We traverse over the given <script type="math/tex; mode=display">A</script> array with <script type="math/tex; mode=display">n</script> elements once only.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-6-using-formula-accepted">Approach #6 Using Formula [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>From the <script type="math/tex; mode=display">dp</script> solution, we can observe that for <script type="math/tex; mode=display">k</script> consecutive elements sastisfying the common difference criteria, we update the <script type="math/tex; mode=display">sum</script> for each such element by <script type="math/tex; mode=display">1, 2, 3, ..., k</script> counts in that order. Thus, instead of updating the <script type="math/tex; mode=display">sum</script> at the same time, we can just keep a track of the number of consecutive elements satisfying the common differnce criteria in a <script type="math/tex; mode=display">count</script> variable and just update the <script type="math/tex; mode=display">sum</script> directly as <script type="math/tex; mode=display">count*(count+1)/2</script> whenver an element not satisfying this criteria is found. At the same time, we also need to reset the <script type="math/tex; mode=display">count</script> value. </p>\n<iframe frameborder="0" height="309" name="fQULWrDF" src="https://leetcode.com/playground/fQULWrDF/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We iterate over <script type="math/tex; mode=display">A</script> with <script type="math/tex; mode=display">n</script> elements exactly once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Baidu', 'Aetion'],
  },
  {
    id: '414',
    name: 'Third Maximum Number',
    acceptance: '27.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a <b>non-empty</b> array of integers, return the <b>third</b> maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [3, 2, 1]\n\n<b>Output:</b> 1\n\n<b>Explanation:</b> The third maximum is 1.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [1, 2]\n\n<b>Output:</b> 2\n\n<b>Explanation:</b> The third maximum does not exist, so the maximum (2) is returned instead.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> [2, 2, 3, 1]\n\n<b>Output:</b> 1\n\n<b>Explanation:</b> Note that the third maximum here means the third maximum distinct number.\nBoth numbers with value 2 are both considered as second maximum.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Amazon'],
  },
  {
    id: '415',
    name: 'Add Strings',
    acceptance: '41.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as string, return the sum of <code>num1</code> and <code>num2</code>.</p>\n\n<p><b>Note:</b>\n</p><ol>\n<li>The length of both <code>num1</code> and <code>num2</code> is &lt; 5100.</li>\n<li>Both <code>num1</code> and <code>num2</code> contains only digits <code>0-9</code>.</li>\n<li>Both <code>num1</code> and <code>num2</code> does not contain any leading zero.</li>\n<li>You <b>must not use any built-in BigInteger library</b> or <b>convert the inputs to integer</b> directly.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Airbnb'],
  },
  {
    id: '416',
    name: 'Partition Equal Subset Sum',
    acceptance: '39.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a <b>non-empty</b> array containing <b>only positive integers</b>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n</p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>Each of the array element will not exceed 100.</li>\n<li>The array size will not exceed 200.</li>\n</ol>\n<p></p>\n\n<p><b>Example 1:</b>\n</p><pre>Input: [1, 5, 11, 5]\n\nOutput: true\n\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre>Input: [1, 2, 3, 5]\n\nOutput: false\n\nExplanation: The array cannot be partitioned into equal sum subsets.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['eBay'],
  },
  {
    id: '417',
    name: 'Pacific Atlantic Water Flow',
    acceptance: '34.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given an <code>m x n</code> matrix of non-negative integers representing the height of each unit cell in a continent, the "Pacific ocean" touches the left and top edges of the matrix and the "Atlantic ocean" touches the right and bottom edges.</p>\n\n<p>Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.</p>\n\n<p>Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.</p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The order of returned grid coordinates does not matter.</li>\n<li>Both <i>m</i> and <i>n</i> are less than 150.</li>\n</ol>\n<p></p>\n<p><b>Example:</b>\n</p><pre>Given the following 5x5 matrix:\n\n  Pacific ~   ~   ~   ~   ~ \n       ~  1   2   2   3  (5) *\n       ~  3   2   3  (4) (4) *\n       ~  2   4  (5)  3   1  *\n       ~ (6) (7)  1   4   5  *\n       ~ (5)  1   1   2   4  *\n          *   *   *   *   * Atlantic\n\nReturn:\n\n[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '418',
    name: 'Sentence Screen Fitting ',
    acceptance: '28.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a <code>rows x cols</code> screen and a sentence represented by a list of <b>non-empty</b> words, find <b>how many times</b> the given sentence can be fitted on the screen.\n</p>\n\n<p><b>Note:</b>\n</p><ol>\n<li>A word cannot be split into two lines.</li>\n<li>The order of words in the sentence must remain unchanged.</li>\n<li>Two consecutive words <b>in a line</b> must be separated by a single space.</li>\n<li>Total words in the sentence won\'t exceed 100.</li>\n<li>Length of each word is greater than 0 and won\'t exceed 10.</li>\n<li>1 ≤ rows, cols ≤ 20,000.</li>\n</ol>\n<p></p>\n\n<p>\n<b>Example 1:</b> \n</p><pre><b>Input:</b>\nrows = 2, cols = 8, sentence = ["hello", "world"]\n\n<b>Output:</b> \n1\n\n<b>Explanation:</b>\nhello---\nworld---\n\nThe character \'-\' signifies an empty space on the screen.\n</pre>\n<p></p>\n\n<p>\n<b>Example 2:</b> \n</p><pre><b>Input:</b>\nrows = 3, cols = 6, sentence = ["a", "bcd", "e"]\n\n<b>Output:</b> \n2\n\n<b>Explanation:</b>\na-bcd- \ne-a---\nbcd-e-\n\nThe character \'-\' signifies an empty space on the screen.\n</pre>\n<p></p>\n\n<p>\n<b>Example 3:</b> \n</p><pre><b>Input:</b>\nrows = 4, cols = 5, sentence = ["I", "had", "apple", "pie"]\n\n<b>Output:</b> \n1\n\n<b>Explanation:</b>\nI-had\napple\npie-I\nhad--\n\nThe character \'-\' signifies an empty space on the screen.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '419',
    name: 'Battleships in a Board',
    acceptance: '62.4%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            Given an 2D board, count how many battleships are in it. The battleships are represented with <code>'X'</code>s, empty slots are represented with <code>'.'</code>s. You may assume the following rules:\n\n<ul>\n<li>You receive a valid board, made of only battleships or empty slots.</li>\n<li>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape <code>1xN</code> (1 row, N columns) or <code>Nx1</code> (N rows, 1 column), where N can be of any size.</li>\n<li>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li>\n</ul>\n\n<p><b>Example:</b><br>\n</p><pre>X..X\n...X\n...X\n</pre>\nIn the above board there are 2 battleships.\n\n<p><b>Invalid Example:</b><br>\n</p><pre>...X\nXXXX\n...X\n</pre>\nThis is an invalid board that you will not receive - as battleships will always have a cell separating between them.\n<p></p>\n<p><b>Follow up:</b><br>Could you do it in <b>one-pass</b>, using only <b>O(1) extra memory</b> and <b>without modifying</b> the value of the board?</p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft'],
  },
  {
    id: '420',
    name: 'Strong Password Checker',
    acceptance: '20.6%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>A password is considered strong if below conditions are all met:</p>\n\n<ol>\n<li> It has at least 6 characters and at most 20 characters. </li>\n<li> It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit. </li>\n<li> It must NOT contain three repeating characters in a row ("...aaa..." is weak, but "...aa...a..." is strong, assuming other conditions are met). </li>\n</ol>\n\n<p>Write a function strongPasswordChecker(s), that takes a string s as input, and return the <b>MINIMUM</b> change required to make s a strong password. If s is already strong, return 0.</p>\n\n<p>Insertion, deletion or replace of any one character are all considered as one change.</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '421',
    name: 'Maximum XOR of Two Numbers in an Array',
    acceptance: '47.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a <b>non-empty</b> array of numbers, a<sub>0</sub>, a<sub>1</sub>, a<sub>2</sub>, … , a<sub>n-1</sub>, where 0 ≤ a<sub>i</sub> &lt; 2<sup>31</sup>.</p>\n\n<p>Find the maximum result of a<sub>i</sub> XOR a<sub>j</sub>, where 0 ≤ <i>i</i>, <i>j</i> &lt; <i>n</i>.</p>\n\n<p>Could you do this in O(<i>n</i>) runtime?</p>\n\n<p><b>Example:</b>\n</p><pre><b>Input:</b> [3, 10, 5, 25, 2, 8]\n\n<b>Output:</b> 28\n\n<b>Explanation:</b> The maximum result is <b>5</b> ^ <b>25</b> = 28.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '422',
    name: 'Valid Word Square ',
    acceptance: '36.4%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a sequence of words, check whether it forms a valid word square.</p>\n\n<p>A sequence of words forms a valid word square if the <i>k</i><sup>th</sup> row and column read the exact same string, where 0 ≤ <i>k</i> &lt; max(numRows, numColumns).</p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The number of words given is at least 1 and does not exceed 500.</li>\n<li>Word length will be at least 1 and does not exceed 500.</li>\n<li>Each word contains only lowercase English alphabet <code>a-z</code>.</li>\n</ol>\n<p></p>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b>\n[\n  "abcd",\n  "bnrt",\n  "crmy",\n  "dtye"\n]\n\n<b>Output:</b>\ntrue\n\n<b>Explanation:</b>\nThe first row and first column both read "abcd".\nThe second row and second column both read "bnrt".\nThe third row and third column both read "crmy".\nThe fourth row and fourth column both read "dtye".\n\nTherefore, it is a valid word square.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b>\n[\n  "abcd",\n  "bnrt",\n  "crm",\n  "dt"\n]\n\n<b>Output:</b>\ntrue\n\n<b>Explanation:</b>\nThe first row and first column both read "abcd".\nThe second row and second column both read "bnrt".\nThe third row and third column both read "crm".\nThe fourth row and fourth column both read "dt".\n\nTherefore, it is a valid word square.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b>\n</p><pre><b>Input:</b>\n[\n  "ball",\n  "area",\n  "read",\n  "lady"\n]\n\n<b>Output:</b>\nfalse\n\n<b>Explanation:</b>\nThe third row reads "read" while the third column reads "lead".\n\nTherefore, it is <b>NOT</b> a valid word square.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '423',
    name: 'Reconstruct Original Digits from English',
    acceptance: '44.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a <b>non-empty</b> string containing an out-of-order English representation of digits <code>0-9</code>, output the digits in ascending order.</p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>Input contains only lowercase English letters.</li>\n<li>Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as "abc" or "zerone" are not permitted.</li>\n<li>Input length is less than 50,000.</li>\n</ol>\n<p></p>\n\n<p><b>Example 1:</b><br>\n</p><pre>Input: "owoztneoer"\n\nOutput: "012"\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre>Input: "fviefuro"\n\nOutput: "45"\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '424',
    name: 'Longest Repeating Character Replacement',
    acceptance: '42.8%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most <i>k</i> times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.</p>\n\n<p><b>Note:</b><br>\nBoth the string's length and <i>k</i> will not exceed 10<sup>4</sup>.\n</p>\n\n<p>\n<b>Example 1:</b>\n</p><pre><b>Input:</b>\ns = \"ABAB\", k = 2\n\n<b>Output:</b>\n4\n\n<b>Explanation:</b>\nReplace the two 'A's with two 'B's or vice versa.\n</pre>\n<p></p>\n\n<p>\n<b>Example 2:</b>\n</p><pre><b>Input:</b>\ns = \"AABABBA\", k = 1\n\n<b>Output:</b>\n4\n\n<b>Explanation:</b>\nReplace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\n</pre>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Pocket Gems'],
  },
  {
    id: '425',
    name: 'Word Squares ',
    acceptance: '43.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given a set of words <b>(without duplicates)</b>, find all <a href="https://en.wikipedia.org/wiki/Word_square" target="_blank">word squares</a> you can build from them.</p>\n\n<p>A sequence of words forms a valid word square if the <i>k</i><sup>th</sup> row and column read the exact same string, where 0 ≤ <i>k</i> &lt; max(numRows, numColumns).</p>\n\n<p>For example, the word sequence <code>["ball","area","lead","lady"]</code> forms a word square because each word reads the same both horizontally and vertically.</p>\n\n<pre>b a l l\na r e a\nl e a d\nl a d y\n</pre>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>There are at least 1 and at most 1000 words.</li>\n<li>All words will have the exact same length.</li>\n<li>Word length is at least 1 and at most 5.</li>\n<li>Each word contains only lowercase English alphabet <code>a-z</code>.</li>\n</ol>\n<p></p>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b>\n["area","lead","wall","lady","ball"]\n\n<b>Output:</b>\n[\n  [ "wall",\n    "area",\n    "lead",\n    "lady"\n  ],\n  [ "ball",\n    "area",\n    "lead",\n    "lady"\n  ]\n]\n\n<b>Explanation:</b>\nThe output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b>\n["abat","baba","atan","atal"]\n\n<b>Output:</b>\n[\n  [ "baba",\n    "abat",\n    "baba",\n    "atan"\n  ],\n  [ "baba",\n    "abat",\n    "baba",\n    "atal"\n  ]\n]\n\n<b>Explanation:</b>\nThe output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '432',
    name: 'All O`one Data Structure',
    acceptance: '28.1%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Implement a data structure supporting the following operations:</p>\n\n<p>\n</p><ol>\n<li>Inc(Key) - Inserts a new key <key> with value 1. Or increments an existing key by 1. Key is guaranteed to be a <b>non-empty</b> string.</key></li>\n<li>Dec(Key) - If Key\'s value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a <b>non-empty</b> string.</li>\n<li>GetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string <code>""</code>.</li>\n<li>GetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string <code>""</code>.</li>\n</ol>\n<p></p>\n\n<p>\nChallenge: Perform all these in O(1) time complexity.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Uber'],
  },
  {
    id: '433',
    name: 'Minimum Genetic Mutation',
    acceptance: '34.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>A gene string can be represented by an 8-character long string, with choices from <code>"A"</code>, <code>"C"</code>, <code>"G"</code>, <code>"T"</code>.</p>\n\n<p>Suppose we need to investigate about a mutation (mutation from "start" to "end"), where ONE mutation is defined as ONE single character changed in the gene string.</p>\n\n<p>For example, <code>"AACCGGTT"</code> -&gt; <code>"AACCGGTA"</code> is 1 mutation.</p>\n\n<p>Also, there is a given gene "bank", which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string.</p>\n\n<p>Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from "start" to "end". If there is no such a mutation, return -1.</p>\n\n<p><b>Note:</b>\n</p><ol>\n<li>Starting point is assumed to be valid, so it might not be included in the bank.</li>\n<li>If multiple mutations are needed, all mutations during in the sequence must be valid.</li>\n<li>You may assume start and end string is not the same.</li>\n</ol>\n<p></p>\n\n<p><b>Example 1:</b>\n</p><pre>start: "AACCGGTT"\nend:   "AACCGGTA"\nbank: ["AACCGGTA"]\n\nreturn: 1\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre>start: "AACCGGTT"\nend:   "AAACGGTA"\nbank: ["AACCGGTA", "AACCGCTA", "AAACGGTA"]\n\nreturn: 2\n</pre>\n<p></p>\n\n<p><b>Example 3:</b>\n</p><pre>start: "AAAAACCC"\nend:   "AACCCCCC"\nbank: ["AAAACCCC", "AAACCCCC", "AACCCCCC"]\n\nreturn: 3\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Twitter'],
  },
  {
    id: '434',
    name: 'Number of Segments in a String',
    acceptance: '36.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.</p>\n\n<p>Please note that the string does not contain any <b>non-printable</b> characters.</p>\n\n<p><b>Example:</b></p>\n<pre><b>Input:</b> "Hello, my name is John"\n<b>Output:</b> 5\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-using-language-builtins-accepted">Approach #1 Using Language Builtins [Accepted]</a></li>\n<li><a href="#approach-2-in-place-accepted">Approach #2 In-place [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-using-language-builtins-accepted">Approach #1 Using Language Builtins [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>In a situation where raw efficiency is less important than code legibility,\nit is likely better to use language-idiomatic builtin functions to solve this\nproblem.</p>\n<p><strong>Algorithm</strong></p>\n<p>There are a few corner cases that you can get snagged on in this problem, at\nleast in Java. First, one or more leading spaces will cause <code>split</code> to deduce\nan erroneous <code>""</code> token at the beginning of the string, so we use the builtin\n<code>trim</code> method to remove leading and trailing spaces. Then, if the resulting\nstring is the empty string, then we can simply output <code>0</code>. This is necessary due\nto the following behavior of the <code>split</code> method:</p>\n<div class="codehilite"><pre><span></span><span class="n">String</span><span class="o">[]</span> <span class="n">tokens</span> <span class="o">=</span> <span class="s">""</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"\\\\s++"</span><span class="o">);</span>\n<span class="n">tokens</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="c1">// 1</span>\n<span class="n">tokens</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// ""</span>\n</pre></div>\n<p>If we reach the final return statement, we <code>split</code> the trimmed string on\nsequences of one or more whitespace characters (<code>split</code> can take a regular\nexpression) and return the length of the resulting array.</p>\n<p>The Python solution is trivially short because Python\'s <code>split</code> has a lot of\ndefault behavior that makes it perfect for this sort of problem. Notably, it\nreturns an empty list when <code>split</code>ting an empty string, it splits on\nwhitespace by default, and it implicitly <code>trim</code>s (<code>strip</code>s, in Python lingo)\nthe string beforehand.</p>\n<iframe frameborder="0" height="208" name="FdCZomTr" src="https://leetcode.com/playground/FdCZomTr/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>All builtin language functionality used here (in both the Java and Python\nexamples) runs in either <script type="math/tex; mode=display">O(n)</script> or <script type="math/tex; mode=display">O(1)</script> time, so the entire algorithm\nruns in linear time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p><code>split</code> (in both languages) returns an array/list of <script type="math/tex; mode=display">O(n)</script> length, so\nthe algorithm uses linear additional space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-in-place-accepted">Approach #2 In-place [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we cannot afford to allocate linear additional space, a fairly simple\nalgorithm can deduce the number of segments in linear time and constant\nspace.</p>\n<p><strong>Algorithm</strong></p>\n<p>To count the number of segments, it is equivalent to count the number of\nstring indices at which a segment begins. Therefore, by formally defining the\ncharacteristics of such an index, we can simply iterate over the string and\ntest each index in turn. Such a definition is as follows: a string index\nbegins a segment if it is preceded by whitespace (or is the first index) and\nis not whitespace itself, which can be checked in constant time. Finally, we\nsimply return the number of indices for which the condition is satisfied.</p>\n<iframe frameborder="0" height="276" name="XX7WFxaA" src="https://leetcode.com/playground/XX7WFxaA/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>We do a constant time check for each of the string\'s <script type="math/tex; mode=display">n</script> indices, so the\nruntime is overall linear.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n<p>There are only a few integers allocated, so the memory footprint is\nconstant.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/emptyset">@emptyset</a></p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '435',
    name: 'Non-overlapping Intervals',
    acceptance: '41.5%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nGiven a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n</p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>You may assume the interval's end point is always bigger than its start point.</li>\n<li>Intervals like [1,2] and [2,3] have borders \"touching\" but they don't overlap each other.</li>\n</ol>\n<p></p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [ [1,2], [2,3], [3,4], [1,3] ]\n\n<b>Output:</b> 1\n\n<b>Explanation:</b> [1,3] can be removed and the rest of intervals are non-overlapping.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [ [1,2], [1,2], [1,2] ]\n\n<b>Output:</b> 2\n\n<b>Explanation:</b> You need to remove two [1,2] to make the rest of intervals non-overlapping.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> [ [1,2], [2,3] ]\n\n<b>Output:</b> 0\n\n<b>Explanation:</b> You don't need to remove any of the intervals since they're already non-overlapping.\n</pre>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-dp-based-on-starting-point-accepted">Approach #2 Using DP based on starting point [Accepted]</a></li>\n<li><a href="#approach-3-using-dp-based-on-the-end-points-accepted">Approach #3 Using DP based on the end points [Accepted]</a></li>\n<li><a href="#approach-4-using-greedy-approach-based-on-starting-points-accepted">Approach #4 Using Greedy Approach based on starting points [Accepted]</a></li>\n<li><a href="#approach-5-using-greedy-approach-based-on-end-points-accepted">Approach #5 Using Greedy Approach based on end points [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>Given a collection of intervals, we need to find the minimum number of intervals to be removed to make the rest of the intervals non-overlapping.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>In the brute force approach, we try to remove the overlapping intervals in different combinations and then check which combination needs the minimum number of removals. To do this, firstly we sort the given intervals based on the starting point. Then, we make use of a recursive function <code>eraseOverlapIntervals</code> which takes the index of the previous interval <script type="math/tex; mode=display">prev</script> and the index of the current interval <script type="math/tex; mode=display">curr</script> (which we try to add to the list of intervals not removed), and returns the count of intervals that need to be removed from the current index onwards.</p>\n<p>We start by using <script type="math/tex; mode=display">prev=-1</script> and <script type="math/tex; mode=display">curr=0</script>. In each recursive call, we check if the current interval overlaps with the previous interval. If not, we need not remove the current interval from the final list and we can call the function <code>eraseOverlapIntervals</code> with <script type="math/tex; mode=display">prev=curr</script> and <script type="math/tex; mode=display">curr=curr + 1</script>. The result of this function call in which we have included the current element is stored in <script type="math/tex; mode=display">taken</script> variable.</p>\n<p>We also make another function call by removing the current interval because this could be overlapping with the upcoming intervals in the next function call and thus, its removal could eventually require lesser total number of removals. Thus, the recursive call takes the arguments <script type="math/tex; mode=display">prev=prev</script> and <script type="math/tex; mode=display">curr=curr + 1</script>. Since, we have removed one interval, the result if the current interval isn\'t included is the sum of the value returned by the function call incremented by 1, which is stored in <script type="math/tex; mode=display">notTaken</script> variable. While returning the count of removals following a particular index, we return the minimum of <script type="math/tex; mode=display">taken</script> and <script type="math/tex; mode=display">notTaken</script>.</p>\n<iframe frameborder="0" height="428" name="QtauivZC" src="https://leetcode.com/playground/QtauivZC/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(2^n)</script>. Total possible number of Combinations of subsets are <script type="math/tex; mode=display">2^n</script> .</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Depth of recursion is <script type="math/tex; mode=display">n</script>.</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-dp-based-on-starting-point-accepted">Approach #2 Using DP based on starting point [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The given problem can be simplified to a great extent if we sort the given interval list based on the starting points. Once it\'s done, we can make use of a <script type="math/tex; mode=display">dp</script> array, scuh that <script type="math/tex; mode=display">dp[i]</script> stores the maximum number of valid intervals that can be included in the final list if the intervals upto the <script type="math/tex; mode=display">i^{th}</script> interval only are considered, including itself. Now, while finding <script type="math/tex; mode=display">dp[i+1]</script>, we can\'t consider the value of <script type="math/tex; mode=display">dp[i]</script> only, because it could be possible that the <script type="math/tex; mode=display">i^{th}</script> or any previous interval could be overlapping with the <script type="math/tex; mode=display">(i+1)^{th}</script> interval. Thus, we need to consider the maximum of all <script type="math/tex; mode=display">dp[j]</script>\'s such that <script type="math/tex; mode=display">j \\leq i</script> and <script type="math/tex; mode=display">j^{th}</script> interval and <script type="math/tex; mode=display">i^{th}</script> don\'t overlap, to evaluate <script type="math/tex; mode=display">dp[i+1]</script>. Therefore, the equation for <script type="math/tex; mode=display">dp[i+1]</script> becomes:</p>\n<p>\n<script type="math/tex; mode=display">\ndp[i+1]= \\max(dp[j]) + 1,\n</script>\n</p>\n<p>such that <script type="math/tex; mode=display">j^{th}</script> interval and <script type="math/tex; mode=display">i^{th}</script> don\'t overlap, for all <script type="math/tex; mode=display">j \\leq i</script>.</p>\n<p>In the end, to obtain the maximum number of intervals that can be included in the final list(<script type="math/tex; mode=display">ans</script>) we need to find the maximum value in the <script type="math/tex; mode=display">dp</script> array. The final result will be the total number of intervals given less the result just obtained(<script type="math/tex; mode=display">intervals.length-ans</script>).</p>\n<p>The animation below illustrates the approach more clearly:</p>\n<p>!?!../Documents/435_Non_Overlapping_Intervalsdp1.json:866,487!?!</p>\n<iframe frameborder="0" height="515" name="9SpbjLHA" src="https://leetcode.com/playground/9SpbjLHA/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Two nested loops are required to fill <script type="math/tex; mode=display">dp</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-dp-based-on-the-end-points-accepted">Approach #3 Using DP based on the end points [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the DP approach just discussed above, for calculating the value of every <script type="math/tex; mode=display">dp[i]</script>, we need to traverse the <script type="math/tex; mode=display">dp</script> array back till the starting index. This overhead can be removed, if we use an interval list sorted on the basis of the end points. Thus, now, again we use the same kind of <script type="math/tex; mode=display">dp</script> array, where <script type="math/tex; mode=display">dp[i]</script> is used to store the maximum number of intervals that can be included in the final list if the intervals only upto the <script type="math/tex; mode=display">i^{th}</script> index in the sorted list are considered. Thus, in order to find <script type="math/tex; mode=display">dp[i+1]</script> now, we\'ve to consider two cases:</p>\n<p><strong>Case 1:</strong></p>\n<blockquote>\n<p>The interval corresponding to <script type="math/tex; mode=display">(i+1)^{th}</script> interval needs to be included in the final list to obtain the minimum number of removals:</p>\n</blockquote>\n<p>In this case, we need to traverse back in the sorted interval array form the <script type="math/tex; mode=display">(i+1)^{th}</script> index upto the starting index to find the first interval which is non-overlapping. This is because, if we are including the current interval, we need to remove all the intervals which are overlapping with the current interval. But, we need not go back till the starting index everytime. Instead we can stop the traversal as soon as we hit the first non-overlapping interval and use its <script type="math/tex; mode=display">dp[j] + 1</script> to fill in <script type="math/tex; mode=display">dp[i+1]</script>, since <script type="math/tex; mode=display">dp[j]</script> will be the element storing the maximum number of intervals that can be included considering elements upto the <script type="math/tex; mode=display">j^{th}</script> index.</p>\n<p><strong>Case 2:</strong></p>\n<blockquote>\n<p>The interval corresponding to <script type="math/tex; mode=display">(i+1)^{th}</script> interval needs to be removed from the final list to obtain the minimum number of removals:</p>\n</blockquote>\n<p>In this case, the current element won\'t be included in the final list. So, the count of intervals to be included upto <script type="math/tex; mode=display">(i+1)^{th}</script> index is the same as the count of intervals upto the <script type="math/tex; mode=display">i^{th}</script> index. Thus, we can use <script type="math/tex; mode=display">dp[i]</script>\'s value to fill in <script type="math/tex; mode=display">dp[i+1]</script>.</p>\n<p>The value finally entered in <script type="math/tex; mode=display">dp[i+1]</script> will be the maximum of the above two values.</p>\n<p>The final result will again be the total count of intervals less the result obtained at the end from the <script type="math/tex; mode=display">dp</script> array.</p>\n<p>The animation below illustrates the approach more clearly:</p>\n<!--![Non_overlapping_dp](https://leetcode.com/articles/Figures/435_NonOverlapping_Intervalsdp2.gif)-->\n<p>!?!../Documents/435_Non.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="McmA5f64" src="https://leetcode.com/playground/McmA5f64/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Two nested loops are required to fill <script type="math/tex; mode=display">dp</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-greedy-approach-based-on-starting-points-accepted">Approach #4 Using Greedy Approach based on starting points [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>If we sort the given intervals based on starting points, the greedy approach works very well. While considering the intervals in the ascending order of starting points, we make use of a pointer <script type="math/tex; mode=display">prev</script> pointer to keep track of the interval just included in the final list. While traversing, we can encounter 3 possibilities as shown in the figure:</p>\n<p><img alt="Non_overlapping" src="https://leetcode.com/articles/Figures/435_NonOverlapping_greedy1.JPG"></p>\n<p><strong>Case 1:</strong></p>\n<blockquote>\n<p>The two intervals currently considered are non-overlapping:</p>\n</blockquote>\n<p>In this case, we need not remove any interval and we can continue by simply assigning the <script type="math/tex; mode=display">prev</script> pointer to the later interval and the count of intervals removed remains unchanged.</p>\n<p><strong>Case 2:</strong></p>\n<blockquote>\n<p>The two intervals currently considered are overlapping and the end point of the later interval falls before the end point of the previous interval:</p>\n</blockquote>\n<p>In this case, we can simply take the later interval. The choice is obvious since choosing an interval of smaller width will lead to more available space labelled as <script type="math/tex; mode=display">A</script> and <script type="math/tex; mode=display">B</script>, in which more intervals can be accommodated. Hence, the <script type="math/tex; mode=display">prev</script> pointer is updated to current interval and the count of intervals removed is incremented by 1.</p>\n<p><strong>Case 3:</strong></p>\n<blockquote>\n<p>The two intervals currently considered are overlapping and the end point of the later interval falls after the end point of the previous interval:</p>\n</blockquote>\n<p>In this case, we can work in a greedy manner and directly remove the later interval. To understand why this greedy approach works, we need to see the figure below, which includes all the subcases possible. It is clear from the figures that we choosing interval 1 always leads to a better solution in the future. Thus, the <script type="math/tex; mode=display">prev</script> pointer remains unchanged and the count of intervals removed is incremented by 1.</p>\n<p><img alt="Non_overlapping" src="https://leetcode.com/articles/Figures/435_NonOverlapping_greedy2.JPG"></p>\n<iframe frameborder="0" height="479" name="nv3azNFK" src="https://leetcode.com/playground/nv3azNFK/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(n \\log(n)\\big)</script>. Sorting takes <script type="math/tex; mode=display">O\\big(n \\log(n)\\big)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-using-greedy-approach-based-on-end-points-accepted">Approach #5 Using Greedy Approach based on end points [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The Greedy approach just discussed was based on choosing intervals greedily based on the starting points. But in this approach, we go for choosing points greedily based on the end points. For this, firstly we sort the given intervals based on the end points. Then, we traverse over the sorted intervals. While traversing, if there is no overlapping between the previous interval and the current interval, we need not remove any interval. But, if an overlap exists between the previous interval and the current interval, we always drop the current interval.</p>\n<p>To explain how it works, again we consider every possible arrangement of the intervals.</p>\n<p><img alt="Non_overlapping" src="https://leetcode.com/articles/Figures/435_NonOverlapping_greedy3.JPG"></p>\n<p><strong>Case 1:</strong></p>\n<blockquote>\n<p>The two intervals currently considered are non-overlapping:</p>\n</blockquote>\n<p>In this case, we need not remove any interval and for the next iteration the current interval becomes the previous interval.</p>\n<p><strong>Case 2:</strong></p>\n<blockquote>\n<p>The two intervals currently considered are overlapping and the starting point of the later interval falls before the starting point of the previous interval:</p>\n</blockquote>\n<p>In this case, as shown in the figure below, it is obvious that the later interval completely subsumes the previous interval. Hence, it is advantageous to remove the later interval so that we can get more range available to accommodate future intervals. Thus, previous interval remains unchanged and the current interval is updated.</p>\n<p><strong>Case 3:</strong></p>\n<blockquote>\n<p>The two intervals currently considered are overlapping and the starting point of the later interval falls before the starting point of the previous interval:</p>\n</blockquote>\n<p>In this case, the only opposition to remove the current interval arises because it seems that more intervals could be accommodated by removing the previous interval in the range marked by <script type="math/tex; mode=display">A</script>. But that won\'t be possible as can be visualized with a case similar to Case 3a and 3b shown above. But, if we remove the current interval, we can save the range <script type="math/tex; mode=display">B</script> to accommodate further intervals. Thus, previous interval remains unchanged and the current interval is updated.</p>\n<iframe frameborder="0" height="428" name="23TqSoF7" src="https://leetcode.com/playground/23TqSoF7/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(n \\log(n)\\big)</script>. Sorting takes <script type="math/tex; mode=display">O\\big(n \\log(n)\\big)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '436',
    name: 'Find Right Interval',
    acceptance: '41.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the "right" of i.\n</p>\n\n<p>\nFor any interval i, you need to store the minimum interval j\'s index, which means that the interval j has the minimum start point to build the "right" relationship for interval i. If the interval j doesn\'t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.\n</p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>You may assume the interval\'s end point is always bigger than its start point.</li>\n<li>You may assume none of these intervals have the same start point.</li>\n</ol>\n<p></p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [ [1,2] ]\n\n<b>Output:</b> [-1]\n\n<b>Explanation:</b> There is only one interval in the collection, so it outputs -1.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [ [3,4], [2,3], [1,2] ]\n\n<b>Output:</b> [-1, 0, 1]\n\n<b>Explanation:</b> There is no satisfied "right" interval for [3,4].\nFor [2,3], the interval [3,4] has minimum-"right" start point;\nFor [1,2], the interval [2,3] has minimum-"right" start point.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> [ [1,4], [2,3], [3,4] ]\n\n<b>Output:</b> [-1, 2, -1]\n\n<b>Explanation:</b> There is no satisfied "right" interval for [1,4] and [3,4].\nFor [2,3], the interval [3,4] has minimum-"right" start point.\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-sorting-scanning-time-limit-exceeded">Approach #2 Using Sorting + Scanning [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-using-sorting-binary-search-accepted">Approach #3 Using Sorting + Binary Search [Accepted]</a></li>\n<li><a href="#approach-4-using-treemap-accepted">Approach #4 Using TreeMap [Accepted]</a></li>\n<li><a href="#approach-5-using-two-arrays-without-binary-searchaccepted">Approach #5 Using Two Arrays without Binary Search[Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The simplest solution consists of picking up every interval in the set and looking for the the interval whose start point is larger(by a\n minimum difference) than\n the chosen interval\'s end point by scanning the complete set for every interval chosen. While scanning, we keep a track of the interval\n with the minimum start point satisfying the given criteria along with its index. The result obtained for every interval chosen is\n stored at the corresponding index in the res array which is returned at the end.</p>\n<iframe frameborder="0" height="496" name="qzN73MkH" src="https://leetcode.com/playground/qzN73MkH/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. The complete set of <script type="math/tex; mode=display">n</script> intervals is scanned for every(<script type="math/tex; mode=display">n</script>) interval chosen.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">res</script> array of size <script type="math/tex; mode=display">n</script> is used.</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-sorting-scanning-time-limit-exceeded">Approach #2 Using Sorting + Scanning [Time Limit Exceeded]</h4>\n<p>We make use of a hashmap <script type="math/tex; mode=display">\\text{hash}</script>, which stores the data in the form of a <script type="math/tex; mode=display">(Key, Value)</script> pair. Here, the <script type="math/tex; mode=display">Key</script> corresponds to the interval chosen and the <script type="math/tex; mode=display">Value</script> corresponds to the index of the particular interval in the given <script type="math/tex; mode=display">intervals</script> array. We store every element of the <script type="math/tex; mode=display">intervals</script> array in the <script type="math/tex; mode=display">hash</script>-map.</p>\n<p>Now, we sort the <script type="math/tex; mode=display">intervals</script> array based on the starting points. We needed to store the indices of the array in the hashmap, so as to be able to obtain the indices even after the sorting.</p>\n<p>Now, we pick up every interval of the sorted array, and find out the interval from the remaining ones whose start point comes just after\nthe end point of the interval chosen. How do we proceed? Say, we\'ve picked up the <script type="math/tex; mode=display">i^{th}</script> interval right now. In order to find an\ninterval satisfying the given criteria, we need not search in the intervals behind it. This is because the <script type="math/tex; mode=display">intervals</script> array has been sorted based on the\nstarting points and the end point is always greater than the starting point for a given interval. Thus, we search in the intervals only with indices <script type="math/tex; mode=display">j</script>, such that <script type="math/tex; mode=display">i+1< j < n</script>. The first element encountered while scanning in the ascending order is the required result for the interval chosen, since all the intervals lying after this interval will have comparatively larger start points.</p>\n<p>Then, we can obtain the index corresponding to the corresponding interval from the hashmap, which is stored in the corresponding entry of the <script type="math/tex; mode=display">res</script> array. If no interval satifies the criteria, we put a <script type="math/tex; mode=display">\\text{-1}</script> in the corresponding entry.</p>\n<iframe frameborder="0" height="515" name="EsSkj3SC" src="https://leetcode.com/playground/EsSkj3SC/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>.</li>\n</ul>\n<p>Sorting takes <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script> time. For the first interval we need to search among <script type="math/tex; mode=display">n-1</script> elements. For the second interval, the search is done among <script type="math/tex; mode=display">n-2</script> elements and so on leading to a total of:</p>\n<p>\n<script type="math/tex; mode=display">(n-1) + (n-2) + (n-3) + .... + 3 + 2 + 1 = \\frac{n.(n-1)}{2} = O(n^2)</script> calculations.</p>\n<ul>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">res</script> array of size <script type="math/tex; mode=display">n</script> is used. A hashmap <script type="math/tex; mode=display">hash</script> of size <script type="math/tex; mode=display">n</script> is used.</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-sorting-binary-search-accepted">Approach #3 Using Sorting + Binary Search [Accepted]</h4>\n<p>We can optimize the above approach to some extent, since we can make use of the factor of the <script type="math/tex; mode=display">intervals</script> array being sorted. Instead of searching for the required interval in a linear manner, we can make use of Binary Search to find an interval whose start point is just larger than the end point of the current interval.</p>\n<p>Again, if such an interval is found, we obtain its index from the hashmap and store the result in the appropriate <script type="math/tex; mode=display">res</script> entry. If not, we put a <script type="math/tex; mode=display">\\text{-1}</script> at the corresponding entry.</p>\n<iframe frameborder="0" height="515" name="pn9fpMev" src="https://leetcode.com/playground/pn9fpMev/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big((n.log(n)\\big)</script>. Sorting takes <script type="math/tex; mode=display">O\\big(n.log(n)\\big)</script> time. Binary search takes <script type="math/tex; mode=display">O\\big(log(n)\\big) time for each of the </script>n$$ intervals.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">res</script> array of size <script type="math/tex; mode=display">n</script> is used. A hashmap <script type="math/tex; mode=display">hash</script> of size <script type="math/tex; mode=display">O(n)</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-treemap-accepted">Approach #4 Using TreeMap [Accepted]</h4>\n<p>In this approach, instead of using a hashmap, we make use of a TreeMap <script type="math/tex; mode=display">starts</script>, which is simply a Red-Black Tree(a kind of balanced Binary Search Tree) . This Treemap <script type="math/tex; mode=display">start</script> stores data in the form of <script type="math/tex; mode=display">(Key, Value)</script> pair and always remain sorted based on its keys.\nIn our case, we store the data such that the start point of an interval acts as the <script type="math/tex; mode=display">Key</script> and the index corresponding to the interval acts as the value, since we are concerned with data sorted based on the start points, as discussed in previous approaches. Every element of the <script type="math/tex; mode=display">intervals</script> array is stored in the TreeMap.</p>\n<p>Now, we choose each element of the <script type="math/tex; mode=display">intervals</script> array and make use of a function <code>TreeMap.ceilingEntry(end_point)</code> to obtain the element in the TreeMap with its <script type="math/tex; mode=display">Key</script> just larger than the <script type="math/tex; mode=display">end_point</script> of the currently chosen interval. The function <code>ceilingEntry(Key)</code> returns the element just with its <script type="math/tex; mode=display">Key</script> larger than the <code>Key</code>(passed as the argument) from amongst the elements of the TreeMap and returns <code>null</code> if no such element exists.</p>\n<p>If non-null value is returned, we obtain the <script type="math/tex; mode=display">Value</script> from the <script type="math/tex; mode=display">(Key, Value)</script> pair obtained at the appropriate entry in the <script type="math/tex; mode=display">res</script> array. If a null value is returned, we simply store a <script type="math/tex; mode=display">\\text{-1}</script> at the corresponding <script type="math/tex; mode=display">res</script> entry.</p>\n<iframe frameborder="0" height="462" name="7wB2XEVo" src="https://leetcode.com/playground/7wB2XEVo/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big((n.log(n)\\big)</script>. Inserting an element into TreeMap takes <script type="math/tex; mode=display">O\\big(log(n)\\big)</script> time. <script type="math/tex; mode=display">n</script> such insertions are done. The search in TreeMap using <code>ceilingEntry</code> also takes <script type="math/tex; mode=display">O\\big((log(n)\\big)</script> time. <script type="math/tex; mode=display">n</script> such searches are done.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">res</script> array of size <script type="math/tex; mode=display">n</script> is used. TreeMap <script type="math/tex; mode=display">starts</script> of size <script type="math/tex; mode=display">O(n)</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-using-two-arrays-without-binary-searchaccepted">Approach #5 Using Two Arrays without Binary Search[Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>The intuition behind this approach is as follows: If we maintain two arrays,</p>\n<ol>\n<li>\n<p>\n<script type="math/tex; mode=display">\\text{intervals}</script>, which is sorted based on the start points.</p>\n</li>\n<li>\n<p>\n<script type="math/tex; mode=display">\\text{endIntervals}</script>, which is sorted based on the end points.</p>\n</li>\n</ol>\n<p>Once we pick up the first interval(or, say the <script type="math/tex; mode=display">i^{th}</script> interval) from the <script type="math/tex; mode=display">\\text{endIntervals}</script> array, we can determine the appropriate interval satisfying the right interval criteria by scanning the intervals in <script type="math/tex; mode=display">\\text{intervals}</script> array from left towards the right, since the <script type="math/tex; mode=display">\\text{intervals}</script> array is sorted based on the start points. Say, the index of the element chosen from the <script type="math/tex; mode=display">\\text{intervals}</script> array happens to be <script type="math/tex; mode=display">j</script>.</p>\n<p>Now, when we pick up the next interval(say the <script type="math/tex; mode=display">(i+1)^{th}</script> interval) from the <script type="math/tex; mode=display">\\text{endIntervals}</script> array, we need not start scanning the <script type="math/tex; mode=display">\\text{intervals}</script> array from the first index. Rather, we can start off directly from the <script type="math/tex; mode=display">j^{th}</script> index where we left off last time in the <script type="math/tex; mode=display">\\text{intervals}</script> array. This is because end point corresponding to <script type="math/tex; mode=display">\\text{endIntervals[i+1]}</script> is larger than the one corresponding to <script type="math/tex; mode=display">\\text{endIntervals[i]}</script> and none of the intervals from <script type="math/tex; mode=display">\\text{intervals[k]}</script>, such that <script type="math/tex; mode=display">0< k < j</script>, satisfies the right neighbor criteria with <script type="math/tex; mode=display">\\text{endIntervals[i]}</script>, and hence not with <script type="math/tex; mode=display">\\text{endIntervals[i+1]}</script> as well.</p>\n<p>If at any moment, we reach the end of the array i.e. <script type="math/tex; mode=display">j=intervals.length</script> and no element satisfying the right interval criteria is available in the <script type="math/tex; mode=display">\\text{intervals}</script> array, we put a <script type="math/tex; mode=display">\\text{-1}</script> in the corresponding <script type="math/tex; mode=display">res</script> entry. The same holds for all the remaining elements of the <script type="math/tex; mode=display">\\text{endIntervals}</script> array, whose end points are even larger than the previous interval encountered.</p>\n<p>Also we make use of a hashmap <script type="math/tex; mode=display">hash</script> initially to preserve the indices corresponding to the intervals even after sorting.</p>\n<p>For more understanding see the below animation:</p>\n<!--![Find_Right_Interval](https://leetcode.com/articles/Figures/436_Find_Right_Interval.gif)-->\n<p>!?!../Documents/436_Find.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="YVrCA3RQ" src="https://leetcode.com/playground/YVrCA3RQ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(n.log(n)\\big)</script>. Sorting takes <script type="math/tex; mode=display">O\\big(n.log(n)\\big)</script> time. A total of <script type="math/tex; mode=display">O(n)</script> time is spent on searching for the appropriate intervals, since the <script type="math/tex; mode=display">\\text{endIntervals}</script> and <script type="math/tex; mode=display">\\text{intervals}</script> array is scanned only once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">\\text{endIntervals}</script>, <script type="math/tex; mode=display">\\text{intervals}</script> and <script type="math/tex; mode=display">res</script> array of size <script type="math/tex; mode=display">n</script> are used. A hashmap <script type="math/tex; mode=display">hash</script> of size <script type="math/tex; mode=display">O(n)</script> is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '437',
    name: 'Path Sum III',
    acceptance: '40.1%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>You are given a binary tree in which each node contains an integer value.</p>\n\n<p>Find the number of paths that sum to a given value.</p>\n\n<p>The path does not need to start or end at the root or a leaf, but it must go downwards\n(traveling only from parent nodes to child nodes).</p>\n\n<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.\n\n</p><p><b>Example:</b>\n</p><pre>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n\n      10\n     /  \\\n    <b>5</b>   <b>-3</b>\n   <b>/</b> <b>\\</b>    <b>\\</b>\n  <b>3</b>   <b>2</b>   <b>11</b>\n / \\   <b>\\</b>\n3  -2   <b>1</b>\n\nReturn 3. The paths that sum to 8 are:\n\n1.  5 -&gt; 3\n2.  5 -&gt; 2 -&gt; 1\n3. -3 -&gt; 11\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '438',
    name: 'Find All Anagrams in a String',
    acceptance: '33.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a string <b>s</b> and a <b>non-empty</b> string <b>p</b>, find all the start indices of <b>p</b>\'s anagrams in <b>s</b>.</p>\n\n<p>Strings consists of lowercase English letters only and the length of both strings <b>s</b> and <b>p</b> will not be larger than 20,100.</p>\n\n<p>The order of output does not matter.</p>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b>\ns: "cbaebabacd" p: "abc"\n\n<b>Output:</b>\n[0, 6]\n\n<b>Explanation:</b>\nThe substring with start index = 0 is "cba", which is an anagram of "abc".\nThe substring with start index = 6 is "bac", which is an anagram of "abc".\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b>\ns: "abab" p: "ab"\n\n<b>Output:</b>\n[0, 1, 2]\n\n<b>Explanation:</b>\nThe substring with start index = 0 is "ab", which is an anagram of "ab".\nThe substring with start index = 1 is "ba", which is an anagram of "ab".\nThe substring with start index = 2 is "ab", which is an anagram of "ab".\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Amazon'],
  },
  {
    id: '439',
    name: 'Ternary Expression Parser ',
    acceptance: '51.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a string representing arbitrarily nested ternary expressions, calculate the result of the expression. You can always assume that the given expression is valid and only consists of digits <code>0-9</code>, <code>?</code>, <code>:</code>, <code>T</code> and <code>F</code> (<code>T</code> and <code>F</code> represent True and False respectively).\n\n</p><p><b>Note:</b>\n</p><ol>\n<li>The length of the given string is ≤ 10000.</li>\n<li>Each number will contain only one digit.</li>\n<li>The conditional expressions group right-to-left (as usual in most languages).</li>\n<li>The condition will always be either <code>T</code> or <code>F</code>. That is, the condition will never be a digit.</li>\n<li>The result of the expression will always evaluate to either a digit <code>0-9</code>, <code>T</code> or <code>F</code>.</li>\n</ol>\n<p></p>\n\n<p>\n<b>Example 1:</b>\n</p><pre><b>Input:</b> "T?2:3"\n\n<b>Output:</b> "2"\n\n<b>Explanation:</b> If true, then result is 2; otherwise result is 3.\n</pre>\n<p></p>\n\n<p>\n<b>Example 2:</b>\n</p><pre><b>Input:</b> "F?1:T?4:5"\n\n<b>Output:</b> "4"\n\n<b>Explanation:</b> The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:\n\n             "(F ? 1 : (T ? 4 : 5))"                   "(F ? 1 : (T ? 4 : 5))"\n          -&gt; "(F ? 1 : 4)"                 or       -&gt; "(T ? 4 : 5)"\n          -&gt; "4"                                    -&gt; "4"\n</pre>\n<p></p>\n\n<p>\n<b>Example 3:</b>\n</p><pre><b>Input:</b> "T?T?F:5:3"\n\n<b>Output:</b> "F"\n\n<b>Explanation:</b> The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:\n\n             "(T ? (T ? F : 5) : 3)"                   "(T ? (T ? F : 5) : 3)"\n          -&gt; "(T ? F : 3)"                 or       -&gt; "(T ? F : 5)"\n          -&gt; "F"                                    -&gt; "F"\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Snapchat'],
  },
  {
    id: '440',
    name: 'K-th Smallest in Lexicographical Order',
    acceptance: '25.4%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given integers <code>n</code> and <code>k</code>, find the lexicographically k-th smallest integer in the range from <code>1</code> to <code>n</code>.</p>\n\n<p>Note: 1 ≤ k ≤ n ≤ 10<sup>9</sup>.</p>\n\n<p><b>Example:</b>\n</p><pre><b>Input:</b>\nn: 13   k: 2\n\n<b>Output:</b>\n10\n\n<b>Explanation:</b>\nThe lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.\n</pre>\n<p></p>\n\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Hulu'],
  },
  {
    id: '441',
    name: 'Arranging Coins',
    acceptance: '36.4%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>You have a total of <i>n</i> coins that you want to form in a staircase shape, where every <i>k</i>-th row must have exactly <i>k</i> coins.</p>\n \n<p>Given <i>n</i>, find the total number of <b>full</b> staircase rows that can be formed.</p>\n\n<p><i>n</i> is a non-negative integer and fits within the range of a 32-bit signed integer.</p>\n\n<p><b>Example 1:</b>\n</p><pre>n = 5\n\nThe coins can form the following rows:\n¤\n¤ ¤\n¤ ¤\n\nBecause the 3rd row is incomplete, we return 2.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre>n = 8\n\nThe coins can form the following rows:\n¤\n¤ ¤\n¤ ¤ ¤\n¤ ¤\n\nBecause the 4th row is incomplete, we return 3.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['GoDaddy'],
  },
  {
    id: '442',
    name: 'Find All Duplicates in an Array',
    acceptance: '56.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given an array of integers, 1 ≤ a[i] ≤ <i>n</i> (<i>n</i> = size of array), some elements appear <b>twice</b> and others appear <b>once</b>.</p>\n\n<p>Find all the elements that appear <b>twice</b> in this array.</p>\n\n<p>Could you do it without extra space and in O(<i>n</i>) runtime?</p>\n<p></p>\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b>\n[4,3,2,7,8,2,3,1]\n\n<b>Output:</b>\n[2,3]\n</pre>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Pocket Gems'],
  },
  {
    id: '443',
    name: 'String Compression',
    acceptance: '36.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given an array of characters, compress it <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank"><b>in-place</b></a>.</p>\n\n<p>The length after compression must always be smaller than or equal to the original array.</p>\n\n<p>Every element of the array should be a <b>character</b> (not int) of length 1.</p>\n \n<p>After you are done <b>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">in-place</a></b>, return the new length of the array.</p>\n\n<br>\n\n<p><b>Follow up:</b><br>\nCould you solve it using only O(1) extra space?\n</p>\n\n<br>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>\n["a","a","b","b","c","c","c"]\n\n<b>Output:</b>\nReturn 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]\n\n<b>Explanation:</b>\n"aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b>\n["a"]\n\n<b>Output:</b>\nReturn 1, and the first 1 characters of the input array should be: ["a"]\n\n<b>Explanation:</b>\nNothing is replaced.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b>\n["a","b","b","b","b","b","b","b","b","b","b","b","b"]\n\n<b>Output:</b>\nReturn 4, and the first 4 characters of the input array should be: ["a","b","1","2"].\n\n<b>Explanation:</b>\nSince the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12".\nNotice each digit has it\'s own entry in the array.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>All characters have an ASCII value in <code>[35, 126]</code>.</li>\n<li><code>1 &lt;= len(chars) &lt;= 1000</code>.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-read-and-write-heads-accepted">Approach #1: Read and Write Heads [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-read-and-write-heads-accepted">Approach #1: Read and Write Heads [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We will use separate pointers <code>read</code> and <code>write</code> to mark where we are reading and writing from.  Both operations will be done left to right alternately:  we will read a contiguous group of characters, then write the compressed version to the array.  At the end, the position of the <code>write</code> head will be the length of the answer that was written.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let\'s maintain <code>anchor</code>, the start position of the contiguous group of characters we are currently reading.</p>\n<p>Now, let\'s read from left to right.  We know that we must be at the end of the block when we are at the last character, or when the next character is different from the current character.</p>\n<p>When we are at the end of a group, we will write the result of that group down using our <code>write</code> head.  <code>chars[anchor]</code> will be the correct character, and the length (if greater than 1) will be <code>read - anchor + 1</code>.  We will write the digits of that number to the array.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="p">):</span>\n        <span class="n">anchor</span> <span class="o">=</span> <span class="n">write</span> <span class="o">=</span> <span class="mi">0</span>\n        <span class="k">for</span> <span class="n">read</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chars</span><span class="p">):</span>\n            <span class="k">if</span> <span class="n">read</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span> <span class="ow">or</span> <span class="n">chars</span><span class="p">[</span><span class="n">read</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">c</span><span class="p">:</span>\n                <span class="n">chars</span><span class="p">[</span><span class="n">write</span><span class="p">]</span> <span class="o">=</span> <span class="n">chars</span><span class="p">[</span><span class="n">anchor</span><span class="p">]</span>\n                <span class="n">write</span> <span class="o">+=</span> <span class="mi">1</span>\n                <span class="k">if</span> <span class="n">read</span> <span class="o">&gt;</span> <span class="n">anchor</span><span class="p">:</span>\n                    <span class="k">for</span> <span class="n">digit</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">read</span> <span class="o">-</span> <span class="n">anchor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>\n                        <span class="n">chars</span><span class="p">[</span><span class="n">write</span><span class="p">]</span> <span class="o">=</span> <span class="n">digit</span>\n                        <span class="n">write</span> <span class="o">+=</span> <span class="mi">1</span>\n                <span class="n">anchor</span> <span class="o">=</span> <span class="n">read</span> <span class="o">+</span> <span class="mi">1</span>\n        <span class="k">return</span> <span class="n">write</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compress</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">anchor</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">write</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">read</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">read</span> <span class="o">&lt;</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">read</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">read</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">chars</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span> <span class="n">chars</span><span class="o">[</span><span class="n">read</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">!=</span> <span class="n">chars</span><span class="o">[</span><span class="n">read</span><span class="o">])</span> <span class="o">{</span>\n                <span class="n">chars</span><span class="o">[</span><span class="n">write</span><span class="o">++]</span> <span class="o">=</span> <span class="n">chars</span><span class="o">[</span><span class="n">anchor</span><span class="o">];</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">read</span> <span class="o">&gt;</span> <span class="n">anchor</span><span class="o">)</span> <span class="o">{</span>\n                    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">:</span> <span class="o">(</span><span class="s">""</span> <span class="o">+</span> <span class="o">(</span><span class="n">read</span> <span class="o">-</span> <span class="n">anchor</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)).</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>\n                        <span class="n">chars</span><span class="o">[</span><span class="n">write</span><span class="o">++]</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>\n                    <span class="o">}</span>\n                <span class="o">}</span>\n                <span class="n">anchor</span> <span class="o">=</span> <span class="n">read</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">write</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>chars</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>, the space used by <code>read</code>, <code>write</code>, and <code>anchor</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Microsoft', 'Bloomberg', 'Snapchat', 'Yelp', 'Expedia', 'GoDaddy', 'Lyft'],
  },
  {
    id: '444',
    name: 'Sequence Reconstruction ',
    acceptance: '19.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Check whether the original sequence <code>org</code> can be uniquely reconstructed from the sequences in <code>seqs</code>. The <code>org</code> sequence is a permutation of the integers from 1 to n, with 1 ≤ n ≤ 10<sup>4</sup>. Reconstruction means building a shortest common supersequence of the sequences in <code>seqs</code> (i.e., a shortest sequence so that all sequences in <code>seqs</code> are subsequences of it). Determine whether there is only one sequence that can be reconstructed from <code>seqs</code> and it is the <code>org</code> sequence.</p>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b>\norg: [1,2,3], seqs: [[1,2],[1,3]]\n\n<b>Output:</b>\nfalse\n\n<b>Explanation:</b>\n[1,2,3] is not the only one sequence that can be reconstructed, because [1,3,2] is also a valid sequence that can be reconstructed.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b>\norg: [1,2,3], seqs: [[1,2]]\n\n<b>Output:</b>\nfalse\n\n<b>Explanation:</b>\nThe reconstructed sequence can only be [1,2].\n</pre>\n<p></p>\n\n<p><b>Example 3:</b>\n</p><pre><b>Input:</b>\norg: [1,2,3], seqs: [[1,2],[1,3],[2,3]]\n\n<b>Output:</b>\ntrue\n\n<b>Explanation:</b>\nThe sequences [1,2], [1,3], and [2,3] can uniquely reconstruct the original sequence [1,2,3].\n</pre>\n<p></p>\n\n<p><b>Example 4:</b>\n</p><pre><b>Input:</b>\norg: [4,1,5,2,6,3], seqs: [[5,2,6,3],[4,1,5,2]]\n\n<b>Output:</b>\ntrue\n</pre>\n<p></p>\n\n<p>\n<b><font color="red">UPDATE (2017/1/8):</font></b><br>\nThe <i>seqs</i> parameter had been changed to a list of list of strings (instead of a 2d array of strings). Please reload the code definition to get the latest changes.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '445',
    name: 'Add Two Numbers II',
    acceptance: '46.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>You are given two <b>non-empty</b> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>\n\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n\n<p><b>Follow up:</b><br>\nWhat if you cannot modify the input lists? In other words, reversing the lists is not allowed.\n</p>\n\n<p>\n<b>Example:</b>\n</p><pre><b>Input:</b> (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\n<b>Output:</b> 7 -&gt; 8 -&gt; 0 -&gt; 7\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft', 'Bloomberg'],
  },
  {
    id: '446',
    name: 'Arithmetic Slices II - Subsequence',
    acceptance: '27.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>\n\n<p>For example, these are arithmetic sequences:</p>\n<pre>1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9</pre>\n\n<p>The following sequence is not arithmetic.</p> <pre>1, 1, 2, 5, 7</pre> \n<br>\n\n<p>A zero-indexed array A consisting of N numbers is given. A <b>subsequence</b> slice of that array is any sequence of integers (P<sub>0</sub>, P<sub>1</sub>, ..., P<sub>k</sub>) such that 0 ≤ P<sub>0</sub> &lt; P<sub>1</sub> &lt; ... &lt; P<sub>k</sub> &lt; N.</p>\n\n<p>A <b>subsequence</b> slice (P<sub>0</sub>, P<sub>1</sub>, ..., P<sub>k</sub>) of array A is called arithmetic if the sequence A[P<sub>0</sub>], A[P<sub>1</sub>], ..., A[P<sub>k-1</sub>], A[P<sub>k</sub>] is arithmetic. In particular, this means that k ≥ 2.</p>\n\n<p>The function should return the number of arithmetic subsequence slices in the array A. </p>\n\n<p>The input contains N integers. Every integer is in the range of -2<sup>31</sup> and 2<sup>31</sup>-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 2<sup>31</sup>-1.</p>\n<br>\n\n<p><b>Example:</b>\n</p><pre><b>Input:</b> [2, 4, 6, 8, 10]\n\n<b>Output:</b> 7\n\n<b>Explanation:</b>\nAll arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Baidu'],
  },
  {
    id: '447',
    name: 'Number of Boomerangs',
    acceptance: '45.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given <i>n</i> points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points <code>(i, j, k)</code> such that the distance between <code>i</code> and <code>j</code> equals the distance between <code>i</code> and <code>k</code> (<b>the order of the tuple matters</b>).</p>\n\n<p>Find the number of boomerangs. You may assume that <i>n</i> will be at most <b>500</b> and coordinates of points are all in the range <b>[-10000, 10000]</b> (inclusive).</p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b>\n[[0,0],[1,0],[2,0]]\n\n<b>Output:</b>\n2\n\n<b>Explanation:</b>\nThe two boomerangs are <b>[[1,0],[0,0],[2,0]]</b> and <b>[[1,0],[2,0],[0,0]]</b>\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '448',
    name: 'Find All Numbers Disappeared in an Array',
    acceptance: '51.3%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given an array of integers where 1 ≤ a[i] ≤ <i>n</i> (<i>n</i> = size of array), some elements appear twice and others appear once.</p>\n\n<p>Find all the elements of [1, <i>n</i>] inclusive that do not appear in this array.</p>\n\n<p>Could you do it without extra space and in O(<i>n</i>) runtime? You may assume the returned list does not count as extra space.</p>\n\n<p><b>Example:</b>\n</p><pre><b>Input:</b>\n[4,3,2,7,8,2,3,1]\n\n<b>Output:</b>\n[5,6]\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '449',
    name: 'Serialize and Deserialize BST',
    acceptance: '42.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. </p>\n\n<p>Design an algorithm to serialize and deserialize a <b>binary search tree</b>. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>\n\n<p>\n<b>The encoded string should be as compact as possible.</b>\n</p>\n\n<p>\n<b>Note:</b> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Amazon'],
  },
  {
    id: '450',
    name: 'Delete Node in a BST',
    acceptance: '37.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>\n\n<p>Basically, the deletion can be divided into two stages:\n</p><ol>\n<li>Search for a node to remove.</li>\n<li>If the node is found, delete the node.</li>\n</ol>\n<p></p>\n\n<p><b>Note:</b> Time complexity should be O(height of tree).</p>\n\n<p><b>Example:</b>\n</p><pre>root = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\nGiven key to delete is 3. So we find the node with value 3 and delete it.\n\nOne valid answer is [5,4,6,2,null,null,7], shown in the following BST.\n\n    5\n   / \\\n  4   6\n /     \\\n2       7\n\nAnother valid answer is [5,2,6,null,4,null,7].\n\n    5\n   / \\\n  2   6\n   \\   \\\n    4   7\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Uber'],
  },
  {
    id: '451',
    name: 'Sort Characters By Frequency',
    acceptance: '51.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a string, sort it in decreasing order based on the frequency of characters.</p>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b>\n"tree"\n\n<b>Output:</b>\n"eert"\n\n<b>Explanation:</b>\n\'e\' appears twice while \'r\' and \'t\' both appear once.\nSo \'e\' must appear before both \'r\' and \'t\'. Therefore "eetr" is also a valid answer.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b>\n"cccaaa"\n\n<b>Output:</b>\n"cccaaa"\n\n<b>Explanation:</b>\nBoth \'c\' and \'a\' appear three times, so "aaaccc" is also a valid answer.\nNote that "cacaca" is incorrect, as the same characters must be together.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b>\n</p><pre><b>Input:</b>\n"Aabb"\n\n<b>Output:</b>\n"bbAa"\n\n<b>Explanation:</b>\n"bbaA" is also a valid answer, but "Aabb" is incorrect.\nNote that \'A\' and \'a\' are treated as two different characters.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Amazon'],
  },
  {
    id: '452',
    name: 'Minimum Number of Arrows to Burst Balloons',
    acceptance: '44.5%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 10<sup>4</sup> balloons.</p>\n\n<p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with x<sub>start</sub> and x<sub>end</sub> bursts by an arrow shot at x if x<sub>start</sub> ≤ x ≤ x<sub>end</sub>. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons. </p>\n\n<p><b>Example:</b>\n</p><pre><b>Input:</b>\n[[10,16], [2,8], [1,6], [7,12]]\n\n<b>Output:</b>\n2\n\n<b>Explanation:</b>\nOne way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).\n</pre>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft'],
  },
  {
    id: '453',
    name: 'Minimum Moves to Equal Array Elements',
    acceptance: '47.8%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a <b>non-empty</b> integer array of size <i>n</i>, find the minimum number of moves required to make all array elements equal, where a move is incrementing <i>n</i> - 1 elements by 1.</p>\n\n<p><b>Example:</b>\n</p><pre><b>Input:</b>\n[1,2,3]\n\n<b>Output:</b>\n3\n\n<b>Explanation:</b>\nOnly three moves are needed (remember each move increments two elements):\n\n[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-forcetime-limit-exceeded">Approach #2 Better Brute Force[Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-using-sorting-accepted">Approach #3 Using Sorting [Accepted]</a></li>\n<li><a href="#approach-4-using-dp-accepted">Approach #4 Using DP [Accepted]</a></li>\n<li><a href="#approach-5-using-mathaccepted">Approach #5 Using Math[Accepted]</a></li>\n<li><a href="#approach-6-modified-approach-using-mathsaccepted">Approach #6 Modified Approach Using Maths[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>Firstly, we know that in order to make all the elements equal to each other with minimum moves, we need to do the increments in all but the maximum element of the array.\n Thus, in the brute force approach, we scan the complete array to find the maximum and the minimum element. After this, we add 1 to all the elements except the maximum element, and\nincrement the count for the number of moves done. Again, we repeat the same process, and this continues until the maximum and the minimum element become equal to each other.</p>\n<iframe frameborder="0" height="479" name="zDzVEUkJ" src="https://leetcode.com/playground/zDzVEUkJ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n^2 k)</script>, where <script type="math/tex; mode=display">n</script> is the length of the array and <script type="math/tex; mode=display">k</script> is the difference between maximum element and minimum element.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space required.</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-forcetime-limit-exceeded">Approach #2 Better Brute Force[Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the previous approach, we added 1 to every element in a single step. But, we can modify this approach to some extent. In order to make the minimum element equal to the maximum element, we need to add 1 atleast <script type="math/tex; mode=display">k</script> times,\nafter which, the maximum element could change. Thus, instead of incrementing in steps of 1,we increment in bursts, where each burst will be of size <script type="math/tex; mode=display">k=max-min</script>.\nThus, we scan the complete array to find the maximum and minimum element. Then, we increment every element by <script type="math/tex; mode=display">k</script> units and add <script type="math/tex; mode=display">k</script> to the count of moves. Again we\nrepeat the same process, until the maximum and minimum element become equal.</p>\n<iframe frameborder="0" height="496" name="FG9JKTT6" src="https://leetcode.com/playground/FG9JKTT6/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. In every iteration two elements are equalized.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space required.</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-sorting-accepted">Approach #3 Using Sorting [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The problem gets simplified if we sort the given array in order to obtain a sorted array <script type="math/tex; mode=display">a</script>. Now, similar to Approach 2,we use the difference <script type="math/tex; mode=display">diff=max-min</script> to update the elements of the array, but we need not traverse the whole array to find the maximum and minimum element every time,\nsince if the array is sorted, we can make use of this property to find the maximum and minimum element after updation in <script type="math/tex; mode=display">O(1)</script> time. Further, we need not actually update all the elements of the array.\nTo understand how this works, we\'ll go in a stepwise manner.</p>\n<p>Firstly, assume that we are updating the elements of the sorted array after every step of calculating the difference <script type="math/tex; mode=display">diff</script>. We\'ll see how to find the maximum and minimum element without\ntraversing the array. In the first step, the last element is the largest element. Therefore, <script type="math/tex; mode=display">diff=a[n-1]-a[0]</script>. We add <script type="math/tex; mode=display">diff</script> to all the elements except the last one i.e. <script type="math/tex; mode=display">a[n-1]</script>.\n Now, the updated element at index 0 ,<script type="math/tex; mode=display">a\'[0]</script> will be <script type="math/tex; mode=display">a[0]+diff=a[n-1]</script>. Thus, the smallest element <script type="math/tex; mode=display">a\'[0]</script> is now equal to the previous largest element <script type="math/tex; mode=display">a[n-1]</script>. Since, the\n elements of the array are sorted, the elements upto index <script type="math/tex; mode=display">i-2</script> satisfy the property <script type="math/tex; mode=display">a[j]>=a[j-1]</script>. Thus, after updation, the element <script type="math/tex; mode=display">a\'[n-2]</script> will become the largest element, which is obvious due to the sorted array property. Also, a[0]\n is still the smallest element.</p>\n<p>Thus, for the second updation, we consider the difference <script type="math/tex; mode=display">diff</script> as <script type="math/tex; mode=display">diff=a[n-2]-a[0]</script>. After updation, <script type="math/tex; mode=display">a\'\'[0]</script> will become equal to <script type="math/tex; mode=display">a\'[n-2]</script> similar to the first iteration.\n Further, since <script type="math/tex; mode=display">a\'[0]</script> and <script type="math/tex; mode=display">a\'[n-1]</script> were equal. After the second updation, we get <script type="math/tex; mode=display">a\'\'[0]=a\'\'[n-1]=a\'[n-2]</script>. Thus, now the largest element will be <script type="math/tex; mode=display">a[n-3]</script>.\n Thus, we can continue in this fashion, and keep on incrementing the number of moves with the difference found at every step.</p>\n<p>Now, let\'s come to step 2. In the first step, we assumed that we are updating the elements of the array <script type="math/tex; mode=display">a</script> at every step, but we need not do this. This is because, even after updating\n the elements the difference which we consider to add to the number of moves required remains the same because both the elements <script type="math/tex; mode=display">max</script> and <script type="math/tex; mode=display">min</script> required to find the <script type="math/tex; mode=display">diff</script> get updated by the\n same amount everytime.</p>\n<p>Thus, we can simply sort the given array once and use <script type="math/tex; mode=display">moves=\\sum_{i=1}^{n-1} (a[i]-a[0])</script>.</p>\n<iframe frameborder="0" height="224" name="RaVVUTFL" src="https://leetcode.com/playground/RaVVUTFL/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script>. Sorting will take <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space required.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-dp-accepted">Approach #4 Using DP [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The given problem can be simplified if we sort the given array once. If we consider a sorted array <script type="math/tex; mode=display">a</script>, instead of trying to work on the complete problem of\nequalizing every element of the array, we can break the problem for array of size <script type="math/tex; mode=display">n</script> into problems of solving arrays of smaller sizes. Assuming, the elements upto\nindex <script type="math/tex; mode=display">i-1</script> have been equalized, we can simply consider the element at index <script type="math/tex; mode=display">i</script> and add the difference <script type="math/tex; mode=display">diff=a[i]-a[i-1]</script> to the total number of moves for the array upto index <script type="math/tex; mode=display">i</script> to be equalized i.e. <script type="math/tex; mode=display">moves=moves+diff</script>.\n But when we try to proceed with this step, as per a valid move, the elements following <script type="math/tex; mode=display">a[i]</script> will also be incremented by the amount <script type="math/tex; mode=display">diff</script> i.e. <script type="math/tex; mode=display">a[j]=a[j]+diff</script>, for <script type="math/tex; mode=display">j>i</script>.\n But while implementing this approach, we need not increment all such <script type="math/tex; mode=display">a[j]</script>\'s. Instead, we\'ll add the number of <script type="math/tex; mode=display">moves</script> done so far to the current element i.e. <script type="math/tex; mode=display">a[i]</script> and update it to <script type="math/tex; mode=display">a\'[i]=a[i]+moves</script>.</p>\n<p>In short, we sort the given array, and keep on updating the <script type="math/tex; mode=display">moves</script> required so far in order to equalize the elements upto the current index without actually changing the elements of the\n  array except the current element. After the complete array has been scanned <script type="math/tex; mode=display">moves</script> gives the required solution.</p>\n<p>The following animation will make the process more clear for this example:</p>\n<p><code>[13 18 3 10 35 68 50 20 50]</code></p>\n<p><!-- <img alt="Minimum_Moves_dp" src="https://leetcode.com/articles/Figures/453_Minimum_Moves.gif" />-->\n  !?!../Documents/453_Minimum_Moves.json:1000,563!?!</p>\n<iframe frameborder="0" height="258" name="ZeTzTVy6" src="https://leetcode.com/playground/ZeTzTVy6/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script>. Sorting will take <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Only single extra variable is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-using-mathaccepted">Approach #5 Using Math[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This approach is based on the idea that adding 1 to all the elements except one is equivalent to decrementing 1 from a single element, since we are interested in the relative levels of the\n elements which need to be equalized. Thus, the problem is simplified to find the number of decrement operations required to equalize all the elements of the given array.\n For finding this, it is obvious that we\'ll reduce all the elements of the array to the minimum element. But, in order to find the solution, we need not actually decrement the elements. We can find the\n number of moves required as <script type="math/tex; mode=display">moves=\\sum_{i=0}^{n-1} a[i] - min(a)*n</script>, where <script type="math/tex; mode=display">n</script> is the length of the array.</p>\n<iframe frameborder="0" height="241" name="n9x34Fi5" src="https://leetcode.com/playground/n9x34Fi5/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We traverse the complete array once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space required.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-6-modified-approach-using-mathsaccepted">Approach #6 Modified Approach Using Maths[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>There could be a problem with the above approach. The value <script type="math/tex; mode=display">\\sum_{i=0}^{n-1} a[i]</script> could be very large and hence could lead to integer overflow if the <script type="math/tex; mode=display">a[i]</script>\'s are\nvery large. To avoid this problem, we can calculate the required number of <script type="math/tex; mode=display">moves</script> on the fly. <script type="math/tex; mode=display">\\sum_{i=0}^{n-1} (a[i]-min(a))</script>.</p>\n<iframe frameborder="0" height="258" name="9udsqVkr" src="https://leetcode.com/playground/9udsqVkr/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. One pass for finding minimum and one pass for calculating moves.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space required.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Indeed', 'Coursera'],
  },
  {
    id: '454',
    name: '4Sum II',
    acceptance: '47.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given four lists A, B, C, D of integer values, compute how many tuples <code>(i, j, k, l)</code> there are such that <code>A[i] + B[j] + C[k] + D[l]</code> is zero.</p>\n\n<p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2<sup>28</sup> to 2<sup>28</sup> - 1 and the result is guaranteed to be at most 2<sup>31</sup> - 1.</p>\n\n<p><b>Example:</b>\n</p><pre><b>Input:</b>\nA = [ 1, 2]\nB = [-2,-1]\nC = [-1, 2]\nD = [ 0, 2]\n\n<b>Output:</b>\n2\n\n<b>Explanation:</b>\nThe two tuples are:\n1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '455',
    name: 'Assign Cookies',
    acceptance: '47.2%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nAssume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor g<sub>i</sub>, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s<sub>j</sub>. If s<sub>j</sub> &gt;= g<sub>i</sub>, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\n</p>\n\n<p><b>Note:</b><br>\nYou may assume the greed factor is always positive. <br>\nYou cannot assign more than one cookie to one child.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,2,3], [1,1]\n\n<b>Output:</b> 1\n\n<b>Explanation:</b> You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [1,2], [1,2,3]\n\n<b>Output:</b> 2\n\n<b>Explanation:</b> You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '456',
    name: '132 Pattern',
    acceptance: '28.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a sequence of n integers a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>, a 132 pattern is a subsequence a<sub><b>i</b></sub>, a<sub><b>j</b></sub>, a<sub><b>k</b></sub> such\nthat <b>i</b> &lt; <b>j</b> &lt; <b>k</b> and a<sub><b>i</b></sub> &lt; a<sub><b>k</b></sub> &lt; a<sub><b>j</b></sub>. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p>\n\n<p><b>Note:</b> n will be less than 15,000.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1, 2, 3, 4]\n\n<b>Output:</b> False\n\n<b>Explanation:</b> There is no 132 pattern in the sequence.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [3, 1, 4, 2]\n\n<b>Output:</b> True\n\n<b>Explanation:</b> There is a 132 pattern in the sequence: [1, 4, 2].\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> [-1, 3, 2, 0]\n\n<b>Output:</b> True\n\n<b>Explanation:</b> There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</a></li>\n<li><a href="#approach-3-searching-intervals-accepted">Approach #3 Searching Intervals [Accepted]</a></li>\n<li><a href="#approach-4-using-stack-accepted">Approach #4 Using Stack [Accepted]:</a></li>\n<li><a href="#approach-5-using-binary-search-accepted">Approach #5 Using Binary Search [Accepted]:</a></li>\n<li><a href="#approach-6-using-array-as-a-stackaccepted">Approach #6 Using Array as a stack[Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The simplest solution is to consider every triplet <script type="math/tex; mode=display">(i, j, k)</script> and check if the corresponding numbers satisfy the 132 criteria. If any such triplet is found, we can return a True value. If no such triplet is found, we need to return a False value.</p>\n<iframe frameborder="0" height="292" name="WxSeh6mX" src="https://leetcode.com/playground/WxSeh6mX/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. Three loops are used to consider every possible triplet. Here, <script type="math/tex; mode=display">n</script> refers to the size of <script type="math/tex; mode=display">nums</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can improve the last approach to some extent, if we make use of some observations. We can note that for a particular number <script type="math/tex; mode=display">nums[j]</script> chosen as 2nd element in the 132 pattern, if we don\'t consider <script type="math/tex; mode=display">nums[k]</script>(the 3rd element) for the time being, our job is to find out the first element, <script type="math/tex; mode=display">nums[i]</script>(<script type="math/tex; mode=display">i<j</script>) which is lesser than <script type="math/tex; mode=display">nums[j]</script>. </p>\n<p>Now, assume that we have somehow found a <script type="math/tex; mode=display">nums[i],nums[j]</script> pair. Our task now reduces to finding out a <script type="math/tex; mode=display">nums[k]</script>(<script type="math/tex; mode=display">Kk>j>i)</script>, which falls in the range <script type="math/tex; mode=display">(nums[i], nums[j])</script>. Now, to maximize the likelihood of a <script type="math/tex; mode=display">nums[k]</script> falling in this range, we need to increase this range as much as possible. </p>\n<p>Since, we started off by fixing a <script type="math/tex; mode=display">nums[j]</script>, the only option in our hand is to choose a minimum value of <script type="math/tex; mode=display">nums[i]</script> given a particular <script type="math/tex; mode=display">nums[j]</script>. Once, this pair <script type="math/tex; mode=display">nums[i],nums[j]</script>, has been found out, we simply need to traverse beyond the index <script type="math/tex; mode=display">j</script> to find if a <script type="math/tex; mode=display">nums[k]</script> exists for this pair satisfying the 132 criteria.</p>\n<p>Based on the above observations, while traversing over the <script type="math/tex; mode=display">nums</script> array choosing various values of <script type="math/tex; mode=display">nums[j]</script>, we simultaneously keep a track of the minimum element found so far(excluding <script type="math/tex; mode=display">nums[j]</script>). This minimum element always serves as the <script type="math/tex; mode=display">nums[i]</script> for the current <script type="math/tex; mode=display">nums[j]</script>. Thus, we only need to traverse beyond the <script type="math/tex; mode=display">j^{th}</script> index to check the <script type="math/tex; mode=display">nums[k]</script>\'s to determine if any of them satisfies the 132 criteria.</p>\n<iframe frameborder="0" height="292" name="otcaotVk" src="https://leetcode.com/playground/otcaotVk/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Two loops are used to find the <script type="math/tex; mode=display">nums[j],nums[k]</script> pairs. Here, <script type="math/tex; mode=display">n</script> refers to the size of <script type="math/tex; mode=display">nums</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-searching-intervals-accepted">Approach #3 Searching Intervals [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>As discussed in the last approach, once we\'ve fixed a <script type="math/tex; mode=display">nums[i],nums[j]</script> pair, we just need to determine a <script type="math/tex; mode=display">nums[k]</script> which falls in the range <script type="math/tex; mode=display">(nums[i],nums[j])</script>. Further, to maximize the likelihood of any arbitrary <script type="math/tex; mode=display">nums[k]</script> falling in this range, we need to try to keep this range as much as possible. But, in the last approach, we tried to work only on <script type="math/tex; mode=display">nums[i]</script>. But, it\'ll be a better choice, if we can somehow work out on <script type="math/tex; mode=display">nums[j]</script> as well.</p>\n<p>To do so, we can look at the given <script type="math/tex; mode=display">nums</script> array in the form of a graph, as shown below:</p>\n<p align="center"><img alt="Graph" src="https://leetcode.com/articles/Figures/456/456_132_Pattern.PNG"></p>\n<p>From the above graph, which consists of rising and falling slopes, we know, the best qualifiers to act as the <script type="math/tex; mode=display">nums[i],nums[j]</script> pair,  as discussed above, to maximize the range <script type="math/tex; mode=display">nums[i], nums[j]</script>, at any instant, while traversing the <script type="math/tex; mode=display">nums</script> array, will be the points at the endpoints of a local rising slope. Thus, once we\'ve found such points, we can traverse over the <script type="math/tex; mode=display">nums</script> array to find a <script type="math/tex; mode=display">nums[k]</script> satisfying the given 132 criteria. </p>\n<p>To find these points at the ends of a local rising slope, we can traverse over the given <script type="math/tex; mode=display">nums</script> array. While traversing, we can keep a track of the minimum point found after the last peak(<script type="math/tex; mode=display">nums[s]</script>). </p>\n<p>Now, whenever we encounter a falling slope, say, at index <script type="math/tex; mode=display">i</script>, we know, that <script type="math/tex; mode=display">nums[i-1]</script> was the endpoint of the last rising slope found. Thus, we can scan over the <script type="math/tex; mode=display">k</script> indices(k&gt;i), to find a 132 pattern.</p>\n<p>But, instead of traversing over <script type="math/tex; mode=display">nums</script> to find a <script type="math/tex; mode=display">k</script> satisfying the 132 pattern for every such rising slope, we can store this range <script type="math/tex; mode=display">(nums[s], nums[i-1])</script>(acting as <script type="math/tex; mode=display">(nums[i], nums[j])</script>) in, say an <script type="math/tex; mode=display">intervals</script> array. </p>\n<p>While traversing over the <script type="math/tex; mode=display">nums</script> array to check the rising/falling slopes, whenever we find any rising slope, we can keep adding the endpoint pairs to this <script type="math/tex; mode=display">intervals</script> array. At the same time, we can also check if the current element falls in any of the ranges found so far. If so, this element satisfies the 132 criteria for that range. </p>\n<p>If no such element is found till the end, we need to return a False value.</p>\n<iframe frameborder="0" height="360" name="7sk67PQp" src="https://leetcode.com/playground/7sk67PQp/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. We traverse over the <script type="math/tex; mode=display">nums</script> array of size <script type="math/tex; mode=display">n</script> once to find the slopes. But for every element, we also need to traverse over the <script type="math/tex; mode=display">intervals</script> to check if any element falls in any range found so far. This array can contain atmost <script type="math/tex; mode=display">(n/2)</script> pairs, in the case of an alternate increasing-decreasing sequence(worst case e.g.<code>[5 6 4 7 3 8 2 9]</code>). </p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">intervals</script> array can contain atmost <script type="math/tex; mode=display">n/2</script> pairs, in the worst case(alternate increasing-decreasing sequence).</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-stack-accepted">Approach #4 Using Stack [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>In Approach 2, we found out <script type="math/tex; mode=display">nums[i]</script> corresponding to a particular <script type="math/tex; mode=display">nums[j]</script> directly without having to consider every pair possible in <script type="math/tex; mode=display">nums</script> to find this <script type="math/tex; mode=display">nums[i],nums[j]</script> pair. If we do some preprocessing, we can make the process of finding a <script type="math/tex; mode=display">nums[k]</script> corresponding to this <script type="math/tex; mode=display">nums[i],nums[j]</script> pair also easy.</p>\n<p>The preprocessing required is to just find the best <script type="math/tex; mode=display">nums[i]</script> value corresponding to every <script type="math/tex; mode=display">nums[j]</script> value. This is done in the same manner as in the second approach i.e. we find the minimum element found till the <script type="math/tex; mode=display">j^{th}</script> element which acts as the <script type="math/tex; mode=display">nums[i]</script> for the current <script type="math/tex; mode=display">nums[j]</script>. We maintain thes values in a <script type="math/tex; mode=display">min</script> array. Thus, <script type="math/tex; mode=display">min[j]</script> now refers to the best <script type="math/tex; mode=display">nums[i]</script> value for a particular <script type="math/tex; mode=display">nums[j]</script>. </p>\n<p>Now, we traverse back from the end of the <script type="math/tex; mode=display">nums</script> array to find the <script type="math/tex; mode=display">nums[k]</script>\'s. Suppose, we keep a track of the <script type="math/tex; mode=display">nums[k]</script> values which can potentially satisfy the 132 criteria for the current <script type="math/tex; mode=display">nums[j]</script>. We know, one of the conditions to be satisfied by such a <script type="math/tex; mode=display">nums[k]</script> is that it must be greater than <script type="math/tex; mode=display">nums[i]</script>. Or in other words, we can also say that it must be greater than <script type="math/tex; mode=display">min[j]</script> for a particular <script type="math/tex; mode=display">nums[j]</script> chosen. </p>\n<p>Once it is ensured that the elements left for competing for the <script type="math/tex; mode=display">nums[k]</script> are all greater than <script type="math/tex; mode=display">min[j]</script>(or <script type="math/tex; mode=display">nums[i]</script>), our only task is to ensure that it should be lesser than <script type="math/tex; mode=display">nums[j]</script>. Now, the best element from among the competitors, for satisfying this condition will be the minimum one from out of these elements. </p>\n<p>If this element, <script type="math/tex; mode=display">nums[min]</script> satisfies <script type="math/tex; mode=display">nums[min] < nums[j]</script>, we\'ve found a 132 pattern. If not, no other element will satisfy this criteria, since they are all greater than or equal to <script type="math/tex; mode=display">nums[min]</script>$ and thus greater than or equal to <script type="math/tex; mode=display">nums[j]</script> as well.</p>\n<p>To keep a track of these potential <script type="math/tex; mode=display">nums[k]</script> values for a particular <script type="math/tex; mode=display">nums[i],nums[j]</script> considered currently, we maintain a <script type="math/tex; mode=display">stack</script> on which these potential <script type="math/tex; mode=display">nums[k]</script>\'s satisfying the 132 criteria lie in a descending order(minimum element on the top). We need not sort these elements on the <script type="math/tex; mode=display">stack</script>, but they\'ll be sorted automatically as we\'ll discuss along with the process.</p>\n<p>After creating a <script type="math/tex; mode=display">min</script> array, we start traversing the <script type="math/tex; mode=display">nums[j]</script> array in a backward manner. Let\'s say, we are currently at the <script type="math/tex; mode=display">j^{th}</script> element and let\'s also assume that the <script type="math/tex; mode=display">stack</script> is sorted right now. Now, firstly, we check if <script type="math/tex; mode=display">nums[j] > min[j]</script>. If not, we continue with the <script type="math/tex; mode=display">(j-1)^{th}</script> element and the <script type="math/tex; mode=display">stack</script> remains sorted. If not, we keep on popping the elements from the top of the <script type="math/tex; mode=display">stack</script> till we find an element, <script type="math/tex; mode=display">stack[top]</script> such that, <script type="math/tex; mode=display">stack[top] > min[j]</script>(or <script type="math/tex; mode=display">stack[top] > nums[i]</script>). </p>\n<p>Once the popping is done, we\'re sure that all the elements pending on the <script type="math/tex; mode=display">stack</script> are greater than <script type="math/tex; mode=display">nums[i]</script> and are thus, the potential candidates for <script type="math/tex; mode=display">nums[k]</script> satisfying the 132 criteria. We can also note that the elements which have been popped from the <script type="math/tex; mode=display">stack</script>, all satisfy <script type="math/tex; mode=display">stack[top] &leq; min[j]</script>. </p>\n<p>Since, in the <script type="math/tex; mode=display">min</script> array, <script type="math/tex; mode=display">min[p] &leq; min[q]</script>, for every <script type="math/tex; mode=display">p > q</script>, these popped elements also satisfy <script type="math/tex; mode=display">stack[top] &leq; min[k]</script>, for all <script type="math/tex; mode=display">0 &leq; k < j</script>. Thus, they are not the potential <script type="math/tex; mode=display">nums[k]</script> candidates for even the preceding elements. Even after  doing the popping, the <script type="math/tex; mode=display">stack</script> remains sorted.</p>\n<p>After the popping is done, we\'ve got the minimum element from amongst all the potential <script type="math/tex; mode=display">nums[k]</script>\'s on the top of the <script type="math/tex; mode=display">stack</script>(as per the assumption). We can check if it is greater than <script type="math/tex; mode=display">nums[j]</script> to satisfy the 132 criteria(we\'ve already checked <script type="math/tex; mode=display">stack[top] > nums[i]</script>). If this element satisfies the 132 criteria, we can return a True value. If not, we know that for the current <script type="math/tex; mode=display">j</script>, <script type="math/tex; mode=display">nums[j] > min[j]</script>. Thus, the element <script type="math/tex; mode=display">nums[j]</script> could be a potential <script type="math/tex; mode=display">nums[k]</script> value, for the preceding <script type="math/tex; mode=display">nums[i]\'s</script>. </p>\n<p>Thus, we push it over the <script type="math/tex; mode=display">stack</script>. We can note that, we need to push this element <script type="math/tex; mode=display">nums[j]</script> on the <script type="math/tex; mode=display">stack</script> only when it didn\'t satisfy <script type="math/tex; mode=display">stack[top]<nums[j]</script>. Thus, <script type="math/tex; mode=display">nums[j] &leq; stack[top]</script>. Thus, even after pushing this element on the <script type="math/tex; mode=display">stack</script>, the <script type="math/tex; mode=display">stack</script> remains sorted. Thus, we\'ve seen by induction, that the <script type="math/tex; mode=display">stack</script> always remains sorted.</p>\n<p>Also, note that in case <script type="math/tex; mode=display">nums[j] &leq; min[j]</script>, we don\'t push <script type="math/tex; mode=display">nums[j]</script> onto the <script type="math/tex; mode=display">stack</script>. This is because this <script type="math/tex; mode=display">nums[j]</script> isn\'t greater than even the minimum element lying towards its left and thus can\'t act as <script type="math/tex; mode=display">nums[k]</script> in the future.</p>\n<p>If no element is found satisfying the 132 criteria till reaching the first element, we return a False value.</p>\n<p>The following animation better illustrates the process.</p>\n<p>!?!../Documents/456_132_Pattern.json:1000,563!?!</p>\n<iframe frameborder="0" height="411" name="mhTQ2qWz" src="https://leetcode.com/playground/mhTQ2qWz/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We travesre over the <script type="math/tex; mode=display">nums</script> array of size <script type="math/tex; mode=display">n</script> once to fill the <script type="math/tex; mode=display">min</script> array. After this, we traverse over <script type="math/tex; mode=display">nums</script> to find the <script type="math/tex; mode=display">nums[k]</script>. During this process, we also push and pop the elements on the <script type="math/tex; mode=display">stack</script>. But, we can note that atmost <script type="math/tex; mode=display">n</script> elements can be pushed and popped off the <script type="math/tex; mode=display">stack</script> in total. Thus, the second traversal requires only <script type="math/tex; mode=display">O(n)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The <script type="math/tex; mode=display">stack</script> can grow upto a maximum depth of <script type="math/tex; mode=display">n</script>. Furhter, <script type="math/tex; mode=display">min</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-using-binary-search-accepted">Approach #5 Using Binary Search [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we\'ve made use of a separate <script type="math/tex; mode=display">stack</script> to push and pop the <script type="math/tex; mode=display">nums[k]</script>\'s. But, we can also note that when we reach the index <script type="math/tex; mode=display">j</script> while scanning backwards for finding <script type="math/tex; mode=display">nums[k]</script>, the <script type="math/tex; mode=display">stack</script> can contain atmost <script type="math/tex; mode=display">n-j-1</script> elements. Here, <script type="math/tex; mode=display">n</script> refers to the number of elements in <script type="math/tex; mode=display">nums</script> array. </p>\n<p>We can also note that this is the same number of elements which lie beyond the <script type="math/tex; mode=display">j^{th}</script> index in <script type="math/tex; mode=display">nums</script> array. We also know that these elements lying beyond the <script type="math/tex; mode=display">j^{th}</script> index won\'t be needed in the future ever again. Thus, we can make use of this space in <script type="math/tex; mode=display">nums</script> array instead of using a separate <script type="math/tex; mode=display">stack</script>. The rest of the process can be carried on in the same manner as discussed in the last approach.</p>\n<p>We can try to go for another optimization here. Since, we\'ve got an array for storing the potential <script type="math/tex; mode=display">nums[k]</script> values now, we need not do the popping process for a <script type="math/tex; mode=display">min[j]</script> to find an element just larger than <script type="math/tex; mode=display">min[j]</script> from amongst these potential values. </p>\n<p>Instead, we can make use of Binary Search to directly find an element, which is just larger than <script type="math/tex; mode=display">min[j]</script> in the required interval, if it exists. If such an element is found, we can compare it with <script type="math/tex; mode=display">nums[j]</script> to check the 132 criteria. Otherwise, we continue the process as in the last approach.</p>\n<iframe frameborder="0" height="411" name="RBDptaN7" src="https://leetcode.com/playground/RBDptaN7/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script>. Filling <script type="math/tex; mode=display">min</script> array requires <script type="math/tex; mode=display">O(n)</script> time. The second traversal is done over the whole <script type="math/tex; mode=display">nums</script> array of length <script type="math/tex; mode=display">n</script>. For every current <script type="math/tex; mode=display">nums[j]</script> we need to do the Binary Search, which requires <script type="math/tex; mode=display">O\\big(log(n)\\big)</script>. In the worst case, this Binary Search will be done for all the <script type="math/tex; mode=display">n</script> elements, and the required element won\'t be found in any case, leading to a complexity of <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">min</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-6-using-array-as-a-stackaccepted">Approach #6 Using Array as a stack[Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we\'ve seen that in the worst case, the required element won\'t be found for all the <script type="math/tex; mode=display">n</script> elements and thus Binary Search is done at every step increasing the time complexity. </p>\n<p>To remove this problem, we can follow the same steps as in Approach 4 i.e. We can remove those elements(update the index <script type="math/tex; mode=display">k</script>) which aren\'t greater than <script type="math/tex; mode=display">nums[i]</script>(<script type="math/tex; mode=display">min[j]</script>). Thus, in case no element is larger than <script type="math/tex; mode=display">min[j]</script> the index <script type="math/tex; mode=display">k</script> reaches the last element. </p>\n<p>Now, at every step, only <script type="math/tex; mode=display">nums[j]</script> will be added and removed from consideration in the next step, improving the time complexity in the worst case. The rest of the method remains the same as in Approach 4.</p>\n<p>This approach is inspired by <a href="https://leetcode.com/fun4leetcode/">@fun4leetcode</a></p>\n<iframe frameborder="0" height="411" name="oPrsY93V" src="https://leetcode.com/playground/oPrsY93V/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We travesre over the <script type="math/tex; mode=display">nums</script> array of size <script type="math/tex; mode=display">n</script> once to fill the <script type="math/tex; mode=display">min</script> array. After this, we traverse over <script type="math/tex; mode=display">nums</script> to find the <script type="math/tex; mode=display">nums[k]</script>. Atmost <script type="math/tex; mode=display">n</script> elements can be put in and out of the <script type="math/tex; mode=display">nums</script> array in total. Thus, the second traversal requires only <script type="math/tex; mode=display">O(n)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">min</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '457',
    name: 'Circular Array Loop',
    acceptance: '20.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nYou are given an array of positive and negative integers. If a number n at an index is positive, then move forward n steps. Conversely, if it\'s negative (-n), move backward n steps. Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. Determine if there is a loop in this array. A loop starts and ends at a particular index with more than 1 element along the loop. The loop must be "forward" or "backward\'.\n</p>\n\n<p><b>Example 1:</b>\n\nGiven the array [2, -1, 1, 2, 2], there is a loop, from index 0 -&gt; 2 -&gt; 3 -&gt; 0.\n</p>\n\n<p><b>Example 2:</b>\n\nGiven the array [-1, 2], there is no loop.\n</p>\n\n<p><b>Note:</b>\n\nThe given array is guaranteed to contain no element "0".\n</p>\n\n<p>\nCan you do it in <b>O(n)</b> time complexity and <b>O(1)</b> space complexity?\n</p>\n\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '458',
    name: 'Poor Pigs',
    acceptance: '41.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nThere are 1000 buckets, one and only one of them contains poison, the rest are filled with water. They all look the same. If a pig drinks that poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour. \n</p>\n<p>\nAnswer this question, and write an algorithm for the follow-up general case.\n</p>\n<p>\n<b>\nFollow-up:\n</b>\n</p>\n<p>\nIf there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the "poison" bucket within p minutes? There is exact one bucket with poison.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '459',
    name: 'Repeated Substring Pattern',
    acceptance: '38.2%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.  You may assume the given string consists of lowercase English letters only and its length  will not exceed 10000. \n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "abab"\n\n<b>Output:</b> True\n\n<b>Explanation:</b> It\'s the substring "ab" twice.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> "aba"\n\n<b>Output:</b> False\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> "abcabcabcabc"\n\n<b>Output:</b> True\n\n<b>Explanation:</b> It\'s the substring "abc" four times. (And the substring "abcabc" twice.)\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Amazon'],
  },
  {
    id: '460',
    name: 'LFU Cache',
    acceptance: '24.6%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Least_frequently_used" target="_blank">Least Frequently Used (LFU)</a> cache. It should support the following operations: <code>get</code> and <code>put</code>.\n</p>\n\n<p>\n<code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>\n<code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least <b>recently</b> used key would be evicted.\n</p>\n\n<p><b>Follow up:</b><br>\nCould you do both operations in <b>O(1)</b> time complexity?</p>\n\n<p><b>Example:</b>\n</p><pre>LFUCache cache = new LFUCache( 2 /* capacity */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // returns 1\ncache.put(3, 3);    // evicts key 2\ncache.get(2);       // returns -1 (not found)\ncache.get(3);       // returns 3.\ncache.put(4, 4);    // evicts key 1.\ncache.get(1);       // returns -1 (not found)\ncache.get(3);       // returns 3\ncache.get(4);       // returns 4\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Amazon'],
  },
  {
    id: '461',
    name: 'Hamming Distance',
    acceptance: '69.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>The <a href="https://en.wikipedia.org/wiki/Hamming_distance" target="_blank">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p>\n\n<p>Given two integers <code>x</code> and <code>y</code>, calculate the Hamming distance.</p>\n\n<p><b>Note:</b><br>\n0 ≤ <code>x</code>, <code>y</code> &lt; 2<sup>31</sup>.\n</p>\n\n<p><b>Example:</b>\n</p><pre><b>Input:</b> x = 1, y = 4\n\n<b>Output:</b> 2\n\n<b>Explanation:</b>\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\n\nThe above arrows point to positions where the corresponding bits are different.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Facebook'],
  },
  {
    id: '462',
    name: 'Minimum Moves to Equal Array Elements II',
    acceptance: '51.9%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p></p><p>Given a <b>non-empty</b> integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.</p>\n\n<p>You may assume the array's length is at most 10,000.</p>\n\n<p><b>Example:</b>\n</p><pre><b>Input:</b>\n[1,2,3]\n\n<b>Output:</b>\n2\n\n<b>Explanation:</b>\nOnly two moves are needed (remember each move increments or decrements one element):\n\n[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]\n</pre>\n<p></p><p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-forceaccepted">Approach #2 Better Brute Force[Accepted]</a></li>\n<li><a href="#approach-3-using-sorting-accepted">Approach #3 Using Sorting [Accepted]</a></li>\n<li><a href="#approach-4-using-median-and-sorting-accepted">Approach #4 Using Median and Sorting [Accepted]</a></li>\n<li><a href="#approach-5-without-finding-median-accepted">Approach #5 Without finding Median [Accepted]</a></li>\n<li><a href="#approach-6-using-quick-select-accepted">Approach #6 Using quick-select [Accepted]</a></li>\n<li><a href="#approach-7-using-median-of-medians-accepted">Approach #7 Using Median of Medians [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>In the brute force approach, we consider every possible number to which all the array elements should be equated so as to minimize the number of moves required. One point is obvious that the number to which all the elements are equated at the end should lie between the minimum and the maximum elements present in the array. Thus, we first find the minimum and the maximum element in the array. Suppose <script type="math/tex; mode=display">k</script> is the number to which all the elements are equated. Then, we iterate <script type="math/tex; mode=display">k</script> over the range between the minimum and maximum values and find the number of moves required for each <script type="math/tex; mode=display">k</script>, simultaneously finding the minimum moves, which will be the end result.</p>\n<iframe frameborder="0" height="377" name="zoXHVMT9" src="https://leetcode.com/playground/zoXHVMT9/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n*diff)</script>, where <script type="math/tex; mode=display">n</script> is the length of the array and <script type="math/tex; mode=display">diff</script> is the difference between maximum element and minimum element.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space required.</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-forceaccepted">Approach #2 Better Brute Force[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, rather than choosing every possible <script type="math/tex; mode=display">k</script> between the minimum and the maximum values in the array,\nwe can simply consider <script type="math/tex; mode=display">k</script> as every element of the array. To understand why we need not iterate over all the complete range but only the elements of the array, consider the\nfollowing example.</p>\n<p>Say the array is:</p>\n<p>\n<script type="math/tex; mode=display">mums = [x_1 x_2 x_3 x_4 x_5 x_6 x_7]</script>. Now, if we try to equalize all the elements to <script type="math/tex; mode=display">x_4</script>, which by the way, may or may not be the final number required to be settled down to.</p>\n<p>The total number of moves for doing this is given by: <script type="math/tex; mode=display">moves_1 = (x_4 - x_1) + (x_4 - x_2) + (x_4 - x_3) + (x_5 - x_4) + (x_6 - x_4) + (x_7 - x_4)</script>\n</p>\n<p>Suppose, now, instead of <script type="math/tex; mode=display">x_4</script>, we try to equalize all the elements to a number <script type="math/tex; mode=display">x\'</script>, which is not present in the given array, but is slightly larger than <script type="math/tex; mode=display">x_4</script> and is thus given by\n say <script type="math/tex; mode=display">x\' =  x_4 + \\delta x</script>, where <script type="math/tex; mode=display">\\delta x</script> is an integer. Thus, the total number of moves required now will be given by:</p>\n<p>\n<script type="math/tex; mode=display">moves_2 = (x\' - x_1) + (x\' - x_2) + (x\' - x_3) + (x\' - x_4) + (x_5 - x\') + (x_6 - x\') + (x_7 - x\')</script>\n</p>\n<p>\n<script type="math/tex; mode=display">moves_2 = ((x_4 + \\delta x) - x_1) + ((x_4 + \\delta x) - x_2) + ((x_4 + \\delta x) - x_3) + ((x_4 + \\delta x) - x_4) + (x_5 - (x_4 + \\delta x)) + (x_6 - (x_4 + \\delta x)) + (x_7 - (x_4 + \\delta x))</script>\n</p>\n<p>\n<script type="math/tex; mode=display">moves_2 = (x_4 - x_1) + \\delta x + (x_4 - x_2) + \\delta x + (x_4 - x_3) + \\delta x + 0 + \\delta x + (x_5 - x_4) - \\delta x + (x_6 - x_4) - \\delta x + (x_7 - x_4) - \\delta x</script>\n</p>\n<p>\n<script type="math/tex; mode=display">moves_2 = (x_4 - x_1) + (x_4 - x_2) + (x_4 - x_3) + (x_5 - x_4) + (x_6 - x_4) + (x_7 - x_4) + 4\\delta x - 3\\delta x</script>\n</p>\n<p>\n<script type="math/tex; mode=display">moves_2 = moves_1 + \\delta x</script>      ...using <script type="math/tex; mode=display">moves_1</script> from above</p>\n<p>From this equation, it is clear that the number of moves required to settle to some arbitrary number present in the array <script type="math/tex; mode=display">x_4</script> is always lesser than the number of moves\n  required to settle down to some arbitrary number <script type="math/tex; mode=display">x\' = x_4 + \\delta x</script>. This completes the proof.</p>\n<iframe frameborder="0" height="292" name="5gKgkRs6" src="https://leetcode.com/playground/5gKgkRs6/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Two nested loops are there.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space required.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-sorting-accepted">Approach #3 Using Sorting [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the previous approach, we needed to find the number of moves required for every <script type="math/tex; mode=display">k</script> chosen from the array, by iterating over the whole array. We can optimize this approach to sum extent by sorting the array and observing the following fact. The number of moves required to raise the elements smaller than <script type="math/tex; mode=display">k</script> to equalize them to <script type="math/tex; mode=display">k</script> will be given by: <script type="math/tex; mode=display">(k*countBefore_k) - (sumBefore_k)</script>(The meanings of the keywords are given below) .\n Similarly, the number of moves required to decrement the elements larger than <script type="math/tex; mode=display">k</script> to equalize them to <script type="math/tex; mode=display">k</script> will be: <script type="math/tex; mode=display">(sumAfter_k) - (k*countAfter_k)</script>.\nThe total number of moves required will, thus, be the sum of these two parts.\nHence, for a particular <script type="math/tex; mode=display">k</script> chosen, the total number of moves required will be given by:</p>\n<p>\n<script type="math/tex; mode=display">numberOfMoves_k = [(k*countBefore_k) - (sumBefore_k)] + [(sumAfter_k) - (k*countAfter_k)]</script>\n</p>\n<p>where, <script type="math/tex; mode=display">k</script> = The number to which all the elements are equalized at the end.</p>\n<p>\n<script type="math/tex; mode=display">countBefore_k</script> = The number of elements which are lesser than <script type="math/tex; mode=display">k</script>.</p>\n<p>\n<script type="math/tex; mode=display">sumBefore_k</script> =  The sum of elements which are lesser than <script type="math/tex; mode=display">k</script>.</p>\n<p>\n<script type="math/tex; mode=display">countAfter_k</script> = The number of elements which are larger than <script type="math/tex; mode=display">k</script>.</p>\n<p>\n<script type="math/tex; mode=display">sumAfter_k</script> =  The sum of elements which are larger than <script type="math/tex; mode=display">k</script>.</p>\n<p>\n<script type="math/tex; mode=display">numberOfMoves_k</script> = The total number of moves required to equalize all the elements of the array to <script type="math/tex; mode=display">k</script>.</p>\n<p>Let\'s say that the index of the element corresponding to the element <script type="math/tex; mode=display">k</script> be given by <script type="math/tex; mode=display">index_k</script>. Instead of iterating over the array for calculating <script type="math/tex; mode=display">sumBefore_k</script> and\n<script type="math/tex; mode=display">sumAfter_k</script>, we can keep on calculating them while traversing the array since the array is sorted. We calculate the total sum of the given array <script type="math/tex; mode=display">nums</script> once, given\nby <script type="math/tex; mode=display">total</script>. We start by choosing <script type="math/tex; mode=display">sumBefore_k=0</script> and <script type="math/tex; mode=display">sumAfter_k</script> as <script type="math/tex; mode=display">total</script>.\nTo calculate <script type="math/tex; mode=display">sumBefore_k</script>, we just add the element <script type="math/tex; mode=display">nums[index_k - 1]</script> to the previous <script type="math/tex; mode=display">sumBefore_k</script>.\nTo calculate <script type="math/tex; mode=display">sumAfter_k</script>, we subtract the element <script type="math/tex; mode=display">k</script> from the previous <script type="math/tex; mode=display">sumAfter_k</script>.</p>\n<iframe frameborder="0" height="343" name="8RLhocE9" src="https://leetcode.com/playground/8RLhocE9/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script>. Sorting will take <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space required.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-median-and-sorting-accepted">Approach #4 Using Median and Sorting [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The problem of finding the number <script type="math/tex; mode=display">k</script> to which all the other numbers eventually settle can also be viewed as: Given a set of points in 1-d.\n Find a point <script type="math/tex; mode=display">k</script> such that the cumulative sum of distances between <script type="math/tex; mode=display">k</script> and the rest of the points is minimum. This is a very common mathematical problem whose answer is known.\n  The point <script type="math/tex; mode=display">k</script> is the median of the given points. The reason behind choosing the median is given after the algorithm.</p>\n<p>We can simply sort the given points and find the <script type="math/tex; mode=display">median</script> as the element in the middle of the array. Thus, the total number of moves required to equalize all the array elements is given by\n  the sum of differences of all the elements from the <script type="math/tex; mode=display">median</script>. In mathematical terms, the solution is given by:</p>\n<p>\n<script type="math/tex; mode=display">moves = \\sum_{i=0}^{n-1} |median - nums[i]|</script> , where <script type="math/tex; mode=display">n</script> is the size of the given array.</p>\n<!--![Median_Partition](https://leetcode.com/articles/Figures/462_Minimum_Moves_Median.gif)-->\n<p>!?!../Documents/462_Minimum_Moves1.json:1000,563!?!</p>\n<p>Now, we\'ll look at the mathematical reasoning behind choosing the median as the number <script type="math/tex; mode=display">k</script> to which we\'ll settle. As discussed in the previous approach, the total number of moves\nrequired is given by:</p>\n<p>\n<script type="math/tex; mode=display">numberOfMoves_k = [(k*countBefore_k) - (sumBefore_k)] + [(sumAfter_k) - (k*countAfter_k)]</script>, where all the variables have the same definition.</p>\n<p>Now, as we know, in order to maximize this term w.r.t. the changes in <script type="math/tex; mode=display">k</script>, we can take the derivative of the above term w.r.t. <script type="math/tex; mode=display">k</script>. Thus, we proceed as:</p>\n<p>\n<script type="math/tex; mode=display">\\frac{d(numberOfMoves_k)}{dk} = \\frac{[(k*countBefore_k) - (sumBefore_k)] + [(sumAfter_k) - (k*countAfter_k)]}{dk}</script>\n</p>\n<p>\n<script type="math/tex; mode=display">\\frac{d(numberOfMoves_k)}{dk} = \\frac{(k*countBefore_k)}{dk} - \\frac{d(sumBefore_k)}{dk} + \\frac{d(sumAfter_k)}{dk} - \\frac{(k*countAfter_k)}{dk}</script>\n</p>\n<p>\n<script type="math/tex; mode=display">\\frac{d(numberOfMoves_k)}{dk} = countBefore_k - countAfter_k</script>\n</p>\n<p>Setting derivative <script type="math/tex; mode=display">\\frac{d(numberOfMoves_k)}{dk}</script> equal to <script type="math/tex; mode=display">0</script>, we get:</p>\n<p>\n<script type="math/tex; mode=display">countBefore_k - countAfter_k = 0</script> or <script type="math/tex; mode=display">countBefore_k = countAfter_k</script>. This property is satisfied by the median only, which completes the proof.</p>\n<iframe frameborder="0" height="241" name="87ETNbXm" src="https://leetcode.com/playground/87ETNbXm/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script>. Sorting will take <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Only single extra variable is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-without-finding-median-accepted">Approach #5 Without finding Median [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the previous approach, we went for finding the median after sorting and then calculated the number of moves required. But, if we observe properly, we\'ll find that if the array is sorted, we can\ndo the same task without actually finding the median or the number <script type="math/tex; mode=display">k</script> to which we need to settle at the end. To proceed with this, let\'s look at the maximum(<script type="math/tex; mode=display">max</script>) and the minimum\nnumbers(<script type="math/tex; mode=display">min</script>) in the array, which currently lie at its extreme positions. We know, at the end, both these numbers should be equalized to <script type="math/tex; mode=display">k</script>. For the number <script type="math/tex; mode=display">max</script>, the number of moves\nrequired to do this is given by <script type="math/tex; mode=display">max - k</script>. Similarly, for the number <script type="math/tex; mode=display">min</script>, the number of moves is given by <script type="math/tex; mode=display">k - min</script>. Thus, the total number of moves for both <script type="math/tex; mode=display">max</script> and <script type="math/tex; mode=display">min</script> is given by\n<script type="math/tex; mode=display">max - k + (k - min) = max - min</script>, which is independent of the number <script type="math/tex; mode=display">k</script>. Thus, we can continue now, with the next maximum and the next minimum number in the array, until the complete array is exhausted.</p>\n<p>Therefore, the equation becomes:</p>\n<p>\n<script type="math/tex; mode=display">moves = \\sum_{i=0}^{\\left \\lceil{\\frac{n}{2}} \\right \\rceil - 1} |nums[n-i] - nums[i]|</script>, where <script type="math/tex; mode=display">n</script> is the number of elements in the array <script type="math/tex; mode=display">nums</script>.</p>\n<iframe frameborder="0" height="258" name="BjSKEzdE" src="https://leetcode.com/playground/BjSKEzdE/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script>. Sorting will take <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space required.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-6-using-quick-select-accepted">Approach #6 Using quick-select [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In order to find the median, we need not necessarily sort the given array. But we can find the median directly using the Quick-Select method to find the median, which\ndoesn\'t use sorting.</p>\n<p>The quick-select method is similar to the Quick-Sort method. In a single iteration, we choose a pivot and somehow bring it to its correct position in the array.\nIf the correct position happens to be the central position(corresponding to the median), we can return the median directly from there. Now, let\'s look at the implementation of quick-select.</p>\n<p>Quick-Select makes use of two functions <script type="math/tex; mode=display">partition</script> and <script type="math/tex; mode=display">select</script>. <script type="math/tex; mode=display">select</script> function takes the leftmost and the rightmost indices of the given array and the central index as well. If the element reaching the\n correct position in the current function call to <script type="math/tex; mode=display">select</script> function happens to be the median(i.e. it reaches the central position), we return the element(since it is the median).\n The function <script type="math/tex; mode=display">partition</script> takes the leftmost and the rightmost indices of the array and returns the correct position of the current pivot(which is chosen as the rightmost element of the array).\n This function makes use of two pointers <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script>. Both the pointers initially point to the leftmost element of the array.</p>\n<p>At every step, we compare the element at the\n <script type="math/tex; mode=display">j^{th}</script> index(<script type="math/tex; mode=display">list[j]</script>) with the pivot element(<script type="math/tex; mode=display">pivot</script>). If <script type="math/tex; mode=display">list[j]<pivot</script>, we swap the elements <script type="math/tex; mode=display">list[i]</script> and <script type="math/tex; mode=display">list[j]</script> and increment <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script>. Otherwise,\n only <script type="math/tex; mode=display">j</script> is incremented. When <script type="math/tex; mode=display">j</script> reaches the end of the array, we swap the <script type="math/tex; mode=display">pivot</script> with <script type="math/tex; mode=display">list[i]</script>. In this way, now, all the elements lesser than <script type="math/tex; mode=display">pivot</script> lie to the\n left of the <script type="math/tex; mode=display">i^{th}</script> index, and all the elements larger than <script type="math/tex; mode=display">pivot</script> lie to the right of the <script type="math/tex; mode=display">i^{th}</script> index and thus, the <script type="math/tex; mode=display">pivot</script> reaches at its correct position in the array.\n If this position isn\'t the central index of the array, we again make use of the <script type="math/tex; mode=display">select</script> functions passing the left and the right subarrays relative to the <script type="math/tex; mode=display">i^{th}</script> index.</p>\n<p>For more clarification, look at the animation below for this example:\n <code>[3 8 2 5 1 4 7 6]</code></p>\n<p><!--<img alt="Median_Partition" src="https://leetcode.com/articles/Figures/462_Minimum_Moves_Partition.gif" />-->\n !?!../Documents/462_Minimum_Moves2.json:1000,563!?!</p>\n<p>After finding the median, we can find the sum of absolute differences of all the elements from the median to determine the number of moves required. Mathematically, we use:</p>\n<p>\n<script type="math/tex; mode=display">moves = \\sum_{i=0}^{n-1} |median - list[i]|</script> , where <script type="math/tex; mode=display">n</script> is the size of the given array.</p>\n<iframe frameborder="0" height="515" name="BaPB5Gde" src="https://leetcode.com/playground/BaPB5Gde/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity :\nAverage Case: <script type="math/tex; mode=display">O(n)</script>. Quick-Select average case time complexity is <script type="math/tex; mode=display">O(n)</script>.\nWorst Case: <script type="math/tex; mode=display">O(n^2)</script>. In worst case quick-select can go upto <script type="math/tex; mode=display">n^2</script>\n</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space required.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-7-using-median-of-medians-accepted">Approach #7 Using Median of Medians [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>It isn\'t hard to see that, in quick-select, if we naively choose the pivot element, this\nalgorithm has a worst case performance of <script type="math/tex; mode=display">O(n^2)</script>. To guarantee the linear running\ntime in order to find the median, however we need a strategy for choosing the pivot element that\nguarantees that we partition the list into two sublists of\nrelatively comparable size. Obviously the median of the values\nin the list would be the optimal choice, but if we could find the\n median in linear time, we would already have a solution to our problem.</p>\n<p>The median-of-medians algorithm chooses its pivot in the following clever way:</p>\n<p>\n<script type="math/tex; mode=display">kthSmallest(arr[0..n-1], k)</script>\n</p>\n<ol>\n<li>\n<p>Divide <script type="math/tex; mode=display">arr[]</script> into <script type="math/tex; mode=display">\\left \\lceil{\\frac{n}{5}}\\right\\rceil</script> groups where size of each group is 5 elements,\n   except possibly the last group which may have less than 5 elements.  </p>\n</li>\n<li>\n<p>Sort the above created <script type="math/tex; mode=display">\\left \\lceil{\\frac{n}{5}}\\right\\rceil</script> groups and find median\n   of all groups. Create an auxiliary array <script type="math/tex; mode=display">median[]</script> and store medians\n   of all <script type="math/tex; mode=display">\\left \\lceil{\\frac{n}{5}}\\right\\rceil</script> groups in this median array.\n   Also, recursively call this method to find median of median[0...<script type="math/tex; mode=display">(\\left \\lceil{\\frac{n}{5}}\\right\\rceil - 1)</script>]</p>\n</li>\n<li>\n<p>\n<script type="math/tex; mode=display">medOfMed</script> = <script type="math/tex; mode=display">kthSmallest\\big(median[0...(\\left \\lceil{\\frac{n}{5}}\\right\\rceil - 1)], \\left \\lceil{\\frac{n}{10}}\\right\\rceil\\big)</script>\n</p>\n</li>\n<li>\n<p>Partition <script type="math/tex; mode=display">arr[]</script> around <script type="math/tex; mode=display">medOfMed</script> and obtain its position(i.e. use <script type="math/tex; mode=display">medOfMedians</script> as the pivot element).\n     <script type="math/tex; mode=display">pos = partition(arr, n, medOfMed)</script>\n</p>\n</li>\n<li>\n<p>If <script type="math/tex; mode=display">pos == k</script> return <script type="math/tex; mode=display">medOfMed</script>\n</p>\n</li>\n<li>If <script type="math/tex; mode=display">pos < k</script> return <script type="math/tex; mode=display">kthSmallest(arr[l..pos-1], k)</script>\n</li>\n<li>If <script type="math/tex; mode=display">pos > k</script> return <script type="math/tex; mode=display">kthSmallest(arr[pos+1..r], k-pos+l-1)</script>\n</li>\n</ol>\n<p>Using the above method ensures that the chosen pivot, in the worst case, has atmost 70% elements which are larger/smaller than the pivot.\n The proof of the same as well as the reason behind choosing the group size of 5 is given\nin the explanation of time complexity.</p>\n<iframe frameborder="0" height="515" name="nJGDyFut" src="https://leetcode.com/playground/nJGDyFut/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Worst case time complexity is <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space required.</p>\n</li>\n</ul>\n<p><strong>Proof: Time Complexity <script type="math/tex; mode=display">O(n)</script></strong>:</p>\n<p>The worst case time complexity of the above algorithm is <script type="math/tex; mode=display">O(n)</script>. Let us analyze all steps.</p>\n<p>The steps 1. and 2. take <script type="math/tex; mode=display">O(n)</script> time as finding median of an array of size 5 takes O(1) time and there are <script type="math/tex; mode=display">\\left \\lceil{\\frac{n}{5}}\\right\\rceil</script> such arrays.\nThe step 3. takes <script type="math/tex; mode=display">T(n/5)</script> time(if the whole algorithm takes <script type="math/tex; mode=display">T(n)</script> time). The step 4. is standard partition and takes <script type="math/tex; mode=display">O(n)</script> time.\nThe interesting steps are 6. and 7. At most, one of them is executed. These are recursive steps. What is the worst case size of these recursive calls?\nThe answer is maximum number of elements greater than medOfMed (obtained in step 3) or maximum number of elements smaller than <script type="math/tex; mode=display">medOfMed</script>.</p>\n<p>How many elements are greater than <script type="math/tex; mode=display">medOfMed</script> and how many are smaller?</p>\n<p>Let\'s assume that the list of medians obtained from step 2. in the sorted order be\n <script type="math/tex; mode=display">m_1, m_2, m_3,....,m_{x-1}, m_x, m_{x+1} ...m_{n-2}, m_{n-1}, m_n</script>, where <script type="math/tex; mode=display">m_x</script> is the median chosen as the pivot. To find an upper bound on the number of elements in\n the given array smaller than our pivot, first consider the half of the medians from step 2(<script type="math/tex; mode=display">m_1, m_2, ..., m_{x-1}</script>) which are smaller than\n the pivot. It is possible for all five of the elements in the sublists corresponding to these medians to be smaller than the pivot(<script type="math/tex; mode=display">m_x</script>, which leads to an upper\n bound of <script type="math/tex; mode=display">\\left \\lceil{\\frac{n}{5}}\\right\\rceil*5*\\frac{1}{2}</script> such elements. Now consider the half of the medians from step 2 which are larger than the pivot\n (<script type="math/tex; mode=display">m_{x+1}, ..., m_{n-1}, m_n</script>). It is only possible for two of the\n elements(which are smaller than the respective medians) in the sublists corresponding to these medians to be smaller than the pivot(<script type="math/tex; mode=display">m_x</script>), which leads to an upper bound of\n <script type="math/tex; mode=display">\\left \\lceil{\\frac{n}{5}}\\right\\rceil*2*\\frac{1}{2} = \\left \\lceil{\\frac{n}{5}}\\right\\rceil</script> such elements. In addition, the sublist containing the pivot(<script type="math/tex; mode=display">m_x</script>) contributes\n exactly two elements smaller than the pivot. It total, we may have at most:</p>\n<p>\n<script type="math/tex; mode=display">\\frac{5}{2}\\left \\lceil{\\frac{n}{5}}\\right\\rceil + \\left \\lceil{\\frac{n}{5}}\\right\\rceil + 2 = \\frac{7}{2}\\left \\lceil{\\frac{n}{5}}\\right\\rceil + 2 \\leq \\frac{7n}{10} + 6</script>\n</p>\n<p>elements smaller than the pivot, or approximately 70% of the list. The same upper bound applies the the number of elements in the list larger than the pivot. It is this\n guarantee that the partitions cannot be too lopsided that leads to linear run time.</p>\n<p>Thus, the minimum number of elements which are smaller or larger than the chosen pivot(<script type="math/tex; mode=display">medOfMed</script>) is given by <script type="math/tex; mode=display">n - (\\frac{7n}{10} + 6) = \\frac{3n}{10} - 6</script> or nearly\n30% of the elements.</p>\n<p>In the worst case, the function recurs for at most <script type="math/tex; mode=display">\\frac{7n}{10} + 6</script> times.</p>\n<p>Note that <script type="math/tex; mode=display">\\frac{7n}{10} + 6 < n</script> for <script type="math/tex; mode=display">n > 20</script> and that any input of 80 or fewer elements requires <script type="math/tex; mode=display">O(1)</script> time. We can therefore obtain the recurrence:</p>\n<p>$$T(n)  &lt;= <script type="math/tex; mode=display">\\begin{cases} \\Theta(1), & n\\leq80 \\\\ T\\left \\lceil\\frac{n}{5}\\right\\rceil + T(\\frac{7n}{10} + 6) + O(n), & n>80 \\end{cases}</script>\n</p>\n<p>We show that the running time is linear by substitution. Assume that <script type="math/tex; mode=display">T(n) = cn </script>for some constant <script type="math/tex; mode=display">c</script> and all <script type="math/tex; mode=display">n > 80</script>. Substituting this inductive hypothesis into the right-hand side of the recurrence yields</p>\n<p>\n<script type="math/tex; mode=display">T(n) \\leq \\frac{cn}{5} + c(\\frac{7n}{10} + 6) + O(n)</script>\n<script type="math/tex; mode=display">\\leq \\frac{cn}{5} + c + \\frac{7cn}{10} + 6c + O(n)</script>\n<script type="math/tex; mode=display">\\leq \\frac{9cn}{10} + 7c + O(n)</script>\n<script type="math/tex; mode=display">\\leq cn</script>\nsince we can pick c large enough so that <script type="math/tex; mode=display">c(\\frac{n}{10} - 7)</script> is larger than the function described by the <script type="math/tex; mode=display">O(n)</script> term for all <script type="math/tex; mode=display">n > 80</script>. The worst-case running time of is therefore linear.</p>\n<p>Choosing the group size of 3 leads to at least half of the n/3 blocks having at least 2 elements <script type="math/tex; mode=display">\\geq medOfMed</script>, hence this gives a n/3 split, or 2n/3 in the worst case.</p>\n<p>This gives <script type="math/tex; mode=display">T(n)</script> = <script type="math/tex; mode=display">T(\\frac{n}{3}) + T(\\frac{2n}{3}) + O(n)</script>, which reduces to <script type="math/tex; mode=display">O(nlogn)</script> in the worst case.</p>\n<p>There is no reason why you should not use something greater than five; for example with seven the inequality would be</p>\n<p>\n<script type="math/tex; mode=display">T(n) \\leq T(\\frac{n}{7})+T(\\frac{5n}{7})+O(n)</script>\n</p>\n<p>\n<script type="math/tex; mode=display">T(n) \\leq T(\\frac{n}{7})+T(\\frac{5n}{7})+O(n)</script>\n</p>\n<p>which also works, but five is the smallest odd number (useful for medians) which works.</p>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '463',
    name: 'Island Perimeter',
    acceptance: '57.5%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn\'t have "lakes" (water inside that isn\'t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don\'t exceed 100. Determine the perimeter of the island.</p>\n\n<p><b>Example:</b>\n</p><pre>[[0,1,0,0],\n [1,1,1,0],\n [0,1,0,0],\n [1,1,0,0]]\n\nAnswer: 16\nExplanation: The perimeter is the 16 yellow stripes in the image below:\n<img src="https://leetcode.com/static/images/problemset/island.png">\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '464',
    name: 'Can I Win',
    acceptance: '25.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>In the "100 game," two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins. </p>\n\n<p>What if we change the game so that players cannot re-use integers? </p>\n\n<p>For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total &gt;= 100.</p>\n\n<p>Given an integer <code>maxChoosableInteger</code> and another integer <code>desiredTotal</code>, determine if the first player to move can force a win, assuming both players play optimally. </p>\n\n<p>You can always assume that <code>maxChoosableInteger</code> will not be larger than 20 and <code>desiredTotal</code> will not be larger than 300.\n</p>\n\n<p><b>Example</b>\n</p><pre><b>Input:</b>\nmaxChoosableInteger = 10\ndesiredTotal = 11\n\n<b>Output:</b>\nfalse\n\n<b>Explanation:</b>\nNo matter which integer the first player choose, the first player will lose.\nThe first player can choose an integer from 1 up to 10.\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\nThe second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.\nSame with other integers chosen by the first player, the second player will always win.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '465',
    name: 'Optimal Account Balancing ',
    acceptance: '38.3%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>A group of friends went on holiday and sometimes lent each other money. For example, Alice paid for Bill's lunch for $10. Then later Chris gave Alice $5 for a taxi ride. We can model each transaction as a tuple (x, y, z) which means person x gave person y $z. Assuming Alice, Bill, and Chris are person 0, 1, and 2 respectively (0, 1, 2 are the person's ID), the transactions can be represented as <code>[[0, 1, 10], [2, 0, 5]]</code>.</p>\n\n<p>Given a list of transactions between a group of people, return the minimum number of transactions required to settle the debt.</p>\n\n<p><b>Note:</b>\n</p><ol>\n<li>A transaction will be given as a tuple (x, y, z). Note that <code>x ≠ y</code> and <code>z &gt; 0</code>.</li>\n<li>Person's IDs may not be linear, e.g. we could have the persons 0, 1, 2 or we could also have the persons 0, 2, 6.</li>\n</ol>\n<p></p>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b>\n[[0,1,10], [2,0,5]]\n\n<b>Output:</b>\n2\n\n<b>Explanation:</b>\nPerson #0 gave person #1 $10.\nPerson #2 gave person #0 $5.\n\nTwo transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b>\n[[0,1,10], [1,0,1], [1,2,5], [2,0,5]]\n\n<b>Output:</b>\n1\n\n<b>Explanation:</b>\nPerson #0 gave person #1 $10.\nPerson #1 gave person #0 $1.\nPerson #1 gave person #2 $5.\nPerson #2 gave person #0 $5.\n\nTherefore, person #1 only need to give person #0 $4, and all debt is settled.\n</pre>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '466',
    name: 'Count The Repetitions',
    acceptance: '27.6%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Define <code>S = [s,n]</code> as the string S which consists of n connected strings s. For example, <code>["abc", 3]</code> ="abcabcabc". </p>\n<p>On the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, “abc”  can be obtained from “abdbec” based on our definition, but it can not be obtained from “acbbe”.</p>\n<p>You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 ≤ n1 ≤ 10<sup>6</sup> and 1 ≤ n2 ≤ 10<sup>6</sup>. Now consider the strings S1 and S2, where <code>S1=[s1,n1]</code> and <code>S2=[s2,n2]</code>. Find the maximum integer M such that <code>[S2,M]</code> can be obtained from <code>S1</code>.</p>\n\n<p><b>Example:</b>\n</p><pre>Input:\ns1="acb", n1=4\ns2="ab", n2=2\n\nReturn:\n2\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-a-better-brute-force-accepted">Approach #2 A better brute force [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute force [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>According to the question, we need to find <script type="math/tex; mode=display">m</script> such that <script type="math/tex; mode=display">[S2,m]</script> is the largest subsequence that can be found in <script type="math/tex; mode=display">S1</script>. <script type="math/tex; mode=display">S2</script> is essentially <script type="math/tex; mode=display">[s2,n2]</script> and <script type="math/tex; mode=display">S1</script> is <script type="math/tex; mode=display">[s1,n1]</script> and so, we can find the number of times <script type="math/tex; mode=display">s2</script> repeats in <script type="math/tex; mode=display">[s1,n1]</script>, say <script type="math/tex; mode=display">\\text{repeat_count}</script>. And the number of times <script type="math/tex; mode=display">S2</script> repeats in <script type="math/tex; mode=display">S1</script> is therefore <script type="math/tex; mode=display">\\text{(repeat_count/n2)}</script>. Simple.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>Initialize <script type="math/tex; mode=display">\\text{index=0}</script> and <script type="math/tex; mode=display">\\text{repeat_count=0}</script>. <script type="math/tex; mode=display">\\text{index}</script> represents the current index in <script type="math/tex; mode=display">s2</script> to be checked against <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">\\text{repeat_count}</script> represents the number of times <script type="math/tex; mode=display">s2</script> repeats in <script type="math/tex; mode=display">S1</script>.</li>\n<li>Iterate over the variable <script type="math/tex; mode=display">i</script> from <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">n1-1</script>:<ul>\n<li>Iterate over the variable <script type="math/tex; mode=display">j</script> from <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">\\text{size(s1)}-1</script>:  <ul>\n<li>If <script type="math/tex; mode=display">\\text{s1[j] }</script> is equal to <script type="math/tex; mode=display">\\text{s2[index]}</script>, increment <script type="math/tex; mode=display">\\text{index}</script>.</li>\n<li>If <script type="math/tex; mode=display">index</script> is equal to <script type="math/tex; mode=display">size(s2)</script>, this implies that <script type="math/tex; mode=display">s2</script> has completed one repartition and hence set <script type="math/tex; mode=display">\\text{index=0}</script> and increment the <script type="math/tex; mode=display">\\text{repeat_count}</script>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Return <script type="math/tex; mode=display">\\text{(repeat_count / n2)}</script> since, <script type="math/tex; mode=display">S2</script> is <script type="math/tex; mode=display">\\text{[s2,n2]}</script>.</li>\n</ul>\n<iframe frameborder="0" height="326" name="y5jtZgJj" src="https://leetcode.com/playground/y5jtZgJj/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O(n1*size(s1))</script>.</p>\n<ul>\n<li>We iterate over the entire length of string <script type="math/tex; mode=display">s1</script> for <script type="math/tex; mode=display">n1</script> times.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(1)</script> extra space for <script type="math/tex; mode=display">\\text{index}</script> and <script type="math/tex; mode=display">\\text{repeat_count}</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-a-better-brute-force-accepted">Approach #2 A better brute force [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>In Approach #1, we simply checked for repetition over the entire <script type="math/tex; mode=display">[s1,n1]</script>. However, <script type="math/tex; mode=display">n1</script> could be quiet large and thus, is inefficient to iterate over complete <script type="math/tex; mode=display">S1</script>. We can take advantage of the fact that <script type="math/tex; mode=display">s1</script> is repeating and hence, we could find a pattern of repetition of <script type="math/tex; mode=display">s2</script> in <script type="math/tex; mode=display">S1</script>. Once, we get the repetition pattern, we can easy calculate how many times the pattern repeats in <script type="math/tex; mode=display">n2</script> in <script type="math/tex; mode=display">O(1)</script>.</p>\n<p><em>But what\'s the pattern!</em></p>\n<p>In approach #1, we kept <script type="math/tex; mode=display">\\text{index}</script> which tells the index to search in <script type="math/tex; mode=display">s2</script>. We try to see in the below illustration if this <script type="math/tex; mode=display">\\text{index}</script> repeats itself after some fixed iterations of <script type="math/tex; mode=display">s1</script> or not and if so, then how can we leverage it.</p>\n<p align="center"><img alt="Count the repitition" src="https://leetcode.com/articles/Figures/466/count_the_repititions.png" width="700px"></p>\n<p>After finding the repitition pattern, we can calculate the sum of repeating pattern, part before repitition and part left after repitition as the result in <script type="math/tex; mode=display">O(1)</script>.   </p>\n<p><em>But will this repitition always take place?</em></p>\n<p>Yes! By <strong>Pigeonhole principle</strong>, which states that if <script type="math/tex; mode=display">n</script> items are put into <script type="math/tex; mode=display">m</script> containers, with <script type="math/tex; mode=display">n > m</script>, then at least one container must contain more than one item. So, according to this, we are sure to find 2 same <script type="math/tex; mode=display">index</script> after scanning at max <script type="math/tex; mode=display">\\text{size(s2)}</script> blocks of <script type="math/tex; mode=display">s1</script>.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>Intialize <script type="math/tex; mode=display">count=0</script> nd <script type="math/tex; mode=display">index=0</script>, which are same as in Approach #1.</li>\n<li>Initialize 2 arrays, say <script type="math/tex; mode=display">\\text{indexr}</script> and <script type="math/tex; mode=display">\\text{countr}</script> of size <script type="math/tex; mode=display">(\\text{size(s2)}+1)</script>, initialized with 0. The size <script type="math/tex; mode=display">(\\text{size(s2)}+1)</script> is based on the Pigeonhole principle as discussed above. The 2 arrays specifies the <script type="math/tex; mode=display">\\text{index}</script> and <script type="math/tex; mode=display">\\text{count}</script> at the start of each <script type="math/tex; mode=display">s1</script> block.</li>\n<li>Iterate over <script type="math/tex; mode=display">i</script> from <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">n1-1</script>:<ul>\n<li>Iterate over <script type="math/tex; mode=display">j</script> from <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">\\text{size(s1)}-1</script>:<ul>\n<li>If <script type="math/tex; mode=display">\\text{s1[j]} == \\text{s2[index]}</script>, increment <script type="math/tex; mode=display">\\text{index}</script>.</li>\n<li>If <script type="math/tex; mode=display">\\text{index}</script> is equal to <script type="math/tex; mode=display">\\text{size(s2)}</script>, set <script type="math/tex; mode=display">\\text{index} = 0</script> and increment <script type="math/tex; mode=display">\\text{count}</script>.</li>\n</ul>\n</li>\n<li>Set <script type="math/tex; mode=display">\\text{countr[i]}=\\text{count}</script> and <script type="math/tex; mode=display">\\text{indexr[i]}=\\text{index}</script>\n</li>\n<li>\n<p>Iterate over <script type="math/tex; mode=display">k</script> from <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">i-1</script>:</p>\n<ul>\n<li>If we find the repitition, i.e. current <script type="math/tex; mode=display">\\text{index} = \\text{indexr[k]}</script>, we calculate the count for block before the repitition starts, the repeating block and the block left after repitition pattern, which can be calculated as:</li>\n</ul>\n<p>\n<script type="math/tex; mode=display">\n\\begin{align}\n\\text{prev_count} &= \\text{countr}[k] \\\\\n\\text{pattern_count} &= (\\text{countr}[i] - \\text{countr}[k]) * \\frac{n1 - 1 - k}{i - k} \\\\\n\\text{remain_count} &= \\text{countr}\\left[k + \\left(n1 - 1 - k\\right) \\% \\left(i - k \\right)\\right] - \\text{countr}[k]\n\\end{align}\n</script>\n</p>\n<ul>\n<li>Sum the 3 counts and return the sum divided by <script type="math/tex; mode=display">n2</script>, since <script type="math/tex; mode=display">\\text{S2 = [s2,n2]}</script>\n</li>\n<li>If no repetition is found, return <script type="math/tex; mode=display">\\text{countr[n1-1]/n2}</script>.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<iframe frameborder="0" height="515" name="2UJEXG8V" src="https://leetcode.com/playground/2UJEXG8V/shared" width="100%"></iframe>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">\\text{O(size(s1)*size(s2))}</script>.</p>\n<ul>\n<li>According to the Pigeonhole principle, we need to iterate over <script type="math/tex; mode=display">s1</script> only <script type="math/tex; mode=display">(\\text{size(s2)+1})</script> times at max.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(\\text{size(s2)})</script> extra space for <script type="math/tex; mode=display">\\text{indexr}</script> and <script type="math/tex; mode=display">\\text{countr}</script> string.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by <a href="https://leetcode.com/abhinavbansal0">@abhinavbansal0</a>.</p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '467',
    name: 'Unique Substrings in Wraparound String',
    acceptance: '33.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Consider the string <code>s</code> to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so <code>s</code> will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....".</p>\n\n<p>Now we have another string <code>p</code>. Your job is to find out how many unique non-empty substrings of <code>p</code> are present in <code>s</code>. In particular, your input is the string <code>p</code> and you need to output the number of different non-empty substrings of <code>p</code> in the string <code>s</code>.</p>\n\n<p><b>Note:</b> <code>p</code> consists of only lowercase English letters and the size of p might be over 10000.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "a"\n<b>Output:</b> 1\n\n<b>Explanation:</b> Only the substring "a" of string "a" is in the string \u0010s.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> "cac"\n<b>Output:</b> 2\n<b>Explanation:</b> There are two substrings "a", "c" of string "cac" in the string s.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> "zab"\n<b>Output:</b> 6\n<b>Explanation:</b> There are six substrings "z", "a", "b", "za", "ab", "zab" of string "zab" in the string s.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['MAQ Software'],
  },
  {
    id: '468',
    name: 'Validate IP Address',
    acceptance: '20.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nWrite a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.\n</p>\n\n<p>\n<b>IPv4</b> addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots ("."), e.g.,<code>172.16.254.1</code>;\n</p>\n\n<p>\nBesides, leading zeros in the IPv4 is invalid. For example, the address <code>172.16.254.01</code> is invalid.\n</p>\n\n<p>\n<b>IPv6</b> addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (":"). For example, the address <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code> is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so <code>2001:db8:85a3:0:0:8A2E:0370:7334</code> is also a valid IPv6 address(Omit leading zeros and using upper cases).\n</p>\n\n\n<p>\nHowever, we don\'t replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, <code>2001:0db8:85a3::8A2E:0370:7334</code> is an invalid IPv6 address.\n</p>\n\n<p>\nBesides, extra leading zeros in the IPv6 is also invalid. For example, the address <code>02001:0db8:85a3:0000:0000:8a2e:0370:7334</code> is invalid.\n</p>\n\n\n<p><b>Note:</b>\nYou may assume there is no extra space or special characters in the input string.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "172.16.254.1"\n\n<b>Output:</b> "IPv4"\n\n<b>Explanation:</b> This is a valid IPv4 address, return "IPv4".\n</pre>\n<p></p>\n\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> "2001:0db8:85a3:0:0:8A2E:0370:7334"\n\n<b>Output:</b> "IPv6"\n\n<b>Explanation:</b> This is a valid IPv6 address, return "IPv6".\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> "256.256.256.256"\n\n<b>Output:</b> "Neither"\n\n<b>Explanation:</b> This is neither a IPv4 address nor a IPv6 address.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Twitter'],
  },
  {
    id: '469',
    name: 'Convex Polygon ',
    acceptance: '33.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a list of points that form a polygon when joined sequentially, find if this polygon is convex <a href="https://en.wikipedia.org/wiki/Convex_polygon" target="_blank">(Convex polygon definition)</a>.</p>\n\n<p><b>Note:</b>\n</p><ol>\n<li>There are at least 3 and at most 10,000 points.</li>\n<li>Coordinates are in the range -10,000 to 10,000.</li>\n<li>You may assume the polygon formed by given points is always a simple polygon<a href="https://en.wikipedia.org/wiki/Simple_polygon" target="_blank"> (Simple polygon definition)</a>. In other words, we ensure that exactly two edges intersect at each vertex, and that edges otherwise <b>don\'t intersect each other</b>. \n</li>\n</ol>\n<p></p>\n\n<p><b>Example 1:</b>\n</p><pre>[[0,0],[0,1],[1,1],[1,0]]\n\nAnswer: True\n\nExplanation:<img src="https://leetcode.com/static/images/problemset/polygon_convex.png" width="100" height="100">\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre>[[0,0],[0,10],[10,10],[10,0],[5,5]]\n\nAnswer: False\n\nExplanation:<img src="https://leetcode.com/static/images/problemset/polygon_not_convex.png" width="100" height="100">\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '471',
    name: 'Encode String with Shortest Length ',
    acceptance: '42.9%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given a <b>non-empty</b> string, encode the string such that its encoded length is the shortest.</p>\n\n<p>\nThe encoding rule is: <code>k[encoded_string]</code>, where the <i>encoded_string</i> inside the square brackets is being repeated exactly <i>k</i> times.</p>\n\n\n<p><b>Note:</b><br>\n</p><ol>\n<li><i>k</i> will be a positive integer and encoded string will not be empty or have extra space.</li>\n<li>You may assume that the input string contains only lowercase English letters. The string\'s length is at most 160.</li>\n<li>If an encoding process does not make the string shorter, then do not encode it. If there are several solutions, return any of them is fine.</li>\n</ol>\n<p></p>\n\n<p><b>Example 1:</b>\n</p><pre>Input: "aaa"\nOutput: "aaa"\nExplanation: There is no way to encode it such that it is shorter than the input string, so we do not encode it.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre>Input: "aaaaa"\nOutput: "5[a]"\nExplanation: "5[a]" is shorter than "aaaaa" by 1 character.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b>\n</p><pre>Input: "aaaaaaaaaa"\nOutput: "10[a]"\nExplanation: "a9[a]" or "9[a]a" are also valid solutions, both of them have the same length = 5, which is the same as "10[a]".\n</pre>\n<p></p>\n\n<p><b>Example 4:</b>\n</p><pre>Input: "aabcaabcd"\nOutput: "2[aabc]d"\nExplanation: "aabc" occurs twice, so one answer can be "2[aabc]d".\n</pre>\n<p></p>\n\n<p><b>Example 5:</b>\n</p><pre>Input: "abbbabbbcabbbabbbc"\nOutput: "2[2[abbb]c]"\nExplanation: "abbbabbbc" occurs twice, but "abbbabbbc" can also be encoded to "2[abbb]c", so one answer can be "2[2[abbb]c]".\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '472',
    name: 'Concatenated Words',
    acceptance: '30.5%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            Given a list of words (<b>without duplicates</b>), please write a program that returns all concatenated words in the given list of words.\n<p>A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.</p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]\n\n<b>Output:</b> ["catsdogcats","dogcatsdog","ratcatdogcat"]\n\n<b>Explanation:</b> "catsdogcats" can be concatenated by "cats", "dog" and "cats"; <br> "dogcatsdog" can be concatenated by "dog", "cats" and "dog"; <br>"ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The number of elements of the given array will not exceed <code>10,000 </code>\n</li><li>The length sum of elements in the given array will not exceed <code>600,000</code>. </li>\n<li>All the input string will only include lower case letters.</li>\n<li>The returned elements order does not matter. </li>\n</ol>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '473',
    name: 'Matchsticks to Square',
    acceptance: '35.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used <b>exactly</b> one time.</p>\n\n<p> Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,1,2,2,2]\n<b>Output:</b> true\n\n<b>Explanation:</b> You can form a square with length 2, one side of the square came two sticks with length 1.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [3,3,3,3,4]\n<b>Output:</b> false\n\n<b>Explanation:</b> You cannot find a way to form a square with all the matchsticks.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The length sum of the given matchsticks is in the range of <code>0</code> to <code>10^9</code>.\n</li><li>The length of the given matchstick array will not exceed <code>15</code>.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Rackspace'],
  },
  {
    id: '474',
    name: 'Ones and Zeroes',
    acceptance: '39.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.</p>\n<p>For now, suppose you are a dominator of <b>m</b> <code>0s</code> and <b>n</b> <code>1s</code> respectively. On the other hand, there is an array with strings consisting of only <code>0s</code> and <code>1s</code>.</p>\n\n<p>\nNow your task is to find the maximum number of strings that you can form with given <b>m</b> <code>0s</code> and <b>n</b> <code>1s</code>. Each <code>0</code> and <code>1</code> can be used at most <b>once</b>.\n</p>\n\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The given numbers of <code>0s</code> and <code>1s</code> will both not exceed <code>100</code></li>\n<li>The size of given string array won\'t exceed <code>600</code>.</li>\n</ol>\n<p></p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3\n<b>Output:</b> 4\n\n<b>Explanation:</b> This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> Array = {"10", "0", "1"}, m = 1, n = 1\n<b>Output:</b> 2\n\n<b>Explanation:</b> You could form "10", but then you\'d have nothing left. Better form "0" and "1".\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-using-recursion-time-limit-exceeded">Approach #3 Using Recursion [Time Limit Exceeded]</a></li>\n<li><a href="#approach-4-using-memoization-accepted">Approach #4 Using Memoization [Accepted]</a></li>\n<li><a href="#approach-5-dynamic-programming-accepted">Approach #5 Dynamic Programming [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>In the brute force approach we will consider every subset of <script type="math/tex; mode=display">strs</script> array and count the total number of zeroes and ones in that subset. The subset with zeroes less than equal to <script type="math/tex; mode=display">m</script> and ones less than equal to <script type="math/tex; mode=display">n</script> will be considered as the valid subsets. The maximum length subset among all valid subsets will be  our required subset.</p>\n<p>Obviously, there are <script type="math/tex; mode=display">2^n</script> subsets possible for the list of length <script type="math/tex; mode=display">n</script> and here we are using int(32 bits) for iterating every subset. So this method will not work for the list having length greater than 32.</p>\n<iframe frameborder="0" height="515" name="PB4G7F5Z" src="https://leetcode.com/playground/PB4G7F5Z/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(2^l*x)</script>. <script type="math/tex; mode=display">2^l</script> possible subsets, where <script type="math/tex; mode=display">l</script> is the length of the list <script type="math/tex; mode=display">strs</script> and <script type="math/tex; mode=display">x</script> is the average string length.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant Space required.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the previous approach we were considering every possible subset and then we were counting its zeroes and ones. We can limit the number of subsets by breaking the loop when total number of zeroes exceed <script type="math/tex; mode=display">m</script> or total number of ones exceed <script type="math/tex; mode=display">n</script>. This will reduce little computation not the complexity.</p>\n<iframe frameborder="0" height="515" name="XyDP2sRL" src="https://leetcode.com/playground/XyDP2sRL/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(2^l*x)</script>. <script type="math/tex; mode=display">2^l</script> possible subsets, where <script type="math/tex; mode=display">l</script> is the length of the list <script type="math/tex; mode=display">strs</script> and <script type="math/tex; mode=display">x</script> is the average string length.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant Space required.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-recursion-time-limit-exceeded">Approach #3 Using Recursion [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the above approaches we were considering every subset iteratively. The subset formation can also be done in a recursive manner. For this, we make use of a function <code>calculate(strs, i, ones, zeroes)</code>. This function takes the given list of strings <script type="math/tex; mode=display">strs</script> and gives the size of the largest subset with <script type="math/tex; mode=display">ones</script> 1\'s and <script type="math/tex; mode=display">zeroes</script>  0\'s considering the strings lying after the <script type="math/tex; mode=display">i^{th}</script> index(including itself) in <script type="math/tex; mode=display">strs</script>.</p>\n<p>Now, in every function call of <code>calculate(...)</code>, we can:</p>\n<ol>\n<li>\n<p>Include the current string in the subset currently being considered. But if we include the current string, we\'ll need to deduct the number of 0\'s and 1\'s in the current string from the total available respective counts. Thus, we make a function call of the form <script type="math/tex; mode=display">calculate(strs,i+1,zeroes-zeroes_{current\\_string},ones-ones_{current\\_string})</script>. We also need to increment the total number of strings considered so far by 1. We store the result obtained from this call(including the +1) in <script type="math/tex; mode=display">taken</script> variable.</p>\n</li>\n<li>\n<p>Not include the current string in the current subset. In this case, we need not update the count of <script type="math/tex; mode=display">ones</script> and <script type="math/tex; mode=display">zeroes</script>. Thus, the new function call takes the form <script type="math/tex; mode=display">calculate(strs,i+1,zeroes,ones)</script>. The result obtained from this function call is stored in <script type="math/tex; mode=display">notTaken</script> variable.</p>\n</li>\n</ol>\n<p>The larger value out of <script type="math/tex; mode=display">taken</script> and <script type="math/tex; mode=display">notTaken</script> represents the required result to be returned for the current function call.</p>\n<p>Thus, the function call <script type="math/tex; mode=display">calculate(strs, 0, m, n)</script> gives us the required maximum number of subsets possible satisfying the given constraints.</p>\n<iframe frameborder="0" height="428" name="SjPQE6wg" src="https://leetcode.com/playground/SjPQE6wg/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong>\n* Time complexity : <script type="math/tex; mode=display">O(2^l*x)</script>. <script type="math/tex; mode=display">2^l</script> possible subsets, where <script type="math/tex; mode=display">l</script> is the length of the list <script type="math/tex; mode=display">strs</script> and <script type="math/tex; mode=display">x</script> is the average string length.</p>\n<ul>\n<li>Space complexity : <script type="math/tex; mode=display">O(l)</script>. Depth of recursion tree grows upto <script type="math/tex; mode=display">l</script>.</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-memoization-accepted">Approach #4 Using Memoization [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the recursive approach just discussed, a lot of redundant function calls will be made taking the same values of <script type="math/tex; mode=display">(i, zeroes, ones)</script>. This redundancy in the recursive tree can be pruned off by making use of a 3-D memoization array, <script type="math/tex; mode=display">memo</script>.</p>\n<p>\n<script type="math/tex; mode=display">memo[i][j][k]</script> is used to store the result obtained for the function call <code>calculate(strs, i, j, k)</code>. Or in other words, it stores the maximum number of subsets possible considering the strings starting from the <script type="math/tex; mode=display">i^{th}</script> index onwards, provided only <script type="math/tex; mode=display">j</script> 0\'s and <script type="math/tex; mode=display">k</script> 1\'s are available to be used.</p>\n<p>Thus, whenever <script type="math/tex; mode=display">memo[i][j][k]</script> already contains a valid entry, we need not make use of the function calls again, but we can pick up the result directly from the <script type="math/tex; mode=display">memo</script> array.</p>\n<p>The rest of the procedure remains the same as that of the recursive approach.</p>\n<iframe frameborder="0" height="515" name="oVimjcfS" src="https://leetcode.com/playground/oVimjcfS/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(l*m*n)</script>. <script type="math/tex; mode=display">memo</script> array of size <script type="math/tex; mode=display">l*m*n</script> is filled, where <script type="math/tex; mode=display">l</script> is the length of <script type="math/tex; mode=display">strs</script>, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> are the number of zeroes and ones respectively.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(l*m*n)</script>. 3D array <script type="math/tex; mode=display">memo</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-dynamic-programming-accepted">Approach #5 Dynamic Programming [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This problem can be solved by using 2-D Dynamic Programming. We can make use of a <script type="math/tex; mode=display">dp</script> array, such that an entry <script type="math/tex; mode=display">dp[i][j]</script> denotes the maximum number of strings that can be included in the subset given only <script type="math/tex; mode=display">i</script> 0\'s and <script type="math/tex; mode=display">j</script> 1\'s are available.</p>\n<p>Now, let\'s look at the process by which we\'ll fill the <script type="math/tex; mode=display">dp</script> array. We traverse the given list of strings one by one. Suppose, at some point, we pick up any string <script type="math/tex; mode=display">s_k</script> consisting of <script type="math/tex; mode=display">x</script> zeroes and <script type="math/tex; mode=display">y</script> ones. Now, choosing to put this string in any of the subset possible by using the previous strings traversed so far will impact the element denoted by <script type="math/tex; mode=display">dp[i][j]</script> for <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> satisfying <script type="math/tex; mode=display">x &leq; i &leq; m</script>, <script type="math/tex; mode=display">y &leq; j &leq; n</script>. This is because for entries <script type="math/tex; mode=display">dp[i][j]</script> with <script type="math/tex; mode=display">i < x</script> or <script type="math/tex; mode=display">j < y</script>, there won\'t be sufficient number of 1\'s and 0\'s available to accomodate the current string in any subset.</p>\n<p>Thus, for every string encountered, we need to appropriately update the <script type="math/tex; mode=display">dp</script> entries within the correct range.</p>\n<p>Further, while updating the <script type="math/tex; mode=display">dp</script> values, if we consider choosing the current string to be a part of the subset, the updated result will depend on whether it is profitable to include the current string in any subset or not. If included in the subset, the <script type="math/tex; mode=display">dp[i][j]</script> entry needs to be updated as <script type="math/tex; mode=display">dp[i][j]=1 + dp[i - zeroes_{current\\_string}][j - ones_{current\\_string}]</script>, where the factor of +1 takes into account the number of elements in the current subset being increased due to a new entry.</p>\n<p>But, it could be possible that the current string could be so long that it could be profitable not to include it in any of the subsets. Thus, the correct equation for <script type="math/tex; mode=display">dp</script> updation becomes:</p>\n<p>\n<script type="math/tex; mode=display">dp[i][j]= max(1+dp[i - zeroes_{current\\_string}][j - ones_{current\\_string}],dp[i][j])</script>\n</p>\n<p>Thus, after the complete list of strings has been traversed, <script type="math/tex; mode=display">dp[m][n]</script> gives the required size of the largest subset.</p>\n<p>Watch this animation for clear understanding:</p>\n<p>!?!../Documents/474_Ones_Zeroes.json:1000,563!?!</p>\n<iframe frameborder="0" height="411" name="uSvKvaat" src="https://leetcode.com/playground/uSvKvaat/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(l*m*n)</script>. Three nested loops are their, where <script type="math/tex; mode=display">l</script> is the length of <script type="math/tex; mode=display">strs</script>, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> are the number of zeroes and ones respectively.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m*n)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">m*n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '475',
    name: 'Heaters',
    acceptance: '29.6%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.</p>\n\n<p>Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.</p>\n\n<p>So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>Numbers of houses and heaters you are given are non-negative and will not exceed 25000.</li>\n<li>Positions of houses and heaters you are given are non-negative and will not exceed 10^9.</li>\n<li>As long as a house is in the heaters' warm radius range, it can be warmed.</li>\n<li>All the heaters follow your radius standard and the warm radius will the same.</li>\n</ol>\n<p></p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,2,3],[2]\n<b>Output:</b> 1\n<b>Explanation:</b> The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [1,2,3,4],[1,4]\n<b>Output:</b> 1\n<b>Explanation:</b> The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.\n</pre>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '476',
    name: 'Number Complement',
    acceptance: '61.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The given integer is guaranteed to fit within the range of a 32-bit signed integer.</li>\n<li>You could assume no leading zero bit in the integer’s binary representation.</li>\n</ol>\n<p></p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> 5\n<b>Output:</b> 2\n<b>Explanation:</b> The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> 1\n<b>Output:</b> 0\n<b>Explanation:</b> The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\n</pre>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Cloudera'],
  },
  {
    id: '477',
    name: 'Total Hamming Distance',
    acceptance: '47.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>The <a href="https://en.wikipedia.org/wiki/Hamming_distance" target="_blank">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p>\n\n<p>Now your job is to find the total Hamming distance between all pairs of the given numbers.\n\n\n</p><p><b>Example:</b><br>\n</p><pre><b>Input:</b> 4, 14, 2\n\n<b>Output:</b> 6\n\n<b>Explanation:</b> In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\nshowing the four bits relevant in this case). So the answer will be:\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>Elements of the given array are in the range of <code>0 </code> to <code>10^9</code>\n</li><li>Length of the array will not exceed <code>10^4</code>. </li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-loop-over-the-bits-accepted">Approach #2 Loop over the bits! [Accepted]</a></li>\n<li><a href="#bonus">Bonus!</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<ol>\n<li>Check all the unique pairs of elements for differing bits.</li>\n<li><code>xor</code> of two bits is <code>1</code> if they are not the same, and <code>0</code> otherwise.</li>\n</ol>\n<p><strong>Algorithm</strong></p>\n<p>Bitwise <code>xor</code> of two numbers will give a bitwise representation of where the bits of two numbers differ. Such bit positions are represented by a <code>1</code> bit in the resultant. For example:</p>\n<div class="codehilite"><pre><span></span>    0010 1101   ==  45\n  ^ 0100 1010   ==  74\n----------------\n    0110 0111\n     ^^   ^^^   =&gt; 5 differing bits\n</pre></div>\n<p>Hence the numbers <script type="math/tex; mode=display">45</script> and <script type="math/tex; mode=display">74</script> have five differing bits. Thus the Hamming Distance between them is <script type="math/tex; mode=display">5</script>.</p>\n<p>For each of the <script type="math/tex; mode=display">\\approx n^2/2</script> pairs of elements, simply apply bitwise <code>xor</code> to them to find out a resultant representation which tells us the differing bits. Count the <code>1</code> bits to find the Hamming Distance for that pair of elements. Sum over all pairs to get the total Hamming Distance.</p>\n<iframe frameborder="0" height="275" name="HpH92ApX" src="https://leetcode.com/playground/HpH92ApX/shared" width="100%"></iframe>\n<p><strong>NOTE:</strong> The <code>__builtin_popcount()</code> method is an internal built-in function available in <strong>C</strong> (and hence by extension <strong>C++</strong>) which gives the count of <code>1</code> bits for an <code>int</code> type argument. Being a low level built-in method, it is understandably faster than running a hand rolled loop.\nAs an alternative, you can iterate over all the bits of the number and count the <code>1</code> bits. Take a look at the code for <a href="#approach-2-loop-over-the-bits-accepted">Approach #2</a> for hints on how to achieve that.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O(n^2 \\cdot log_2V) \\simeq O(n^2)</script>.</p>\n<ul>\n<li>There are exactly <script type="math/tex; mode=display">\\binom{n}{2} = {}^nC_2 = \\frac{n \\cdot (n-1)}{2}</script> unique pairs of elements for an <script type="math/tex; mode=display">n</script> element array.</li>\n<li>Each of these pairs, when <code>xor</code>ed, result in a resultant number which is <script type="math/tex; mode=display">\\lceil log_2V \\rceil</script> bits long. Here <script type="math/tex; mode=display">V</script> is the largest value any of the elements can ever take.</li>\n<li>We iterate over these many bits to count the number of <code>1</code> bits.  In our case, since all elements are <script type="math/tex; mode=display">\\leq 10^9</script>, the value <script type="math/tex; mode=display">\\lceil log_2V \\rceil = 30</script> is a small constant. Hence counting the <code>1</code> bits takes place in nearly constant (i.e. <script type="math/tex; mode=display">O(1)</script>) time.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(1)</script> constant space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-loop-over-the-bits-accepted">Approach #2 Loop over the bits! [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Looping over all possible combinations of two element pairs, increases quadratically over the size of the input. If we could instead loop over the bits of the elements (which is constant), we could shave off an input dimension from our runtime complexity.</p>\n<p><strong>Algorithm</strong></p>\n<p>Say for any particular bit position, count the number of elements with this bit <strong>ON</strong> (i.e. this particular bit is <code>1</code>). Let this count be <script type="math/tex; mode=display">k</script>. Hence the number of elements with this bit <strong>OFF</strong> (i.e. <code>0</code>) is <script type="math/tex; mode=display">(n - k)</script> (in an <script type="math/tex; mode=display">n</script> element array).</p>\n<p>Certainly unique pairs of elements exists where one element has this particular bit <strong>ON</strong> while the other element has this <strong>OFF</strong> (i.e. this particular bit differs for the two elements of this pair).</p>\n<blockquote>\n<p>We can argue that every such pair contributes one unit to the Hamming Distance for this particular bit.</p>\n</blockquote>\n<p>We know that the count of such unique pairs is <script type="math/tex; mode=display">{}^kC_1 * {}^{n-k}C_1 = k \\cdot (n-k)</script> for this particular bit. Hence Hamming Distance for this particular bit is <script type="math/tex; mode=display">k \\cdot (n-k)</script>.</p>\n<p>For each of the <script type="math/tex; mode=display">\\lceil log_2V \\rceil</script> bits that we can check, we can calculate a Hamming Distance pertaining to that bit. Taking sum over the Hamming Distances of all these bits, we get the total Hamming Distance.</p>\n<iframe frameborder="0" height="445" name="EoYRygcG" src="https://leetcode.com/playground/EoYRygcG/shared" width="100%"></iframe>\n<p><strong>NOTE:</strong> You <em>can switch the order of the loops</em> while counting <code>1</code> bits without affecting complexity. However it might give some performance changes due to locality of reference and the resultant cache hits/misses.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O(n \\cdot log_2V) \\simeq O(n)</script>. Runtime performance is limited by the double loop where we are counting elements for particular bits. In our case, since all elements are <script type="math/tex; mode=display">\\leq 10^9</script>, the value <script type="math/tex; mode=display">\\lceil log_2V \\rceil = 30</script> is a small constant. Thus the inner loop runs in nearly constant time.</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(log_2V) \\to O(1)</script> extra space.</p>\n<ul>\n<li>For each of the <script type="math/tex; mode=display">\\lceil log_2V \\rceil</script> bits, we need to maintain a count which is later used to calculate the Hamming Distance for that bit. Since <script type="math/tex; mode=display">\\lceil log_2V \\rceil \\approx 32</script> is a small constant in our case, that takes nearly constant extra space.</li>\n<li>Another thing to notice, is that if we <strong>switch the order of the double loop,</strong> we can do away with storing the count and calculate the Hamming Distance for that bit then and there. That results in only constant extra space being used.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id="bonus">Bonus!</h4>\n<p>This question is a perfect example of how vectorized operations can result in small, elegant and good performance code. Take a look at this slick <strong>Python</strong> solution to this problem (by <a href="https://leetcode.com/StefanPochmann/">@StefanPochmann</a>):</p>\n<iframe frameborder="0" height="88" name="uskMAwMG" src="https://leetcode.com/playground/uskMAwMG/shared" width="100%"></iframe>\n<p>The <code>*</code> operator turns the list of <code>32</code>-bit wide binary strings returned by <code>map</code> into individual arguments to the <code>zip</code> method. The <code>zip</code> method vectorizes the string arguments to create a list of vectors (each of which is a vector <code>b</code> of particular bits from every element in the input array; There are <code>32</code> such vectors of size <code>len(nums)</code> each, in this list ). Finally we use the same technique as <a href="#approach-2-loop-over-the-bits-accepted">Approach #2</a> to calculate the total Hamming Distance.</p>\n<hr>\n<p>Analysis written by <a href="https://leetcode.com/babhishek21">@babhishek21</a>.</p>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '479',
    name: 'Largest Palindrome Product',
    acceptance: '24.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Find the largest palindrome made from the product of two n-digit numbers.</p>\n<p> Since the result could be very large, you should return the largest palindrome mod 1337.</p>\n\n<p><b>Example:</b>\n</p><p>Input: 2</p>\n<p>Output: 987</p>\n<p>Explanation: 99 x 91 = 9009, 9009 % 1337 = 987\n</p>\n<p></p>\n\n\n<p><b>Note:</b>\n</p><p>The range of n is [1,8].</p>\n<p></p>\n\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Yahoo'],
  },
  {
    id: '480',
    name: 'Sliding Window Median',
    acceptance: '30.9%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>\nExamples: <br>\n<p><code>[2,3,4]</code> , the median is <code>3</code></p>\n<p><code>[2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code> </p>\n\n<p>Given an array <i>nums</i>, there is a sliding window of size <i>k</i> which is moving from the very left of the array to the very right. You can only see the <i>k</i> numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.</p>\n\n<p>For example,<br>\nGiven <i>nums</i> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <i>k</i> = 3.</p>\n\n<pre>Window position                Median\n---------------               -----\n[1  3  -1] -3  5  3  6  7       1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7       3\n 1  3  -1  -3 [5  3  6] 7       5\n 1  3  -1  -3  5 [3  6  7]      6\n</pre>\n\n<p>Therefore, return the median sliding window as <code>[1,-1,-1,3,5,6]</code>.</p>\n\n<p><b>Note: </b><br>\nYou may assume <code>k</code> is always valid, ie: <code>k</code> is always smaller than input array's size for non-empty array.</p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#a-word-of-advice">A word of advice</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-simple-sorting-time-limit-exceeded-barely-accepted">Approach #1 Simple Sorting [Time Limit Exceeded / Barely Accepted]</a></li>\n<li><a href="#approach-2-two-heaps-lazy-removal-accepted">Approach #2 Two Heaps! (Lazy Removal) [Accepted]</a></li>\n<li><a href="#approach-3-two-multisets-accepted">Approach #3 Two Multisets! [Accepted]</a></li>\n<li><a href="#approach-4-multiset-and-two-pointers-accepted">Approach #4 Multiset and Two Pointers [Accepted]</a></li>\n<li><a href="#further-thoughts">Further Thoughts</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h3 id="a-word-of-advice">A word of advice</h3>\n<p>This problem is a companion problem to <a href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median From Data Stream</a>. This means that a lot of approaches to solve this problem are based on the <a href="https://leetcode.com/articles/find-median-from-data-stream">methods to solve 295. Find Median From Data Stream</a>. Perhaps try that problem before you approach this one.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-simple-sorting-time-limit-exceeded-barely-accepted">Approach #1 Simple Sorting [Time Limit Exceeded / Barely Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Do what the question says.</p>\n<p><strong>Algorithm</strong></p>\n<p>Store the numbers in a window container of size <script type="math/tex; mode=display">k</script>. The following operations must take place:</p>\n<ol>\n<li><strong>Inserting</strong> the incoming element.</li>\n<li><strong>Deleting</strong> the outgoing element.</li>\n<li><strong>Sorting</strong> the window to find the medians.</li>\n</ol>\n<p>One primitive approach is to copy <script type="math/tex; mode=display">k</script> consecutive elements from the input to the window and keep sorting these every time. This constitutes duplication of effort.</p>\n<p>We can do a bit better if we instead <em>insert</em> and <em>delete</em> one element per window shift. The challenge then is to maintain the window as <strong>sorted</strong>, before and after the <em>insert</em> and <em>delete</em> operations.</p>\n<p><strong>C++ [Time Limit Exceeded]</strong></p>\n<iframe frameborder="0" height="343" name="Nez6uisz" src="https://leetcode.com/playground/Nez6uisz/shared" width="100%"></iframe>\n<p><strong>Python [Accepted]</strong></p>\n<p>Python comes with an excellent <code>bisect</code> module to help perform efficient insert operations on lists while maintaining their sorted property.</p>\n<iframe frameborder="0" height="394" name="rt3SZUz3" src="https://leetcode.com/playground/rt3SZUz3/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O(n \\cdot k \\cdot log(k))</script> to <script type="math/tex; mode=display">O(n \\cdot k)</script>.</p>\n<ul>\n<li>Copying elements into the container takes about <script type="math/tex; mode=display">O(k)</script> time each. This happens about <script type="math/tex; mode=display">(n-k)</script> times.</li>\n<li>\n<p>Sorting for each of the <script type="math/tex; mode=display">(n-k)</script> sliding window instances takes about <script type="math/tex; mode=display">O(k \\cdot log(k))</script> time each.</p>\n</li>\n<li>\n<p>Bisected insertion or deletion takes about <script type="math/tex; mode=display">O(log(k))</script> for searching and <script type="math/tex; mode=display">O(k)</script> for actual shifting of elements. This takes place about <script type="math/tex; mode=display">n</script> times.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(k)</script> extra linear space for the window container.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-two-heaps-lazy-removal-accepted">Approach #2 Two Heaps! (Lazy Removal) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>The idea is the same as <a href="https://leetcode.com/articles/find-median-from-data-stream#approach-3-two-heaps-accepted">Approach #3</a> from <a href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median From Data Stream</a>. The only additional requirement is removing the outgoing elements from the window.</p>\n<p>Since the window elements are stored in heaps, deleting elements that are not at the top of the heaps is a pain.</p>\n<p>Some languages (like <strong>Java</strong>) provide implementations of the <code>PriorityQueue</code> class that allow for removing <em>arbitrarily</em> placed elements. Generally, using such features is not efficient nor is their portability assured.</p>\n<p>Assuming that only the tops of heaps (and by extension the <code>PriorityQueue</code> class) are accessible, we need to find a way to efficiently invalidate and remove elements that are moving out of the sliding window.</p>\n<p>At this point, an important thing to notice is the fact that if the two heaps are balanced, only the top of the heaps are actually needed to find the medians. This means that as long as we can somehow keep the heaps balanced, we could also keep some extraneous elements.</p>\n<p>Thus, we can use hash-tables to keep track of invalidated elements. Once they reach the heap tops, we remove them from the heaps. This is the lazy removal technique.</p>\n<p>An immediate challenge at this point is balancing the heaps while keeping extraneous elements. This is done by actually moving some elements to the heap which has extraneous elements, from the other heap. This cancels out the effect of having extraneous elements and maintains the invariant that the heaps are balanced.</p>\n<p><strong>NOTE:</strong> When we talk about keeping the heaps balanced, we are <strong>not</strong> referring to the actual heap sizes. We are only concerned with valid elements and hence when we talk about balancing heaps, we are referring to count of such elements.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>Two priority queues:</p>\n<ol>\n<li>A max-heap <code>lo</code> to store the smaller half of the numbers</li>\n<li>A min-heap <code>hi</code> to store the larger half of the numbers</li>\n</ol>\n</li>\n<li>\n<p>A hash-map or hash-table <code>hash_table</code> for keeping track of invalid numbers. It holds the count of the occurrences of all such numbers that have been invalidated and yet remain in the heaps.</p>\n</li>\n<li>\n<p>The max-heap <code>lo</code> is allowed to store, at worst, one more element more than the min-heap <code>hi</code>. Hence if we have processed <script type="math/tex; mode=display">k</script> elements:</p>\n<ul>\n<li>If <script type="math/tex; mode=display">k = 2*n + 1 \\quad (\\forall \\, n \\in \\mathbb{Z})</script>, then <code>lo</code> is allowed to hold <script type="math/tex; mode=display">n+1</script> elements, while <code>hi</code> can hold <script type="math/tex; mode=display">n</script> elements.</li>\n<li>If <script type="math/tex; mode=display">k = 2*n \\quad (\\forall \\, n \\in \\mathbb{Z})</script>, then both heaps are balanced and hold <script type="math/tex; mode=display">n</script> elements each.</li>\n</ul>\n<p>This gives us the nice property that when the heaps are perfectly balanced, the median can be derived from the tops of both heaps. Otherwise, the top of the max-heap <code>lo</code> holds the legitimate median.</p>\n</li>\n</ul>\n<p><strong>NOTE:</strong> As mentioned before, when we are talking about keeping the heaps balanced, the actual sizes of the heaps are irrelevant. Only the count of valid elements in both heaps matter.</p>\n<ul>\n<li>\n<p>Keep a <code>balance</code> factor. It indicates three situations:</p>\n<ul>\n<li><code>balance</code> <script type="math/tex; mode=display">= 0</script>: Both heaps are balanced or nearly balanced.</li>\n<li><code>balance</code> <script type="math/tex; mode=display">< 0</script>: <code>lo</code> needs more valid elements. Elements from <code>hi</code> are moved to <code>lo</code>.</li>\n<li><code>balance</code> <script type="math/tex; mode=display">> 0</script>: <code>hi</code> needs more valid elements. Elements from <code>lo</code> are moved to <code>hi</code>.</li>\n</ul>\n</li>\n<li>\n<p>Inserting an incoming number <code>in_num</code>:</p>\n<ul>\n<li>\n<p>If <code>in_num</code> is less than or equal to the top element of <code>lo</code>, then it can be inserted to <code>lo</code>. However this unbalances <code>hi</code> (<code>hi</code> has lesser valid elements now). Hence <code>balance</code> is incremented.</p>\n</li>\n<li>\n<p>Otherwise, <code>in_num</code> must be added to <code>hi</code>. Obviously, now <code>lo</code> is unbalanced. Hence <code>balance</code> is decremented.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Lazy removal of an outgoing number <code>out_num</code>:</p>\n<ul>\n<li>If <code>out_num</code> is present in <code>lo</code>, then invalidating this occurrence will unbalance <code>lo</code> itself. Hence <code>balance</code> must be decremented.</li>\n<li>\n<p>If <code>out_num</code> is present in <code>hi</code>, then invalidating this occurrence will unbalance <code>hi</code> itself. Hence <code>balance</code> must be incremented.</p>\n</li>\n<li>\n<p>We increment the count of this element in the hash_table table.</p>\n</li>\n<li>Once an invalid element reaches either of the heap tops, we remove them and decrement their counts in the hash_table table.</li>\n</ul>\n</li>\n</ul>\n<iframe frameborder="0" height="515" name="nhx46JwP" src="https://leetcode.com/playground/nhx46JwP/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O(2 * n * log(k)) + O(n-k) \\approx O(n \\cdot log(k))</script>.</p>\n<ul>\n<li>Either (or sometimes both) of the heaps gets every element inserted into it at least once. Collectively each of those takes about <script type="math/tex; mode=display">O(log(k))</script> time. That is <script type="math/tex; mode=display">n</script> such insertions.</li>\n<li>About <script type="math/tex; mode=display">(n-k)</script> removals from the top of the heaps take place (the number of sliding window instances). Each of those takes about <script type="math/tex; mode=display">O(log(k))</script> time.</li>\n<li>Hash table operations are assumed to take <script type="math/tex; mode=display">O(1)</script> time each. This happens roughly the same number of times as removals from heaps take place.</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(k) + O(n) \\approx O(n)</script> extra linear space.</p>\n<ul>\n<li>The heaps collectively require <script type="math/tex; mode=display">O(k)</script> space.</li>\n<li>The hash table needs about <script type="math/tex; mode=display">O(n-k)</script> space.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-two-multisets-accepted">Approach #3 Two Multisets! [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>One can see that <code>multiset</code>s are a great way to keep elements sorted while providing efficient access to the first and last elements. Inserting and deleting arbitrary elements are also fairly efficient operations in a <code>multiset</code>. (Refer to <a href="https://leetcode.com/articles/find-median-from-data-stream#approach-4-multiset-and-two-pointers-accepted">Approach #4 Intuition</a> for <a href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median From Data Stream</a>)</p>\n<p>Thus, if the previous approach gives you too much heartburn, consider replacing the use of <code>priority_queue</code> with <code>multiset</code>.</p>\n<p><strong>Algorithm</strong></p>\n<p>Inserting or deleting an element is straight-forward. Balancing the heaps takes the same route as <a href="https://leetcode.com/articles/find-median-from-data-stream#approach-3-two-heaps-accepted">Approach #3</a> of <a href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median From Data Stream</a>.</p>\n<iframe frameborder="0" height="515" name="gF6jWb7Y" src="https://leetcode.com/playground/gF6jWb7Y/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O((n-k) * 6 * log(k)) \\approx O(n \\cdot log(k))</script>.</p>\n<ul>\n<li>At worst, there are three set insertions and three set deletions from the start or end. Each of these takes about <script type="math/tex; mode=display">O(log(k))</script> time.</li>\n<li>Finding the mean takes constant <script type="math/tex; mode=display">O(1)</script> time since the start or ends of sets are directly accessible.</li>\n<li>Each of these steps takes place about <script type="math/tex; mode=display">(n-k)</script> times (the number of sliding window instances).</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(k)</script> extra linear space to hold contents of the window.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-multiset-and-two-pointers-accepted">Approach #4 Multiset and Two Pointers [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>This is same as <a href="https://leetcode.com/articles/find-median-from-data-stream#approach-4-multiset-and-two-pointers-accepted">Approach #4</a> for <a href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median From Data Stream</a>.</p>\n<blockquote>\n<p>But, we don\'t actually need two pointers.</p>\n</blockquote>\n<p>Median elements are derived using a single iterator position (when the window size <script type="math/tex; mode=display">k</script> is odd) or two consecutive iterator positions (when <script type="math/tex; mode=display">k</script> is even). Hence keeping track of <em>only</em> one pointer is sufficient. The other pointer can be <em>implicitly derived</em> when required.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>\n<p>A single iterator <code>mid</code>, which iterates over the <code>window</code> multiset. It is analogous to <code>upper_median</code> in <a href="https://leetcode.com/articles/find-median-from-data-stream#approach-4-multiset-and-two-pointers-accepted">Approach #4</a> for <a href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median From Data Stream</a>. <code>lower_median</code> is <em>implicitly derived</em> from <code>mid</code>. It\'s either equal to <code>mid</code> (when the window size <script type="math/tex; mode=display">k</script> is odd) or <code>prev(mid)</code> <sup id="fnref:note-1"><a class="footnote-ref" href="#fn:note-1" rel="footnote">1</a></sup> <script type="math/tex">when the window size $$k$$ is even</script>.</p>\n</li>\n<li>\n<p>We start with populating our multiset <code>window</code> with the first <script type="math/tex; mode=display">k</script> elements. We set <code>mid</code> to the <script type="math/tex; mode=display">\\lfloor k/2 \\rfloor</script> indexed element in <code>window</code> (<code>0</code>-based indexing; Multisets always maintain their sorted property).</p>\n</li>\n<li>\n<p>While inserting an element <code>num</code> into <code>window</code>, three cases arise:</p>\n<ol>\n<li>\n<p><code>num</code> is less than the value of upper median <code>mid</code>.</p>\n</li>\n<li>\n<p><code>num</code> is greater than the value of upper median <code>mid</code>.</p>\n</li>\n<li>\n<p><code>num</code> is equal to the value of upper median <code>mid</code>. This situation is often handled as language-dependent. Since C++ <code>multiset</code> insert elements at the end of their equal range, this situation is essentially the same as the previous case.</p>\n</li>\n<li>\n<p>For the first case, <code>num</code> is inserted before the upper median element <code>mid</code>. Thus <code>mid</code> now, no longer points to the <script type="math/tex; mode=display">\\lfloor k/2 \\rfloor</script> indexed element. In fact it points to the <script type="math/tex; mode=display">\\lfloor k/2 \\rfloor + 1</script> indexed element. We fix that by decrementing <code>mid</code>.</p>\n</li>\n<li>\n<p>For the second and third cases, <code>num</code> is inserted after the upper median element <code>mid</code> and hence does not spoil the <code>mid</code> iterator. It still points to the <script type="math/tex; mode=display">\\lfloor k/2 \\rfloor</script> indexed element.</p>\n</li>\n<li>\n<p>Of course, the window size just increased to <script type="math/tex; mode=display">k + 1</script> in all three cases. That will easily be fixed by removing the element that is about to exit the window.</p>\n</li>\n</ol>\n</li>\n<li>\n<p>While removing an element <code>num</code>, the same three cases arise as when we wanted to insert an element:</p>\n<ol>\n<li>\n<p><code>num</code> is less than the value of upper median <code>mid</code>.</p>\n</li>\n<li>\n<p><code>num</code> is greater than the value of upper median <code>mid</code>.</p>\n</li>\n<li>\n<p><code>num</code> is equal to the value of upper median <code>mid</code>. Since <code>mid</code> will point to the first occurrence of <code>num</code> in the multiset <code>window</code> and we deterministically remove the first occurrence (take note that we use <code>std::multiset::lower_bound()</code> <sup id="fnref:note-2"><a class="footnote-ref" href="#fn:note-2" rel="footnote">2</a></sup> to find the correct occurrence to erase), this case is handled in the same manner as the first case.</p>\n</li>\n<li>\n<p>In the first and third cases, removing <code>num</code> will spoil the <code>mid</code> iterator. Thus we need to fix that by incrementing <code>mid</code> before we remove that element.</p>\n</li>\n<li>\n<p>For the second case, the <code>mid</code> iterator is not spoiled. No further action is required.</p>\n</li>\n<li>\n<p>Once this element has been removed, the window size returns to being <script type="math/tex; mode=display">k</script>.</p>\n</li>\n</ol>\n</li>\n<li>\n<p>After insertion of the incoming element and removal of the outgoing element, we are left again with some nice invariants:</p>\n<ol>\n<li>Window size is again <script type="math/tex; mode=display">k</script>.</li>\n<li>The window is still fully sorted.</li>\n<li><code>mid</code> still points to the <script type="math/tex; mode=display">\\lfloor k/2 \\rfloor</script> indexed element.</li>\n</ol>\n</li>\n<li>\n<p>Finding the median of the window is easy! It is simply the <strong>mean</strong> of the elements pointed to by the two pointers <code>lo_median</code> and <code>hi_median</code>. In our case those are <code>mid</code> or <code>prev(mid)</code> (as decided by whether <script type="math/tex; mode=display">k</script> is odd or even) , and <code>mid</code> respectively.</p>\n</li>\n</ul>\n<p><sup id="fnref:note-3"><a class="footnote-ref" href="#fn:note-3" rel="footnote">3</a></sup></p>\n<iframe frameborder="0" height="515" name="bVVJJaz7" src="https://leetcode.com/playground/bVVJJaz7/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O((n-k) \\cdot log(k)) + O(k) \\approx O(n \\cdot log(k))</script>.</p>\n<ul>\n<li>Initializing <code>mid</code> takes about <script type="math/tex; mode=display">O(k)</script> time.</li>\n<li>Inserting or deleting a number takes <script type="math/tex; mode=display">O(log(k))</script> time for a standard <code>multiset</code> scheme. <sup id="fnref:note-4"><a class="footnote-ref" href="#fn:note-4" rel="footnote">4</a></sup></li>\n<li>Finding the mean takes constant <script type="math/tex; mode=display">O(1)</script> time since the median elements are directly accessible from <code>mid</code> iterator.</li>\n<li>The last two steps take place about <script type="math/tex; mode=display">(n-k)</script> times (the number of sliding window instances).</li>\n</ul>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(k)</script> extra linear space to hold contents of the window.</p>\n</li>\n</ul>\n<hr>\n<h4 id="further-thoughts">Further Thoughts</h4>\n<p>As noted before, this problem is essentially an extension to <a href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median From Data Stream</a>. That problem had a lot of ways to go about, that frankly, are not of much use in an interview. But they are interesting to follow all the same. If you are interested take a look <a href="https://leetcode.com/articles/find-median-from-data-stream#further-thoughts">here.</a> Try extending those methods to this problem.</p>\n<hr>\n<p>Analysis written by <a href="https://leetcode.com/babhishek21">@babhishek21</a>.</p>\n<div class="footnote">\n<hr>\n<ol>\n<li id="fn:note-1">\n<p><code>std::prev()</code> is a C++ method to find the previous element to the current one being pointed to by an iterator.&nbsp;<a class="footnote-backref" href="#fnref:note-1" rev="footnote" title="Jump back to footnote 1 in the text">↩</a></p>\n</li>\n<li id="fn:note-2">\n<p>Had we used <code>std::multiset::find()</code>, there was no guarantee that the first occurrence of <code>num</code> would be found. Although the contrary did happen in all of our tests, I don\'t recommend using it. Your mileage may vary.&nbsp;<a class="footnote-backref" href="#fnref:note-2" rev="footnote" title="Jump back to footnote 2 in the text">↩</a></p>\n</li>\n<li id="fn:note-3">\n<p>Shout-out to <a href="https://leetcode.com/votrubac/">@votrubac</a> and <a href="https://leetcode.com/stefanpochmann">@StefanPochmann</a>!&nbsp;<a class="footnote-backref" href="#fnref:note-3" rev="footnote" title="Jump back to footnote 3 in the text">↩</a></p>\n</li>\n<li id="fn:note-4">\n<p><a href="http://en.cppreference.com/w/cpp/container/multiset/insert">Hinting</a> can reduce that to amortized constant <script type="math/tex; mode=display">O(1)</script> time.&nbsp;<a class="footnote-backref" href="#fnref:note-4" rev="footnote" title="Jump back to footnote 4 in the text">↩</a></p>\n</li>\n</ol>\n</div>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '481',
    name: 'Magical String',
    acceptance: '45.7%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nA magical string <b>S</b> consists of only '1' and '2' and obeys the following rules:\n</p>\n<p>\nThe string <b>S</b> is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string <b>S</b> itself.\n</p>\n\n<p>\nThe first few elements of string <b>S</b> is the following:\n<b>S</b> = \"1221121221221121122……\"\n</p>\n\n<p>\nIf we group the consecutive '1's and '2's in <b>S</b>, it will be:\n</p>\n<p>\n1   22  11  2  1  22  1  22  11  2  11  22 ......\n</p>\n<p>\nand the occurrences of '1's or '2's in each group are:\n</p>\n<p>\n1   2\t   2    1   1    2     1    2     2    1    2    2 ......\n</p>\n\n<p>\nYou can see that the occurrence sequence above is the <b>S</b> itself. \n</p>\n\n<p>\nGiven an integer N as input, return the number of '1's in the first N number in the magical string <b>S</b>.\n</p>\n\n<p><b>Note:</b>\nN will not exceed 100,000.\n</p>\n\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> 6\n<b>Output:</b> 3\n<b>Explanation:</b> The first 6 elements of magical string S is \"12211\" and it contains three 1's, so return 3.\n</pre>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '482',
    name: 'License Key Formatting',
    acceptance: '41.5%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes.</p>\n\n<p>Given a number K, we would want to reformat the strings such that each group contains <i>exactly</i> K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase.</p>\n\n<p>Given a non-empty string S and a number K, format the string according to the rules described above.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> S = "5F3Z-2e-9-w", K = 4\n\n<b>Output:</b> "5F3Z-2E9W"\n\n<b>Explanation:</b> The string S has been split into two parts, each part has 4 characters.\nNote that the two extra dashes are not needed and can be removed.\n</pre>\n<p></p>\n\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> S = "2-5g-3-J", K = 2\n\n<b>Output:</b> "2-5G-3J"\n\n<b>Explanation:</b> The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The length of string S will not exceed 12,000, and K is a positive integer.</li>\n<li>String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).</li>\n<li>String S is non-empty.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '483',
    name: 'Smallest Good Base',
    acceptance: '33.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>For an integer n, we call k&gt;=2 a <i><b>good base</b></i> of n, if all digits of n base k are 1.</p>\n<p>Now given a string representing n, you should return the smallest good base of n in string format. <br></p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "13"\n<b>Output:</b> "3"\n<b>Explanation:</b> 13 base 3 is 111.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> "4681"\n<b>Output:</b> "8"\n<b>Explanation:</b> 4681 base 8 is 11111.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> "1000000000000000000"\n<b>Output:</b> "999999999999999999"\n<b>Explanation:</b> 1000000000000000000 base 999999999999999999 is 11.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The range of n is [3, 10^18].</li>\n<li>The string representing n is always valid and will not have leading zeros.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '484',
    name: 'Find Permutation ',
    acceptance: '55.2%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nBy now, you are given a <b>secret signature</b> consisting of character 'D' and 'I'. 'D' represents a decreasing relationship between two numbers, 'I' represents an increasing relationship between two numbers. And our <b>secret signature</b> was constructed by a special integer array, which contains uniquely all the different number from 1 to n (n is the length of the secret signature plus 1). For example, the secret signature \"DI\" can be constructed by array [2,1,3] or [3,1,2], but won't be constructed by array [3,2,4] or [2,1,3,4], which are both illegal constructing special string that can't represent the \"DI\" <b>secret signature</b>.\n</p>\n\n<p>\nOn the other hand, now your job is to find the lexicographically smallest permutation of [1, 2, ... n] could refer to the given <b>secret signature</b> in the input.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \"I\"\n<b>Output:</b> [1,2]\n<b>Explanation:</b> [1,2] is the only legal initial spectial string can construct secret signature \"I\", where the number 1 and 2 construct an increasing relationship.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \"DI\"\n<b>Output:</b> [2,1,3]\n<b>Explanation:</b> Both [2,1,3] and [3,1,2] can construct the secret signature \"DI\", <br>but since we want to find the one with the smallest lexicographical permutation, you need to output [2,1,3]\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>The input string will only contain the character 'D' and 'I'.</li>\n<li>The length of input string is a positive integer and will not exceed 10,000</li>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-stack-accepted">Approach #1 Using Stack [Accepted]</a></li>\n<li><a href="#approach-2-reversing-the-subarray-accepted">Approach #2 Reversing the subarray [Accepted]</a></li>\n<li><a href="#approach-3-two-pointers-accepted">Approach #3 Two pointers [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-stack-accepted">Approach #1 Using Stack [Accepted]</h4>\n<p>Let\'s revisit the important points of the given problem statement. For a given <script type="math/tex; mode=display">n</script>, we need to use all the integers in the range <script type="math/tex; mode=display">(1,n)</script> to generate a lexicographically smallest permutation of these <script type="math/tex; mode=display">n</script> numbers which satsfies the pattern given in the string <script type="math/tex; mode=display">s</script>.</p>\n<p>Firstly, we note that the lexicographically smallest permutation that can be generated(irrelevant of the given pattern <script type="math/tex; mode=display">s</script>) using the <script type="math/tex; mode=display">n</script> integers from <script type="math/tex; mode=display">(1,n)</script> is <script type="math/tex; mode=display">[1, 2, 3,.., n]</script>(say <script type="math/tex; mode=display">min</script>). Thus, while generating the required permutation, we can surely say that the permutation generated should be as close as possible to <script type="math/tex; mode=display">min</script>.</p>\n<p>Now, we can also note that the number generated will be the smallest possible only if the digits lying towards the most significant positions are as small as possible while satisfying the given pattern. Now, to understand how these observations help in providing the solution of the given problem, we\'ll look at a simple example.</p>\n<p>Say, the given pattern <script type="math/tex; mode=display">s</script> is <code>"DDIIIID"</code>. This corresponds to <script type="math/tex; mode=display">n=8</script>. Thus, the <script type="math/tex; mode=display">min</script> permutation possible will be <code>[1, 2, 3, 4, 5, 6, 7, 8]</code>. Now, to satisfy the first two <code>"DD"</code> pattern, we can observe that the best course of action to generate the smallest arrangement will be to rearrange only <code>1, 2, 3</code>, because these are the smallest numbers that can be placed at the three most significant positions to generate the smallest arrangement satisfying the given pattern till now, leading to the formation of <code>[3, 2, 1, 4, 5, 6, 7, 8]</code> till now. We can note that placing any number larger than 3 at any of these positions will lead to the generation of a lexicographically larger arrangement as discussed above.</p>\n<p>We can also note that irrespective of how we rearrange the first three <code>1, 2, 3</code>, the relationship of the last number among them with the  next number always satisfies the criteria required for satisfying the first <code>I</code> in <script type="math/tex; mode=display">s</script>. Further, note that, the pattern generated till now already satisfies the subpattern <code>"IIII"</code> in <script type="math/tex; mode=display">s</script>. This will always be satisfied since the <script type="math/tex; mode=display">min</script> number considered originally always satisfies the increasing criteria.</p>\n<p>Now, when we find the last <code>"D"</code> in the pattern <script type="math/tex; mode=display">s</script>, we again need to make rearrangements in the last two positions only and we need to use only the numbers <code>7, 8</code> in such rearrangements at those positions. This is because, again, we would like to keep the larger number towards the least significant possible as much as possible to generate the lexicographically smallest arrangement. Thus, to satisfy the last <code>"D"</code> the best arrangement of the last two numbers is <code>8, 7</code> leading to the generation of <code>[3, 2, 1, 4, 5, 6, 8, 7]</code> as the required output.</p>\n<p>Based on the above example, we can summarize that, to generate the required arrangement, we can start off with the <script type="math/tex; mode=display">min</script> number that can be formed for the given <script type="math/tex; mode=display">n</script>. Then, to satisfy the given pattern <script type="math/tex; mode=display">s</script>, we need to reverse only those subsections of the <script type="math/tex; mode=display">min</script> array which have a <code>D</code> in the pattern at their corresponding positions.</p>\n<p>To perform these operations, we need not necessarily create the <script type="math/tex; mode=display">min</script> array first, because it simply consists of numbers from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script> in ascending order. </p>\n<p>To perform the operations discussed above, we can make use of a <script type="math/tex; mode=display">stack</script>. We can start considering the numbers <script type="math/tex; mode=display">i</script> from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script>. For every current number, whenver we find a <code>D</code> in the pattern <script type="math/tex; mode=display">s</script>, we just push that number onto the <script type="math/tex; mode=display">stack</script>. This is done so that, later on, when we find the next <code>I</code>, we can pop off these numbers from the stack leading to the formation of a reversed (descending) subpattern of those numbers corrresponding to the <code>D</code>\'s in <script type="math/tex; mode=display">s</script>(as discussed above). </p>\n<p>When we encounter an <code>I</code> in the pattern, as discussed above, we push the current number as well onto the <script type="math/tex; mode=display">stack</script> and then pop-off all the numbers on the <script type="math/tex; mode=display">stack</script> and append these numbers to the resultant pattern formed till now.</p>\n<p>Now, we could reach the end of the pattern <script type="math/tex; mode=display">s</script> with a trail of <code>D</code>\'s at the end. In this case, we won\'t find an ending <code>I</code> to pop-off the numbers on the <script type="math/tex; mode=display">stack</script>. Thus, at the end, we push the value <script type="math/tex; mode=display">n</script> on the stack and then pop all the values on the <script type="math/tex; mode=display">stack</script> and append them to the resultant pattern formed till now. Now, if the second last character in <script type="math/tex; mode=display">s</script> was an <code>I</code>, <script type="math/tex; mode=display">n</script> will be appended at the end of the resultant arrangement correctly. If the second last character was a <code>D</code>, the reversed pattern appended at the end of the resultant arrangement will be reversed including the last number <script type="math/tex; mode=display">n</script>. In both the cases, the resultant arrangement turns out to be correct. </p>\n<p>The following animation better illustrates the process.</p>\n<p>!?!../Documents/484_Find_Permutation_1.json:1000,563!?!</p>\n<p>Below code is inpired by <a href="http://leetcode.com/horseno">@horseno</a></p>\n<iframe frameborder="0" height="394" name="oQngSEVg" src="https://leetcode.com/playground/oQngSEVg/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">n</script> numbers will be pushed and popped from the <script type="math/tex; mode=display">stack</script>. Here, <script type="math/tex; mode=display">n</script> refers to the number of elements in the resultant arrangement.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The <script type="math/tex; mode=display">stack</script> can grow upto a depth of <script type="math/tex; mode=display">n</script> in the worst case.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-reversing-the-subarray-accepted">Approach #2 Reversing the subarray [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In order to reverse the subsections of the <script type="math/tex; mode=display">min</script> array, as discussed in the last approach, we can also start by initializing the resultant arrangement <script type="math/tex; mode=display">res</script> with the <script type="math/tex; mode=display">min</script> array i.e. by filling with elements <script type="math/tex; mode=display">(1,n)</script> in ascending order. Then, while traversing the pattern <script type="math/tex; mode=display">s</script>, we can keep a track of the starting and ending indices in <script type="math/tex; mode=display">res</script> corresponding to the <code>D</code>\'s in the pattern <script type="math/tex; mode=display">s</script>, and reverse the portions of the sub-arrays in <script type="math/tex; mode=display">res</script> corresponding to these indices. The reasoning behind this remains the same as discussed in the last approach.</p>\n<p>The following animation illustrates the process.</p>\n<p>!?!../Documents/484_Find_Permutation_Reverse.json:1000,563!?!</p>\n<iframe frameborder="0" height="462" name="JWJKE7wc" src="https://leetcode.com/playground/JWJKE7wc/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The resultant array of size <script type="math/tex; mode=display">n</script> is traversed atmost three times, in the worst case e.g. "DDDDDD"</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-two-pointers-accepted">Approach #3 Two pointers [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of initializing the <script type="math/tex; mode=display">res</script> array once with ascending numbers, we can save one iteration over <script type="math/tex; mode=display">res</script> if we fill it on the fly. To do this, we can keep on filling the numbers in ascending order in <script type="math/tex; mode=display">res</script> for <code>I</code>\'s found in the pattern <script type="math/tex; mode=display">s</script>. Whenever we find a <code>D</code> in the pattern <script type="math/tex; mode=display">s</script>, we can store the current position(counting from 1) being filled in the <script type="math/tex; mode=display">res</script> array in a pointer <script type="math/tex; mode=display">j</script>. Now, whenever we find the first <code>I</code> following this last consecutive set of <code>D</code>\'s, say at the <script type="math/tex; mode=display">i^{th}</script> position(counting from 1) in <script type="math/tex; mode=display">res</script>, we know, that the elements from <script type="math/tex; mode=display">j^{th}</script> position to the <script type="math/tex; mode=display">i^{th}</script> position in <script type="math/tex; mode=display">res</script> need to be filled with the numbers from <script type="math/tex; mode=display">j</script> to <script type="math/tex; mode=display">i</script> in reverse order. Thus, we can fill the numbers in <script type="math/tex; mode=display">res</script> array starting from the <script type="math/tex; mode=display">j^{th}</script> position, with <script type="math/tex; mode=display">i</script> being the number filled at that position and continue the filling in descending order till reaching the <script type="math/tex; mode=display">i^{th}</script> position. In this way, we can generate the required arrangement without initializing <script type="math/tex; mode=display">res</script>.</p>\n<iframe frameborder="0" height="428" name="XWhYV6uZ" src="https://leetcode.com/playground/XWhYV6uZ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The resultant array of size <script type="math/tex; mode=display">n</script> is traversed atmost two times, in the worst case e.g. "DDDDDD"</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '485',
    name: 'Max Consecutive Ones',
    acceptance: '54.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,1,0,1,1,1]\n<b>Output:</b> 3\n<b>Explanation:</b> The first two digits or the last three digits are consecutive 1s.\n    The maximum number of consecutive 1s is 3.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><ul>\n<li>The input array will only contain <code>0</code> and <code>1</code>.</li>\n<li>The length of input array is a positive integer and will not exceed 10,000</li>\n</ul>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '486',
    name: 'Predict the Winner',
    acceptance: '45.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins. </p>\n\n<p>Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score. </p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1, 5, 2]\n<b>Output:</b> False\n<b>Explanation:</b> Initially, player 1 can choose between 1 and 2. <br>If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). <br>So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. <br>Hence, player 1 will never be the winner and you need to return False.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [1, 5, 233, 7]\n<b>Output:</b> True\n<b>Explanation:</b> Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.<br>Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>1 &lt;= length of the array &lt;= 20. </li>\n<li>Any scores in the given array are non-negative integers and will not exceed 10,000,000.</li>\n<li>If the scores of both players are equal, then player 1 is still the winner.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</a></li>\n<li><a href="#approach-2-similar-approach-accepted">Approach #2 Similar Approach [Accepted]</a></li>\n<li><a href="#approach-3-dynamic-programming-accepted">Approach #3 Dynamic Programming [Accepted]:</a></li>\n<li><a href="#approach-4-1-d-dynamic-programming-accepted">Approach #4 1-D Dynamic Programming [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</h4>\n<p>The idea behind the recursive approach is simple. The two players Player 1 and Player 2 will be taking turns alternately. For the Player 1 to be the winner, we need <script type="math/tex; mode=display">score_{Player\\_1} &geq; score_{Player\\_2}</script>. Or in other terms, <script type="math/tex; mode=display">score_{Player\\_1} - score_{Player\\_2} &geq; 0</script>. </p>\n<p>Thus, for the turn of Player 1, we can add its score obtained to the total score and for Player 2\'s turn, we can substract its score from the total score. At the end, we can check if the total score is greater than or equal to zero(equal score of both players), to predict that Player 1 will be the winner.</p>\n<p>Thus, by making use of a recursive function <code>winner(nums,s,e,turn)</code> which predicts the winner for the <script type="math/tex; mode=display">nums</script> array as the score array with the elements in the range of indices <script type="math/tex; mode=display">[s,e]</script> currently being considered, given a particular player\'s turn, indicated by <script type="math/tex; mode=display">turn=1</script> being Player 1\'s turn and <script type="math/tex; mode=display">turn=-1</script> being the Player 2\'s turn, we can predict the winner of the given problem by making the function call <code>winner(nums,0,n-1,1)</code>. Here, <script type="math/tex; mode=display">n</script> refers to the length of <script type="math/tex; mode=display">nums</script> array.</p>\n<p>In every turn, we can either pick up the first(<script type="math/tex; mode=display">nums[s]</script>) or the last(<script type="math/tex; mode=display">nums[e]</script>) element of the current subarray. Since both the players are assumed to be playing smartly and making the best move at every step, both will tend to maximize their scores. Thus, we can make use of the same function <code>winner</code> to determine the maximum score possible for any of the players. </p>\n<p>Now, at every step of the recursive process, we determine the maximum score possible for the current player. It will be the maximum one possible out of the scores obtained by picking the first or the last element of the current subarray. </p>\n<p>To obtain the score possible from the remaining subarray, we can again make use of the same <code>winner</code> function and add the score corresponding to the point picked in the current function call. But, we need to take care of whether to add or subtract this score to the total score available. If it is Player 1\'s turn, we add the current number\'s score to the total score, otherwise, we need to subtract the same. </p>\n<p>Thus, at every step, we need update the search space appropriately based on the element chosen and also invert the <script type="math/tex; mode=display">turn</script>\'s value to indicate the turn change among the players and either add or subtract the current player\'s score from the total score available to determine the end result.</p>\n<p>Further, note that the value returned at every step is given by <script type="math/tex; mode=display">turn *\\text{max}(turn * a, turn * b)</script>. This is equivalent to the statement <script type="math/tex; mode=display">max(a,b)</script> for Player 1\'s turn and <script type="math/tex; mode=display">min(a,b)</script> for Player 2\'s turn. </p>\n<p>This is done because, looking from Player 1\'s perspective, for any move made by Player 1, it tends to leave the remaining subarray in a situation which minimizes the best score possible for Player 2, even if it plays in the best possible manner. But, when the turn passes to Player 1 again, for Player 1 to win, the remaining subarray should be left in a state such that the score obtained from this subarrray is maximum(for Player 1). </p>\n<p>This is a general criteria for any arbitrary two player game and is commonly known as the \n<a href="https://en.wikipedia.org/wiki/Minimax">Min-Max algorithm</a>.</p>\n<p>The following image shows how the scores are passed to determine the end result for a simple example.</p>\n<p align="center"><img alt="Recursive_Tree" src="https://leetcode.com/articles/Figures/486/486_Predict_the_winner_new.PNG"></p>\n<iframe frameborder="0" height="275" name="3SDSCR7V" src="https://leetcode.com/playground/3SDSCR7V/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(2^n)</script>. Size of recursion tree will be <script type="math/tex; mode=display">2^n</script>. Here, <script type="math/tex; mode=display">n</script> refers to the length of <script type="math/tex; mode=display">nums</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of the recursion tree can go upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-similar-approach-accepted">Approach #2 Similar Approach [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can omit the use of <script type="math/tex; mode=display">turn</script> to keep a track of the player for the current turn. To do so, we can make use of a simple observation. If the current turn belongs to, say Player 1, we pick up an element, say <script type="math/tex; mode=display">x</script>, from either end, and give the turn to Player 2. Thus, if we obtain the score for the remaining elements(leaving <script type="math/tex; mode=display">x</script>), this score, now belongs to Player 2. Thus, since Player 2 is competing against Player 1, this score should be subtracted from Player 1\'s current(local) score(<script type="math/tex; mode=display">x</script>) to obtain the effective score of Player 1 at the current instant.</p>\n<p>Similar argument holds true for Player 2\'s turn as well i.e. we can subtract Player 1\'s score for the remaining subarray from Player 2\'s current score to obtain its effective score. By making use of this observation, we can omit the use of <script type="math/tex; mode=display">turn</script> from <code>winner</code> to find the required result by making the slight change discussed above in the <code>winner</code>\'s implementation.</p>\n<p>While returning the result from <code>winner</code> for the current function call, we return the larger of the effective scores possible by choosing either the first or the last element from the currently available subarray. Rest of the process remains the same as the last approach.</p>\n<p>Now, in order to remove the duplicate function calls, we can make use of a 2-D memoization array, <script type="math/tex; mode=display">memo</script>, such that we can store the result obtained for the function call <code>winner</code> for a subarray with starting and ending indices being <script type="math/tex; mode=display">s</script> and <script type="math/tex; mode=display">e</script> ] at <script type="math/tex; mode=display">memo[s][e]</script>. This helps to prune the search space to a great extent.</p>\n<p>This approach is inspired by <a href="http://leetcode.com/chidong">@chidong</a></p>\n<iframe frameborder="0" height="326" name="RGPbqsDC" src="https://leetcode.com/playground/RGPbqsDC/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. The entire <script type="math/tex; mode=display">memo</script> array of size <script type="math/tex; mode=display">n</script>x<script type="math/tex; mode=display">n</script> is filled only once. Here, <script type="math/tex; mode=display">n</script> refers to the size of <script type="math/tex; mode=display">nums</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^2)</script>. <script type="math/tex; mode=display">memo</script> array of size <script type="math/tex; mode=display">n</script>x<script type="math/tex; mode=display">n</script> is used for memoization.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-dynamic-programming-accepted">Approach #3 Dynamic Programming [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can observe that the effective score for the current player for any given subarray <script type="math/tex; mode=display">nums[x:y]</script> only depends on the elements within the range <script type="math/tex; mode=display">[x,y]</script> in the array <script type="math/tex; mode=display">nums</script>. It mainly depends on whether the element <script type="math/tex; mode=display">nums[x]</script> or <script type="math/tex; mode=display">nums[y]</script> is chosen in the current turn and also on the maximum score possible for the other player from the remaining subarray left after choosing the current element. Thus, it is certain that the current effective score isn\'t dependent on the elements outside the range <script type="math/tex; mode=display">[x,y]</script>. </p>\n<p>Based on the above observation, we can say that if know the maximum effective score possible for the subarray <script type="math/tex; mode=display">nums[x+1,y]</script> and <script type="math/tex; mode=display">nums[x,y-1]</script>, we can easily determine the maximum effective score possible for the subarray <script type="math/tex; mode=display">nums[x,y]</script> as <script type="math/tex; mode=display">\\text{max}(nums[x]-score_{[x+1,y]}, nums[y]-score_{[x,y-1]})</script>. These equations are deduced based on the last approach. </p>\n<p>From this,  we conclude that we can make use of Dynamic Programming to determine the required maximum effective score for the array <script type="math/tex; mode=display">nums</script>. We can make use of a 2-D <script type="math/tex; mode=display">dp</script> array, such that <script type="math/tex; mode=display">dp[i][j]</script> is used to store the maximum effective score possible for the subarray <script type="math/tex; mode=display">nums[i,j]</script>. The <script type="math/tex; mode=display">dp</script> updation equation becomes: </p>\n<p>\n<script type="math/tex; mode=display">dp[i,j] = nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]</script>.</p>\n<p>We can fill in the <script type="math/tex; mode=display">dp</script> array starting from the last row. At the end, the value for <script type="math/tex; mode=display">dp[0][n-1]</script> gives the required result. Here, <script type="math/tex; mode=display">n</script> refers to the length of <script type="math/tex; mode=display">nums</script> array.</p>\n<p>Look at the animation below to clearly understand the <script type="math/tex; mode=display">dp</script> filling process.</p>\n<p>!?!../Documents/486_Predict_the_winner.json:1000,563!?!</p>\n<iframe frameborder="0" height="275" name="EFGjsVXp" src="https://leetcode.com/playground/EFGjsVXp/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. <script type="math/tex; mode=display">((n+1)</script>x<script type="math/tex; mode=display">n)/2</script> entries in <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">(n+1)</script>x<script type="math/tex; mode=display">n</script> is filled once. Here, <script type="math/tex; mode=display">n</script> refers to the length of <script type="math/tex; mode=display">nums</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^2)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">(n+1)</script>x<script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-1-d-dynamic-programming-accepted">Approach #4 1-D Dynamic Programming [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>From the last approach, we see that the <script type="math/tex; mode=display">dp</script> updation equation is: </p>\n<p>\n<script type="math/tex; mode=display">dp[i,j] = nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]</script>. </p>\n<p>Thus, for filling in any entry in <script type="math/tex; mode=display">dp</script> array, only the entries in the next row(same column) and the previous column(same row) are needed.</p>\n<p>Instead of making use of a new row in <script type="math/tex; mode=display">dp</script> array for the current <script type="math/tex; mode=display">dp</script> row\'s updations, we can overwrite the values in the previous row itself and consider the values as belonging to the new row\'s entries, since the older values won\'t be needed ever in the future again. Thus, instead of making use of a 2-D <script type="math/tex; mode=display">dp</script> array, we can make use of a 1-D <script type="math/tex; mode=display">dp</script> array and make the updations appropriately.</p>\n<iframe frameborder="0" height="292" name="k9vrYN2X" src="https://leetcode.com/playground/k9vrYN2X/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. The elements of <script type="math/tex; mode=display">dp</script> array are updated <script type="math/tex; mode=display">1+2+3+...+n</script> times. Here, <script type="math/tex; mode=display">n</script> refers to the length of <script type="math/tex; mode=display">nums</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. 1-D <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '487',
    name: 'Max Consecutive Ones II ',
    acceptance: '45.9%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nGiven a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,0,1,1,0]\n<b>Output:</b> 4\n<b>Explanation:</b> Flip the first zero will get the the maximum number of consecutive 1s.\n    After flipping, the maximum number of consecutive 1s is 4.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><ul>\n<li>The input array will only contain <code>0</code> and <code>1</code>.</li>\n<li>The length of input array is a positive integer and will not exceed 10,000</li>\n</ul>\n<p></p>\n\n<p><b>Follow up:</b><br>\nWhat if the input numbers come in one by one as an <b>infinite stream</b>? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently?\n</p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '488',
    name: 'Zuma Game',
    acceptance: '37.3%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.</p>\n<p>\nEach time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.</p>\n<p>\nFind the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.\n</p>\n<pre><p><b>Examples:</b><br>\n<b>Input:</b> "WRRBBW", "RB"\n<b>Output:</b> -1\n<b>Explanation:</b> WRRBBW -&gt; WRR[R]BBW -&gt; WBBW -&gt; WBB[B]W -&gt; WW\n\n<b>Input:</b> "WWRRBBWW", "WRBRW"\n<b>Output:</b> 2\n<b>Explanation:</b> WWRRBBWW -&gt; WWRR[R]BBWW -&gt; WWBBWW -&gt; WWBB[B]WW -&gt; WWWW -&gt; empty\n\n<b>Input:</b>"G", "GGGGG"\n<b>Output:</b> 2\n<b>Explanation:</b> G -&gt; G[G] -&gt; GG[G] -&gt; empty \n\n<b>Input:</b> "RBYYBBRRB", "YRBGB"\n<b>Output:</b> 3\n<b>Explanation:</b> RBYYBBRRB -&gt; RBYY[Y]BBRRB -&gt; RBBBRRB -&gt; RRRB -&gt; B -&gt; B[B] -&gt; BB[B] -&gt; empty \n</p></pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>You may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color.</li>\n<li>The number of balls on the table won\'t exceed 20, and the string represents these balls is called "board" in the input.</li>\n<li>The number of balls in your hand won\'t exceed 5, and the string represents these balls is called "hand" in the input.</li>\n<li>Both input strings will be non-empty and only contain characters \'R\',\'Y\',\'B\',\'G\',\'W\'.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Baidu'],
  },
  {
    id: '490',
    name: 'The Maze ',
    acceptance: '43.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>There is a <b>ball</b> in a maze with empty spaces and walls. The ball can go through empty spaces by rolling <b>up</b>, <b>down</b>, <b>left</b> or <b>right</b>, but it won\'t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.</p>\n\n<p>Given the ball\'s <b>start position</b>, the <b>destination</b> and the <b>maze</b>, determine whether the ball could stop at the destination.</p>\n\n<p>The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.</p>\n\n<p>\n<b>Example 1</b>\n</p><pre><b>Input 1:</b> a maze represented by a 2D array\n\n0 0 1 0 0\n0 0 0 0 0\n0 0 0 1 0\n1 1 0 1 1\n0 0 0 0 0\n\n<b>Input 2:</b> start coordinate (rowStart, colStart) = (0, 4)\n<b>Input 3:</b> destination coordinate (rowDest, colDest) = (4, 4)\n\n<b>Output:</b> true\n<b>Explanation:</b> One possible way is : left -&gt; down -&gt; left -&gt; down -&gt; right -&gt; down -&gt; right.\n<img src="https://leetcode.com/static/images/problemset/maze_1_example_1.png" width="30%">\n</pre>\n<p></p>\n\n<p>\n<b>Example 2</b>\n</p><pre><b>Input 1:</b> a maze represented by a 2D array\n\n0 0 1 0 0\n0 0 0 0 0\n0 0 0 1 0\n1 1 0 1 1\n0 0 0 0 0\n\n<b>Input 2:</b> start coordinate (rowStart, colStart) = (0, 4)\n<b>Input 3:</b> destination coordinate (rowDest, colDest) = (3, 2)\n\n<b>Output:</b> false\n<b>Explanation:</b> There is no way for the ball to stop at the destination.\n<img src="https://leetcode.com/static/images/problemset/maze_1_example_2.png" width="30%">\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>There is only one ball and one destination in the maze.</li>\n<li>Both the ball and the destination exist on an empty space, and they will not be at the same position initially.</li>\n<li>The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.</li>\n<li>The maze contains at least 2 empty spaces, and both the width and height of the maze won\'t exceed 100.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-depth-first-search-time-limit-exceeded">Approach #1 Depth First Search [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-breadth-first-search-accepted">Approach #2 Breadth First Search [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-depth-first-search-time-limit-exceeded">Approach #1 Depth First Search [Time Limit Exceeded]</h4>\n<p>We can view the given search space in the form of a tree. The root node of the tree represents the starting position. Four different routes are possible from each position i.e. left, right, up or down. These four options can be represented by 4 branches of each node in the given tree. Thus, the new node reached from the root traversing over the branch represents the new position occupied by the ball after choosing the corresponding direction of travel.</p>\n<p><img alt="Maze_Tree" src="https://leetcode.com/articles/Figures/490_Maze_Tree.PNG"></p>\n<p>In order to do this traversal, one of the simplest schemes is to undergo depth first search. In this case, we choose one path at a time and try to go as deep as possible into the levels of the tree before going for the next path. In order to implement this, we make use of a recursive function <code>dfs(maze, start, desination, visited)</code>. This function takes the given <script type="math/tex; mode=display">maze</script> array, the <script type="math/tex; mode=display">start</script> position and the <script type="math/tex; mode=display">destination</script> position as its arguments along with a <script type="math/tex; mode=display">visited</script> array. <script type="math/tex; mode=display">visited</script> array is a 2-D boolean array of the same size as that of <script type="math/tex; mode=display">maze</script>. A True value at <script type="math/tex; mode=display">visited[i][j]</script> represents that the current position has already been reached earlier during the path traversal. We make use of this array so as to keep track of the same paths being repeated over and over. We mark a True at the current position in the <script type="math/tex; mode=display">visited</script> array once we reach that particular positon in the <script type="math/tex; mode=display">maze</script>.</p>\n<p>From every <script type="math/tex; mode=display">start</script> position, we can move continuously in either left, right, upward or downward direction till we reach the boundary or a wall. Thus, from the <script type="math/tex; mode=display">start</script> position, we determine all the end points which can be reached by choosing the four directions. For each of the cases, the new endpoint will now act as the new start point for the traversals. The destination, obviously remains unchanged. Thus, now we call the same function four times for the four directions, each time with a new start point obtained previously. </p>\n<p>If any of the function call returns a True value, it means we can reach the desination. </p>\n<p>The following animation depicts the process:</p>\n<p>!?!../Documents/490_Maze_DFS.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="mNXpP4ZF" src="https://leetcode.com/playground/mNXpP4ZF/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(mn)</script>. Complete traversal of maze will be done in the worst case. Here, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> refers to the number of rows and coloumns of the maze.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>. <script type="math/tex; mode=display">visited</script> array of size <script type="math/tex; mode=display">m*n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-breadth-first-search-accepted">Approach #2 Breadth First Search [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The same search space tree can also be explored in a Depth First Search manner. In this case, we try to explore the search space on a level by level basis. i.e. We try to move in all the directions at every step. When all the directions have been explored and we still don\'t reach the destination, then only we proceed to the new set of traversals from the new positions obtained. </p>\n<p>In order to implement this, we make use of a <script type="math/tex; mode=display">queue</script>. We start with the ball at the <script type="math/tex; mode=display">start</script> position. For every current position, we add all the new positions possible by traversing in all the four directions(till reaching the wall or boundary) into the <script type="math/tex; mode=display">queue</script> to act as the new start positions and mark these positions as True in the <script type="math/tex; mode=display">visited</script> array. When all the directions have been covered up, we remove a position value, <script type="math/tex; mode=display">s</script>, from the front of the <script type="math/tex; mode=display">queue</script> and again continue the same process with <script type="math/tex; mode=display">s</script> acting as the new <script type="math/tex; mode=display">start</script> position. </p>\n<p>Further, in order to choose the direction of travel, we make use of a <script type="math/tex; mode=display">dir</script> array, which contains 4 entries. Each entry represents a  one-dimensional direction of travel. To travel in a particular direction, we keep on adding the particular entry of the <script type="math/tex; mode=display">dirs</script> array till we hit a wall or a boundary. For a particular start position, we do this process of <script type="math/tex; mode=display">dir</script> addition for all all the four directions possible.</p>\n<p>If we hit the destination position at any moment, we return a True directly indicating that the <script type="math/tex; mode=display">destination</script> position can be reached starting from the <script type="math/tex; mode=display">start</script> position. </p>\n<p>The following animation depicts the process:</p>\n<p>!?!../Documents/490_Maze_BFS.json:1000,563!?!</p>\n<iframe frameborder="0" height="513" name="5jvdfXTK" src="https://leetcode.com/playground/5jvdfXTK/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(mn)</script>. Complete traversal of maze will be done in the worst case. Here, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> refers to the number of rows and coloumns of the maze.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>. <script type="math/tex; mode=display">visited</script> array of size <script type="math/tex; mode=display">m*n</script> is used and <script type="math/tex; mode=display">queue</script> size can grow upto <script type="math/tex; mode=display">m*n</script> in worst case.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '491',
    name: 'Increasing Subsequences',
    acceptance: '38.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .\n</p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> [4, 6, 7, 7]\n<b>Output:</b> [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The length of the given array will not exceed 15.</li>\n<li>The range of integer in the given array is [-100,100].</li>\n<li>The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Yahoo'],
  },
  {
    id: '492',
    name: 'Construct the Rectangle',
    acceptance: '48.3%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>\nFor a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:</p><pre>1. The area of the rectangular web page you designed must equal to the given target area.\n<br>2. The width W should not be larger than the length L, which means L &gt;= W.\n<br>3. The difference between length L and width W should be as small as possible.\n</pre>\nYou need to output the length L and the width W of the web page you designed in sequence.\n<p></p>\n\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> 4\n<b>Output:</b> [2, 2]\n<b>Explanation:</b> The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. \nBut according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The given area won't exceed 10,000,000 and is a positive integer</li>\n<li>The web page's width and length you designed must be positive integers.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '493',
    name: 'Reverse Pairs',
    acceptance: '20.9%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given an array <code>nums</code>, we call <code>(i, j)</code> an <b><i>important reverse pair</i></b> if <code>i &lt; j</code> and <code>nums[i] &gt; 2*nums[j]</code>.</p>\n\n<p>You need to return the number of important reverse pairs in the given array.</p>\n\n<p><b>Example1:</b>\n</p><pre><b>Input</b>: [1,3,2,3,1]\n<b>Output</b>: 2\n</pre><p></p>\n\n<p><b>Example2:</b>\n</p><pre><b>Input</b>: [2,4,3,5,1]\n<b>Output</b>: 3\n</pre><p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The length of the given array will not exceed <code>50,000</code>.</li>\n<li>All the numbers in the input array are in the range of 32-bit integer.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-binary-search-tree-accepted">Approach #2 Binary Search Tree [Accepted]</a></li>\n<li><a href="#approach-3-bit-accepted">Approach #3 BIT [Accepted]</a></li>\n<li><a href="#approach-4-modified-merge-sort-accepted">Approach #4 Modified Merge Sort [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute force [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>Do as directed in the question. We can simply check all the pairs if they are important reverse pairs or not.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>Iterate over <script type="math/tex; mode=display">i</script> from <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">\\text{size} - 1</script>\n<ul>\n<li>Iterate over <script type="math/tex; mode=display">j</script> from <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">i - 1</script>\n<ul>\n<li>If <script type="math/tex; mode=display">\\text{nums[j]} > 2 * \\text{nums[i]}</script>, increment <script type="math/tex; mode=display">\\text{count}</script>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<iframe frameborder="0" height="258" name="uASZfEgx" src="https://leetcode.com/playground/uASZfEgx/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity: <script type="math/tex; mode=display">O(n^2)</script>\n<ul>\n<li>We iterate over all the possible pairs wherein (<script type="math/tex; mode=display">i<j</script>) in the array which is <script type="math/tex; mode=display">O(n^2)</script>\n</li>\n</ul>\n</li>\n<li>Space complexity: <script type="math/tex; mode=display">O(1)</script> only constant extra space is required for <script type="math/tex; mode=display">n</script>, <script type="math/tex; mode=display">count</script> etc.</li>\n</ul>\n<p><strong>Trivia</strong></p>\n<p>The above code can be expressed as one-liner in Python:</p>\n<p><em>Python</em></p>\n<iframe frameborder="0" height="88" name="s5b8yGJS" src="https://leetcode.com/playground/s5b8yGJS/shared" width="100%"></iframe>\n<p>Herein, we iterate over all the pairs and store the boolean values for <script type="math/tex; mode=display">\\text{nums[i]}>2*\\text{nums[j]}</script>. Finally, we count the number of <script type="math/tex; mode=display">\\text{true}</script> in the array and return the result.</p>\n<hr>\n<h4 id="approach-2-binary-search-tree-accepted">Approach #2 Binary Search Tree [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>In Approach #1, for each element <script type="math/tex; mode=display">i</script>, we searched the subarray <script type="math/tex; mode=display">[0,i)</script> for elements such that their value is greater than <script type="math/tex; mode=display">2*\\text{nums[i]}</script>. In the previous approach, the search is linear. However, we need to make the process efficient. Maybe, memoization can help, but since, we need to compare the elements, we cannot find a linear DP solution.</p>\n<p>Observe that the indices of the elements in subarray <script type="math/tex; mode=display">[0,i)</script> don\'t matter as we only require the count. So, we can sort the elements and perform binary search on the subarray. But, since the subarray keeps growing as we iterate to the next element, we need a data structure to store the previous result as well as to allow efficient searching(preferably <script type="math/tex; mode=display">O(log(n))</script>) - Binary Search Tree(BST) could be a good bet.   </p>\n<p><em>Refreshing BST</em></p>\n<p>BST is a rooted binary tree, wherein each node is associated with a value and has 2 distinguishable sub-trees namely <script type="math/tex; mode=display">left</script> and <script type="math/tex; mode=display">right</script> subtree. The left subtree contains only the nodes with lower values than the parent\'s value, while the right subtree conatins only the nodes with greater values than the parent\'s value.</p>\n<p><em>Voila!</em></p>\n<p>This is exactly what is required. So, if we store our elements in BST, then we can search the larger elements thus eliminating the search on smaller elements altogether.</p>\n<p><strong>Algorithm</strong></p>\n<p>Define the <script type="math/tex; mode=display">\\text{Node}</script> of BST that stores the <script type="math/tex; mode=display">\\text{val}</script> and pointers to the <script type="math/tex; mode=display">\\text{left}</script> and <script type="math/tex; mode=display">\\text{right}</script>. We also need a count of elements(say <script type="math/tex; mode=display">\\text{count_ge}</script>) in the subtree rooted at the current node that are greater than or equal to the current node\'s <script type="math/tex; mode=display">\\text{val}</script>. <script type="math/tex; mode=display">\\text{count_ge}</script> is initialized to 1 for each node and <script type="math/tex; mode=display">\\text{left}</script>, <script type="math/tex; mode=display">\\text{right}</script> pointers are set to <script type="math/tex; mode=display">\\text{NULL}</script>.</p>\n<p>We define the <script type="math/tex; mode=display">\\text{insert}</script> routine that recursively adds the given <script type="math/tex; mode=display">\\text{val}</script> as an appropriate leaf node based on comparisons with the <script type="math/tex; mode=display">Node.val</script>. Each time, the given <script type="math/tex; mode=display">val</script> is smaller than <script type="math/tex; mode=display">Node.val</script>, we increment the <script type="math/tex; mode=display">\\text{count_ge}</script> and move the <script type="math/tex; mode=display">val</script> to the right subtree. While, if the <script type="math/tex; mode=display">val</script> is equal to the current <script type="math/tex; mode=display">Node</script>, we simply increment the <script type="math/tex; mode=display">\\text{count_ge}</script> and exit. While, we move to the left subtree in case <script type="math/tex; mode=display">(\\text{val}<\\text{Node.val})</script>.</p>\n<p>We also require the <script type="math/tex; mode=display">search</script> routine that gives the count of number of elements greater than or equal to the <script type="math/tex; mode=display">\\text{target}</script>. In the <script type="math/tex; mode=display">\\text{search}</script> routine, if the <script type="math/tex; mode=display">head</script> is NULL, return 0. Otherwise, if <script type="math/tex; mode=display">\\text{target}==\\text{head.val}</script>, we know the count of values greater than or equal to the <script type="math/tex; mode=display">\\text{target}</script>, hence simply return <script type="math/tex; mode=display">\\text{head.count_ge}</script>. In case, <script type="math/tex; mode=display">\\text{target}<\\text{head.val}</script>, the ans is calculated by adding <script type="math/tex; mode=display">\\text{Node.count_ge}</script> and recursively calling the <script type="math/tex; mode=display">\\text{search}</script> routine with <script type="math/tex; mode=display">\\text{head.left}</script>. And if <script type="math/tex; mode=display">\\text{target}>\\text{head.val}</script>, ans is obtained by recursively calling the <script type="math/tex; mode=display">\\text{search}</script> routine with <script type="math/tex; mode=display">\\text{head.right}</script>.</p>\n<p>Now, we can get to our main logic:</p>\n<ul>\n<li>Iterate over <script type="math/tex; mode=display">i</script> from <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">(size-1)</script> of <script type="math/tex; mode=display">\\text{nums}</script> :<ul>\n<li>Search the existing BST for <script type="math/tex; mode=display">\\text{nums[i]} * 2 + 1</script> and add the result to <script type="math/tex; mode=display">\\text{count}</script>\n</li>\n<li>Insert <script type="math/tex; mode=display">\\text{nums[i]}</script> to the BST, hence updating the <script type="math/tex; mode=display">\\text{count_ge}</script> of the previous nodes</li>\n</ul>\n</li>\n</ul>\n<p>The algorithm can be better understood using the example below:\n!?!../Documents/493_reverse_pairs.json:1000,662!?!</p>\n<iframe frameborder="0" height="515" name="5xoZwFd2" src="https://leetcode.com/playground/5xoZwFd2/shared" width="100%"></iframe>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>Time complexity: <script type="math/tex; mode=display">O(n^2)</script>\n<ul>\n<li>The best case complexity for BST is <script type="math/tex; mode=display">O(log(n))</script> for search as well as insertion, wherein, the tree formed is complete binary tree</li>\n<li>Whereas, in case like [1,2,3,4,5,6,7,8,...], insertion as well as search for an element becomes <script type="math/tex; mode=display">O(n)</script> in time, since, the tree is skewed in only one direction, and hence, is no better than the array</li>\n<li>So, in worst case, for searching and insertion over n items, the complexity is <script type="math/tex; mode=display">O(n*n)</script>\n</li>\n</ul>\n</li>\n<li>Space complexity: <script type="math/tex; mode=display">O(n)</script> extra space for storing the BST in <script type="math/tex; mode=display">\\text{Node}</script> class.</li>\n</ul>\n<hr>\n<h4 id="approach-3-bit-accepted">Approach #3 BIT [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>The problem with BST is that the tree can be skewed hence, making it <script type="math/tex; mode=display">O(n^2)</script> in complexity. So, need a data structure that remains balanced. We could either use a Red-black or AVL tree to make a balanced BST, but the implementation would be an overkill for the solution. We can use BIT (Binary Indexed Tree, also called Fenwick Tree) to ensure that the complexity is <script type="math/tex; mode=display">O(nlog(n))</script> with only 12-15 lines of code.</p>\n<p><em>BIT Overview:</em></p>\n<p>Fenwick Tree or BIT provides a way to represent an array of numbers in an array(can be visualized as tree), allowing prefix/suffix sums to be calculated efficiently(<script type="math/tex; mode=display">O(log(n))</script>). BIT allows to update an element in <script type="math/tex; mode=display">O(log(n))</script> time.</p>\n<p>We recommend having a look at BIT from the following links before getting into details:</p>\n<ul>\n<li><a href="https://www.youtube.com/watch?v=CWDQJGaN1gY">https://www.youtube.com/watch?v=CWDQJGaN1gY</a></li>\n<li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/">https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/</a></li>\n</ul>\n<p>So, BIT is very useful to accumulate information from front/back and hence, we can use it in the same way we used BST to get the count of elements that are greater than or equal to <script type="math/tex; mode=display">2 * \\text{nums[i]} + 1</script> in the existing tree and then adding the current element to the tree.</p>\n<p><strong>Algorithm</strong></p>\n<p>First, lets review the BIT <script type="math/tex; mode=display">\\text{query}</script> and <script type="math/tex; mode=display">\\text{update}</script> routines of BIT. According to the convention, <script type="math/tex; mode=display">\\text{query}</script> routine goes from <script type="math/tex; mode=display">\\text{index}</script> to <script type="math/tex; mode=display">0</script>, i.e., <script type="math/tex; mode=display">\\text{BIT[i]}</script> gives the sum for the range <script type="math/tex; mode=display">[0,index]</script>, and <script type="math/tex; mode=display">\\text{update}</script> updates the values from current <script type="math/tex; mode=display">\\text{index}</script> to the end of array. But, since, we require to find the numbers greater than the given index, as and when we update an index, we update all the ancestors of the node in the tree, and for <script type="math/tex; mode=display">\\text{search}</script>, we go from the node to the end.   </p>\n<p>The modified <script type="math/tex; mode=display">\\text{update}</script> algorithm is:</p>\n<div class="codehilite"><pre><span></span>update(BIT,index, val):\n  while(index&lt;0):\n    BIT[index]+=val\n    index-=(index&amp;(-index))\n</pre></div>\n<p>Herein, we find get the next index using: <script type="math/tex; mode=display">\\text{index-=index&(-index)}</script>, which is essentially subtracting the rightmost 1 from the <script type="math/tex; mode=display">\\text{index}</script> binary representation. We update the previous indices since, if an element is greater than the index</p>\n<p>And the modified <script type="math/tex; mode=display">\\text{query}</script> algorithm is:</p>\n<div class="codehilite"><pre><span></span>query(BIT,index):\n  sum=0\n  while(index&lt;BIT.size):\n    sum+=BIT[index]\n    index+=(index&amp;(-index))\n</pre></div>\n<p>Herein, we find get the next index using: <script type="math/tex; mode=display">\\text{index+=index&(-index)}</script>. This gives the suffix sum from <script type="math/tex; mode=display">index</script> to the end.</p>\n<p>So, the main idea is to count the number of elements greater than <script type="math/tex; mode=display">2*\\text{nums[i]}</script> in range <script type="math/tex; mode=display">[0,i)</script> as we iterate from <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">\\text{size-1}</script>. The steps are as follows:</p>\n<ul>\n<li>Create a copy of <script type="math/tex; mode=display">\\text{nums}</script>, say <script type="math/tex; mode=display">\\text{nums_copy}</script> ans sort <script type="math/tex; mode=display">\\text{nums_copy}</script>. This array is actually used for creating the Binary indexed tree</li>\n<li>Initialize <script type="math/tex; mode=display">\\text{count}=0</script> and <script type="math/tex; mode=display">\\text{BIT}</script> array of size <script type="math/tex; mode=display">\\text{size(nums)} + 1</script> to store the BIT</li>\n<li>Iterate over <script type="math/tex; mode=display">i</script> from <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">\\text{size(nums)}-1</script> :<ul>\n<li>Search the index of element not less than <script type="math/tex; mode=display">2*\\text{nums[i]}+1</script> in <script type="math/tex; mode=display">\\text{nums_copy}</script> array. <script type="math/tex; mode=display">\\text{query}</script> the obtained index+1 in the <script type="math/tex; mode=display">\\text{BIT}</script>, and add the result to <script type="math/tex; mode=display">\\text{count}</script>\n</li>\n<li>Search for the index of element not less than <script type="math/tex; mode=display">nums[i]</script> in <script type="math/tex; mode=display">\\text{nums_copy}</script>. We need to <script type="math/tex; mode=display">\\text{update}</script> the BIT for this index by 1. This essentially means that 1 is added to this index(or number of elements greater than this index is incremented). The effect of adding <script type="math/tex; mode=display">1</script> to the index is passed to the ancestors as shown in <script type="math/tex; mode=display">\\text{update}</script> algorithm</li>\n</ul>\n</li>\n</ul>\n<iframe frameborder="0" height="515" name="ckjEGCCm" src="https://leetcode.com/playground/ckjEGCCm/shared" width="100%"></iframe>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>Time complexity: <script type="math/tex; mode=display">O(nlog(n))</script>\n<ul>\n<li>In <script type="math/tex; mode=display">\\text{query}</script> and <script type="math/tex; mode=display">\\text{update}</script> operations, we see that the loop iterates at most the number of bits in <script type="math/tex; mode=display">\\text{index}</script> which can be at most <script type="math/tex; mode=display">n</script>. Hence, the complexity of both the operations is <script type="math/tex; mode=display">O(log(n))</script>(Number of bits in <script type="math/tex; mode=display">n</script> is <script type="math/tex; mode=display">log(n)</script>)</li>\n<li>The in-built operation <script type="math/tex; mode=display">\\text{lower_bound}</script> is binary search hence <script type="math/tex; mode=display">O(log(n))</script>\n</li>\n<li>We perform the operations for <script type="math/tex; mode=display">n</script> elements, hence the total complexity is <script type="math/tex; mode=display">O(nlog(n))</script>\n</li>\n</ul>\n</li>\n<li>Space complexity: <script type="math/tex; mode=display">O(n)</script>. Additional space for <script type="math/tex; mode=display">\\text{BITS}</script> array</li>\n</ul>\n<hr>\n<h4 id="approach-4-modified-merge-sort-accepted">Approach #4 Modified Merge Sort [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>In BIT and BST, we iterate over the array, dividing the array into 3 sections: already visited and hence added to the tree, current node and section to be visited. Another approach could be divide the problem into smaller subproblems, solving them and combining these problems to get the final result - Divide and conquer. We see that the problem has a great resemblance to the merge sort routine. The question is to find the inversions such that <script type="math/tex; mode=display">\\text{nums[i]}>2 * \\text{nums[j]}</script> and <script type="math/tex; mode=display">i<j</script>. So, we can easily modify the merge sort to count the inversions as required.</p>\n<p><em>Mergesort</em></p>\n<p>Mergesort is a divide-and-conquer based sorting technique that operates in <script type="math/tex; mode=display">O(nlog(n))</script> time. The basic idea to divide the array into several sub-arrays until each sub-array is single element long and merging these sublists recursively that results in the final sorted array.</p>\n<p><strong>Algorithm</strong></p>\n<p>We define <script type="math/tex; mode=display">\\text{mergesort_and_count}</script> routine that takes parameters an array say <script type="math/tex; mode=display">A</script> and <script type="math/tex; mode=display">\\text{start}</script> and <script type="math/tex; mode=display">\\text{end}</script> indices:</p>\n<ul>\n<li>If <script type="math/tex; mode=display">\\text{start}</script>&gt;=<script type="math/tex; mode=display">\\text{end}</script> this implies that elements can no longer be broken further and hence we return 0</li>\n<li>Otherwise, set <script type="math/tex; mode=display">\\text{mid}=(\\text{start} + \\text{end})/2</script>\n</li>\n<li>Store <script type="math/tex; mode=display">count</script> by recursively calling <script type="math/tex; mode=display">\\text{mergesort_and_count}</script> on range <script type="math/tex; mode=display">\\text{[start,mid]}</script> and <script type="math/tex; mode=display">\\text{[mid+1,end]}</script> and adding the results. This is the divide step on our routine, breaking it into the 2 ranges, and finding the results for each range separately</li>\n<li>Now, we that we have separately calculated the results for ranges <script type="math/tex; mode=display">\\text{[start,mid]}</script> and <script type="math/tex; mode=display">\\text{[mid+1,end]}</script>, but we still have to count the elements in <script type="math/tex; mode=display">\\text{[start,mid]}</script> that are greater than 2 * elements in <script type="math/tex; mode=display">\\text{[mid+1,end]}</script>. Count all such elements and add the result to <script type="math/tex; mode=display">\\text{count}</script>\n</li>\n<li>Finally, <script type="math/tex; mode=display">\\text{merge}</script> the array from <script type="math/tex; mode=display">\\text{start}</script> to <script type="math/tex; mode=display">\\text{end}</script>\n<ul>\n<li>Make 2 array : <script type="math/tex; mode=display">L</script> from elements in range <script type="math/tex; mode=display">\\text{[start,mid]}</script> and <script type="math/tex; mode=display">R</script> from elements in range <script type="math/tex; mode=display">\\text{R[mid+1,end]}</script>\n</li>\n<li>Keep pointers <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> to <script type="math/tex; mode=display">L</script> and <script type="math/tex; mode=display">R</script> respectively both initialized to start to the arrays</li>\n<li>Iterate over <script type="math/tex; mode=display">k</script> from <script type="math/tex; mode=display">\\text{start}</script> to <script type="math/tex; mode=display">\\text{end}</script> and set <script type="math/tex; mode=display">\\text{A[k]}</script> to the smaller of <script type="math/tex; mode=display">\\text{L[i]}</script> or <script type="math/tex; mode=display">\\text{R[j]}</script> and increment the respective index</li>\n</ul>\n</li>\n</ul>\n<iframe frameborder="0" height="515" name="PVpymxwQ" src="https://leetcode.com/playground/PVpymxwQ/shared" width="100%"></iframe>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>Time complexity: <script type="math/tex; mode=display">O(nlog(n))</script>\n<ul>\n<li>In each step we divide the array into 2 sub-arrays, and hence, the maximum times we need to divide is equal to <script type="math/tex; mode=display">O(log(n))</script>\n</li>\n<li>Additional <script type="math/tex; mode=display">O(n)</script> work needs to be done to count the inversions and to merge the 2 sub-arrays after sorting. Hence total time complexity is <script type="math/tex; mode=display">O(n * log(n))</script>\n</li>\n</ul>\n</li>\n<li>Space complexity: <script type="math/tex; mode=display">O(n)</script>. Additional space for storing <script type="math/tex; mode=display">L</script> and <script type="math/tex; mode=display">R</script> arrays</li>\n</ul>\n<hr>\n<p>Analysis written by <a href="https://leetcode.com/abhinavbansal0">@abhinavbansal0</a>.</p>\n<p>Shoutout to <a href="https://discuss.leetcode.com/user/fun4leetcode">@FUN4LEETCODE</a> for the brilliant post!</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '494',
    name: 'Target Sum',
    acceptance: '43.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nYou are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols <code>+</code> and <code>-</code>. For each integer, you should choose one from <code>+</code> and <code>-</code> as its new symbol.\n</p> \n\n<p>Find out how many ways to assign symbols to make sum of integers equal to target S.  \n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> nums is [1, 1, 1, 1, 1], S is 3. \n<b>Output:</b> 5\n<b>Explanation:</b> \n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n\nThere are 5 ways to assign symbols to make the sum of nums be target 3.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The length of the given array is positive and will not exceed 20. </li>\n<li>The sum of elements in the given array will not exceed 1000.</li>\n<li>Your output answer is guaranteed to be fitted in a 32-bit integer.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-recursion-with-memoization-accepted">Approach #2 Recursion with memoization [Accepted]</a></li>\n<li><a href="#approach-3-2d-dynamic-programming-accepted">Approach #3 2D Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-4-1d-dynamic-programming-accepted">Approach #4 1D Dynamic Programming [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The brute force approach is based on recursion. We need to try to put both the <code>+</code> and <code>-</code> symbols at every location in the given <script type="math/tex; mode=display">nums</script> array and find out the assignments which lead to the required result <script type="math/tex; mode=display">S</script>.</p>\n<p>For this, we make use of a recursive function <code>calculate(nums, i, sum, S)</code>, which returns the assignments leading to the sum <script type="math/tex; mode=display">S</script>, starting from the <script type="math/tex; mode=display">i^{th}</script> index onwards, provided the sum of elements upto the <script type="math/tex; mode=display">i^{th}</script> element is <script type="math/tex; mode=display">sum</script>. This function appends a <code>+</code> sign and a <code>-</code> sign both to the element at the current index and calls itself with the updated <script type="math/tex; mode=display">sum</script> as <script type="math/tex; mode=display">sum + nums[i]</script> and <script type="math/tex; mode=display">sum - nums[i]</script> repectively along with the updated current index as <script type="math/tex; mode=display">i+1</script>.  Whenver, we reach the end of the array, we compare the sum obtained with <script type="math/tex; mode=display">S</script>. If they are equal, we increment the <script type="math/tex; mode=display">count</script> value to be returned.</p>\n<p>Thus, the function call <code>calculate(nums, 0, 0, S)</code> retuns the required no. of assignments.</p>\n<iframe frameborder="0" height="326" name="zHJSM65m" src="https://leetcode.com/playground/zHJSM65m/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(2^n)</script>. Size of recursion tree will be <script type="math/tex; mode=display">2^n</script>. <script type="math/tex; mode=display">n</script> refers to the size of <script type="math/tex; mode=display">nums</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of the recursion tree can go upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-recursion-with-memoization-accepted">Approach #2 Recursion with memoization [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>It can be easily observed that in the last approach, a lot of redundant function calls could be made with the same value of <script type="math/tex; mode=display">i</script> as the current index and the same value of <script type="math/tex; mode=display">sum</script> as the current sum, since the same values could be obtained through multiple paths in the recursion tree. In order to remove this redundancy, we make use of memoization as well to store the results which have been calculated earlier.</p>\n<p>Thus, for every call to <code>calculate(nums, i, sum, S)</code>, we store the result obtained in <script type="math/tex; mode=display">memo[i][sum + 1000]</script>. The factor of 1000 has been added as an offset to the <script type="math/tex; mode=display">sum</script> value to map all the <script type="math/tex; mode=display">sum</script>s possible to positive integer range. By making use of memoization, we can prune the search space to a good extent.</p>\n<iframe frameborder="0" height="496" name="jAQP4A3v" src="https://leetcode.com/playground/jAQP4A3v/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(l*n)</script>. The <script type="math/tex; mode=display">memo</script> array of size <script type="math/tex; mode=display">l*n</script> has been filled just once. Here, <script type="math/tex; mode=display">l</script> refers to the range of <script type="math/tex; mode=display">sum</script> and <script type="math/tex; mode=display">n</script> refers to the size of <script type="math/tex; mode=display">nums</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of recursion tree can go upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-2d-dynamic-programming-accepted">Approach #3 2D Dynamic Programming [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The idea behind this approach is as follows. Suppose we can find out the number of times a particular sum, say <script type="math/tex; mode=display">sum_i</script> is possible upto a particular index, say <script type="math/tex; mode=display">i</script>, in the given <script type="math/tex; mode=display">nums</script> array, which is given by say <script type="math/tex; mode=display">count_i</script>. Now, we can find out the number of times the sum <script type="math/tex; mode=display">sum_i + nums[i]</script> can occur easily as <script type="math/tex; mode=display">count_i</script>. Similarly, the number of times the sum <script type="math/tex; mode=display">sum_i - nums[i]</script> occurs is also given by <script type="math/tex; mode=display">count_i</script>. </p>\n<p>Thus, if we know all the sums <script type="math/tex; mode=display">sum_j</script>\'s which are possible upto the <script type="math/tex; mode=display">j^{th}</script> index by using various assignments, along with the corresponding count of assignments, <script type="math/tex; mode=display">count_j</script>, leading to the same sum, we can determine all the sums possible upto the <script type="math/tex; mode=display">(j+1)^{th}</script> index  along with the corresponding count of assignments leading to the new sums.</p>\n<p>Based on this idea, we make use of a <script type="math/tex; mode=display">dp</script> to determine the number of assignments which can lead to the given sum. <script type="math/tex; mode=display">dp[i][j]</script> refers to the number of assignments which can lead to a sum of <script type="math/tex; mode=display">j</script> upto the <script type="math/tex; mode=display">i^{th}</script> index. To determine the number of assignments which can lead to a sum of <script type="math/tex; mode=display">sum + nums[i]</script> upto the <script type="math/tex; mode=display">(i+1)^{th}</script> index, we can use <script type="math/tex; mode=display">dp[i][sum + nums[i]] = dp[i][sum + nums[i]] + dp[i-1][sum]</script>. Similarly, <script type="math/tex; mode=display">dp[i][sum - nums[i]] = dp[i][sum + nums[i]] + dp[i-1][sum]</script>. We iterate over the <script type="math/tex; mode=display">dp</script> array in a rowwise fashion i.e. Firstly we obtain all the sums which are possible upto a particular index along with the corresponding count of assignments and then proceed for the next element(index) in the <script type="math/tex; mode=display">nums</script> array.</p>\n<p>But, since the $$sum can range from -1000 to +1000, we need to add an offset of 1000 to the sum indices (column number) to map all the sums obtained to positive range only. </p>\n<p>At the end, the value of <script type="math/tex; mode=display">dp[n-1][S+1000]</script> gives us the required number of assignments. Here, <script type="math/tex; mode=display">n</script> refers to the number of elements in the <script type="math/tex; mode=display">nums</script> array.</p>\n<p>The animation below shows the way various sums are generated along with the corresponding indices. The example assumes <script type="math/tex; mode=display">sum</script> values to lie in the range of -6 to +6 just for the purpose of illustration. This animation is inspired by <a href="http://leetcode.com/Chidong">@Chidong</a></p>\n<p>!?!../Documents/494_Target_Sum.json:1000,563!?!</p>\n<iframe frameborder="0" height="326" name="PfZkp9b3" src="https://leetcode.com/playground/PfZkp9b3/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(l*n)</script>. The entire <script type="math/tex; mode=display">nums</script> array is travesed 2001(constant no.: <script type="math/tex; mode=display">l</script>) times. <script type="math/tex; mode=display">n</script> refers to the size of <script type="math/tex; mode=display">nums</script> array. <script type="math/tex; mode=display">l</script> refers to the range of <script type="math/tex; mode=display">sum</script> possible.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(l*n)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">l*n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-1d-dynamic-programming-accepted">Approach #4 1D Dynamic Programming [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>If we look closely at the last solution, we can observe that for the evaluation of the current row of <script type="math/tex; mode=display">dp</script>, only the values of the last row of <script type="math/tex; mode=display">dp</script> are needed. Thus, we can save some space by using a 1D DP array instead of a 2-D DP array. The only difference that needs to be made is that now the same <script type="math/tex; mode=display">dp</script> array will be updated for every row traversed. </p>\n<p>Below code is inspired by <a href="http://leetcode.com/Chidong">@Chidong</a></p>\n<iframe frameborder="0" height="360" name="YJzJ5KpW" src="https://leetcode.com/playground/YJzJ5KpW/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(l.n)</script>. The entire <script type="math/tex; mode=display">nums</script> array is traversed <script type="math/tex; mode=display">l</script> times. <script type="math/tex; mode=display">n</script> refers to the size of <script type="math/tex; mode=display">nums</script> array. <script type="math/tex; mode=display">l</script> refers to the range of <script type="math/tex; mode=display">sum</script> possible.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google', 'Facebook'],
  },
  {
    id: '495',
    name: 'Teemo Attacking',
    acceptance: '51.6%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nIn LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking <b>ascending</b> time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.\n</p>\n\n<p>You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,4], 2\n<b>Output:</b> 4\n<b>Explanation:</b> At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. <br>This poisoned status will last 2 seconds until the end of time point 2. <br>And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. <br>So you finally need to output 4.\n</pre>\n<p></p>\n\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [1,2], 2\n<b>Output:</b> 3\n<b>Explanation:</b> At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. <br>This poisoned status will last 2 seconds until the end of time point 2. <br>However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. <br>Since the poisoned status won't add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. <br>So you finally need to output 3.\n</pre>\n<p></p>\n\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>You may assume the length of given time series array won't exceed 10000.</li>\n<li>You may assume the numbers in the Teemo's attacking time series and his poisoning time duration per attacking are non-negative integers, which won't exceed 10,000,000.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Riot Games'],
  },
  {
    id: '496',
    name: 'Next Greater Element I',
    acceptance: '56.5%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>\nYou are given two arrays <b>(without duplicates)</b> <code>nums1</code> and <code>nums2</code> where <code>nums1</code>’s elements are subset of <code>nums2</code>. Find all the next greater numbers for <code>nums1</code>'s elements in the corresponding places of <code>nums2</code>. \n</p>\n\n<p>\nThe Next Greater Number of a number <b>x</b> in <code>nums1</code> is the first greater number to its right in <code>nums2</code>. If it does not exist, output -1 for this number.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> <b>nums1</b> = [4,1,2], <b>nums2</b> = [1,3,4,2].\n<b>Output:</b> [-1,3,-1]\n<b>Explanation:</b>\n    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.\n    For number 1 in the first array, the next greater number for it in the second array is 3.\n    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> <b>nums1</b> = [2,4], <b>nums2</b> = [1,2,3,4].\n<b>Output:</b> [3,-1]\n<b>Explanation:</b>\n    For number 2 in the first array, the next greater number for it in the second array is 3.\n    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.\n</pre>\n<p></p>\n\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>All elements in <code>nums1</code> and <code>nums2</code> are unique.</li>\n<li>The length of both <code>nums1</code> and <code>nums2</code> would not exceed 1000.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</a></li>\n<li><a href="#approach-3-using-stack-accepted">Approach #3 Using Stack [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>You are given two arrays (without duplicates) <script type="math/tex; mode=display">findNums</script> and <script type="math/tex; mode=display">nums</script> where <script type="math/tex; mode=display">findNums</script>’s elements are subset of <script type="math/tex; mode=display">nums</script>.Find all the\nnext greater\nnumbers for <script type="math/tex; mode=display">findNums</script>\'s elements in the corresponding places of <script type="math/tex; mode=display">nums</script>.</p>\n<p>The Next Greater Number of a number x in <script type="math/tex; mode=display">findNums</script> is the first greater number to its right in <script type="math/tex; mode=display">nums</script>. If it does not exist, output -1 for\nthis number.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</h4>\n<p>In this method, we pick up every element of the <script type="math/tex; mode=display">findNums</script> array(say <script type="math/tex; mode=display">findNums[i]</script>) and then search for its own occurence in the <script type="math/tex; mode=display">nums</script> array(which is\n indicated by setting <script type="math/tex; mode=display">found</script> to True). After this, we look linearly for a number in <script type="math/tex; mode=display">nums</script> which is greater than <script type="math/tex; mode=display">findNums[i]</script>, which\n is also added to the <script type="math/tex; mode=display">res</script> array to be returned. If no such element is found, we put a <script type="math/tex; mode=display">\\text{-1}</script> at the corresponding location.</p>\n<iframe frameborder="0" height="428" name="FEQ5JHVr" src="https://leetcode.com/playground/FEQ5JHVr/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. The complete <script type="math/tex; mode=display">nums</script> array(of size <script type="math/tex; mode=display">n</script>) needs to be scanned for all the <script type="math/tex; mode=display">m</script> elements of <script type="math/tex; mode=display">findNums</script> in\n the worst case.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(m)</script>. <script type="math/tex; mode=display">res</script> array of size <script type="math/tex; mode=display">m</script> is used, where <script type="math/tex; mode=display">m</script> is the length of <script type="math/tex; mode=display">findNums</script> array.</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</h4>\n<p>Instead of searching for the occurence of <script type="math/tex; mode=display">findNums[i]</script> linearly in the <script type="math/tex; mode=display">nums</script> array, we can make use of a hashmap <script type="math/tex; mode=display">hash</script> to store\nthe elements of <script type="math/tex; mode=display">nums</script> in the form of <script type="math/tex; mode=display">(element, index)</script>. By doing this, we can find <script type="math/tex; mode=display">findNums[i]</script>\'s index in <script type="math/tex; mode=display">nums</script> array directly and\nthen continue to search for the next larger element in a linear fashion.</p>\n<iframe frameborder="0" height="445" name="xtBuL7iz" src="https://leetcode.com/playground/xtBuL7iz/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. The whole <script type="math/tex; mode=display">nums</script> array, of length <script type="math/tex; mode=display">n</script> needs to be scanned for all the <script type="math/tex; mode=display">m</script> elements of <script type="math/tex; mode=display">finalNums</script> in the worst case.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m)</script>. <script type="math/tex; mode=display">res</script> array of size <script type="math/tex; mode=display">m</script> is used. A hashmap <script type="math/tex; mode=display">hash</script> of size <script type="math/tex; mode=display">m</script> is used, where <script type="math/tex; mode=display">m</script> refers to the\n length of the <script type="math/tex; mode=display">findNums</script> array.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-stack-accepted">Approach #3 Using Stack [Accepted]</h4>\n<p>In this approach, we make use of pre-processing first so as to make the results easily available later on.\n We make use of a stack(<script type="math/tex; mode=display">stack</script>) and a hashmap(<script type="math/tex; mode=display">map</script>). <script type="math/tex; mode=display">map</script> is used to store the result for every posssible number in <script type="math/tex; mode=display">nums</script> in\nthe form of <script type="math/tex; mode=display">(element, next\\_greater\\_element)</script>. Now, we look at how to make entries in <script type="math/tex; mode=display">map</script>.</p>\n<p>We iterate over the <script type="math/tex; mode=display">nums</script> array\nfrom the left to right. We push every element <script type="math/tex; mode=display">nums[i]</script> on the stack if it is less than the previous element on the top of the stack\n(<script type="math/tex; mode=display">stack[top]</script>). No entry is made in <script type="math/tex; mode=display">map</script> for such <script type="math/tex; mode=display">nums[i]\'s</script> right now. This happens because\nthe <script type="math/tex; mode=display">nums[i]\'s</script> encountered so far are coming in a descending order.</p>\n<p>If we encounter an element <script type="math/tex; mode=display">nums[i]</script> such that <script type="math/tex; mode=display">nums[i] > stack[top]</script>, we keep on popping all the elements\nfrom <script type="math/tex; mode=display">stack[top]</script> until we encounter <script type="math/tex; mode=display">stack[k]</script> such that <script type="math/tex; mode=display">stack[k] &leq; nums[i]</script>. For every element popped out of the stack\n<script type="math/tex; mode=display">stack[j]</script>, we put the popped element along with its next greater number(result) into the hashmap <script type="math/tex; mode=display">map</script>, in the form\n<script type="math/tex; mode=display">(stack[j], nums[i])</script> . Now, it is obvious that the\nnext greater element for all elements <script type="math/tex; mode=display">stack[j]</script>, such that <script type="math/tex; mode=display">k < j &le; top</script> is <script type="math/tex; mode=display">nums[i]</script>(since this larger element caused all the\n<script type="math/tex; mode=display">stack[j]</script>\'s to be popped out). We stop popping the elements at <script type="math/tex; mode=display">stack[k]</script> because this <script type="math/tex; mode=display">nums[i]</script> can\'t act as the next greater element\nfor the next elements on the stack.</p>\n<p>Thus, an element is popped out of the stack whenever a next greater element is found for it. Thus, the elements remaining in the stack are the\nones for which no next greater element exists in the <script type="math/tex; mode=display">nums</script> array. Thus, at the end of the iteration over <script type="math/tex; mode=display">nums</script>, we pop the remaining\nelements from the <script type="math/tex; mode=display">stack</script> and put their entries in <script type="math/tex; mode=display">hash</script> with a <script type="math/tex; mode=display">\\text{-1}</script> as their corresponding results.</p>\n<p>Then, we can simply iterate over the <script type="math/tex; mode=display">findNums</script> array to find the corresponding results from <script type="math/tex; mode=display">map</script> directlhy.</p>\n<p>The following animation makes the method clear:</p>\n<p>!?!../Documents/496_Next_Greater_Element_I.json:1280,720!?!</p>\n<iframe frameborder="0" height="360" name="hvr7nhcH" src="https://leetcode.com/playground/hvr7nhcH/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m+n)</script>. The entire <script type="math/tex; mode=display">nums</script> array(of size <script type="math/tex; mode=display">n</script>) is scanned only once. The stack\'s <script type="math/tex; mode=display">n</script> elements are popped\n only once. The <script type="math/tex; mode=display">findNums</script> array is also scanned only once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m+n)</script>. <script type="math/tex; mode=display">stack</script> and <script type="math/tex; mode=display">map</script> of size <script type="math/tex; mode=display">n</script> is used. <script type="math/tex; mode=display">res</script> array of size <script type="math/tex; mode=display">m</script> is used, where <script type="math/tex; mode=display">n</script> refers to the\n length of the <script type="math/tex; mode=display">nums</script> array and <script type="math/tex; mode=display">m</script> refers to the length of the <script type="math/tex; mode=display">findNums</script> array.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '498',
    name: 'Diagonal Traverse',
    acceptance: '46.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image. \n</p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b>\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n<b>Output:</b>  [1,2,4,7,5,3,6,8,9]\n<b>Explanation:</b>\n<img src="https://leetcode.com/static/images/problemset/diagonal_traverse.png" width="20%">\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The total number of elements of the given matrix will not exceed 10,000.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '499',
    name: 'The Maze III ',
    acceptance: '33.1%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>There is a <b>ball</b> in a maze with empty spaces and walls. The ball can go through empty spaces by rolling <b>up</b> (u), <b>down</b> (d), <b>left</b> (l) or <b>right</b> (r), but it won\'t stop rolling until hitting a wall. When the ball stops, it could choose the next direction. There is also a <b>hole</b> in this maze. The ball will drop into the hole if it rolls on to the hole.</p>\n\n<p> Given the <b>ball position</b>, the <b>hole position</b> and the <b>maze</b>, find out how the ball could drop into the hole by moving the <b>shortest distance</b>. The distance is defined by the number of <b>empty spaces</b> traveled by the ball from the start position (excluded) to the hole (included). Output the moving <b>directions</b> by using \'u\', \'d\', \'l\' and \'r\'. Since there could be several different shortest ways, you should output the <b>lexicographically smallest</b> way. If the ball cannot reach the hole, output "impossible".</p>\n\n<p>The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The ball and the hole coordinates are represented by row and column indexes.</p>\n\n<p>\n<b>Example 1</b>\n</p><pre><b>Input 1:</b> a maze represented by a 2D array\n\n0 0 0 0 0\n1 1 0 0 1\n0 0 0 0 0\n0 1 0 0 1\n0 1 0 0 0\n\n<b>Input 2:</b> ball coordinate (rowBall, colBall) = (4, 3)\n<b>Input 3:</b> hole coordinate (rowHole, colHole) = (0, 1)\n\n<b>Output:</b> "lul"\n<b>Explanation:</b> There are two shortest ways for the ball to drop into the hole.\nThe first way is left -&gt; up -&gt; left, represented by "lul".\nThe second way is up -&gt; left, represented by \'ul\'.\nBoth ways have shortest distance 6, but the first way is lexicographically smaller because \'l\' &lt; \'u\'. So the output is "lul".\n<img src="https://leetcode.com/static/images/problemset/maze_2_example_1.png" width="30%">\n</pre>\n<p></p>\n\n<p>\n<b>Example 2</b>\n</p><pre><b>Input 1:</b> a maze represented by a 2D array\n\n0 0 0 0 0\n1 1 0 0 1\n0 0 0 0 0\n0 1 0 0 1\n0 1 0 0 0\n\n<b>Input 2:</b> ball coordinate (rowBall, colBall) = (4, 3)\n<b>Input 3:</b> hole coordinate (rowHole, colHole) = (3, 0)\n<b>Output:</b> "impossible"\n<b>Explanation:</b> The ball cannot reach the hole.\n<img src="https://leetcode.com/static/images/problemset/maze_2_example_2.png" width="30%">\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>There is only one ball and one hole in the maze.</li>\n<li>Both the ball and hole exist on an empty space, and they will not be at the same position initially.</li>\n<li>The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.</li>\n<li>The maze contains at least 2 empty spaces, and the width and the height of the maze won\'t exceed 30.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '500',
    name: 'Keyboard Row',
    acceptance: '59.8%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a List of words, return the words that can be typed using letters of <b>alphabet</b> on only one row\'s of American keyboard like the image below. </p>\n\n<br>\n<p>\n<img src="https://leetcode.com/static/images/problemset/keyboard.png" alt="American keyboard">\n</p>\n<br>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> ["Hello", "Alaska", "Dad", "Peace"]\n<b>Output:</b> ["Alaska", "Dad"]\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>You may use one character in the keyboard more than once.</li>\n<li>You may assume the input string will only contain letters of alphabet.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Mathworks'],
  },
  {
    id: '501',
    name: 'Find Mode in Binary Search Tree',
    acceptance: '37.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a binary search tree (BST) with duplicates, find all the <a href="https://en.wikipedia.org/wiki/Mode_(statistics)" target="_blank">mode(s)</a> (the most frequently occurred element) in the given BST.</p>\n\n<p>\nAssume a BST is defined as follows:\n</p><ul>\n<li>The left subtree of a node contains only nodes with keys <b>less than or equal to</b> the node\'s key.</li>\n<li>The right subtree of a node contains only nodes with keys <b>greater than or equal to</b> the node\'s key.</li>\n<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n<p></p>\n\n<p>\nFor example:<br>\nGiven BST <code>[1,null,2,2]</code>,<br>\n</p><pre>   1\n    \\\n     2\n    /\n   2\n</pre>\n<p></p>\n<p>\nreturn <code>[2]</code>.\n</p>\n\n<p><b>Note:</b>\nIf a tree has more than one mode, you can return them in any order.\n</p>\n\n<p><b>Follow up:</b>\nCould you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '502',
    name: 'IPO',
    acceptance: '36.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nSuppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most <b>k</b> distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most <b>k</b> distinct projects. \n</p>\n\n<p>\nYou are given several projects. For each project <b>i</b>, it has a pure profit <b>P<sub>i</sub></b> and a minimum capital of <b>C<sub>i</sub></b> is needed to start the corresponding project. Initially, you have <b>W</b> capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n</p>\n\n<p>\nTo sum up, pick a list of at most <b>k</b> distinct projects from given projects to maximize your final capital, and output your final maximized capital.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].\n\n<b>Output:</b> 4\n\n<b>Explanation:</b> Since your initial capital is 0, you can only start the project indexed 0.\n             After finishing it you will obtain profit 1 and your capital becomes 1.\n             With capital 1, you can either start the project indexed 1 or the project indexed 2.\n             Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\n             Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>You may assume all numbers in the input are non-negative integers.</li>\n<li>The length of Profits array and Capital array will not exceed 50,000.</li>\n<li>The answer is guaranteed to fit in a 32-bit signed integer.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '503',
    name: 'Next Greater Element II',
    acceptance: '47.6%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nGiven a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,2,1]\n<b>Output:</b> [2,-1,2]\n<b>Explanation:</b> The first 1's next greater number is 2; <br>The number 2 can't find next greater number; <br>The second 1's next greater number needs to search circularly, which is also 2.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\nThe length of given array won't exceed 10000.\n</p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-using-double-length-array-time-limit-exceeded">Approach #1 Brute Force (using Double Length Array) [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</a></li>\n<li><a href="#approach-3-using-stack-accepted">Approach #3 Using Stack [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-using-double-length-array-time-limit-exceeded">Approach #1 Brute Force (using Double Length Array) [Time Limit Exceeded]</h4>\n<p>In this method, we make use of an array <script type="math/tex; mode=display">doublenums</script> which is formed by concatenating two copies of the given <script type="math/tex; mode=display">nums</script> array one after the other. Now, when we need to find out the next greater element for <script type="math/tex; mode=display">nums[i]</script>, we can simply scan all the elements <script type="math/tex; mode=display">doublenums[j]</script>, such that <script type="math/tex; mode=display">i < j < length(doublenums)</script>. The first element found satisfying the given condition is the required result for <script type="math/tex; mode=display">nums[i]</script>. If no such element is found, we put a <script type="math/tex; mode=display">\\text{-1}</script> at the appropriate position in the <script type="math/tex; mode=display">res</script> array.</p>\n<iframe frameborder="0" height="377" name="tRcR8Lx3" src="https://leetcode.com/playground/tRcR8Lx3/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. The complete <script type="math/tex; mode=display">doublenums</script> array(of size <script type="math/tex; mode=display">\\text{2n}</script>) is scanned for all the elements of <script type="math/tex; mode=display">nums</script> in the worst case.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">doublenums</script> array of size <script type="math/tex; mode=display">\\text{2n}</script> is used. <script type="math/tex; mode=display">res</script> array of size <script type="math/tex; mode=display">\\text{n}</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</h4>\n<p>Instead of making a double length copy of <script type="math/tex; mode=display">nums</script> array , we can traverse circularly in the <script type="math/tex; mode=display">nums</script> array by making use of the <script type="math/tex; mode=display">\\text{%(modulus)}</script> operator. For every element <script type="math/tex; mode=display">nums[i]</script>, we start searching in the <script type="math/tex; mode=display">nums</script> array(of length <script type="math/tex; mode=display">n</script>) from the index <script type="math/tex; mode=display">(i+1)%n</script> and look at the next(cicularly) <script type="math/tex; mode=display">n-1</script> elements. For <script type="math/tex; mode=display">nums[i]</script> we do so by scanning over <script type="math/tex; mode=display">nums[j]</script>, such that\n<script type="math/tex; mode=display">(i+1)%n &leq; j &leq; (i+(n-1))%n</script>, and we look for the first greater element found. If no such element is found, we put a <script type="math/tex; mode=display">\\text{-1}</script> at the appropriate position in the <script type="math/tex; mode=display">res</script> array.</p>\n<iframe frameborder="0" height="309" name="LCG759JD" src="https://leetcode.com/playground/LCG759JD/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. The complete <script type="math/tex; mode=display">nums</script> array of size <script type="math/tex; mode=display">n</script> is scanned for all the elements of <script type="math/tex; mode=display">nums</script> in the worst case.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">res</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-stack-accepted">Approach #3 Using Stack [Accepted]</h4>\n<p>This approach makes use of a stack. This stack stores the indices of the appropriate elements from <script type="math/tex; mode=display">nums</script> array.  The top of the stack refers to the index of the Next Greater Element found so far. We store the indices instead of the elements since there could be duplicates in the <script type="math/tex; mode=display">nums</script> array. The description of the method will make the above statement clearer.</p>\n<p>We start traversing the <script type="math/tex; mode=display">nums</script> array from right towards the left. For an element <script type="math/tex; mode=display">nums[i]</script> encountered, we pop all the elements\n<script type="math/tex; mode=display">stack[top]</script> from the stack such that <script type="math/tex; mode=display">nums\\big[stack[top]\\big] &le; nums[i]</script>. We continue the popping till we encounter a <script type="math/tex; mode=display">stack[top]</script> satisfying <script type="math/tex; mode=display">nums\\big[stack[top]\\big] > nums[i]</script>. Now, it is obvious that the current <script type="math/tex; mode=display">stack[top]</script> only can act as the\nNext Greater Element for <script type="math/tex; mode=display">nums[i]</script>(right now, considering only the elements lying to the right of <script type="math/tex; mode=display">nums[i]</script>).</p>\n<p>If no element remains on the top of the stack, it means no larger element than <script type="math/tex; mode=display">nums[i]</script> exists to its right. Along with this, we also push the index of the element just encountered(<script type="math/tex; mode=display">nums[i]</script>), i.e. <script type="math/tex; mode=display">i</script> over the top of the stack, so that <script type="math/tex; mode=display">nums[i]</script>(or <script type="math/tex; mode=display">stack[top</script>) now acts as the Next Greater Element for the elements lying to its left.</p>\n<p>We go through two such passes over the complete <script type="math/tex; mode=display">nums</script> array. This is done so as to complete a circular traversal over the <script type="math/tex; mode=display">nums</script> array. The first pass could make some wrong entries in the <script type="math/tex; mode=display">res</script> array since it considers only the elements lying to the right of <script type="math/tex; mode=display">nums[i]</script>, without a circular traversal. But, these entries are corrected in the second pass.  </p>\n<p>Further, to ensure the correctness of the method, let\'s look at the following cases.</p>\n<p>Assume that <script type="math/tex; mode=display">nums[j]</script> is the correct Next Greater Element for <script type="math/tex; mode=display">nums[i]</script>, such that <script type="math/tex; mode=display">i < j &le; stack[top]</script>. Now, whenever we encounter <script type="math/tex; mode=display">nums[j]</script>, if <script type="math/tex; mode=display">nums[j] > nums\\big[stack[top]\\big]</script>, it would have already popped the previous <script type="math/tex; mode=display">stack[top]</script> and <script type="math/tex; mode=display">j</script> would have become the topmost element. On the other hand, if  <script type="math/tex; mode=display">nums[j] < nums\\big[stack[top]\\big]</script>, it would have become the topmost element by being pushed above the previous <script type="math/tex; mode=display">stack[top]</script>. In both the cases, if <script type="math/tex; mode=display">nums[j] > nums[i]</script>, it will be correctly determined to be the Next Greater Element.</p>\n<p>The following example makes the procedure clear:</p>\n<!--![Next_Greater_Element_II](https://leetcode.com/articles/Figures/503_Next_Greater_Element_II.gif)-->\n<p>!?!../Documents/503_Next_Greater2.json:1000,563!?!</p>\n<p>As the animation above depicts, after the first pass, there are a number of wrong entries(marked as <script type="math/tex; mode=display">\\text{-1}</script>) in the <script type="math/tex; mode=display">res</script> array, because only the elements lying to the corresponding right(non-circular) have been considered till now. But, after the second pass, the correct values are substituted.</p>\n<iframe frameborder="0" height="309" name="in37fqRd" src="https://leetcode.com/playground/in37fqRd/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Only two traversals of the <script type="math/tex; mode=display">nums</script> array are done. Further, atmost <script type="math/tex; mode=display">\\text{2n}</script> elements are pushed and popped from the stack.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. A stack of size <script type="math/tex; mode=display">n</script> is used. <script type="math/tex; mode=display">res</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '504',
    name: 'Base 7',
    acceptance: '44.1%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given an integer, return its base 7 string representation.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> 100\n<b>Output:</b> "202"\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> -7\n<b>Output:</b> "-10"\n</pre>\n<p></p>\n\n<p><b>Note:</b>\nThe input will be in range of [-1e7, 1e7].\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '505',
    name: 'The Maze II ',
    acceptance: '38.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>There is a <b>ball</b> in a maze with empty spaces and walls. The ball can go through empty spaces by rolling <b>up</b>, <b>down</b>, <b>left</b> or <b>right</b>, but it won\'t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.</p>\n\n<p>Given the ball\'s <b>start position</b>, the <b>destination</b> and the <b>maze</b>, find the shortest distance for the ball to stop at the destination. The distance is defined by the number of <b>empty spaces</b> traveled by the ball from the start position (excluded) to the destination (included). If the ball cannot stop at the destination, return -1.</p>\n\n<p>The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.</p>\n\n<p>\n<b>Example 1</b>\n</p><pre><b>Input 1:</b> a maze represented by a 2D array\n\n0 0 1 0 0\n0 0 0 0 0\n0 0 0 1 0\n1 1 0 1 1\n0 0 0 0 0\n\n<b>Input 2:</b> start coordinate (rowStart, colStart) = (0, 4)\n<b>Input 3:</b> destination coordinate (rowDest, colDest) = (4, 4)\n\n<b>Output:</b> 12\n<b>Explanation:</b> One shortest way is : left -&gt; down -&gt; left -&gt; down -&gt; right -&gt; down -&gt; right.\n             The total distance is 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12.\n<img src="https://leetcode.com/static/images/problemset/maze_1_example_1.png" width="30%">\n</pre>\n<p></p>\n\n<p>\n<b>Example 2</b>\n</p><pre><b>Input 1:</b> a maze represented by a 2D array\n\n0 0 1 0 0\n0 0 0 0 0\n0 0 0 1 0\n1 1 0 1 1\n0 0 0 0 0\n\n<b>Input 2:</b> start coordinate (rowStart, colStart) = (0, 4)\n<b>Input 3:</b> destination coordinate (rowDest, colDest) = (3, 2)\n\n<b>Output:</b> -1\n<b>Explanation:</b> There is no way for the ball to stop at the destination.\n<img src="https://leetcode.com/static/images/problemset/maze_1_example_2.png" width="30%">\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>There is only one ball and one destination in the maze.</li>\n<li>Both the ball and the destination exist on an empty space, and they will not be at the same position initially.</li>\n<li>The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.</li>\n<li>The maze contains at least 2 empty spaces, and both the width and height of the maze won\'t exceed 100.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-depth-first-search-accepted">Approach #1 Depth First Search [Accepted]</a></li>\n<li><a href="#approach-2-using-breadth-first-search-accepted">Approach #2 Using Breadth First Search [Accepted]</a></li>\n<li><a href="#approach-3-using-dijkstra-algorithm-accepted">Approach #3 Using Dijkstra Algorithm [Accepted]</a></li>\n<li><a href="#approach-4-using-dijkstra-algorithm-and-priority-queueaccepted">Approach #4 Using Dijkstra Algorithm and Priority Queue[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-depth-first-search-accepted">Approach #1 Depth First Search [Accepted]</h4>\n<p>We can view the given search space in the form of a tree. The root node of the tree represents the starting position. Four different routes are possible from each position i.e. left, right, up or down. These four options can be represented by 4 branches of each node in the given tree. Thus, the new node reached from the root traversing over the branch represents the new position occupied by the ball after choosing the corresponding direction of travel.</p>\n<p><img alt="Maze_Tree" src="https://leetcode.com/articles/Figures/490_Maze_Tree.PNG"></p>\n<p>In order to do this traversal, one of the simplest schemes is to undergo depth first search. We make use of a recursive function <code>dfs</code> for this. From every current position, we try to go as deep as possible into the levels of a tree taking a particular branch traversal direction as possible. When one of the deepest levels is exhausted, we continue the process by reaching the next deepest levels of the tree. In order to travel in the various directions from the current position, we make use of a <script type="math/tex; mode=display">dirs</script> array. <script type="math/tex; mode=display">dirs</script> is an array with 4 elements, where each of the elements represents a single step of a one-dimensional movement. For travelling in a particular direction, we keep on adding the appropriate <script type="math/tex; mode=display">dirs</script> element in the current position till the ball hits a boundary or a wall.</p>\n<p>We start with the given <script type="math/tex; mode=display">start</script> position, and try to explore these directions represented by the <script type="math/tex; mode=display">dirs</script> array one by one. For every element <script type="math/tex; mode=display">dir</script> of the <script type="math/tex; mode=display">dirs</script> chosen for the current travelling direction, we determine how far can the ball travel in this direction prior to hitting a wall or a boundary. We keep a track of the number of steps using <script type="math/tex; mode=display">count</script> variable. </p>\n<p>Apart from this, we also make use of a 2-D <script type="math/tex; mode=display">distance</script> array. <script type="math/tex; mode=display">distance[i][j]</script> represents the minimum number of steps required to reach the positon <script type="math/tex; mode=display">(i, j)</script> starting from the <script type="math/tex; mode=display">start</script> position. This array is initialized with largest integer values in the beginning. </p>\n<p>When we reach any position next to a boundary or a wall during the traversal in a particular direction, as discussed earlier, we keep a track of the number of steps taken in the last direction in <script type="math/tex; mode=display">count</script> variable. Suppose, we reach the position <script type="math/tex; mode=display">(i,j)</script> starting from the last position <script type="math/tex; mode=display">(k,l)</script>. Now, for this position, we need to determine the minimum number of steps taken to reach this position starting from the <script type="math/tex; mode=display">start</script> position. For this, we check if the current path takes lesser steps to reach <script type="math/tex; mode=display">(i,j)</script> than any other previous path taken to reach the same position i.e. we check if <script type="math/tex; mode=display">distance[k][l] + count</script> is lesser than <script type="math/tex; mode=display">distance[i][j]</script>. If not, we continue the process of traversal from the position <script type="math/tex; mode=display">(k,l)</script> in the next direction.</p>\n<p>If <script type="math/tex; mode=display">distance[k][l] + count</script> is lesser than <script type="math/tex; mode=display">distance[i][j]</script>, we can reach the position <script type="math/tex; mode=display">(i,j)</script> from the current route in lesser number of steps. Thus, we need to update the value of <script type="math/tex; mode=display">distance[i][j]</script> as <script type="math/tex; mode=display">distance[k][l] + count</script>. Further, now we need to try to reach the destination, <script type="math/tex; mode=display">dest</script>, from the end position <script type="math/tex; mode=display">(i,j)</script>, since this could lead to a shorter path to <script type="math/tex; mode=display">dest</script>. Thus, we again call the same function <code>dfs</code> but with the position <script type="math/tex; mode=display">(i,j)</script> acting as the current position. </p>\n<p>After this, we try to explore the routes possible by choosing all the other directions of travel from the current position <script type="math/tex; mode=display">(k,l)</script> as well.</p>\n<p>At the end, the entry in distance array corresponding to the destination, <script type="math/tex; mode=display">dest</script>\'s coordinates gives the required minimum distance to reach the destination. If the destination can\'t be reached, the corresponding entry will contain <script type="math/tex; mode=display">\\text{Integer.MAX_VALUE}</script>.</p>\n<p>The following animation depicts the process.</p>\n<p>!?!../Documents/505_Maze2_DFS.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="9KoQFAmz" src="https://leetcode.com/playground/9KoQFAmz/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n*\\text{max}(m,n))</script>. Complete traversal of maze will be done in the worst case. Here, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> refers to the number of rows and columns of the maze. Further, for every current node chosen, we can travel upto a maximum depth of <script type="math/tex; mode=display">\\text{max}(m,n)</script> in any direction.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>. <script type="math/tex; mode=display">distance</script> array of size <script type="math/tex; mode=display">m*n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-breadth-first-search-accepted">Approach #2 Using Breadth First Search [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of making use of Depth First Search for exploring the search space, we can make use of Breadth First Search as well. In this, instead of exploring the search space on a depth basis, we traverse the search space(tree) on a level by level basis i.e. we explore all the new positions that can be reached starting from the current position first, before moving onto the next positions that can be reached from these new positions. </p>\n<p>In order to make a traversal in any direction, we again make use of <script type="math/tex; mode=display">dirs</script> array as in the DFS approach. Again, whenever we make a traversal in any direction, we keep a track of the number of steps taken while moving in this direction in <script type="math/tex; mode=display">count</script> variable as done in the last approach. We also make use of <script type="math/tex; mode=display">distance</script> array initialized with very large values in the beginning. <script type="math/tex; mode=display">distance[i][j]</script> again represents the minimum number of steps required to reach the position <script type="math/tex; mode=display">(i,j)</script> from the <script type="math/tex; mode=display">start</script> position. </p>\n<p>This approach differs from the last approach only in the way the search space is explored. In order to reach the new positions in a Breadth First Search order, we make use of a <script type="math/tex; mode=display">queue</script>, which contains the new positions to be explored in the future. We start from the current position <script type="math/tex; mode=display">(k,l)</script>, try to traverse in a particular direction, obtain the corresponding <script type="math/tex; mode=display">count</script> for that direction, reaching an end position of <script type="math/tex; mode=display">(i,j)</script> just near the boundary or a wall. If the position <script type="math/tex; mode=display">(i,j)</script> can be reached in a lesser number of steps from the current route than any other previous route checked, indicated by <script type="math/tex; mode=display">distance[k][l] + count < distance[i][j]</script>, we need to update <script type="math/tex; mode=display">distance[i][j]</script> as <script type="math/tex; mode=display">distance[k][l] + count</script>. </p>\n<p>After this, we add the new position obtained, <script type="math/tex; mode=display">(i,j)</script> to the back of a <script type="math/tex; mode=display">queue</script>, so that the various paths possible from this new position will be explored later on when all the directions possible from the current position <script type="math/tex; mode=display">(k,l)</script> have been explored. After exploring all the directions from the current position, we remove an element from the front of the <script type="math/tex; mode=display">queue</script> and continue checking the routes possible through all the directions now taking the new position(obtained from the <script type="math/tex; mode=display">queue</script>) as the current position. </p>\n<p>Again, the entry in distance array corresponding to the destination, <script type="math/tex; mode=display">dest</script>\'s coordinates gives the required minimum distance to reach the destination. If the destination can\'t be reached, the corresponding entry will contain <script type="math/tex; mode=display">\\text{Integer.MAX_VALUE}</script>.</p>\n<iframe frameborder="0" height="515" name="58PgnMeA" src="https://leetcode.com/playground/58PgnMeA/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n*max(m,n))</script>. Time complexity : <script type="math/tex; mode=display">O(m*n*\\text{max}(m,n))</script>. Complete traversal of maze will be done in the worst case. Here, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> refers to the number of rows and columns of the maze. Further, for every current node chosen, we can travel upto a maximum depth of <script type="math/tex; mode=display">\\text{max}(m,n)</script> in any direction.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>. <script type="math/tex; mode=display">queue</script> size can grow upto <script type="math/tex; mode=display">m*n</script> in the worst case.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-dijkstra-algorithm-accepted">Approach #3 Using Dijkstra Algorithm [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Before we look into this approach, we take a quick overview of Dijkstra\'s Algorithm. </p>\n<p>Dijkstra\'s Algorithm is a very famous graph algorithm, which is used to find the shortest path from any <script type="math/tex; mode=display">start</script> node to any <script type="math/tex; mode=display">destination</script> node in the given weighted graph(the edges of the graph represent the distance between the nodes). </p>\n<p>The algorithm consists of the following steps:</p>\n<ol>\n<li>\n<p>Assign a tentative distance value to every node: set it to zero for our <script type="math/tex; mode=display">start</script> node and to infinity for all other nodes.</p>\n</li>\n<li>\n<p>Set the <script type="math/tex; mode=display">start</script> node as <script type="math/tex; mode=display">current</script> node. Mark it as visited.</p>\n</li>\n<li>\n<p>For the <script type="math/tex; mode=display">current</script> node, consider all of its neighbors and calculate their tentative distances. Compare the newly calculated tentative distance to the current assigned value and assign the smaller one to all the neighbors. For example, if the current node A is marked with a distance of 6, and the edge connecting it with a neighbor B has length 2, then the distance to B (through A) will be 6 + 2 = 8. If B was previously marked with a distance greater than 8 then change it to 8. Otherwise, keep the current value.</p>\n</li>\n<li>\n<p>When we are done considering all of the neighbors of the current node, mark the <script type="math/tex; mode=display">current</script> node as visited. A visited node will never be checked again.</p>\n</li>\n<li>\n<p>If the <script type="math/tex; mode=display">destination</script> node has been marked visited  or if the smallest tentative distance among all the nodes left is infinity(indicating that the <script type="math/tex; mode=display">destination</script> can\'t be reached), then stop. The algorithm has finished.</p>\n</li>\n<li>\n<p>Otherwise, select the unvisited node that is marked with the smallest tentative distance, set it as the new <script type="math/tex; mode=display">current</script> node, and go back to step 3.</p>\n</li>\n</ol>\n<p>The working of this algorithm can be understood by taking two simple examples. Consider the first set of nodes as shown below. </p>\n<p><img alt="Dijkstra_Graph" src="https://leetcode.com/articles/Figures/505_Maze2_1.PNG"></p>\n<p>Suppose that the node <script type="math/tex; mode=display">b</script> is at a shorter distance from the <script type="math/tex; mode=display">start</script> node <script type="math/tex; mode=display">a</script> as compared to <script type="math/tex; mode=display">c</script>, but the distance from <script type="math/tex; mode=display">a</script> to the <script type="math/tex; mode=display">destination</script> node, <script type="math/tex; mode=display">e</script>, is shorter through the node <script type="math/tex; mode=display">c</script> itself. In this case, we need to check if the Dijkstra\'s algorithm works correctly, since the node <script type="math/tex; mode=display">b</script> is considered first while selecting the nodes being at a shorter distance from <script type="math/tex; mode=display">a</script>. Let\'s look into this.</p>\n<ol>\n<li>\n<p>Firstly, we choose <script type="math/tex; mode=display">a</script> as the <script type="math/tex; mode=display">start</script> node, mark it as visited and update the <script type="math/tex; mode=display">distance_b</script> and <script type="math/tex; mode=display">distance_c</script> values. Here, <script type="math/tex; mode=display">distance_i</script> represents the distance of node <script type="math/tex; mode=display">i</script> from the <script type="math/tex; mode=display">start</script> node.</p>\n</li>\n<li>\n<p>Since <script type="math/tex; mode=display">distance_b < distance_c</script>, <script type="math/tex; mode=display">b</script> is chosen as the next node for calculating the distances. We mark <script type="math/tex; mode=display">b</script> as visited. Now, we update the <script type="math/tex; mode=display">distance_e</script> value as <script type="math/tex; mode=display">distance_b + weight_{be}</script>. </p>\n</li>\n<li>\n<p>Now, <script type="math/tex; mode=display">c</script> is obviously the next node to be chosen as per the conditions of the assumptions taken above. (For path to <script type="math/tex; mode=display">e</script> through <script type="math/tex; mode=display">c</script> to be  shorter than path to <script type="math/tex; mode=display">e</script> through <script type="math/tex; mode=display">c</script>, <script type="math/tex; mode=display">distance_c < distance_b + weight_{be}</script>. From <script type="math/tex; mode=display">c</script>, we determine the distance to node <script type="math/tex; mode=display">e</script>. Since <script type="math/tex; mode=display">distance_c + weight_{ce}</script> is shorter than the previous value of <script type="math/tex; mode=display">distance_e</script>, we update <script type="math/tex; mode=display">distance_e</script> with the correct shorter value.</p>\n</li>\n<li>\n<p>We choose <script type="math/tex; mode=display">e</script> as the current node. No other distances need to be updated. Thus, we mark <script type="math/tex; mode=display">e</script> as visited. <script type="math/tex; mode=display">distance_e</script> now gives the required shortest distance.</p>\n</li>\n</ol>\n<p>The above example proves that even if a locally closer node is chosen as the current node first, the ultimate shortest distance to any node is calculated correctly.</p>\n<p>Let\'s take another example to demonstrate that the visited node needs not be chosen again as the current node. </p>\n<p><img alt="Dijkstra_Graph" src="https://leetcode.com/articles/Figures/505_Maze2_2.PNG"></p>\n<p>Suppose <script type="math/tex; mode=display">a</script> is the <script type="math/tex; mode=display">start</script> node and <script type="math/tex; mode=display">e</script> is the <script type="math/tex; mode=display">destination</script> node. Now, suppose we visit <script type="math/tex; mode=display">b</script> first and mark it as visited, but later on we find that another path exists through <script type="math/tex; mode=display">c</script> to <script type="math/tex; mode=display">b</script>, which makes the <script type="math/tex; mode=display">distance_b</script> shorter than the previous value. But, because of this, we need to consider <script type="math/tex; mode=display">b</script> as the current node again, since it would affect the value of <script type="math/tex; mode=display">distance_e</script>. But, if we observe closely, such a situation would never occur, because for <script type="math/tex; mode=display">weight_{ac} + weight_{cb}</script> to be lesser than <script type="math/tex; mode=display">weight_{ab}</script>, <script type="math/tex; mode=display">weight_{ac} < weight_{ab}</script> in the first place. Thus, <script type="math/tex; mode=display">b</script> would never be marked <script type="math/tex; mode=display">visited</script> before <script type="math/tex; mode=display">c</script>, which contradicts the first assumption. This proves that the <script type="math/tex; mode=display">visited</script> node needs not be chosen as the current node again.</p>\n<p>The given problem is also a shortest distance finding problem with a slightly different set of rules. Thus, we can make use of Dijkstra\'s Algorithm to determine the minimum number of steps to reach the destination.</p>\n<p>The methodology remains the same as the DFS or BFS Approach discussed above, except the order in which the current positions are chosen. We again make use of a <script type="math/tex; mode=display">distance</script> array to keep a track of the minimum number of steps needed to reach every position from the <script type="math/tex; mode=display">start</script> position. At every step, we choose a position which hasn\'t been marked as visited and which is at the shortest distance from the <script type="math/tex; mode=display">start</script> position to be the current position. We mark this position as visited so that we don\'t consider this position as the current position again.</p>\n<p>From the current position, we determine the number of steps required to reach all the positions possible travelling from the current position(in all the four directions possible till hitting a wall/boundary). If it is possible to reach any position through the current route with a lesser number of steps than the earlier routes considered, we update the corresponding <script type="math/tex; mode=display">distance</script> entry. We continue the same process for the other directions as well for the current position. </p>\n<p>In order to determine the current node, we make use of <code>minDistance</code> function, in which we traverse over the whole <script type="math/tex; mode=display">distance</script> array and find out an unvisited node at the shortest distance from the <script type="math/tex; mode=display">start</script> node.</p>\n<p>At the end, the entry in <script type="math/tex; mode=display">distance</script> array corresponding to the <script type="math/tex; mode=display">destination</script> position gives the required minimum number of steps.\nIf the destination can\'t be reached, the corresponding entry will contain <script type="math/tex; mode=display">\\text{Integer.MAX_VALUE}</script>.</p>\n<iframe frameborder="0" height="515" name="L8dvTQnh" src="https://leetcode.com/playground/L8dvTQnh/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O((mn)^2)</script>. Complete traversal of maze will be done in the worst case and function <code>minDistance</code> takes <script type="math/tex; mode=display">O(mn)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>. <script type="math/tex; mode=display">distance</script> array of size <script type="math/tex; mode=display">m*n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-dijkstra-algorithm-and-priority-queueaccepted">Approach #4 Using Dijkstra Algorithm and Priority Queue[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, in order to choose the current node, we traversed over the whole <script type="math/tex; mode=display">distance</script> array and found out an unvisited node at the shortest distance from the <script type="math/tex; mode=display">start</script> node. Rather than doing this, we can do the same task much efficiently by making use of a Priority Queue, <script type="math/tex; mode=display">queue</script>. This priority queue is implemented internally in the form of a heap. The criteria used for heapifying is that the node which is unvisited and at the smallest distance from the <script type="math/tex; mode=display">start</script> node, is always present on the top of the heap. Thus, the node to be chosen as the current node, is always present at the front of the <script type="math/tex; mode=display">queue</script>. </p>\n<p>For every current node, we again try to traverse in all the possible directions. We determine the minimum number of steps(till now) required to reach all the end points possible from the current node. If any such end point can be reached in a lesser number of steps through the current path than the paths previously considered, we need to update its <script type="math/tex; mode=display">distance</script> entry. </p>\n<p>Further, we add an entry corresponding to this node in the <script type="math/tex; mode=display">queue</script>, since its <script type="math/tex; mode=display">distance</script> entry has been updated and we need to consider this node as the competitors for the next current node choice. Thus, the process remains the same as the last approach, except the way in which the pick out the current node(which is the unvisited node at the shortest distance from the <script type="math/tex; mode=display">start</script> node).</p>\n<iframe frameborder="0" height="515" name="iyiLhqSD" src="https://leetcode.com/playground/iyiLhqSD/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(mn*log(mn)\\big)</script>. Complete traversal of maze will be done in the worst case giving a factor of <script type="math/tex; mode=display">mn</script>. Further, <code>poll</code> method is a combination of heapifying(<script type="math/tex; mode=display">O\\big(log(n)\\big)</script>) and removing the top element(<script type="math/tex; mode=display">O(1)</script>) from the priority queue, and it takes <script type="math/tex; mode=display">O(n)</script> time for <script type="math/tex; mode=display">n</script> elements. In the current case, <code>poll</code> introduces a factor of <script type="math/tex; mode=display">log(mn)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(mn)</script>. <script type="math/tex; mode=display">distance</script> array of size <script type="math/tex; mode=display">m*n</script> is used and <script type="math/tex; mode=display">queue</script> size can grow upto <script type="math/tex; mode=display">m*n</script> in worst case.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '506',
    name: 'Relative Ranks',
    acceptance: '46.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven scores of <b>N</b> athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: "Gold Medal", "Silver Medal" and "Bronze Medal".</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [5, 4, 3, 2, 1]\n<b>Output:</b> ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"]\n<b>Explanation:</b> The first three athletes got the top three highest scores, so they got "Gold Medal", "Silver Medal" and "Bronze Medal". <br>For the left two athletes, you just need to output their relative ranks according to their scores.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>N is a positive integer and won\'t exceed 10,000.</li>\n<li>All the scores of athletes are guaranteed to be unique.</li>\n</ol>\n<p></p>\n\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '507',
    name: 'Perfect Number',
    acceptance: '33.3%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>We define the Perfect Number is a <b>positive</b> integer that is equal to the sum of all its <b>positive</b> divisors except itself. \n</p>\nNow, given an <b>integer</b> n, write a function that returns true when it is a perfect number and false when it is not.\n<p></p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> 28\n<b>Output:</b> True\n<b>Explanation:</b> 28 = 1 + 2 + 4 + 7 + 14\n</pre>\n<p></p>\n\n<p><b>Note:</b>\nThe input number <b>n</b> will not exceed 100,000,000. (1e8)\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-optimal-solution-accepted">Approach #3 Optimal Solution [Accepted]</a></li>\n<li><a href="#approach-4-euclid-euler-theorem-accepted">Approach #4 Euclid-Euler Theorem [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In brute force approach, we consider every possible number to be a divisor of the given number <script type="math/tex; mode=display">num</script>, by iterating over all the numbers lesser than <script type="math/tex; mode=display">num</script>. Then, we add up all the factors to check if the given number satisfies the Perfect Number property. This approach obviously fails if the number <script type="math/tex; mode=display">num</script> is very large.</p>\n<iframe frameborder="0" height="343" name="6Nzf7w9h" src="https://leetcode.com/playground/6Nzf7w9h/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We iterate over all the numbers lesser than <script type="math/tex; mode=display">n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can little optimize the brute force by breaking the loop when the value of <script type="math/tex; mode=display">sum</script> increase the value of <script type="math/tex; mode=display">num</script>. In that case, we can directly return <script type="math/tex; mode=display">false</script>.</p>\n<iframe frameborder="0" height="377" name="bGGFxpmt" src="https://leetcode.com/playground/bGGFxpmt/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. In worst case, we iterate over all the numbers lesser than <script type="math/tex; mode=display">n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-optimal-solution-accepted">Approach #3 Optimal Solution [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this method, instead of iterating over all the integers to find the factors of <script type="math/tex; mode=display">num</script>, we only iterate upto the <script type="math/tex; mode=display">\\sqrt{n}</script>. The reasoning behind this can be understood as follows.</p>\n<p>Consider the given number <script type="math/tex; mode=display">num</script> which can have <script type="math/tex; mode=display">m</script> distinct factors, namely <script type="math/tex; mode=display">n_1, n_2,..., n_m</script>. Now, since the number <script type="math/tex; mode=display">num</script> is divisible by <script type="math/tex; mode=display">n_i</script>, it is also divisible by <script type="math/tex; mode=display">n_j=num/n_1</script> i.e. <script type="math/tex; mode=display">n_i*n_j=num</script>. Also, the largest number in such a pair can only be up to <script type="math/tex; mode=display">\\sqrt{num}</script> (because <script type="math/tex; mode=display">\\sqrt{num} \\times \\sqrt{num}=num</script>). Thus, we can get a significant reduction in the run-time by iterating only upto <script type="math/tex; mode=display">\\sqrt{num}</script> and considering such <script type="math/tex; mode=display">n_i</script>\'s and <script type="math/tex; mode=display">n_j</script>\'s in a single pass directly.</p>\n<p>Further, if <script type="math/tex; mode=display">\\sqrt{num}</script> is also a factor, we have to consider the factor only once while checking for the perfect number property.</p>\n<p>We sum up all such factors and check if the given number is a Perfect Number or not. Another point to be observed is that while considering 1 as such a factor, <script type="math/tex; mode=display">num</script> will also be considered as the other factor. Thus, we need to subtract <script type="math/tex; mode=display">num</script> from the <script type="math/tex; mode=display">sum</script>.</p>\n<iframe frameborder="0" height="377" name="ZpHuGfHj" src="https://leetcode.com/playground/ZpHuGfHj/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(\\sqrt{n})</script>. We iterate only over the range <script type="math/tex; mode=display">1 < i &leq; \\sqrt{num}</script>.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</li>\n</ul>\n<hr>\n<h4 id="approach-4-euclid-euler-theorem-accepted">Approach #4 Euclid-Euler Theorem [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Euclid proved that <script type="math/tex; mode=display">2^{p−1}(2^p − 1)</script> is an even perfect number whenever <script type="math/tex; mode=display">2^p − 1</script> is prime, where <script type="math/tex; mode=display">p</script> is prime.</p>\n<p>For example, the first four perfect numbers are generated by the formula <script type="math/tex; mode=display">2^{p−1}(2^p − 1)</script>, with <script type="math/tex; mode=display">p</script> a prime number, as follows:</p>\n<div class="codehilite"><pre><span></span>for p = 2:   21(22 − 1) = 6\nfor p = 3:   22(23 − 1) = 28\nfor p = 5:   24(25 − 1) = 496\nfor p = 7:   26(27 − 1) = 8128.\n</pre></div>\n<p>Prime numbers of the form <script type="math/tex; mode=display">2^p − 1</script> are known as Mersenne primes. For <script type="math/tex; mode=display">2^p − 1</script> to be prime, it is necessary that <script type="math/tex; mode=display">p</script> itself be prime. However, not all numbers of the form <script type="math/tex; mode=display">2^p − 1</script> with a prime <script type="math/tex; mode=display">p</script> are prime; for example, <script type="math/tex; mode=display">2^{11} − 1 = 2047 = 23 × 89</script> is not a prime number.</p>\n<p>You can see that for small value of <script type="math/tex; mode=display">p</script>, its related perfect number goes very high. So, we need to evaluate perfect numbers for some primes <script type="math/tex; mode=display">(2, 3, 5, 7, 13, 17, 19, 31)</script> only, as for bigger prime its perfect number will not fit in 64 bits.</p>\n<iframe frameborder="0" height="292" name="kBfJ6TtU" src="https://leetcode.com/playground/kBfJ6TtU/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(\\log{n})</script>. Number of primes will be in order <script type="math/tex; mode=display">\\log{num}</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(\\log{n})</script>. Space used to store primes.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Fallible'],
  },
  {
    id: '508',
    name: 'Most Frequent Subtree Sum',
    acceptance: '52.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.\n</p>\n\n<p><b>Examples 1</b><br>\nInput:\n</p><pre>  5\n /  \\\n2   -3\n</pre>\nreturn [2, -3, 4], since all the values happen only once, return all of them in any order.\n<p></p>\n\n<p><b>Examples 2</b><br>\nInput:\n</p><pre>  5\n /  \\\n2   -5\n</pre>\nreturn [2], since 2 happens twice, however -5 only occur once.\n<p></p>\n\n<p><b>Note:</b>\nYou may assume the sum of values in any subtree is in the range of 32-bit signed integer.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Amazon'],
  },
  {
    id: '513',
    name: 'Find Bottom Left Tree Value',
    acceptance: '56.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a binary tree, find the leftmost value in the last row of the tree. \n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre>Input:\n\n    2\n   / \\\n  1   3\n\nOutput:\n1\n</pre>\n<p></p>\n\n<p> <b> Example 2: </b><br>\n</p><pre>Input:\n\n        1\n       / \\\n      2   3\n     /   / \\\n    4   5   6\n       /\n      7\n\nOutput:\n7\n</pre>\n<p></p>\n\n<p><b>Note:</b>\nYou may assume the tree (i.e., the given root node) is not <b>NULL</b>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Microsoft'],
  },
  {
    id: '514',
    name: 'Freedom Trail',
    acceptance: '39.1%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nIn the video game Fallout 4, the quest "Road to Freedom" requires players to reach a metal dial called the "Freedom Trail Ring", and use the dial to spell a specific keyword in order to open the door. \n</p>\n\n<p>\nGiven a string <b>ring</b>, which represents the code engraved on the outer ring and another string <b>key</b>, which represents the keyword needs to be spelled. You need to find the <b>minimum</b> number of steps in order to spell all the characters in the keyword.\n</p>\nInitially, the first character of the <b>ring</b> is aligned at 12:00 direction. You need to spell all the characters in the string <b>key</b> one by one by rotating the ring clockwise or anticlockwise to make each character of the string <b>key</b> aligned at 12:00 direction and then by pressing the center button.\n<br>\n\nAt the stage of rotating the ring to spell the key character <b>key[i]</b>:\n<ol>\n<li>You can rotate the <b>ring</b> clockwise or anticlockwise <b>one place</b>, which counts as 1 step. The final purpose of the rotation is to align one of the string <b>ring\'s</b> characters at the 12:00 direction, where this character must equal to the character <b>key[i]</b>.\n\n</li><li>If the character <b>key[i]</b> has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you\'ve finished all the spelling.</li>\n</ol>\n\n<p></p>\n\n<p><b>Example:</b><br>\n</p><center>\n<img src="https://leetcode.com/static/images/problemset/ring.jpg" width="26%">\n</center>\n<br>\n<pre><b>Input:</b> ring = "godding", key = "gd"\n<b>Output:</b> 4\n<b>Explanation:</b><br> For the first key character \'g\', since it is already in place, we just need 1 step to spell this character. <br> For the second key character \'d\', we need to rotate the ring "godding" anticlockwise by two steps to make it become "ddinggo".<br> Also, we need 1 more step for spelling.<br> So the final output is 4.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>Length of both ring and <b>key</b> will be in range 1 to 100.</li>\n<li>There are only lowercase letters in both strings and might be some duplcate characters in both strings.</li>\n<li>It\'s guaranteed that string <b>key</b> could always be spelled by rotating the string <b>ring</b>.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '515',
    name: 'Find Largest Value in Each Tree Row',
    acceptance: '55.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>You need to find the largest value in each row of a binary tree.</p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> \n\n          1\n         / \\\n        3   2\n       / \\   \\  \n      5   3   9 \n\n<b>Output:</b> [1, 3, 9]\n</pre>\n<p></p>\n\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '516',
    name: 'Longest Palindromic Subsequence',
    acceptance: '42.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a string s, find the longest palindromic subsequence\'s length in s. You may assume that the maximum length of s is 1000.\n</p>\n\n<p><b>Example 1:</b><br>\nInput: \n</p><pre>"bbbab"\n</pre>\nOutput: \n<pre>4\n</pre>\nOne possible longest palindromic subsequence is "bbbb".\n<p></p>\n\n<p><b>Example 2:</b><br>\nInput:\n</p><pre>"cbbd"\n</pre>\nOutput:\n<pre>2\n</pre>\nOne possible longest palindromic subsequence is "bb".\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Amazon', 'Uber'],
  },
  {
    id: '517',
    name: 'Super Washing Machines',
    acceptance: '36.5%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>You have <b>n</b> super washing machines on a line. Initially, each washing machine has some dresses or is empty. \n</p>\n\n<p>For each <b>move</b>, you could choose <b>any m</b> (1 ≤ m ≤ n) washing machines, and pass <b>one dress</b> of each washing machine to one of its adjacent washing machines <b> at the same time </b>.  </p>\n\n<p>Given an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the <b>minimum number of moves</b> to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.</p>\n\n<p><b>Example1</b>\n</p><pre><b>Input:</b> [1,0,5]\n\n<b>Output:</b> 3\n\n<b>Explanation:</b> \n1st move:    1     0 &lt;-- 5    =&gt;    1     1     4\n2nd move:    1 &lt;-- 1 &lt;-- 4    =&gt;    2     1     3    \n3rd move:    2     1 &lt;-- 3    =&gt;    2     2     2   \n</pre>\n\n<p><b>Example2</b>\n</p><pre><b>Input:</b> [0,3,0]\n\n<b>Output:</b> 2\n\n<b>Explanation:</b> \n1st move:    0 &lt;-- 3     0    =&gt;    1     2     0    \n2nd move:    1     2 --&gt; 0    =&gt;    1     1     1     \n</pre>\n\n<p><b>Example3</b>\n</p><pre><b>Input:</b> [0,2,0]\n\n<b>Output:</b> -1\n\n<b>Explanation:</b> \nIt's impossible to make all the three washing machines have the same number of dresses. \n</pre>\n\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The range of n is [1, 10000].</li>\n<li>The range of dresses number in a super washing machine is [0, 1e5].</li>\n</ol>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Amazon'],
  },
  {
    id: '518',
    name: 'Coin Change 2',
    acceptance: '33.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nYou are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.\n</p>\n\n<p><b>Note:</b> \nYou can assume that\n</p><ul>\n<li> 0 &lt;= amount &lt;= 5000</li>\n<li> 1 &lt;= coin &lt;= 5000</li>\n<li> the number of coins is less than 500 </li>\n<li> the answer is guaranteed to fit into signed 32-bit integer\n</li></ul>\n<p></p>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b> amount = 5, coins = [1, 2, 5]\n<b>Output:</b> 4\n<b>Explanation:</b> there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n</pre><p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b> amount = 3, coins = [2]\n<b>Output:</b> 0\n<b>Explanation:</b> the amount of 3 cannot be made up just with coins of 2.\n</pre><p></p>\n\n<p><b>Example 3:</b>\n</p><pre><b>Input:</b> amount = 10, coins = [10] \n<b>Output:</b> 1\n</pre><p></p>\n\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '520',
    name: 'Detect Capital',
    acceptance: '52.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a word, you need to judge whether the usage of capitals in it is right or not.\n</p>\n\n<p>\nWe define the usage of capitals in a word to be right when one of the following cases holds:\n</p><ol>\n<li>All letters in this word are capitals, like "USA".</li>\n<li>All letters in this word are not capitals, like "leetcode".</li>\n<li>Only the first letter in this word is capital if it has more than one letter, like "Google".</li>\n</ol>\nOtherwise, we define that this word doesn\'t use capitals in a right way.\n<p></p>\n\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "USA"\n<b>Output:</b> True\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> "FlaG"\n<b>Output:</b> False\n</pre>\n<p></p>\n\n<p><b>Note:</b>\nThe input will be a non-empty word consisting of uppercase and lowercase latin letters.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '521',
    name: 'Longest Uncommon Subsequence I',
    acceptance: '55.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a group of two strings, you need to find the longest uncommon subsequence of this group of two strings.\nThe longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be <b>any</b> subsequence of the other strings.\n</p>\n\n<p>\nA <b>subsequence</b> is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.\n</p>\n\n<p>\nThe input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn\'t exist, return -1.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "aba", "cdc"\n<b>Output:</b> 3\n<b>Explanation:</b> The longest uncommon subsequence is "aba" (or "cdc"), <br>because "aba" is a subsequence of "aba", <br>but not a subsequence of any other strings in the group of two strings. \n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><ol>\n<li>Both strings\' lengths will not exceed 100.</li>\n<li>Only letters from a ~ z will appear in input strings. </li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-simple-solutionaccepted">Approach #2 Simple Solution[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>In the brute force approach we will generate all the possible <script type="math/tex; mode=display">2^n</script> subsequences of both the strings and store their number of occurences in a hashmap.\nLongest subsequence whose frequency is equal to <script type="math/tex; mode=display">1</script> will be the required subsequence.\nAnd, if it is not found we will return <script type="math/tex; mode=display">-1</script>.</p>\n<iframe frameborder="0" height="479" name="tSXGPoqU" src="https://leetcode.com/playground/tSXGPoqU/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(2^x+2^y)</script>. where <script type="math/tex; mode=display">x</script> and <script type="math/tex; mode=display">y</script> are the lengths of strings <script type="math/tex; mode=display">a</script> and <script type="math/tex; mode=display">b</script> respectively . Number of subsequences will be <script type="math/tex; mode=display">2^x+2^y</script>.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(2^x+2^y)</script>. <script type="math/tex; mode=display">2^x+2^y</script> subsequences will be generated.</li>\n</ul>\n<hr>\n<h4 id="approach-2-simple-solutionaccepted">Approach #2 Simple Solution[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Simple analysis of this problem can lead to an easy solution.</p>\n<p>These three cases are possible with string <script type="math/tex; mode=display">a</script> and <script type="math/tex; mode=display">b</script>:-</p>\n<ul>\n<li>\n<p>\n<script type="math/tex; mode=display">a=b</script>. If both the strings are identical, it is obvious that no subsequence will be uncommon. Hence, return -1.</p>\n</li>\n<li>\n<p>\n<script type="math/tex; mode=display">length(a)=length(b)</script> and <script type="math/tex; mode=display">a \\ne b</script>. Example: <script type="math/tex; mode=display">abc</script> and <script type="math/tex; mode=display">abd</script>. In this case we can consider any string i.e. <script type="math/tex; mode=display">abc</script> or <script type="math/tex; mode=display">abd</script> as a required subsequence, as out of these two strings one string will never be a subsequence of other string. Hence, return <script type="math/tex; mode=display">length(a)</script> or <script type="math/tex; mode=display">length(b)</script>.</p>\n</li>\n<li>\n<p>\n<script type="math/tex; mode=display">length(a) \\ne length(b)</script>. Example <script type="math/tex; mode=display">abcd</script> and <script type="math/tex; mode=display">abc</script>. In this case we can consider bigger string as a required subsequence because bigger string can\'t be a subsequence of smaller string. Hence, return <script type="math/tex; mode=display">max(length(a),length(b))</script>.</p>\n</li>\n</ul>\n<iframe frameborder="0" height="173" name="YdNcPgTE" src="https://leetcode.com/playground/YdNcPgTE/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(min(x,y))</script>. where <script type="math/tex; mode=display">x</script> and <script type="math/tex; mode=display">y</script> are the lengths of strings <script type="math/tex; mode=display">a</script> and <script type="math/tex; mode=display">b</script> respectively. Here equals method will take <script type="math/tex; mode=display">min(x,y)</script> time .</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space required.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '522',
    name: 'Longest Uncommon Subsequence II',
    acceptance: '32.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be <b>any</b> subsequence of the other strings.\n</p>\n\n<p>\nA <b>subsequence</b> is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.\n</p>\n\n<p>\nThe input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn\'t exist, return -1.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "aba", "cdc", "eae"\n<b>Output:</b> 3\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><ol>\n<li>All the given strings\' lengths will not exceed 10.</li>\n<li>The length of the given list will be in the range of [2, 50].</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-forceaccepted">Approach #1 Brute Force[Accepted]</a></li>\n<li><a href="#approach-2-checking-subsequence-accepted">Approach #2 Checking Subsequence [Accepted]</a></li>\n<li><a href="#approach-3-sorting-and-checking-subsequence-accepted">Approach #3 Sorting and Checking Subsequence [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-forceaccepted">Approach #1 Brute Force[Accepted]</h4>\n<p>In the brute force approach we will generate all the possible <script type="math/tex; mode=display">2^n</script> subsequences of all the strings and store their number of occurences in a hashmap. Longest subsequence whose frequency is equal to <script type="math/tex; mode=display">1</script> will be the required subsequence. And, if it is not found we will return <script type="math/tex; mode=display">-1</script>.</p>\n<iframe frameborder="0" height="479" name="HSf9Ggnx" src="https://leetcode.com/playground/HSf9Ggnx/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n*2^x)</script>. where <script type="math/tex; mode=display">x</script> is the average length of the strings and <script type="math/tex; mode=display">n</script> is the total number of given strings.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n*2^x)</script>. Hashmap of size <script type="math/tex; mode=display">n*2^x</script> is used.</li>\n</ul>\n<hr>\n<h4 id="approach-2-checking-subsequence-accepted">Approach #2 Checking Subsequence [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>By some analysis, we can note that if longest uncommon subsequence is there, then it will always be one of the string from the given list of strings.\nUsing this idea, we can check each string that whether it is a subsequence of any other string. If a string is not a subsequence of any other string i.e. it is uncommon , we will return maximum length string out of them. If no string found, we will return <script type="math/tex; mode=display">-1</script>.</p>\n<p>To understand the method, look at the example given below:</p>\n<!--![Checking_Subsequence](https://leetcode.com/articles/Figures/595_Longest_Uncommon_Subsequence.gif)-->\n<p>!?!../Documents/595_Longest_Uncommon.json:1000,563!?!</p>\n<iframe frameborder="0" height="462" name="8u5yUq7G" src="https://leetcode.com/playground/8u5yUq7G/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(x*n^2)</script>. where <script type="math/tex; mode=display">n</script> is the number of strings and <script type="math/tex; mode=display">x</script> is the average length of the strings.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space required.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-sorting-and-checking-subsequence-accepted">Approach #3 Sorting and Checking Subsequence [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we needed to compare all the given strings and compare them for the subsequence criteria. We can save some computations if we sort the given set of strings based on their lengths initially.</p>\n<p>In this approach, firstly we sort the given strings in decreasing order of their lengths. Then, we start off by comparing the longest string with all the other strings. If none of the other strings happens to be the subsequence of the longest string, we return the length of the longest string as the result without any need of further comparisons. If some string happens to be a subsequence of the longest string, we continue the same process by choosing the second largest string as the first string and repeat the process, and so on.</p>\n<iframe frameborder="0" height="515" name="88P8AEzt" src="https://leetcode.com/playground/88P8AEzt/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(x*n^2)</script>. where <script type="math/tex; mode=display">n</script> is the number of strings and <script type="math/tex; mode=display">x</script> is the average length of the strings.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space required.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '523',
    name: 'Continuous Subarray Sum',
    acceptance: '23.3%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nGiven a list of <b>non-negative</b> numbers and a target <b>integer</b> k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of <b>k</b>, that is, sums up to n*k where n is also an <b>integer</b>.\n</p>\n\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [23, 2, 4, 6, 7],  k=6\n<b>Output:</b> True\n<b>Explanation:</b> Because [2, 4] is a continuous subarray of size 2 and sums up to 6.\n</pre>\n<p></p>\n\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [23, 2, 6, 4, 7],  k=6\n<b>Output:</b> True\n<b>Explanation:</b> Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The length of the array won't exceed 10,000.</li>\n<li>You may assume the sum of all the numbers is in the range of a signed 32-bit integer.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</a></li>\n<li><a href="#approach-3-using-hashmap-accepted">Approach #3 Using HashMap [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The brute force approach is trivial. We consider every possible subarray of size greater than or equal to 2, find out its sum by iterating over the elements of the subarray, and then we check if the sum obtained is an integer multiple of the given <script type="math/tex; mode=display">k</script>.</p>\n<iframe frameborder="0" height="309" name="2FrNbepf" src="https://leetcode.com/playground/2FrNbepf/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. Three for loops iterating over the array are used.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can optimize the brute force approach to some extent, if we make use of an array <script type="math/tex; mode=display">sum</script> that stores the cumulative sum of the elements of the array, such that <script type="math/tex; mode=display">sum[i]</script> stores the sum of the elements upto the <script type="math/tex; mode=display">i^{th}</script> element of the array.</p>\n<p>Thus, now as before, we consider every possible subarray for checking its sum. But, instead of iterating over a new subarray everytime to determine its sum, we make use of the cumulative sum array. Thus, to determine the sum of elements from the <script type="math/tex; mode=display">i^{th}</script> index to the <script type="math/tex; mode=display">j^{th}</script> index, including both the corners, we can use: <script type="math/tex; mode=display">sum[j] - sum[i] + nums[i]</script>. </p>\n<iframe frameborder="0" height="326" name="gnCBbVgp" src="https://leetcode.com/playground/gnCBbVgp/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Two for loops are used for considering every subarray possible.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">sum</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-hashmap-accepted">Approach #3 Using HashMap [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this solution, we make use of a HashMap that is used to store the cumulative sums upto the <script type="math/tex; mode=display">i^{th}</script> index after some processing along with the index <script type="math/tex; mode=display">i</script>. The processing done is taking the modulus of the the sum upto the <script type="math/tex; mode=display">i^{th}</script> index with the given <script type="math/tex; mode=display">k</script>. The reasoning behind this will become clear soon. </p>\n<p>We traverse over the given array, and keep on calculating the <script type="math/tex; mode=display">sum%k</script> values upto the current index. Whenever we find a new <script type="math/tex; mode=display">sum%k</script> value, which isn\'t present in the HashMap already, we make an entry in the HashMap of the form, <script type="math/tex; mode=display">(sum%k, i)</script>. </p>\n<p>Now, assume that the given <script type="math/tex; mode=display">sum%k</script> value at the <script type="math/tex; mode=display">i^{th}</script> index be equal to <script type="math/tex; mode=display">rem</script>. Now, if any subarray follows the <script type="math/tex; mode=display">i^{th}</script> element, which has a sum equal to the integer multiple of <script type="math/tex; mode=display">k</script>, say extending upto the <script type="math/tex; mode=display">j^{th}</script> index, the sum value to be stored in the HashMap for the <script type="math/tex; mode=display">j^{th}</script> index will be: <script type="math/tex; mode=display">(rem + n*k)%k</script>, where <script type="math/tex; mode=display">n</script> is some integer &gt; 0. We can observe that <script type="math/tex; mode=display">(rem + n*k)%k = rem</script>, which is the same value as stored corresponding to the <script type="math/tex; mode=display">i^{th}</script> index.</p>\n<p>From this observation, we come to the conclusion that whenever the same <script type="math/tex; mode=display">sum%k</script> value is obtained corresponding to two indices <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script>, it implies that sum of elements betweeen those indices is an integer multiple of <script type="math/tex; mode=display">k</script>. Thus, if the same <script type="math/tex; mode=display">sum%k</script> value is encountered again during the traversal, we return a <script type="math/tex; mode=display">\\text{True}</script> directly.</p>\n<p>The slideshow below depicts the process for the array <code>nums: [2, 5, 33, 6, 7, 25, 15]</code> and <code>k=13</code>.</p>\n<p>!?!../Documents/523_Continous_Subarray_Sum.json:640,360!?!</p>\n<iframe frameborder="0" height="360" name="RKE4GM84" src="https://leetcode.com/playground/RKE4GM84/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Only one traversal of the array <script type="math/tex; mode=display">nums</script> is done.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(min(n,k))</script>. The HashMap can contain upto <script type="math/tex; mode=display">min(n,k)</script> different pairings.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '524',
    name: 'Longest Word in Dictionary through Deleting',
    acceptance: '43.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\n</p>\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>\ns = "abpcplea", d = ["ale","apple","monkey","plea"]\n\n<b>Output:</b> \n"apple"\n</pre>\n<p></p>\n\n<p></p>\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b>\ns = "abpcplea", d = ["a","b","c"]\n\n<b>Output:</b> \n"a"\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>All the strings in the input will only contain lower-case letters.</li>\n<li>The size of the dictionary won\'t exceed 1,000.</li>\n<li>The length of all the strings in the input won\'t exceed 1,000.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-iterative-brute-force-time-limit-exceeded">Approach #2 Iterative Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-sorting-and-checking-subsequence-accepted">Approach #3 Sorting and checking Subsequence [Accepted]</a></li>\n<li><a href="#approach-4-without-sorting-accepted">Approach #4 Without Sorting [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The idea behind this approach is as follows. We create a list of all the possible strings that can be formed by deleting one or more characters from the given string <script type="math/tex; mode=display">s</script>. In order to do so, we make use of a recursive function <code>generate(s, str, i, l)</code> which creates a string by adding and by removing the current character(<script type="math/tex; mode=display">i^{th}</script>) from the string <script type="math/tex; mode=display">s</script> to the string <script type="math/tex; mode=display">str</script> formed till the index <script type="math/tex; mode=display">i</script>. Thus, it adds the <script type="math/tex; mode=display">i^{th}</script> character to <script type="math/tex; mode=display">str</script> and calls itself as <code>generate(s, str + s.charAt(i), i + 1, l)</code>. It also omits the <script type="math/tex; mode=display">i^{th}</script> character to <script type="math/tex; mode=display">str</script> and calls itself as <code>generate(s, str, i + 1, l)</code>.</p>\n<p>Thus, at the end the list <script type="math/tex; mode=display">l</script> contains all the required strings that can be formed using <script type="math/tex; mode=display">s</script>. Then, we look for the strings formed in <script type="math/tex; mode=display">l</script> into the dictionary available to see if a match is available. Further, in case of a match, we check for the length of the matched string to maximize the length and we also take care to consider the lexicographically smallest string in case of length match as well.</p>\n<iframe frameborder="0" height="445" name="stinLqjy" src="https://leetcode.com/playground/stinLqjy/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(2^n)</script>. <code>generate</code> calls itself <script type="math/tex; mode=display">2^n</script> times. Here, <script type="math/tex; mode=display">n</script> refers to the length of string <script type="math/tex; mode=display">s</script>. </p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(2^n)</script>. List <script type="math/tex; mode=display">l</script> contains <script type="math/tex; mode=display">2^n</script> strings.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-iterative-brute-force-time-limit-exceeded">Approach #2 Iterative Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of using recursive <code>generate</code> to create the list of possible strings that can be formed using <script type="math/tex; mode=display">s</script> by performing delete operations, we can also do the same process iteratively. To do so, we use the concept of binary number generation. </p>\n<p>We can treat the given string <script type="math/tex; mode=display">s</script> along with a binary represenation corresponding to the indices of <script type="math/tex; mode=display">s</script>. The rule is that the character at the position <script type="math/tex; mode=display">i</script> has to be added to the newly formed string <script type="math/tex; mode=display">str</script> only if there is a boolean 1 at the corresponding index in the binary representation of a number currently considered.</p>\n<p>We know a total of <script type="math/tex; mode=display">2^n</script> such binary numbers are possible if there are <script type="math/tex; mode=display">n</script> positions to be filled(<script type="math/tex; mode=display">n</script> also corresponds to the number of characters in <script type="math/tex; mode=display">s</script>). Thus, we consider all the numbers from <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">2^n</script> in their binary representation in a serial order and generate all the strings possible using the above rule.</p>\n<p>The figure below shows an example of the strings generated for the given string <script type="math/tex; mode=display">s</script>:"sea".</p>\n<p><img alt="Longest_Word" src="https://leetcode.com/articles/Figures/524_Longest_Word_Binary.PNG"></p>\n<p>A problem with this method is that the maximum length of the string can be 32 only, since we make use of an integer and perform the shift operations on it to generate the binary numbers.</p>\n<iframe frameborder="0" height="411" name="cmWsEFGG" src="https://leetcode.com/playground/cmWsEFGG/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(2^n)</script>. <script type="math/tex; mode=display">2^n</script> strings are generated. </p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(2^n)</script>. List <script type="math/tex; mode=display">l</script> contains <script type="math/tex; mode=display">2^n</script> strings.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-sorting-and-checking-subsequence-accepted">Approach #3 Sorting and checking Subsequence [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The matching condition in the given problem requires that we need to consider the matching string in the dictionary with the longest length and in case of same length, the string which is smallest lexicographically. To ease the searching process, we can sort the given dictionary\'s strings based on the same criteria, such that the more favorable string appears earlier in the sorted dictionary.</p>\n<p>Now, instead of performing the deletions in <script type="math/tex; mode=display">s</script>, we can directly check if any of the words given in the dictionary(say <script type="math/tex; mode=display">x</script>) is a subsequence of the given string <script type="math/tex; mode=display">s</script>, starting from the beginning of the dictionary. This is because, if <script type="math/tex; mode=display">x</script> is a subsequence of <script type="math/tex; mode=display">s</script>, we can obtain <script type="math/tex; mode=display">x</script> by performing delete operations on <script type="math/tex; mode=display">s</script>. </p>\n<p>If <script type="math/tex; mode=display">x</script> is a subsequence of <script type="math/tex; mode=display">s</script> every character of <script type="math/tex; mode=display">x</script> will be present in <script type="math/tex; mode=display">s</script>. The following figure shows the way the subsequence check is done for one example:</p>\n<p>!?!../Documents/524_Longest_Word.json:1000,563!?!</p>\n<p>As soon as we find any such <script type="math/tex; mode=display">x</script>, we can stop the search immediately since we\'ve already processed <script type="math/tex; mode=display">d</script> to our advantage.</p>\n<iframe frameborder="0" height="428" name="bzaQxoMF" src="https://leetcode.com/playground/bzaQxoMF/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n*x*logn + n*x)</script>. Here <script type="math/tex; mode=display">n</script> refers to the number of strings in list <script type="math/tex; mode=display">d</script> and <script type="math/tex; mode=display">x</script> refers to average string length. Sorting takes <script type="math/tex; mode=display">O(nlogn)</script> and <code>isSubsequence</code> takes <script type="math/tex; mode=display">O(x)</script> to check whether a string is a subsequence of another string or not.  </p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(logn)</script>. Sorting takes <script type="math/tex; mode=display">O(logn)</script> space in average case.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-without-sorting-accepted">Approach #4 Without Sorting [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>Since sorting the dictionary could lead to a huge amount of extra effort, we can skip the sorting and directly look for the strings <script type="math/tex; mode=display">x</script> in the unsorted dictionary <script type="math/tex; mode=display">d</script> such that <script type="math/tex; mode=display">x</script> is a subsequence in <script type="math/tex; mode=display">s</script>. If such a string <script type="math/tex; mode=display">x</script> is found, we compare it with the other matching strings found till now based on the required length and lexicographic criteria. Thus, after considering every string in <script type="math/tex; mode=display">d</script>, we can obtain the required result.</p>\n<iframe frameborder="0" height="377" name="qsSjNJwD" src="https://leetcode.com/playground/qsSjNJwD/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n*x)</script>. One iteration over all strings is required. Here <script type="math/tex; mode=display">n</script> refers to the number of strings in list <script type="math/tex; mode=display">d</script> and <script type="math/tex; mode=display">x</script> refers to average string length.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(x)</script>. <script type="math/tex; mode=display">max\\_str</script> variable is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '525',
    name: 'Contiguous Array',
    acceptance: '41.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1. </p>\n\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [0,1]\n<b>Output:</b> 2\n<b>Explanation:</b> [0, 1] is the longest contiguous subarray with equal number of 0 and 1.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [0,1,0]\n<b>Output:</b> 2\n<b>Explanation:</b> [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\nThe length of the given binary array will not exceed 50,000.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-extra-array-accepted">Approach #2 Using Extra Array [Accepted]</a></li>\n<li><a href="#approach-3-using-hashmap-accepted">Approach #3 Using HashMap [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The brute force approach is really simple. We consider every possible subarray within the given array and count the number of zeros and ones in each subarray. Then, we find out the maximum size subarray with equal no. of zeros and ones out of them.</p>\n<iframe frameborder="0" height="428" name="sPZqbexo" src="https://leetcode.com/playground/sPZqbexo/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. We consider every possible subarray by traversing over the complete array for every start point possible.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Only two variables <script type="math/tex; mode=display">zeroes</script> and <script type="math/tex; mode=display">ones</script> are required.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-extra-array-accepted">Approach #2 Using Extra Array [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, we make use of a <script type="math/tex; mode=display">count</script> variable, which is used to store the relative number of ones and zeros encountered so far while traversing the array. The <script type="math/tex; mode=display">count</script> variable is incremented by one for every <script type="math/tex; mode=display">\\text{1}</script> encountered and the same is decremented by one for every <script type="math/tex; mode=display">\\text{0}</script> encountered.</p>\n<p>We start traversing the array from the beginning. If at any moment, the <script type="math/tex; mode=display">count</script> becomes zero, it implies that we\'ve encountered equal number of zeros and ones from the beginning till the current index of the array(<script type="math/tex; mode=display">i</script>). Not only this, another point to be noted is that  if we encounter the same <script type="math/tex; mode=display">count</script> twice while traversing the array, it means that the number of zeros and ones are equal between the indices corresponding to the equal <script type="math/tex; mode=display">count</script> values. The following figure illustrates the observation for the sequence <code>[0 0 1 0 0 0 1 1]</code>:</p>\n<p><img alt="Contiguous_Array" src="https://leetcode.com/articles/Figures/535_Contiguous_Array.PNG"></p>\n<p>In the above figure, the subarrays between (A,B), (B,C) and (A,C) (lying between indices corresponing to <script type="math/tex; mode=display">count = 2</script>) have equal number of zeros and ones.</p>\n<p>Another point to be noted is that the largest subarray is the one between the points (A, C). Thus, if we keep a track of the indices corresponding to the same <script type="math/tex; mode=display">count</script> values that lie farthest apart, we can determine the size of the largest subarray with equal no. of zeros and ones easily.</p>\n<p>Now, the <script type="math/tex; mode=display">count</script> values can range between <script type="math/tex; mode=display">\\text{-n}</script> to <script type="math/tex; mode=display">\\text{+n}</script>, with the extreme points corresponding to the complete array being filled with all 0\'s and all 1\'s respectively. Thus, we make use of an array <script type="math/tex; mode=display">arr</script>(of size <script type="math/tex; mode=display">\\text{2n+1}</script>to keep a track of the various <script type="math/tex; mode=display">count</script>\'s encountered so far. We make an entry containing the current element\'s index (<script type="math/tex; mode=display">i</script>) in the <script type="math/tex; mode=display">arr</script> for a new <script type="math/tex; mode=display">count</script> encountered everytime. Whenever, we come across the same <script type="math/tex; mode=display">count</script> value later while traversing the array, we determine the length of the subarray lying between the indices corresponding to the same <script type="math/tex; mode=display">count</script> values.</p>\n<iframe frameborder="0" height="411" name="Nvw6WnPN" src="https://leetcode.com/playground/Nvw6WnPN/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The complete array is traversed only once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">arr</script> array of size <script type="math/tex; mode=display">\\text{2n+1}</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-hashmap-accepted">Approach #3 Using HashMap [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This approach relies on the same premise as the previous approach. But, we need not use an array of size <script type="math/tex; mode=display">\\text{2n+1}</script>, since it isn\'t necessary that we\'ll encounter all the <script type="math/tex; mode=display">count</script> values possible. Thus, we make use of a HashMap <script type="math/tex; mode=display">map</script> to store the entries in the form of <script type="math/tex; mode=display">(index, count)</script>. We make an entry for a <script type="math/tex; mode=display">count</script> in the <script type="math/tex; mode=display">map</script> whenever the <script type="math/tex; mode=display">count</script> is encountered first, and later on use the correspoding index to find the length of the largest subarray with equal no. of zeros and ones when the same <script type="math/tex; mode=display">count</script> is encountered again.</p>\n<p>The following animation depicts the process:\n<!--<img alt="Contiguous_Array" src="https://leetcode.com/articles/Figures/525_Contiguous_Array.gif" />-->\n!?!../Documents/525_Contiguous_Array.json:1000,563!?!</p>\n<iframe frameborder="0" height="360" name="nG5CTUD8" src="https://leetcode.com/playground/nG5CTUD8/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The entire array is traversed only once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Maximum size of the HashMap <script type="math/tex; mode=display">map</script> will be <script type="math/tex; mode=display">\\text{n}</script>, if all the elements are either 1 or 0.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '526',
    name: 'Beautiful Arrangement',
    acceptance: '54.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nSuppose you have <b>N</b> integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these <b>N</b> numbers successfully if one of the following is true for the i<sub>th</sub> position (1 &lt;= i &lt;= N) in this array:\n</p><ol>\n<li>The number at the i<sub>th</sub> position is divisible by <b>i</b>.</li>\n<li><b>i</b> is divisible by the number at the i<sub>th</sub> position.</li>\n</ol>\n<p></p>\n\n<p>\nNow given N, how many beautiful arrangements can you construct?\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> 2\n<b>Output:</b> 2\n<b>Explanation:</b> \n<br>The first beautiful arrangement is [1, 2]:\n<br>Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).\n<br>Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).\n<br>The second beautiful arrangement is [2, 1]:\n<br>Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).\n<br>Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li><b>N</b> is a positive integer and will not exceed 15.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</a></li>\n<li><a href="#approach-3-backtracking-accepted">Approach #3 Backtracking [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the brute force method, we can find out all the arrays that can be formed using the numbers from 1 to N(by creating every possible permutation of the given elements). Then, we iterate over all the elements of every permutation generated and check for the required conditions of divisibility.</p>\n<p>In order to generate all the possible pairings, we make use of a function <code>permute(nums, current_index)</code>. This function creates all the possible permutations of the elements of the given array.</p>\n<p>To do so, <code>permute</code> takes the index of the current element <script type="math/tex; mode=display">current_index</script> as one of the arguments. Then, it swaps the current element with every other element in the array, lying towards its right, so as to generate a new ordering of the array elements. After the swapping has been done, it makes another call to permute but this time with the index of the next element in the array. While returning back, we reverse the swapping done in the current function call.</p>\n<p>Thus, when we reach the end of the array, a new ordering of the array\'s elements is generated. The following animation depicts the process of generating the permutations.</p>\n<p>!?!../Documents/561_Array.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="PqSksc2S" src="https://leetcode.com/playground/PqSksc2S/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n!)</script>. A total of <script type="math/tex; mode=display">n!</script> permutations will be generated for an array of length <script type="math/tex; mode=display">n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of the recursion tree can go upto <script type="math/tex; mode=display">n</script>. <script type="math/tex; mode=display">nums</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-force-accepted">Approach #2 Better Brute Force [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the brute force approach, we create the full array for every permutation and then check the array for the given divisibilty conditions. But this method can be optimized to a great extent. To do so, we can keep checking the elements while being added to the permutation array at every step for the divisibility condition and  can stop creating it any further as soon as we find out the element just added to the permutation violates the divisiblity condition. </p>\n<iframe frameborder="0" height="513" name="WQVaxmVy" src="https://leetcode.com/playground/WQVaxmVy/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(k)</script>. <script type="math/tex; mode=display">k</script> refers to the number of valid permutations.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of recursion tree can go upto <script type="math/tex; mode=display">n</script>. Further, <script type="math/tex; mode=display">nums</script> array of size <script type="math/tex; mode=display">n</script> is used, where, <script type="math/tex; mode=display">n</script> is the given number.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-backtracking-accepted">Approach #3 Backtracking [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The idea behind this approach is simple. We try to create all the permutations of numbers from 1 to N. We can fix one number at a particular position and check for the divisibility criteria of that number at the particular position. But, we need to keep a track of the numbers which have already been considered earlier so that they aren\'t reconsidered while generating the permutations. If the current \nnumber doesn\'t satisfy the divisibility criteria, we can leave all the permutations that can be generated with that number at the particular position. This helps to prune the search space of the permutations to a great extent. We do so by trying to place each of the numbers at each position.</p>\n<p>We make use of a visited array of size <script type="math/tex; mode=display">N</script>. Here, <script type="math/tex; mode=display">visited[i]</script> refers to the <script type="math/tex; mode=display">i^{th}</script> number being already placed/not placed in the array being formed till now(True indicates that the number has already been placed).</p>\n<p>We make use of a <code>calculate</code> function, which puts all the numbers pending numbers from 1 to N(i.e. not placed till now in the array), indicated by a <script type="math/tex; mode=display">False</script> at the corresponding <script type="math/tex; mode=display">visited[i]</script> position, and tries to create all the permutations with those numbers starting from the <script type="math/tex; mode=display">pos</script> index onwards in the current array. While putting the <script type="math/tex; mode=display">pos^{th}</script> number, we check whether the <script type="math/tex; mode=display">i^{th}</script> number satisfies the divisibility criteria on the go i.e. we continue forward with creating the permutations with the number <script type="math/tex; mode=display">i</script> at the <script type="math/tex; mode=display">pos^{th}</script> position only if the number <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">pos</script> satisfy the given criteria. Otherwise, we continue with putting the next numbers at the same position and keep on generating the permutations.</p>\n<p>Look at the animation below for a better understanding of the methodology:</p>\n<p>!?!../Documents/526_Beautiful.json:1000,563!?!</p>\n<p>Below code is inspired by <a href="http://leetcode.com/shawngao">@shawngao</a></p>\n<iframe frameborder="0" height="377" name="cBVwozT4" src="https://leetcode.com/playground/cBVwozT4/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(k)</script>. <script type="math/tex; mode=display">k</script> refers to the number of valid permutations.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">visited</script> array of size <script type="math/tex; mode=display">n</script> is used. The depth of recursion tree will also go upto <script type="math/tex; mode=display">n</script>. Here, <script type="math/tex; mode=display">n</script> refers to the given integer <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '527',
    name: 'Word Abbreviation ',
    acceptance: '43.1%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given an array of n distinct non-empty strings, you need to generate <b>minimal</b> possible abbreviations for every word following rules below.</p>\n\n<ol>\n<li>Begin with the first character and then the number of characters abbreviated, which followed by the last character.</li>\n<li>If there are any conflict, that is more than one words share the same abbreviation, a longer prefix is used instead of only the first character until making the map from word to abbreviation become unique. In other words, a final abbreviation cannot map to more than one original words.</li>\n<li> If the abbreviation doesn\'t make the word shorter, then keep it as original.</li>\n</ol>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> ["like", "god", "internal", "me", "internet", "interval", "intension", "face", "intrusion"]\n<b>Output:</b> ["l2e","god","internal","me","i6t","interval","inte4n","f2e","intr4n"]\n</pre>\n<p></p>\n\n\n<b>Note:</b> \n<ol>\n<li> Both n and the length of each word will not exceed 400.</li>\n<li> The length of each word is greater than 1.</li>\n<li> The words consist of lowercase English letters only.</li>\n<li> The return answers should be <b>in the same order</b> as the original array.</li>\n</ol>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-greedy-accepted">Approach #1: Greedy [Accepted]</a></li>\n<li><a href="#approach-2-group-least-common-prefix-accepted">Approach #2: Group + Least Common Prefix [Accepted]</a></li>\n<li><a href="#approach-3-group-trie-accepted">Approach #3: Group + Trie [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-greedy-accepted">Approach #1: Greedy [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Let\'s choose the shortest abbreviation for each word.  Then, while we have duplicates, we\'ll increase the length of all duplicates.</p>\n<p><strong>Algorithm</strong></p>\n<p>For example, let\'s say we have <code>"aabaaa", "aacaaa", "aacdaa"</code>, then we start with <code>"a4a", "a4a", "a4a"</code>.  Since these are duplicated, we lengthen them to <code>"aa3a", "aa3a", "aa3a"</code>.  They are still duplicated, so we lengthen them to <code>"aab2a", "aac2a", "aac2a"</code>.  The last two are still duplicated, so we lengthen them to <code>"aacaaa", "aacdaa"</code>.</p>\n<p>Throughout this process, we were tracking an index <code>prefix[i]</code> which told us up to what index to take the prefix to.  For example, <code>prefix[i] = 2</code> means to take a prefix of <code>word[0], word[1], word[2]</code>.</p>\n<iframe frameborder="0" height="500" name="potfaw7d" src="https://leetcode.com/playground/potfaw7d/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(C^2)</script> where <script type="math/tex; mode=display">C</script> is the number of characters across all words in the given array.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(C)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-group-least-common-prefix-accepted">Approach #2: Group + Least Common Prefix [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Two words are only eligible to have the same abbreviation if they have the same first letter, last letter, and length.  Let\'s group each word based on these properties, and then sort out the conflicts.</p>\n<p>In each group <code>G</code>, if a word <code>W</code> has a longest common prefix <code>P</code> with any other word <code>X</code> in <code>G</code>, then our abbreviation must contain a prefix of more than <code>|P|</code> characters.  The longest common prefixes must occur with words adjacent to <code>W</code> (in lexicographical order), so we can just sort <code>G</code> and look at the adjacent words.</p>\n<iframe frameborder="0" height="500" name="oSfs2RA2" src="https://leetcode.com/playground/oSfs2RA2/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(C \\log C)</script> where <script type="math/tex; mode=display">C</script> is the number of characters across all words in the given array.  The complexity is dominated by the sorting step.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(C)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-group-trie-accepted">Approach #3: Group + Trie [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>As in <em>Approach #1</em>, let\'s group words based on length, first letter, and last letter, and discuss when words in a group do not share a longest common prefix.</p>\n<p>Put the words of a group into a trie (prefix tree), and count at each node (representing some prefix <code>P</code>) the number of words with prefix <code>P</code>.  If the count is 1, we know the prefix is unique.</p>\n<iframe frameborder="0" height="500" name="g97bSjjc" src="https://leetcode.com/playground/g97bSjjc/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(C)</script> where <script type="math/tex; mode=display">C</script> is the number of characters across all words in the given array.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(C)</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.  Approach #1 inspired by <a href="https://discuss.leetcode.com/topic/82613/really-simple-and-straightforward-java-solution">@ckcz123</a>.</p>\n</div>\n          ',
    tags: ['Google', 'Snapchat'],
  },
  {
    id: '529',
    name: 'Minesweeper',
    acceptance: '49.6%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Let's play the minesweeper game (<a href=\"https://en.wikipedia.org/wiki/Minesweeper_(video_game)\">Wikipedia</a>, <a href=\"http://minesweeperonline.com\">online game</a>)! </p>\n\n<p>You are given a 2D char matrix representing the game board. <b>'M'</b> represents an <b>unrevealed</b> mine, <b>'E'</b> represents an <b>unrevealed</b> empty square, <b>'B'</b> represents a <b>revealed</b> blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, <b>digit</b> ('1' to '8') represents how many mines are adjacent to this <b>revealed</b> square, and finally <b>'X'</b> represents a <b>revealed</b> mine.</p>\n\n<p>Now given the next click position (row and column indices) among all the <b>unrevealed</b> squares ('M' or 'E'), return the board after revealing this position according to the following rules:</p> \n\n<p>\n</p><ol>\n<li>If a mine ('M') is revealed, then the game is over - change it to <b>'X'</b>.</li>\n<li>If an empty square ('E') with <b>no adjacent mines</b> is revealed, then change it to revealed blank ('B') and all of its adjacent <b>unrevealed</b> squares should be revealed recursively.</li>\n<li>If an empty square ('E') with <b>at least one adjacent mine</b> is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines.</li>\n<li>Return the board when no more squares will be revealed.</li>\n</ol>\n\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \n\n[['E', 'E', 'E', 'E', 'E'],\n ['E', 'E', 'M', 'E', 'E'],\n ['E', 'E', 'E', 'E', 'E'],\n ['E', 'E', 'E', 'E', 'E']]\n\nClick : [3,0]\n\n<b>Output:</b> \n\n[['B', '1', 'E', '1', 'B'],\n ['B', '1', 'M', '1', 'B'],\n ['B', '1', '1', '1', 'B'],\n ['B', 'B', 'B', 'B', 'B']]\n\n<b>Explanation:</b>\n<img src=\"https://leetcode.com/static/images/problemset/minesweeper_example_1.png\" width=\"40%\">\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \n\n[['B', '1', 'E', '1', 'B'],\n ['B', '1', 'M', '1', 'B'],\n ['B', '1', '1', '1', 'B'],\n ['B', 'B', 'B', 'B', 'B']]\n\nClick : [1,2]\n\n<b>Output:</b> \n\n[['B', '1', 'E', '1', 'B'],\n ['B', '1', 'X', '1', 'B'],\n ['B', '1', '1', '1', 'B'],\n ['B', 'B', 'B', 'B', 'B']]\n\n<b>Explanation:</b>\n<img src=\"https://leetcode.com/static/images/problemset/minesweeper_example_2.png\" width=\"40%\">\n</pre>\n<p></p>\n\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The range of the input matrix's height and width is [1,50].</li>\n<li>The click position will only be an unrevealed square ('M' or 'E'), which also means the input board contains at least one clickable square.</li>\n<li>The input board won't be a stage when game is over (some mines have been revealed).</li>\n<li>For simplicity, not mentioned rules should be ignored in this problem. For example, you <b>don't</b> need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Amazon'],
  },
  {
    id: '530',
    name: 'Minimum Absolute Difference in BST',
    acceptance: '47.1%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a binary search tree with non-negative values, find the minimum <a href="https://en.wikipedia.org/wiki/Absolute_difference">absolute difference</a> between values of any two nodes.</p>\n\n<p>\n<b>Example:</b>\n</p><pre><b>Input:</b>\n\n   1\n    \\\n     3\n    /\n   2\n\n<b>Output:</b>\n1\n\n<b>Explanation:</b>\nThe minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).\n</pre>\n<p></p>\n\n\n<p><b>Note:</b>\nThere are at least two nodes in this BST.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '531',
    name: 'Lonely Pixel I ',
    acceptance: '55.6%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given a picture consisting of black and white pixels, find the number of <b>black</b> lonely pixels.</p>\n\n<p>The picture is represented by a 2D char array consisting of 'B' and 'W', which means black and white pixels respectively. </p>\n\n<p>A black lonely pixel is character 'B' that located at a specific position where the same row and same column don't have any other black pixels.</p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> \n[['W', 'W', 'B'],\n ['W', 'B', 'W'],\n ['B', 'W', 'W']]\n\n<b>Output:</b> 3\n<b>Explanation:</b> All the three 'B's are black lonely pixels.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The range of width and height of the input 2D array is [1,500].</li>\n</ol>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '532',
    name: 'K-diff Pairs in an Array',
    acceptance: '28.2%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array of integers and an integer <b>k</b>, you need to find the number of <b>unique</b> k-diff pairs in the array. Here a <b>k-diff</b> pair is defined as an integer pair (i, j), where <b>i</b> and <b>j</b> are both numbers in the array and their <a href="https://en.wikipedia.org/wiki/Absolute_difference">absolute difference</a> is <b>k</b>.\n</p>\n\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [3, 1, 4, 1, 5], k = 2\n<b>Output:</b> 2\n<b>Explanation: </b>There are two 2-diff pairs in the array, (1, 3) and (3, 5).<br>Although we have two 1s in the input, we should only return the number of <b>unique</b> pairs.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b>[1, 2, 3, 4, 5], k = 1\n<b>Output: </b>4\n<b>Explanation:</b> There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input: </b>[1, 3, 1, 5, 4], k = 0\n<b>Output: </b>1\n<b>Explanation:</b> There is one 0-diff pair in the array, (1, 1).\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The pairs (i, j) and (j, i) count as the same pair.</li>\n<li>The length of the array won\'t exceed 10,000.</li>\n<li>All the integers in the given input belong to the range: [-1e7, 1e7].</li>\n</ol>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Amazon'],
  },
  {
    id: '533',
    name: 'Lonely Pixel II ',
    acceptance: '44.6%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given a picture consisting of black and white pixels, and a positive integer N, find the number of black pixels located at some specific row <b>R</b> and column <b>C</b> that align with all the following rules:</p>\n\n<ol>\n<li> Row R and column C both contain exactly N black pixels.</li>\n<li> For all rows that have a black pixel at column C, they should be exactly the same as row R</li>\n</ol>\n\n<p>The picture is represented by a 2D char array consisting of 'B' and 'W', which means black and white pixels respectively. </p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b>                                            \n[['W', 'B', 'W', 'B', 'B', 'W'],    \n ['W', 'B', 'W', 'B', 'B', 'W'],    \n ['W', 'B', 'W', 'B', 'B', 'W'],    \n ['W', 'W', 'B', 'W', 'B', 'W']] \n\nN = 3\n<b>Output:</b> 6\n<b>Explanation:</b> All the bold 'B' are the black pixels we need (all 'B's at column 1 and 3).\n        0    1    2    3    4    5         column index                                            \n0    [['W', <b>'B'</b>, 'W', <b>'B'</b>, 'B', 'W'],    \n1     ['W', <b>'B'</b>, 'W', <b>'B'</b>, 'B', 'W'],    \n2     ['W', <b>'B'</b>, 'W', <b>'B'</b>, 'B', 'W'],    \n3     ['W', 'W', 'B', 'W', 'B', 'W']]    \nrow index\n\nTake 'B' at row R = 0 and column C = 1 as an example:\nRule 1, row R = 0 and column C = 1 both have exactly N = 3 black pixels. \nRule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2. They are exactly the same as row R = 0.\n\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The range of width and height of the input 2D array is [1,200].</li>\n</ol>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google'],
  },
  {
    id: '534',
    name: 'Design TinyURL',
    acceptance: '0.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <blockquote>Note: For the coding companion problem, please see: <a href="https://leetcode.com/problems/encode-and-decode-tinyurl/">Encode and Decode TinyURL</a>.</blockquote>\n\n<p>How would you design a URL shortening service that is similar to <a href="https://en.wikipedia.org/wiki/TinyURL" target="_blank">TinyURL</a>?</p>\n\n<p><b>Background:</b><br>\nTinyURL is a URL shortening service where you enter a URL such as <code>https://leetcode.com/problems/design-tinyurl</code> and it returns a short URL such as <code>http://tinyurl.com/4e9iAk</code>.\n</p>\n\n<p><b>Requirements:</b><br>\n</p><ol>\n<li>For instance, "http://tinyurl.com/<span class="hilight">4e9iAk</span>" is the tiny url for the page <code>"https://leetcode.com/problems/design-tinyurl"</code>. The <b>identifier</b> (<span class="hilight">the highlighted part</span>) can be any string with 6 alphanumeric characters containing <code>0-9</code>, <code>a-z</code>, <code>A-Z</code>.</li>\n\n<li>Each shortened URL must be unique; that is, no two different URLs can be shortened to the same URL.</li>\n</ol>\n<p></p>\n\n<p><b>Note about Questions:</b><br>Below are just a small subset of questions to get you started. In real world, there could be many follow ups and questions possible and the discussion is open-ended (No one true or correct way to solve a problem). If you have more ideas or questions, please ask in Discuss and we may compile it here!</p>\n\n<p><b>Questions:</b><br>\n</p><ol>\n<li>How many unique identifiers possible? Will you run out of unique URLs?</li>\n<li>Should the identifier be increment or not? Which is easier to design? Pros and cons?</li>\n<li>Mapping an identifier to an URL and its reversal - Does this problem ring a bell to you?</li>\n<li>How do you store the URLs? Does a simple flat file database work?</li>\n<li>What is the bottleneck of the system? Is it <b>read-heavy</b> or <b>write-heavy</b>?</li>\n<li>Estimate the maximum number of URLs a single machine can store.</li>\n<li>Estimate the maximum number of queries per second (QPS) for decoding a shortened URL in a single machine.</li>\n<li>How would you scale the service? For example, a viral link which is shared in social media could result in a peak QPS at a moment\'s notice.</li>\n<li>How could you handle redundancy? i,e, if a server is down, how could you ensure the service is still operational?</li>\n<li>Keep URLs forever or prune, pros/cons? How we do pruning? (Contributed by @alex_svetkin)</li>\n<li>What API would you provide to a third-party developer? (Contributed by @alex_svetkin)</li>\n<li>If you can enable caching, what would you cache and what\'s the expiry time? (Contributed by @Humandroid)</li>\n</ol>\n<p></p>\n\n<style>\n.hilight {\n  color: #d14;\n  background-color: #f7f7f9;\n  padding: 1px 3px;\n  border: 1px solid #e1e1e8"\n}\n</style>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Google', 'Facebook', 'Amazon', 'Uber'],
  },
  {
    id: '535',
    name: 'Encode and Decode TinyURL',
    acceptance: '74.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <blockquote>Note: This is a companion problem to the <a href="https://leetcode.com/problemset/system-design/">System Design</a> problem: <a href="https://leetcode.com/problems/design-tinyurl/">Design TinyURL</a>.</blockquote>\n\n<p>TinyURL is a URL shortening service where you enter a URL such as <code>https://leetcode.com/problems/design-tinyurl</code> and it returns a short URL such as <code>http://tinyurl.com/4e9iAk</code>.</p>\n\n<p>Design the <code>encode</code> and <code>decode</code> methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-simple-counteraccepted">Approach #1 Using Simple Counter[Accepted]</a></li>\n<li><a href="#approach-2-variable-length-encodingaccepted">Approach #2 Variable-length Encoding[Accepted]</a></li>\n<li><a href="#approach-3-using-hashcodeaccepted">Approach #3 Using hashcode[Accepted]</a></li>\n<li><a href="#approach-4-using-random-numberaccepted">Approach #4 Using random number[Accepted]</a></li>\n<li><a href="#approach-5-random-fixed-length-encodingaccepted">Approach #5 Random fixed-length encoding[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-simple-counteraccepted">Approach #1 Using Simple Counter[Accepted]</h4>\n<p>In order to encode the URL, we make use of a counter(<script type="math/tex; mode=display">i</script>), which is incremented for every new URL encountered. We put the URL along with its encoded count(<script type="math/tex; mode=display">i</script>) in a HashMap. This way we can retrieve it later at the time of decoding easily.</p>\n<iframe frameborder="0" height="275" name="BEsJT7hF" src="https://leetcode.com/playground/BEsJT7hF/shared" width="100%"></iframe>\n<p><strong>Performance Analysis</strong></p>\n<ul>\n<li>\n<p>The range of URLs that can be decoded is limited by the range of <script type="math/tex; mode=display">\\text{int}</script>.</p>\n</li>\n<li>\n<p>If excessively large number of URLs have to be encoded, after the range of <script type="math/tex; mode=display">\\text{int}</script> is exceeded, integer overflow could lead to overwriting the previous URLs\' encodings, leading to the performance degradation.</p>\n</li>\n<li>\n<p>The length of the URL isn\'t necessarily shorter than the incoming <script type="math/tex; mode=display">\\text{longURL}</script>. It is only dependent on the relative order in which the URLs are encoded.</p>\n</li>\n<li>\n<p>One problem with this method is that it is very easy to predict the next code generated, since the pattern can be detected by generating a few encoded URLs.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-variable-length-encodingaccepted">Approach #2 Variable-length Encoding[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this case, we make use of variable length encoding to encode the given URLs. For every <script type="math/tex; mode=display">\\text{longURL}</script>, we choose a variable codelength for the input URL, which can be any length between 0 and 61. Further, instead of using only numbers as the Base System for encoding the URLSs, we make use of a set of integers and alphabets to be used for encoding.</p>\n<iframe frameborder="0" height="515" name="wbFtiFeG" src="https://leetcode.com/playground/wbFtiFeG/shared" width="100%"></iframe>\n<p><strong>Performance Analysis</strong></p>\n<ul>\n<li>\n<p>The number of URLs that can be encoded is, again, dependent on the range of <script type="math/tex; mode=display">\\text{int}</script>, since, the same <script type="math/tex; mode=display">count</script> will be generated after overflow of integers.</p>\n</li>\n<li>\n<p>The length of the encoded URLs isn\'t necessarily short, but is to some extent dependent on the order in which the incoming <script type="math/tex; mode=display">\\text{longURL}</script>\'s are encountered. For example, the codes generated will have the lengths in the following order: 1(62 times), 2(62 times) and so on.</p>\n</li>\n<li>\n<p>The performance is quite good, since the same code will be repeated only after the integer overflow limit, which is quite large.</p>\n</li>\n<li>\n<p>In this case also, the next code generated could be predicted by the use of some calculations.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-hashcodeaccepted">Approach #3 Using hashcode[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this method, we make use of an inbuilt function <script type="math/tex; mode=display">\\text{hashCode()}</script> to determine a code for mapping every URL. Again, the mapping is stored in a HashMap for decoding.</p>\n<p>The hash code for a String object is computed(using int arithmetic) as −</p>\n<p>\n<script type="math/tex; mode=display">s[0]*31^{(n - 1)} + s[1]*31^{(n - 2)} + ... + s[n - 1]</script> , where s[i] is the ith character of the string, n is the length of the string.</p>\n<iframe frameborder="0" height="292" name="gzRtcrHu" src="https://leetcode.com/playground/gzRtcrHu/shared" width="100%"></iframe>\n<p><strong>Performance Analysis</strong></p>\n<ul>\n<li>\n<p>The number of URLs that can be encoded is limited by the range of <script type="math/tex; mode=display">\\text{int}</script>, since <script type="math/tex; mode=display">\\text{hashCode}</script> uses integer calculations.</p>\n</li>\n<li>\n<p>The average length of the encoded URL isn\'t directly related to the incoming <script type="math/tex; mode=display">\\text{longURL}</script> length.</p>\n</li>\n<li>\n<p>The <script type="math/tex; mode=display">\\text{hashCode()}</script> doesn\'t generate unique codes for different string. This property of getting the same code for two different inputs is called collision. Thus, as the number of encoded URLs increases, the probability of collisions increases, which leads to failure.</p>\n</li>\n<li>\n<p>The following figure demonstrates the mapping of different objects to the same hashcode and the increasing probability of collisions with increasing number of objects.</p>\n</li>\n</ul>\n<p><img alt="Encode_and_Decode_URLs" src="https://leetcode.com/articles/Figures/535_Encode_and_Decode.png"></p>\n<ul>\n<li>\n<p>Thus, it isn\'t necessary that the collisions start occuring only after a certain number of strings have been encoded, but they could occur way before the limit is even near to the <script type="math/tex; mode=display">\\text{int}</script>. This is similar to birthday paradox i.e. the probability of two people having the same birthday is nearly 50% if we consider only 23 people and 99.9% with just 70 people.</p>\n</li>\n<li>\n<p>Predicting the encoded URL isn\'t easy in this scheme.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-random-numberaccepted">Approach #4 Using random number[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this case, we generate a random integer to be used as the code. In case the generated code happens to be already mapped to some previous <script type="math/tex; mode=display">\\text{longURL}</script>, we generate a new random integer to be used as the code. The data is again stored in a HashMap to help in the decoding process.</p>\n<iframe frameborder="0" height="377" name="CdZ9PRZt" src="https://leetcode.com/playground/CdZ9PRZt/shared" width="100%"></iframe>\n<p><strong>Performance Analysis</strong></p>\n<ul>\n<li>\n<p>The number of URLs that can be encoded is limited by the range of <script type="math/tex; mode=display">\\text{int}</script>.</p>\n</li>\n<li>\n<p>The average length of the codes generated is independent of the <script type="math/tex; mode=display">\\text{longURL}</script>\'s length, since a random integer is used.</p>\n</li>\n<li>\n<p>The length of the URL isn\'t necessarily shorter than the incoming <script type="math/tex; mode=display">\\text{longURL}</script>. It is only dependent on the relative order in which the URLs are encoded.</p>\n</li>\n<li>\n<p>Since a random number is used for coding, again, as in the previous case, the number of collisions could increase with the increasing number of input strings, leading to performance degradation.</p>\n</li>\n<li>\n<p>Determining the encoded URL isn\'t possible in this scheme, since we make use of random numbers.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-random-fixed-length-encodingaccepted">Approach #5 Random fixed-length encoding[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this case, again, we make use of the set of numbers and alphabets to generate the coding for the given URLs, similar to Approach 2. But in this case, the length of the code is fixed to 6 only. Further, random characters from the string to form the characters of the code. In case, the code generated collides with some previously generated code, we form a new random code.</p>\n<iframe frameborder="0" height="515" name="u5oj9dfd" src="https://leetcode.com/playground/u5oj9dfd/shared" width="100%"></iframe>\n<p><strong>Performance Analysis</strong></p>\n<ul>\n<li>\n<p>The number of URLs that can be encoded is quite large in this case, nearly of the order <script type="math/tex; mode=display">(10+26*2)^6</script>.</p>\n</li>\n<li>\n<p>The length of the encoded URLs is fixed to 6 units, which is a significant reduction for very large URLs.</p>\n</li>\n<li>\n<p>The performance of this scheme is quite good, due to a very less probability of repeated same codes generated.</p>\n</li>\n<li>\n<p>We can increase the number of encodings possible as well, by increasing the length of the encoded strings. Thus, there exists a  tradeoff between the length of the code and the number of encodings possible.</p>\n</li>\n<li>\n<p>Predicting the encoding isn\'t possible in this scheme since random numbers are used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google', 'Facebook', 'Amazon', 'Uber'],
  },
  {
    id: '536',
    name: 'Construct Binary Tree from String ',
    acceptance: '42.8%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>You need to construct a binary tree from a string consisting of parenthesis and integers. </p>\n\n<p>The whole input represents a binary tree. It contains an integer followed by zero, one or two pairs of parenthesis. The integer represents the root's value and a pair of parenthesis contains a child binary tree with the same structure. </p>\n\n<p>You always start to construct the <b>left</b> child node of the parent first if it exists.</p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> \"4(2(3)(1))(6(5))\"\n<b>Output:</b> return the tree root node representing the following tree:\n\n       4\n     /   \\\n    2     6\n   / \\   / \n  3   1 5   \n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>There will only be <code>'('</code>,  <code>')'</code>,  <code>'-'</code> and  <code>'0'</code> ~ <code>'9'</code> in the input string.</li>\n<li>An empty tree is represented by <code>\"\"</code> instead of <code>\"()\"</code>.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Amazon'],
  },
  {
    id: '537',
    name: 'Complex Number Multiplication',
    acceptance: '64.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven two strings representing two <a href="https://en.wikipedia.org/wiki/Complex_number">complex numbers</a>.</p>\n\n<p>\nYou need to return a string representing their multiplication. Note i<sup>2</sup> = -1 according to the definition.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "1+1i", "1+1i"\n<b>Output:</b> "0+2i"\n<b>Explanation:</b> (1 + i) * (1 + i) = 1 + i<sup>2</sup> + 2 * i = 2i, and you need convert it to the form of 0+2i.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> "1+-1i", "1+-1i"\n<b>Output:</b> "0+-2i"\n<b>Explanation:</b> (1 - i) * (1 - i) = 1 + i<sup>2</sup> - 2 * i = -2i, and you need convert it to the form of 0+-2i.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><ol>\n<li>The input strings will not have extra blank.</li>\n<li>The input strings will be given in the form of <b>a+bi</b>, where the integer <b>a</b> and <b>b</b> will both belong to the range of [-100, 100]. And <b>the output should be also in this form</b>.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-simple-solutionaccepted">Approach #1 Simple Solution[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-simple-solutionaccepted">Approach #1 Simple Solution[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Multiplication of two complex numbers can be done as:</p>\n<p>\n<script type="math/tex; mode=display">\n(a+ib) \\times (x+iy)=ax+i^2by+i(bx+ay)=ax-by+i(bx+ay)\n</script>\n</p>\n<p>We simply split up the real and the imaginary parts of the given complex strings based on the \'+\' and the \'i\' symbols. We store the real parts of the two strings <script type="math/tex; mode=display">a</script> and <script type="math/tex; mode=display">b</script> as <script type="math/tex; mode=display">x[0]</script> and <script type="math/tex; mode=display">y[0]</script> respectively and the imaginary parts as <script type="math/tex; mode=display">x[1]</script> and <script type="math/tex; mode=display">y[1]</script> respectively. Then, we multiply the real and the imaginary parts as required after converting the extracted parts into integers. Then, we again form the return string in the required format and return the result.</p>\n<iframe frameborder="0" height="309" name="jgLSUzDc" src="https://leetcode.com/playground/jgLSUzDc/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script>. Here splitting takes constant time as length of the string is very small <script type="math/tex; mode=display">(<20)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '538',
    name: 'Convert BST to Greater Tree',
    acceptance: '49.1%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.</p>\n\n<p>\n<b>Example:</b>\n</p><pre><b>Input:</b> The root of a Binary Search Tree like this:\n              5\n            /   \\\n           2     13\n\n<b>Output:</b> The root of a Greater Tree like this:\n             18\n            /   \\\n          20     13\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#initial-thoughts">Initial Thoughts</a></li>\n<li><a href="#approach-1-recursion-accepted">Approach #1 Recursion [Accepted]</a></li>\n<li><a href="#approach-2-iteration-with-a-stack-accepted">Approach #2 Iteration with a Stack [Accepted]</a></li>\n<li><a href="#approach-3-reverse-morris-in-order-traversal-accepted">Approach #3 Reverse Morris In-order Traversal [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="initial-thoughts">Initial Thoughts</h4>\n<p>This question asks us to modify an asymptotically linear number of nodes in a\ngiven binary search tree, so a very efficient solution will visit each node\nonce. The key to such a solution would be a way to visit nodes in descending\norder, keeping a sum of all values that we have already visited and adding\nthat sum to the node\'s values as we traverse the tree. This method for tree traversal is\nknown as a\n<em>reverse in-order traversal</em>, and allows us to guarantee visitation of each\nnode in the desired order. The basic idea of such a traversal is that before\nvisiting any node in the tree, we must first visit all nodes with greater\nvalue. Where are all of these nodes conveniently located? In the right\nsubtree.</p>\n<h4 id="approach-1-recursion-accepted">Approach #1 Recursion [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>One way to perform a reverse in-order traversal is via recursion. By using\nthe call stack to return to previous nodes, we can easily visit the nodes in\nreverse order.</p>\n<p><strong>Algorithm</strong></p>\n<p>For the recursive approach, we maintain some minor "global" state so each\nrecursive call can access and modify the current total sum. Essentially, we\nensure that the current node exists, recurse on the right subtree, visit the\ncurrent node by updating its value and the total sum, and finally recurse on\nthe left subtree. If we know that recursing on <code>root.right</code> properly\nupdates the right subtree and that recursing on <code>root.left</code> properly updates\nthe left subtree, then we are guaranteed to update all nodes with larger values\nbefore the current node and all nodes with smaller values after.</p>\n<iframe frameborder="0" height="276" name="izz2BZVf" src="https://leetcode.com/playground/izz2BZVf/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>A binary tree has no cycles by definition, so <code>convertBST</code> gets called on\neach node no more than once. Other than the recursive calls, <code>convertBST</code>\ndoes a constant amount of work, so a linear number of calls to <code>convertBST</code>\nwill run in linear time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>Using the prior assertion that <code>convertBST</code> is called a linear number of\ntimes, we can also show that the entire algorithm has linear space\ncomplexity. Consider the worst case, a tree with only right (or only left)\nsubtrees. The call stack will grow until the end of the longest path is\nreached, which in this case includes all <script type="math/tex; mode=display">n</script> nodes.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-iteration-with-a-stack-accepted">Approach #2 Iteration with a Stack [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we don\'t want to use recursion, we can also perform a reverse in-order\ntraversal via iteration and a literal stack to emulate the call stack.</p>\n<p><strong>Algorithm</strong></p>\n<p>One way to describe the iterative stack method is in terms of the intuitive\nrecursive solution. First, we initialize an empty stack and set the current\nnode to the root. Then, so long as there are unvisited nodes in the stack or\n<code>node</code> does not point to <code>null</code>, we push all of the nodes along the path to\nthe rightmost leaf onto the stack. This is equivalent to always processing\nthe right subtree first in the recursive solution, and is crucial for the\nguarantee of visiting nodes in order of decreasing value. Next, we visit the\nnode on the top of our stack, and consider its left subtree. This is just\nlike visiting the current node before recursing on the left subtree in the\nrecursive solution. Eventually, our stack is empty and <code>node</code> points to the\nleft <code>null</code> child of the tree\'s minimum value node, so the loop terminates.</p>\n<iframe frameborder="0" height="497" name="U56ntS8W" src="https://leetcode.com/playground/U56ntS8W/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>The key observation is that each node is pushed onto the stack exactly\nonce. I will take for granted the assumption that a node will always be\npushed <em>at least</em> once, as the alternative would imply that at least one\nnode is disconnected from the root. Notice that nodes are only pushed\nonto the stack when they are pointed to by <code>node</code> at the beginning of the\nouter <code>while</code> loop, or when there is a path to them from such a node by\nusing only <code>right</code> pointers. Then notice that at the end of each\niteration of the loop, <code>node</code> points to the left child of a node that has\nbeen pushed onto (and subsequently popped from) the stack. Therefore,\nbecause the outer <code>while</code> loop always begins with <code>node</code> pointing to\n<code>None</code>, the root (which is not pointed to by any other node), or a left\nchild of a visited node, we cannot revisit nodes.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>If we assume that the above logic is sound, the assertion that each node is\npushed onto the stack exactly once implies that the stack can contain (at\nmost) <script type="math/tex; mode=display">n</script> nodes. All other parts of the algorithm use constant space, so\nthere is overall a linear memory footprint.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-reverse-morris-in-order-traversal-accepted">Approach #3 Reverse Morris In-order Traversal [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>There is a clever way to perform an in-order traversal using only linear time\nand constant space, first described by J. H. Morris in his 1979 paper\n"Traversing Binary Trees Simply and Cheaply". In general, the recursive and\niterative stack methods sacrifice linear space for the ability to return to a\nnode after visiting its left subtree. The Morris traversal instead exploits\nthe unused <code>null</code> pointer(s) of the tree\'s leaves to create a temporary link\nout of the left subtree, allowing the traversal to be performed using only\nconstant additional memory. To apply it to this problem, we can simply swap\nall "left" and "right" references, which will reverse the traversal.</p>\n<p><strong>Algorithm</strong></p>\n<p>First, we initialize <code>node</code>, which points to the root. Then, until <code>node</code>\npoints to <code>null</code> (specifically, the left <code>null</code> of the tree\'s minimum-value\nnode), we repeat the following. First, consider whether the current node has\na right subtree. If it does not have a right subtree, then there is no\nunvisited node with a greater value, so we can visit this node and move into\nthe left subtree. If it does have a right subtree, then there is at least one\nunvisited node with a greater value, and thus we must visit first go to the\nright subtree. To do so, we obtain a reference to the in-order successor (the\nsmallest-value node larger than the current) via our helper function\n<code>getSuccessor</code>. This successor node is the node that must be visited\nimmediately before the current node, so it by definition has a <code>null</code> <code>left</code>\npointer (otherwise it would not be the successor). Therefore, when we first\nfind a node\'s successor, we temporarily link it (via its <code>left</code> pointer) to\nthe node and proceed to the node\'s right subtree. Then, when we finish\nvisiting the right subtree, the leftmost <code>left</code> pointer in it will be our\ntemporary link that we can use to escape the subtree. After following this\nlink, we have returned to the original node that we previously passed\nthrough, but did not visit. This time, when we find that the successor\'s\n<code>left</code> pointer loops back to the current node, we know that we have visited\nthe entire right subtree, so we can now erase the temporary link and move\ninto the left subtree.</p>\n<p align="center"><img alt="Reverse Morris Traversal Example" src="https://leetcode.com/articles/Figures/543/morris.png"></p>\n<p>The figure above shows an example of the modified tree during a reverse\nMorris traversal. Left pointers are illustrated in blue and right pointers in\nred. Dashed edges indicate temporary links generated at some point during the\nalgorithm (which will be erased before it terminates). Notice that blue edges\ncan be dashed, as we always exploit the empty <code>left</code> pointer of successor\nnodes. Additionally, notice that every node with a right subtree has a link\nfrom its in-order successor.</p>\n<iframe frameborder="0" height="500" name="9fu9CDg3" src="https://leetcode.com/playground/9fu9CDg3/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>\n</p>\n<p>Although the Morris traversal does slightly more work than the other\napproaches, it is only by a constant factor. To be specific, if we can\nshow that each edge in the tree is traversed no more than <script type="math/tex; mode=display">k</script> times (for\nsome constant <script type="math/tex; mode=display">k</script>), then the algorithm is shown to have linear time\ncomplexity. First, note that <code>getSuccessor</code> is called at most twice per\nnode. On the first invocation, the temporary link back to the node in\nquestion is created, and on the second invocation, the temporary link is\nerased. Then, the algorithm steps into the left subtree with no way to\nreturn to the node. Therefore, each edge can only be traversed 3 times:\nonce when we move the <code>node</code> pointer, and once for each of the two calls\nto <code>getSuccessor</code>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>\n</p>\n<p>Because we only manipulate pointers that already exist, the Morris\ntraversal uses constant space.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/emptyset/">@emptyset</a>.</p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '539',
    name: 'Minimum Time Difference',
    acceptance: '46.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            Given a list of 24-hour clock time points in "Hour:Minutes" format, find the minimum <b>minutes</b> difference between any two time points in the list. \n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> ["23:59","00:00"]\n<b>Output:</b> 1\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The number of time points in the given list is at least 2 and won\'t exceed 20000.</li>\n<li>The input time is legal and ranges from 00:00 to 23:59.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Palantir'],
  },
  {
    id: '540',
    name: 'Single Element in a Sorted Array',
    acceptance: '56.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once. \n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,1,2,3,3,4,4,8,8]\n<b>Output:</b> 2\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [3,3,7,7,10,11,11]\n<b>Output:</b> 10\n</pre>\n<p></p>\n\n<p><b>Note:</b>\nYour solution should run in O(log n) time and O(1) space.\n</p>\n\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '541',
    name: 'Reverse String II',
    acceptance: '43.8%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p></p>\nGiven a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.\n<p></p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> s = "abcdefg", k = 2\n<b>Output:</b> "bacdfeg"\n</pre>\n<p></p>\n\n<b>Restrictions:</b> \n<ol>\n<li> The string consists of lower English letters only.</li>\n<li> Length of the given string and k will in the range [1, 10000]</li>\n</ol>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-direct-accepted">Approach #1: Direct [Accepted]</a></li>\n</ul>\n</div>\n<hr>\n<h4 id="approach-1-direct-accepted">Approach #1: Direct [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>We will reverse each block of <code>2k</code> characters directly.</p>\n<p>Each block starts at a multiple of <code>2k</code>: for example, <code>0, 2k, 4k, 6k, ...</code>.  One thing to be careful about is we may not reverse each block if there aren\'t enough characters.</p>\n<p>To reverse a block of characters from <code>i</code> to <code>j</code>, we can swap characters in positions <code>i++</code> and <code>j--</code>.</p>\n<iframe frameborder="0" height="293" name="2qnQN5xs" src="https://leetcode.com/playground/2qnQN5xs/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the size of <code>s</code>.  We build a helper array, plus reverse about half the characters in <code>s</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of <code>a</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '542',
    name: '01 Matrix',
    acceptance: '32.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.\n</p>\nThe distance between two adjacent cells is 1.\n\n<p><b>Example 1: </b><br>\nInput:\n</p><pre>0 0 0\n0 1 0\n0 0 0\n</pre>\nOutput:\n<pre>0 0 0\n0 1 0\n0 0 0\n</pre>\n<p></p>\n\n<p><b>Example 2: </b><br>\nInput:\n</p><pre>0 0 0\n0 1 0\n1 1 1\n</pre>\nOutput:\n<pre>0 0 0\n0 1 0\n1 2 1\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The number of elements of the given matrix will not exceed 10,000.</li>\n<li>There are at least one 0 in the given matrix.</li>\n<li>The cells are adjacent in only four directions: up, down, left and right.</li>\n</ol>\n<p></p>\n\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-bfs-accepted">Approach #2 Using BFS [Accepted]</a></li>\n<li><a href="#approach-3-dp-approach-accepted">Approach #3 DP Approach [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute force [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>Do what the question says.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>Initialize <code>dist[i][j]=INT_MAX</code> for all <code>{i,j}</code> cells.</li>\n<li>Iterate over the matrix.</li>\n<li>If cell is <code>0</code>, <code>dist[i][j]=0</code>,</li>\n<li>Else, for each <code>1</code> cell,<ul>\n<li>Iterate over the entire matrix</li>\n<li>If the cell is <code>0</code>, calculate its distance from current cell as <code>abs(k-i)+abs(l-j)</code>.</li>\n<li>If the distance is smaller than the current distance, update it.</li>\n</ul>\n</li>\n</ul>\n<iframe frameborder="0" height="445" name="WrxDXrW3" src="https://leetcode.com/playground/WrxDXrW3/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity: <script type="math/tex; mode=display">O((r \\cdot c)^2)</script>.\nIterating over the entire matrix for each <code>1</code> in the matrix.</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(r \\cdot c)</script>.\nNo extra space required than the <code>vector&lt;vector&lt;int&gt; &gt; dist</code></p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-bfs-accepted">Approach #2 Using BFS [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p><em>A better brute force</em>:\nLooking over the entire matrix appears wasteful and hence, we can use Breadth First Search(BFS) to limit the search to the nearest <code>0</code> found for each <code>1</code>. As soon as a <code>0</code> appears during the BFS, we know that the <code>0</code> is nearest, and hence, we move to the next <code>1</code>.</p>\n<p><em>Think again</em>:\nBut, in this approach, we will only be able to update the distance of one <code>1</code> using one BFS, which could in fact, result in slightly higher complexity than the Approach #1 brute force.\nBut hey,this could be optimised if we start the BFS from <code>0</code>s and thereby, updating the distances of all the <code>1</code>s in the path.</p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>For our BFS routine, we keep a queue, <code>q</code> to maintain the queue of cells to be examined next.</li>\n<li>We start by adding all the cells with <code>0</code>s to <code>q</code>.</li>\n<li>Intially, distance for each <code>0</code> cell is <code>0</code> and distance for each <code>1</code> is <code>INT_MAX</code>, which is updated during the BFS.</li>\n<li>Pop the cell from queue, and examine its neighbours. If the new calculated distance for neighbour <code>{i,j}</code> is smaller, we add <code>{i,j}</code> to <code>q</code> and update <code>dist[i][j]</code>.</li>\n</ul>\n<iframe frameborder="0" height="515" name="abTJGHUf" src="https://leetcode.com/playground/abTJGHUf/shared" width="100%"></iframe>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>Time complexity: <script type="math/tex; mode=display">O(r \\cdot c)</script>.</li>\n<li>\n<p>Since, the new cells are added to the queue only if their current distance is greater than the calculated distance, cells are not likely to be added multiple times.</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(r \\cdot c)</script>. Additional <script type="math/tex; mode=display">O(r \\cdot c)</script> for queue than in Approach #1</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-dp-approach-accepted">Approach #3 DP Approach [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>The distance of a cell from <code>0</code> can be calculated if we know the nearest distance for all the neighbours, in which case the distance is minimum distance of any neightbour + 1. And, instantly, the word come to mind DP!!<br>\nFor each <code>1</code>, the minimum path to <code>0</code> can be in any direction. So, we need to check all the 4 direction. In one iteration from top to bottom, we can check left and top directions, and we need another iteration from bottom to top to check for right and bottom direction.<br></p>\n<p><strong>Algorithm</strong></p>\n<ul>\n<li>Iterate the matrix from top to bottom-left to right:</li>\n<li>Update\n  <script type="math/tex; mode=display">\\text{dist}[i][j]=\\min(\\text{dist}[i][j],\\min(\\text{dist}[i][j-1],\\text{dist}[i-1][j])+1)</script>\n  i.e., minimum of the current dist and distance from top or left neighbour +1, that would have been already calculated previously in the current iteration.</li>\n<li>Now, we need to do the back iteration in the similar manner: from bottom to top-right to left:</li>\n<li>Update\n  <script type="math/tex; mode=display">\\text{dist}[i][j]=\\min(\\text{dist}[i][j],\\min(\\text{dist}[i][j+1],\\text{dist}[i+1][j])+1)</script>\n  i.e. minimum of current dist and distances calculated from bottom and right neighbours, that would be already available in current iteration.</li>\n</ul>\n<iframe frameborder="0" height="515" name="ZLQD7VF7" src="https://leetcode.com/playground/ZLQD7VF7/shared" width="100%"></iframe>\n<p><strong>Complexity analysis</strong></p>\n<ul>\n<li>Time complexity: <script type="math/tex; mode=display">O(r \\cdot c)</script>. 2 passes of <script type="math/tex; mode=display">r \\cdot c</script> each</li>\n<li>Space complexity: <script type="math/tex; mode=display">O(r \\cdot c)</script>. No additional space required than <code>dist vector&lt;vector&lt;int&gt; &gt;</code></li>\n</ul>\n<hr>\n<p>Analysis written by <a href="https://leetcode.com/abhinavbansal0">@abhinavbansal0</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '543',
    name: 'Diameter of Binary Tree',
    acceptance: '44.8%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <b>longest</b> path between any two nodes in a tree. This path may or may not pass through the root.\n</p>\n\n<p>\n<b>Example:</b><br>\nGiven a binary tree <br>\n</p><pre>          1\n         / \\\n        2   3\n       / \\     \n      4   5    \n</pre>\n<p></p>\n<p>\nReturn <b>3</b>, which is the length of the path [4,2,1,3] or [5,2,1,3].\n</p>\n\n<p><b>Note:</b>\nThe length of path between two nodes is represented by the number of edges between them.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</a></li>\n</ul>\n</div>\n<hr>\n<h4 id="approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Any path can be written as two <em>arrows</em> (in different directions) from some node, where an arrow is a path that starts at some node and only travels down to child nodes.</p>\n<p>If we knew the maximum length arrows <code>L, R</code> for each child, then the best path touches <code>L + R + 1</code> nodes.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let\'s calculate the depth of a node in the usual way: max(depth of node.left, depth of node.right) + 1. While we do, a path "through" this node uses 1 + (depth of node.left) + (depth of node.right) nodes. Let\'s search each node and remember the highest number of nodes used in some path. The desired length is 1 minus this number.</p>\n<iframe frameborder="0" height="310" name="6ahaRHCG" src="https://leetcode.com/playground/6ahaRHCG/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>.  We visit every node once.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of our implicit call stack during our depth-first search.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Google', 'Facebook'],
  },
  {
    id: '544',
    name: 'Output Contest Matches ',
    acceptance: '71.0%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nDuring the NBA playoffs, we always arrange the rather strong team to play with the rather weak team, like make the rank 1 team play with the rank n<sub>th</sub> team, which is a good strategy to make the contest more interesting. Now, you're given <b>n</b> teams, you need to output their <b>final</b> contest matches in the form of a string.\n</p>\n\n<p>The <b>n</b> teams are given in the form of positive integers from 1 to n, which represents their initial rank. (Rank 1 is the strongest team and Rank n is the weakest team.) We'll use parentheses('(', ')') and commas(',') to represent the contest team pairing - parentheses('(' , ')') for pairing and commas(',') for partition. During the pairing process in each round, you always need to follow the strategy of making the rather strong one pair with the rather weak one.</p> \n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> 2\n<b>Output:</b> (1,2)\n<b>Explanation:</b> \nInitially, we have the team 1 and the team 2, placed like: 1,2.\nThen we pair the team (1,2) together with '(', ')' and ',', which is the final answer.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> 4\n<b>Output:</b> ((1,4),(2,3))\n<b>Explanation:</b> \nIn the first round, we pair the team 1 and 4, the team 2 and 3 together, as we need to make the strong team and weak team together.\nAnd we got (1,4),(2,3).\nIn the second round, the winners of (1,4) and (2,3) need to play again to generate the final winner, so you need to add the paratheses outside them.\nAnd we got the final answer ((1,4),(2,3)).\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> 8\n<b>Output:</b> (((1,8),(4,5)),((2,7),(3,6)))\n<b>Explanation:</b> \nFirst round: (1,8),(2,7),(3,6),(4,5)\nSecond round: ((1,8),(4,5)),((2,7),(3,6))\nThird round: (((1,8),(4,5)),((2,7),(3,6)))\nSince the third round will generate the final winner, you need to output the answer (((1,8),(4,5)),((2,7),(3,6))).\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The <b>n</b> is in range [2, 2<sup>12</sup>].</li>\n<li>We ensure that the input <b>n</b> can be converted into the form 2<sup>k</sup>, where k is a positive integer.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-simulation-accepted">Approach #1: Simulation [Accepted]</a></li>\n<li><a href="#approach-2-linear-write-accepted">Approach #2: Linear Write [Accepted]</a></li>\n</ul>\n</div>\n<hr>\n<h4 id="approach-1-simulation-accepted">Approach #1: Simulation [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Let <code>team[i]</code> be the correct team string of the <code>i</code>-th strongest team for that round.  We will maintain these correctly as the rounds progress.</p>\n<p><strong>Algorithm</strong></p>\n<p>In each round, the <code>i</code>-th team becomes <code>"(" + team[i] + "," + team[n-1-i] + ")"</code>, and then there are half as many teams.</p>\n<iframe frameborder="0" height="276" name="q4aFLoLB" src="https://leetcode.com/playground/q4aFLoLB/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N \\log N)</script>.  Each of <script type="math/tex; mode=display">O(\\log N)</script> rounds performs <script type="math/tex; mode=display">O(N)</script> work.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N \\log N)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-linear-write-accepted">Approach #2: Linear Write [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Let\'s try to solve the problem in linear time.  We can treat this problem as two separate problems: outputting the correct sequence of parentheses and commas, and outputting the correct team number.  With a little effort, one can be convinced that a linear time solution probably exists.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let\'s focus on the parentheses first.  We can use recursion to find the answer.  For example, when <code>N = 8</code>, let <code>R = log_2(N) = 3</code> be the number of rounds.  The parentheses and commas look like this:</p>\n<div class="codehilite"><pre><span></span><span class="p">(((</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">),(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)),((</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">),(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)))</span>\n</pre></div>\n<p>But this is just recursively</p>\n<div class="codehilite"><pre><span></span><span class="s2">"("</span> <span class="o">+</span> <span class="p">(</span><span class="n">sequence</span> <span class="k">for</span> <span class="n">R</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s2">","</span> <span class="o">+</span> <span class="p">(</span><span class="n">sequence</span> <span class="k">for</span> <span class="n">R</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s2">")"</span>\n<span class="o">=</span> <span class="s2">"("</span> <span class="o">+</span> <span class="s2">"((x,x),(x,x))"</span> <span class="o">+</span> <span class="s2">","</span> <span class="o">+</span> <span class="s2">"((x,x),(x,x))"</span> <span class="o">+</span> <span class="s2">")"</span>\n</pre></div>\n<p>Now let\'s look at the team numbers.  For <code>N = 16</code>, the team numbers are:</p>\n<p><code>team = [1, 16, 8, 9, 4, 13, 5, 12, 2, 15, 7, 10, 3, 14, 6, 11]</code></p>\n<p>One thing we might notice is that adjacent numbers sum to <code>17</code>.  More specifically, indices that are 0 and 1 (mod 2) sum to <code>17</code>.  Also, indices 0 and 2 (mod 4) sum to <code>9</code>, indices 0 and 4 (mod 8) sum to <code>5</code>, and so on.</p>\n<p>The pattern in general is: indices <code>0</code> and <code>2**r</code> (mod <code>2**(r+1)</code>) sum to <code>N * 2**-r + 1</code>.</p>\n<p>If we want to find the next <code>team[i]</code>, then the lowest bit of <code>i</code> will help determine it\'s lower neighbor.  For example, <code>team[12] = team[0b1100]</code> has lower bit <code>w = 4 = 0b100</code>, so <code>12</code> has lower neighbor <code>12 - w = 8</code>, and also those team numbers sum to <code>N / w + 1</code>.</p>\n<iframe frameborder="0" height="497" name="rHTkiGV4" src="https://leetcode.com/playground/rHTkiGV4/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>.  We print each of <script type="math/tex; mode=display">O(N)</script> characters in order.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>.  </p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '545',
    name: 'Boundary of Binary Tree ',
    acceptance: '31.9%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given a binary tree, return the values of its boundary in <b>anti-clockwise</b> direction starting from root.\nBoundary includes left boundary, leaves, and right boundary in order without duplicate nodes. </p>\n\n<p><b>Left boundary</b> is defined as the path from root to the <b>left-most</b> node. <b>Right boundary</b> is defined as the path from root to the <b>right-most</b> node. If the root doesn't have left subtree or right subtree, then the root itself is left boundary or right boundary. Note this definition only applies to the input binary tree, and not applies to any subtrees.</p>\n\n<p>The <b>left-most</b> node is defined as a <b>leaf</b> node you could reach when you always firstly travel to the left subtree if exists. If not, travel to the right subtree. Repeat until you reach a leaf node.</p>\n\n<p>The <b>right-most</b> node is also defined by the same way with left and right exchanged.</p>\n\n<p>\n<b>Example 1</b><br>\n</p><pre><b>Input:</b>\n  1\n   \\\n    2\n   / \\\n  3   4\n\n<b>Ouput:</b>\n[1, 3, 4, 2]\n\n<b>Explanation:</b>\nThe root doesn't have left subtree, so the root itself is left boundary.\nThe leaves are node 3 and 4.\nThe right boundary are node 1,2,4. Note the anti-clockwise direction means you should output reversed right boundary.\nSo order them in anti-clockwise without duplicates and we have [1,3,4,2].\n</pre>\n<p></p>\n\n<p>\n<b>Example 2</b><br>\n</p><pre><b>Input:</b>\n    ____1_____\n   /          \\\n  2            3\n / \\          / \n4   5        6   \n   / \\      / \\\n  7   8    9  10  \n       \n<b>Ouput:</b>\n[1,2,4,7,8,9,10,6,3]\n\n<b>Explanation:</b>\nThe left boundary are node 1,2,4. (4 is the left-most node according to definition)\nThe leaves are node 4,7,8,9,10.\nThe right boundary are node 1,3,6,10. (10 is the right-most node).\nSo order them in anti-clockwise without duplicate nodes we have [1,2,4,7,8,9,10,6,3].\n</pre>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-simple-solution-accepted">Approach #1 Simple Solution [Accepted]</a></li>\n<li><a href="#approach-2-using-preorder-traversal-accepted">Approach #2 Using PreOrder Traversal [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-simple-solution-accepted">Approach #1 Simple Solution [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>One simple approach is to divide this problem into three subproblems- left boundary, leaves and right boundary.</p>\n<ul>\n<li>Left Boundary: We keep on traversing the tree towards the left and keep on adding the nodes in the <script type="math/tex; mode=display">res</script> array, provided the current node isn\'t a leaf node. If at any point, we can\'t find the left child of a node, but its right child exists, we put the right child in the <script type="math/tex; mode=display">res</script> and continue the process. The following animation depicts the process.</li>\n</ul>\n<!--![Left_Boundary](https://leetcode.com/articles/Figures/545_Boundary_Left.gif)-->\n<p>!?!../Documents/545_Boundary_Of_Binary_Tree1.json:1000,563!?!</p>\n<ul>\n<li>Leaf Nodes: We make use of a recursive function <code>addLeaves(res,root)</code>, in which we change the root node for every recursive call. If the current root node happens to be a leaf node, it is added to the <script type="math/tex; mode=display">res</script> array. Otherwise, we make the recursive call using the left child of the current node as the new root. After this, we make the recursive call using the right child of the current node as the new root. The following animation depicts the process.</li>\n</ul>\n<!--![Leaf_Boundary](https://leetcode.com/articles/Figures/545_Boundary_Leaf.gif)-->\n<p>!?!../Documents/545_Boundary_Of_Binary_Tree2.json:1000,563!?!</p>\n<ul>\n<li>Right Boundary: We perform the same process as the left boundary. But, this time, we traverse towards the right. If the right child doesn\'t exist, we move towards the left child. Also, instead of putting the traversed nodes in the <script type="math/tex; mode=display">res</script> array, we push them over a stack during the traversal. After the complete traversal is done, we pop the element from over the stack and append them to the <script type="math/tex; mode=display">res</script> array. The following animation depicts the process.</li>\n</ul>\n<!--![Right_Boundary](https://leetcode.com/articles/Figures/545_Boundary_Right.gif)-->\n<p>!?!../Documents/545_Boundary_Of_Binary_Tree3.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="xEtX5sQc" src="https://leetcode.com/playground/xEtX5sQc/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script> One complete traversal for leaves and two traversals upto depth of binary tree for left and right boundary.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>\n<script type="math/tex; mode=display">res</script> and <script type="math/tex; mode=display">stack</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-preorder-traversal-accepted">Approach #2 Using PreOrder Traversal [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Before we dive into this approach, let\'s look at the preorder traversal of a simple Binary Tree as shown below:</p>\n<p><img alt="Preorder Traversal" src="https://leetcode.com/articles/Figures/545_Preorder.png"></p>\n<p>From the above figure, we can observe that our problem statement is very similar to the Preorder traversal. Actually, the order of traversal is the same(except for the right boundary nodes, for which it is the reverse), but we need to selectively include the nodes in the return result list. Thus, we need to include only those nodes in the result, which are either on the left boundary, the leaves or the right boundary.</p>\n<p>In order to distinguish between the various kinds of nodes, we make use of a <script type="math/tex; mode=display">flag</script> as follows:</p>\n<ul>\n<li>\n<p>Flag=0: Root Node.</p>\n</li>\n<li>\n<p>Flag=1: Left Boundary Node.</p>\n</li>\n<li>\n<p>Flag=2: Right Boundary Node.</p>\n</li>\n<li>\n<p>Flag=3: Others(Middle Node).</p>\n</li>\n</ul>\n<p>We make use of three lists <script type="math/tex; mode=display">\\text{left_boundary}</script>, <script type="math/tex; mode=display">\\text{right_boundary}</script>, <script type="math/tex; mode=display">\\text{leaves}</script> to store the appropriate nodes and append the three lists at the end.</p>\n<p>We go for the normal preorder traversal, but while calling the recursive function for preorder traversal using the left child or the right child of the current node, we also pass the <script type="math/tex; mode=display">flag</script> information indicating the type of node that the current child behaves like.</p>\n<p>For obtaining the flag information about the left child of the current node, we make use of the function <code>leftChildFlag(node, flag)</code>. In the case of a left child, the following cases are possible, as can be verified by looking at the figure above:</p>\n<ul>\n<li>\n<p>The current node is a left boundary node: In this case, the left child will always be a left boundary node. e.g. relationship between E &amp; J in the above figure.</p>\n</li>\n<li>\n<p>The current node is a root node: In this case, the left child will always be a left boundary node. e.g. relationship between A &amp; B in the above figure.</p>\n</li>\n<li>\n<p>The current node is a right boundary node: In this case, if the right child of the current node doesn\'t exist, the left child always acts as the right boundary node. e.g. G &amp; N. But, if the right child exists, the left child always acts as the middle node. e.g. C &amp; F.</p>\n</li>\n</ul>\n<p>Similarly, for obtaining the flag information about the right child of the current node, we make use of the function <code>rightChildFlag(node, flag)</code>. In the case of a right child, the following cases are possible, as can be verified by looking at the figure above:</p>\n<ul>\n<li>\n<p>The current node is a right boundary node: In this case, the right child will always be a right boundary node. e.g. relationship between C &amp; G in the above figure.</p>\n</li>\n<li>\n<p>The current node is a root node: In this case, the right child will always be a left boundary node. e.g. relationship between A &amp; C in the above figure.</p>\n</li>\n<li>\n<p>The current node is a left boundary node: In this case, if the left child of the current node doesn\'t exist, the right child always acts as the left boundary node. e.g. B &amp; E. But, if the left child exists, the left child always acts as the middle node.</p>\n</li>\n</ul>\n<p>Making use of the above information, we set the <script type="math/tex; mode=display">flag</script> appropriately, which is used to determine the list in which the current node has to be appended.</p>\n<iframe frameborder="0" height="515" name="2t96fXpN" src="https://leetcode.com/playground/2t96fXpN/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script> One complete traversal of the tree is done.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script> The recursive stack can grow upto a depth of <script type="math/tex; mode=display">n</script>. Further, <script type="math/tex; mode=display">\\text{left_boundary}</script>, <script type="math/tex; mode=display">\\text{right_boundary}</script> and <script type="math/tex; mode=display">\\text{leaves}</script> combined together can be of size <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google', 'Amazon'],
  },
  {
    id: '546',
    name: 'Remove Boxes',
    acceptance: '34.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given several boxes with different colors represented by different positive numbers. <br>\nYou may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (composed of k boxes, k &gt;= 1), remove them and get <code>k*k</code> points.<br>\nFind the maximum points you can get.\n</p>\n\n<p><b>Example 1:</b><br>\nInput: \n</p><pre>[1, 3, 2, 2, 2, 3, 4, 3, 1]\n</pre>\nOutput:\n<pre>23\n</pre>\nExplanation: \n<pre>[1, 3, 2, 2, 2, 3, 4, 3, 1] \n----&gt; [1, 3, 3, 4, 3, 1] (3*3=9 points) \n----&gt; [1, 3, 3, 3, 1] (1*1=1 points) \n----&gt; [1, 1] (3*3=9 points) \n----&gt; [] (2*2=4 points)\n</pre>\n<p></p>\n\n<p><b>Note:</b>\nThe number of boxes <code>n</code> would not exceed 100.\n</p>\n\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-approachtime-limit-exceeded">Approach #1 Brute Force Approach[Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-dp-with-memorizationaccepted">Approach #2 Using DP with Memorization[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-approachtime-limit-exceeded">Approach #1 Brute Force Approach[Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The brute force approach is very obvious. We try removing every possible element of the given array and calculate the points obtained for the rest of the array in a recursive manner.</p>\n<iframe frameborder="0" height="513" name="7oDx7spV" src="https://leetcode.com/playground/7oDx7spV/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n!)</script>. <script type="math/tex; mode=display">f(n)</script> be the time to find the solution of n boxes with n different colors, then obviously <script type="math/tex; mode=display">f(n) = n * f(n-1)</script> which results in the <script type="math/tex; mode=display">n!</script> time complexity.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^2)</script>. The recursive tree goes upto a depth of <script type="math/tex; mode=display">n</script>, with every level consisting of upto <script type="math/tex; mode=display">n</script>\n<script type="math/tex; mode=display">\\text{newBoxes}</script> elements.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-dp-with-memorizationaccepted">Approach #2 Using DP with Memorization[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The problem with the previous approach is that it involves a lot of recomputations. e.g. Consider the array <code>[3, 2, 1, 4, 4, 4]</code>. In this case, we try to remove 3 and calculate the cost for the remaining array, in which we try removing 2 first leading to the point calculation for the subarray <code>[1, 4, 4, 4]</code>. The same happens in the second iteration in which we try to remove 2 first and then remove 3. We can prune the depth of the recursion tree a lot by using memorization.</p>\n<p>But the problem of memorization isn\'t simple in this case. We can\'t simply use the start and end index of the array to determine the maximum number of points which that subarray will eventually lead to. This is because the points obtained by using the subarray depend not only on the subarray but also on the removals done prior to reaching the current subarray, which aren\'t even a part of the subarray. e.g. Consider the array <code>[3, 2, 1, 4, 4, 2, 4, 4]</code>. The points obtained for the subarray <code>[3, 2, 1, 4]</code> depend on whether the element 2(index 5) has been already removed or not, since it eventually determines the number of 4\'s which will be combined together to determine the potential points obtained for the currently considered subarray.</p>\n<p>Thus, in order to preserve this information, we need to add another dimension to the memorization array, which tells us how many similar elements are combined together from the end of the current subarray. We make use of a <script type="math/tex; mode=display">\\text{dp}</script> array, which is used to store the maximum number of points that can be obtained for a given subarray with a specific number of similar elements at the end. For an entry in <script type="math/tex; mode=display">\\text{dp[l][r][k]}</script>, <script type="math/tex; mode=display">l</script> represents the starting index of the subarray, <script type="math/tex; mode=display">r</script> represents the ending index of the subarray and <script type="math/tex; mode=display">k</script> represents the number of elements similar to the <script type="math/tex; mode=display">r^{th}</script> element following it which can be combined to obtain the point information to be stored in <script type="math/tex; mode=display">\\text{dp[l][r][k]}</script>. e.g.</p>\n<p>This can be better understood with the following example. Consider a subarray <script type="math/tex; mode=display">[x_l, x_{l+1},.., x_i,.., x_r, 6, 6, 6]</script>. For this subarray, if x_r=6, the entry at <script type="math/tex; mode=display">\\text{dp[l][r][3]}</script> represents the maximum points that can be obtained using the subarray <script type="math/tex; mode=display">boxes[l:r]</script> if three 6\'s are appended with the trailing <script type="math/tex; mode=display">x_r</script>.</p>\n<p>Now, let us look at how to fill in the <script type="math/tex; mode=display">dp</script>. Consider the same suabrray as mentioned above. For filling in the entry, <script type="math/tex; mode=display">\\text{dp[l][r][k]}</script>, we firstly make an initial entry in <script type="math/tex; mode=display">\\text{dp[l][r][k]}</script>, which considers the assumption that we will firstly combine the last <script type="math/tex; mode=display">k+1</script> similar elements and then proceed with the remaining subarray. Thus, the initial entry becomes:</p>\n<p>\n<script type="math/tex; mode=display">\\text{dp[l][r][k]} = dp[l][r-1][0] + (k+1)*(k+1)</script>. Here, we combined all the trailing similar elements, so the value 0 is passed as the k value for the recursive function, since no similar elements to the <script type="math/tex; mode=display">(r-1)^{th}</script> element exist at its end.</p>\n<p>But, the above situation isn\'t the only possible solution. We could obtain a better solution for the same subarray <script type="math/tex; mode=display">boxes[l:r]</script> for making the entry into <script type="math/tex; mode=display">\\text{dp[l][r][k]}</script>, if we could somehow combine the trailing similar elements with some extra similar elements lying between <script type="math/tex; mode=display">boxes[l:r]</script>.</p>\n<p>Thus, we look for the elements within <script type="math/tex; mode=display">boxes[l:r]</script>, which could be similar to the trailing <script type="math/tex; mode=display">k</script> elements, which in turn are similar to the <script type="math/tex; mode=display">r^{th}</script> element. Whenever such an element <script type="math/tex; mode=display">boxes[i]</script> is found, we check if the new solution could lead to more points by using the same array. If so, we update the entry at <script type="math/tex; mode=display">\\text{dp[l][r][k]}</script>.</p>\n<p>To get a clearer understanding of the above statment, consider the same subarray again: <script type="math/tex; mode=display">[x_l, x_{l+1},.., x_i,.., x_r, 6, 6, 6]</script>. If <script type="math/tex; mode=display">x_i = x_r = 6</script>, we could eventually be benefitted by combining <script type="math/tex; mode=display">x_i</script> and <script type="math/tex; mode=display">x_r</script> by removing the elements lying between them, since now we can bring <script type="math/tex; mode=display">k+2</script> similar elements together. By removing the in-between lying elements(<script type="math/tex; mode=display">[x_{i+1}, x_{i+2},..., x_{r-1}]</script>, the maximum points we can obtain are given by: <script type="math/tex; mode=display">\\text{dp[i+1][r-1][0]}</script>. Now, the points obtained from the remaining array <script type="math/tex; mode=display">[x_l, x_{l+1},.., x_i,x_r, 6, 6, 6]</script> are given by: <script type="math/tex; mode=display">\\text{dp[l][i][k+1]}</script>, which is quite clear now.</p>\n<p>Thus equation for <script type="math/tex; mode=display">dp</script> updation becomes:</p>\n<p>\n<script type="math/tex; mode=display">\\text{dp[l][r][k]} = max(\\text{dp[l][r][k]}, \\text{dp[l][i][k+1]} + \\text{dp[i+1][r-1][0]})</script>.</p>\n<p>At the end, the entry for dp[0][n-1][0] gives the required result. In the implementation below, we\'ve made use of <code>calculatePoints</code> function which is simply a recursive function used to obtain the <script type="math/tex; mode=display">\\text{dp}</script> values.</p>\n<iframe frameborder="0" height="445" name="56ydatBv" src="https://leetcode.com/playground/56ydatBv/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>\n<script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n^3</script> is filled.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^3)</script>\n<script type="math/tex; mode=display">dp</script> array is of size <script type="math/tex; mode=display">n^3</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Tencent'],
  },
  {
    id: '547',
    name: 'Friend Circles',
    acceptance: '49.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nThere are <b>N</b> students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a <b>direct</b> friend of B, and B is a <b>direct</b> friend of C, then A is an <b>indirect</b> friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.\n</p>\n\n<p>\nGiven a <b>N*N</b> matrix <b>M</b> representing the friend relationship between students in the class. If M[i][j] = 1, then the i<sub>th</sub> and j<sub>th</sub> students are <b>direct</b> friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \n[[1,1,0],\n [1,1,0],\n [0,0,1]]\n<b>Output:</b> 2\n<b>Explanation:</b>The 0<sub>th</sub> and 1<sub>st</sub> students are direct friends, so they are in a friend circle. <br>The 2<sub>nd</sub> student himself is in a friend circle. So return 2.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \n[[1,1,0],\n [1,1,1],\n [0,1,1]]\n<b>Output:</b> 1\n<b>Explanation:</b>The 0<sub>th</sub> and 1<sub>st</sub> students are direct friends, the 1<sub>st</sub> and 2<sub>nd</sub> students are direct friends, <br>so the 0<sub>th</sub> and 2<sub>nd</sub> students are indirect friends. All of them are in the same friend circle, so return 1.\n</pre>\n<p></p>\n\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>N is in range [1,200].</li>\n<li>M[i][i] = 1 for all students.</li>\n<li>If M[i][j] = 1, then M[j][i] = 1.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-depth-first-searchaccepted">Approach #1 Using Depth First Search[Accepted]</a></li>\n<li><a href="#approach-2-using-breadth-first-searchaccepted">Approach #2 Using Breadth First Search[Accepted]</a></li>\n<li><a href="#approach-3-using-union-find-methodaccepted">Approach #3 Using Union-Find Method[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-depth-first-searchaccepted">Approach #1 Using Depth First Search[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The given matrix can be viewed as the Adjacency Matrix of a graph. By viewing the matrix in such a manner, our problem reduces\nto the problem of finding the number of connected components in an undirected graph. In order to understand the above statement, consider the\nexample matrix below:</p>\n<div class="codehilite"><pre><span></span>M= [1 1 0 0 0 0\n\n    1 1 0 0 0 0\n\n    0 0 1 1 1 0\n\n    0 0 1 1 0 0\n\n    0 0 1 0 1 0\n\n    0 0 0 0 0 1]\n</pre></div>\n<p>If we view this matrix M as the adjancency matrix of a graph, the following graph is formed:</p>\n<p><img alt="Friend_Circles" src="https://leetcode.com/articles/Figures/647_Friend_Circles_1.jpg"></p>\n<p>In this graph, the node numbers represent the indices in the matrix M and an edge exists between the nodes numbered <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script>,\nif there is a 1 at the corresponding <script type="math/tex; mode=display">M[i][j]</script>.</p>\n<p>In order to find the number of connected components in an undirected graph, one of the simplest methods is to make use of Depth First Search\nstarting from every node. We make use of <script type="math/tex; mode=display">visited</script> array of size <script type="math/tex; mode=display">N</script>(<script type="math/tex; mode=display">M</script> is of size <script type="math/tex; mode=display">NxN</script>). This <script type="math/tex; mode=display">visited[i]</script> element\nis used to indicate that the <script type="math/tex; mode=display">i^{th}</script> node has already been visited while undergoing a Depth First Search from some node.</p>\n<p>To undergo DFS, we pick up a node and visit all its directly connected nodes. But, as soon as we visit any of those nodes, we recursively apply the same process to them as well. Thus, we try to go as deeper into the levels of the graph as possible starting from a current node first, leaving the other direct neighbour nodes to be visited later on.</p>\n<p>The depth first search for an arbitrary graph is shown below:</p>\n<!--![Friend_Circles](https://leetcode.com/articles/Figures/647_Friend_Circles2.gif)-->\n<p>!?!../Documents/547_Friend_Circles_dfs.json:1000,563!?!</p>\n<p>From the graph, we can see that the components which are connected can be reached starting from any single node of the connected group.\nThus, to find the number of connected components, we start from every node which isn\'t visited right now and apply DFS starting with it.\nWe increment the <script type="math/tex; mode=display">count</script> of connected components for every new starting node.</p>\n<iframe frameborder="0" height="445" name="YcWQPXNS" src="https://leetcode.com/playground/YcWQPXNS/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. The complete matrix of size <script type="math/tex; mode=display">n^2</script> is traversed.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">visited</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-breadth-first-searchaccepted">Approach #2 Using Breadth First Search[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>As discussed in the above method, if we view the given matrix as an adjacency matrix of a graph, we can use graph algorithms easily to find the number of connected components. This approach makes use of Breadth First Search for a graph.</p>\n<p>In case of Breadth First Search, we start from a particular node and visit all its directly connected nodes first. After all the direct neighbours have been visited, we apply the same process to the neighbour nodes as well. Thus, we exhaust the nodes of a graph on a level by level basis. An example of Breadth First Search is shown below:</p>\n<!--![Friend_Circles](https://leetcode.com/articles/Figures/647_Friend_Circles3.gif)-->\n<p>!?!../Documents/547_Friend_Circles_bfs.json:1000,563!?!</p>\n<p>In this case also, we apply BFS starting from one of the nodes. We make use of a <script type="math/tex; mode=display">visited</script> array to keep a track of the already visited nodes. We increment the <script type="math/tex; mode=display">count</script> of connected components whenever we need to start off with a new node as the root node for applying BFS which hasn\'t been already visited.</p>\n<iframe frameborder="0" height="428" name="srJD42Lf" src="https://leetcode.com/playground/srJD42Lf/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. The complete matrix of size <script type="math/tex; mode=display">n^2</script> is traversed.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. A <script type="math/tex; mode=display">queue</script> and <script type="math/tex; mode=display">visited</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-union-find-methodaccepted">Approach #3 Using Union-Find Method[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Another method that can be used to determine the number of connected components in a graph is the union find method. The method is simple.</p>\n<p>We make use of a <script type="math/tex; mode=display">parent</script> array of size <script type="math/tex; mode=display">N</script>. We traverse over all the nodes of the graph. For every node traversed, we traverse over all the nodes directly connected to it and assign them to a single group which is represented by their <script type="math/tex; mode=display">parent</script> node. This process is called forming a <script type="math/tex; mode=display">union</script>. Every group has a single <script type="math/tex; mode=display">parent</script> node, whose own parent is given by <script type="math/tex; mode=display">\\text{-1}</script>.</p>\n<p>For every new pair of nodes found, we look for the parents of both the nodes. If the parents nodes are the same, it indicates that they have already been united into the same group. If the parent nodes differ, it means they are yet to be united. Thus, for the pair of nodes <script type="math/tex; mode=display">(x, y)</script>, while forming the union, we assign <script type="math/tex; mode=display">parent\\big[parent[x]\\big]=parent[y]</script>, which ultimately combines them into the same group.</p>\n<p>The following animation depicts the process for a simple matrix:</p>\n<!--![Friend_Circles](https://leetcode.com/articles/Figures/647_Friend_Circles4.gif)-->\n<p>!?!../Documents/547_Friend_Circles_dfs.json:1000,563!?!</p>\n<p>At the end, we find the number of groups, or the number of parent nodes. Such nodes have their parents indicated by a <script type="math/tex; mode=display">\\text{-1}</script>. This gives us the required count.</p>\n<iframe frameborder="0" height="515" name="LC2i2T7b" src="https://leetcode.com/playground/LC2i2T7b/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. We traverse over the complete matrix once. Union and find operations take <script type="math/tex; mode=display">O(n)</script> time in the worst case.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">parent</script> array of size <script type="math/tex; mode=display">n</script> is used.</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Bloomberg', 'Two Sigma'],
  },
  {
    id: '548',
    name: 'Split Array with Equal Sum ',
    acceptance: '37.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array with n integers, you need to find if there are triplets  (i, j, k) which satisfies following conditions:\n</p><ol>\n<li> 0 &lt; i, i + 1 &lt; j, j + 1 &lt; k &lt; n - 1 </li>\n<li> Sum of subarrays (0, i - 1), (i + 1, j - 1), (j + 1, k - 1) and (k + 1, n - 1) should be equal. </li>\n</ol>\nwhere we define that subarray (L, R) represents a slice of the original array starting from the element indexed L to the element indexed R.\n<p></p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> [1,2,1,2,1,2,1]\n<b>Output:</b> True\n<b>Explanation:</b>\ni = 1, j = 3, k = 5. \nsum(0, i - 1) = sum(0, 0) = 1\nsum(i + 1, j - 1) = sum(2, 2) = 1\nsum(j + 1, k - 1) = sum(4, 4) = 1\nsum(k + 1, n - 1) = sum(6, 6) = 1\n</pre>\n<p></p>\n\n<b>Note:</b>\n<ol>\n<li> 1 &lt;= n &lt;= 2000. </li>\n<li> Elements in the given array will be in range [-1,000,000, 1,000,000]. </li>\n</ol>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-cumulative-sum-time-limit-exceeded">Approach #2 Cumulative Sum [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-slightly-better-approach-time-limit-exceeded">Approach #3 Slightly Better Approach [Time Limit Exceeded]</a></li>\n<li><a href="#approach-4-using-hashmap-time-limit-exceeded">Approach #4 Using HashMap [Time limit Exceeded]</a></li>\n<li><a href="#approach-5-using-cumulative-sum-and-hashset-accepted">Approach #5 Using Cumulative Sum and HashSet [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Before we start looking at any of the approaches for solving this problem, firstly we need to look at the limits imposed on <script type="math/tex; mode=display">i</script>, <script type="math/tex; mode=display">j</script> and <script type="math/tex; mode=display">k</script> by the given set of constraints. The figure below shows the maximum and minimum values that <script type="math/tex; mode=display">i</script>, <script type="math/tex; mode=display">j</script> and <script type="math/tex; mode=display">k</script> can assume.</p>\n<p><img alt="Split_Array" src="https://leetcode.com/articles/Figures/638_Split_Array.PNG"></p>\n<p>Thus, the limits based on the length of the array <script type="math/tex; mode=display">n</script> can now be rewritten as:</p>\n<p>\n<script type="math/tex; mode=display">1 &le; i &le; n-6</script>\n</p>\n<p>\n<script type="math/tex; mode=display">i+2 &le; j &le; n-4</script>\n</p>\n<p>\n<script type="math/tex; mode=display">j+2 &le; k &le; n-2</script>\n</p>\n<p>Having discussed the limits imposed on the cuts <script type="math/tex; mode=display">i</script>, <script type="math/tex; mode=display">j</script>, <script type="math/tex; mode=display">k</script> that we will apply on the given array <script type="math/tex; mode=display">nums</script>, let\'s look at the first solution that comes to our mind.</p>\n<p>We simply traverse over all the elements of the array. We consider all the possible subarrays taking care of the constraints imposed on the cuts, and check if any such cuts exist which satisfy the given equal sum quadruples criteria.</p>\n<iframe frameborder="0" height="515" name="VVnTPo9k" src="https://leetcode.com/playground/VVnTPo9k/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n^4)</script>. Four for loops inside each other each with a worst case run of length <script type="math/tex; mode=display">n</script>.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant Space required.</li>\n</ul>\n<hr>\n<h4 id="approach-2-cumulative-sum-time-limit-exceeded">Approach #2 Cumulative Sum [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the brute force approach, we traversed over the subarrays for every triplet of cuts considered. Rather than doing this, we can save some calculation effort if we make use of a cumulative sum array <script type="math/tex; mode=display">sum</script>, where <script type="math/tex; mode=display">sum[i]</script> stores the cumulative sum of the array <script type="math/tex; mode=display">nums</script> upto the <script type="math/tex; mode=display">i^{th}</script> element. Thus, now in order to find the <script type="math/tex; mode=display">sum\\big(subarray(i:j)\\big)</script>, we can simply use <script type="math/tex; mode=display">sum[j]-sum[i]</script>. Rest of the process remains the same.</p>\n<iframe frameborder="0" height="462" name="rnHnJfu2" src="https://leetcode.com/playground/rnHnJfu2/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. Three for loops are there, one within the other.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">sum</script> array of size <script type="math/tex; mode=display">n</script> is used for storing cumulative sum.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-slightly-better-approach-time-limit-exceeded">Approach #3 Slightly Better Approach [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can improve the previous implementation to some extent if we stop checking for further quadruples if the first and second parts formed till now don\'t have equal sums. This idea is used in the current implementation.</p>\n<iframe frameborder="0" height="513" name="4ou9KNuS" src="https://leetcode.com/playground/4ou9KNuS/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. Three loops are there.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">sum</script> array of size <script type="math/tex; mode=display">n</script> is used for storing the cumulative sum.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-hashmap-time-limit-exceeded">Approach #4 Using HashMap [Time limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, we create a data structure called <script type="math/tex; mode=display">map</script> which is simply a HashMap, with data arranged in the format:</p>\n<p>\n<script type="math/tex; mode=display">\\big\\{csum(i):[i_1,i_2,i_3,....]\\big\\}</script>, here <script type="math/tex; mode=display">csum(i)</script> represents the cumulative sum in the given array <script type="math/tex; mode=display">nums</script> upto the <script type="math/tex; mode=display">i^{th}</script> index and its corresponding value represents indices upto which cumulative sum=csum(i).</p>\n<p>Once we create this <script type="math/tex; mode=display">map</script>, the solutions gets simplified a lot. Consider only the first two cuts formed by <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script>. Then, the cumulative sum upto the <script type="math/tex; mode=display">(j-1)^{th}</script> index will be given by: <script type="math/tex; mode=display">csum(j-1)=sum(part1) + nums[i] + sum(part2)</script>. Now, if we want the first two parts to have the same sum, the same cumulative sum can be rewritten as:</p>\n<p>\n<script type="math/tex; mode=display">csum\'(j-1) = csum(i-1) + nums[i] + csum(i-1) = 2csum(i-1) + nums[i]</script>.</p>\n<p>Thus, we traverse over the given array, changing the value of the index <script type="math/tex; mode=display">i</script> forming the first cut, and look if the <script type="math/tex; mode=display">map</script> formed initially contains a cumulative sum equal to <script type="math/tex; mode=display">csum\'(j-1)</script>. If <script type="math/tex; mode=display">map</script> contains such a cumulative sum, we consider every possible index <script type="math/tex; mode=display">j</script> satisfying the given constraints and look for the equalities of the first cumulative sum with the third and the fourth parts.</p>\n<p>Following the similar lines as the discussion above, the cumulative sum upto the third cut by <script type="math/tex; mode=display">k^{th}</script> index is given by </p>\n<p>\n<script type="math/tex; mode=display">csum(k-1) = sum(part1) + nums[i] + sum(part2) + nums[j] + sum(part3)</script>. </p>\n<p>For equality of sum, the condition becomes: </p>\n<p>\n<script type="math/tex; mode=display">csum\'(k-1) = 3*csum(i-1) + nums[i] + nums[j]</script>. </p>\n<p>Similarly, the cumulative sum upto the last index becomes:</p>\n<p>\n<script type="math/tex; mode=display">csum(end) = sum(part1) + nums[i] + sum(part2) + nums[j] + sum(part3) + nums[k] + sum(part4)</script>. </p>\n<p>Again, for equality, the condition becomes:</p>\n<p>\n<script type="math/tex; mode=display">csum\'(end) = 4*csum(i-1) + nums[i] + nums[j] + nums[k]</script>.</p>\n<p>For every cut chosen, we look if the required cumulative sum exists in <script type="math/tex; mode=display">map</script>. Thus, we need not calculate sums again and again or traverse over the array for all the triplets <script type="math/tex; mode=display">(i, j, k)</script> possible. Rather, now, we directly know, what cumulative sum to look for in the <script type="math/tex; mode=display">map</script>, which reduces a lot of computations.</p>\n<iframe frameborder="0" height="515" name="bnMtNeme" src="https://leetcode.com/playground/bnMtNeme/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. Three nested loops are there and every loop runs <script type="math/tex; mode=display">n</script> times in the worst case. Consider the worstcase [0,0,0....,1,1,1,1,1,1,1].</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. HashMap size can go upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-using-cumulative-sum-and-hashset-accepted">Approach #5 Using Cumulative Sum and HashSet [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, firstly we form a cumulative sum array <script type="math/tex; mode=display">sum</script>, where <script type="math/tex; mode=display">sum[i]</script> stores the cumulative sum of the array <script type="math/tex; mode=display">nums</script> upto the <script type="math/tex; mode=display">i^{th}</script> index. Then, we start by traversing over the possible positions for the middle cut formed by <script type="math/tex; mode=display">j</script>. For every <script type="math/tex; mode=display">j</script>, firstly, we find all the left cut\'s positions, <script type="math/tex; mode=display">i</script>,  that lead to equalizing the sum of the first and the second part (i.e. <script type="math/tex; mode=display">sum[i-1] = sum [j-1] - sum[i]</script>) and store such sums in the <script type="math/tex; mode=display">set</script> (a new HashSet is formed for every <script type="math/tex; mode=display">j</script> chosen). Thus, the presence of a sum in <script type="math/tex; mode=display">set</script> implies that such a sum is possible for having equal sum of the first and second part for the current position of the middle cut(<script type="math/tex; mode=display">j</script>).</p>\n<p>Then, we go for the right cut and find the position of the right cut that leads to equal sum of the third and the fourth part (<script type="math/tex; mode=display">sum[n-1]-sum[k]=sum[k-1] - sum[j]</script>), for the same middle cut as chosen earlier. We also, look if the same sum exists in the <script type="math/tex; mode=display">set</script>. If so, such a triplet <script type="math/tex; mode=display">(i, j, k)</script> exists which satisfies the required criteria, otherwise not.</p>\n<p>Look at the animation below for a visual representation of the process:</p>\n<!--![Split_Array](https://leetcode.com/articles/Figures/638_Split_Array.gif)-->\n<p>!?!../Documents/548_Split_Array.json:1000,563!?!</p>\n<iframe frameborder="0" height="445" name="rBcQvyon" src="https://leetcode.com/playground/rBcQvyon/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. One outer loop and two inner loops are used.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. HashSet size can go upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Alibaba'],
  },
  {
    id: '549',
    name: 'Binary Tree Longest Consecutive Sequence II ',
    acceptance: '42.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a binary tree, you need to find the length of Longest Consecutive Path in Binary Tree. </p>\n\n<p>Especially, this path can be either increasing or decreasing. For example, [1,2,3,4] and [4,3,2,1] are both considered valid, but the path [1,2,4,3] is not valid. On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>\n        1\n       / \\\n      2   3\n<b>Output:</b> 2\n<b>Explanation:</b> The longest consecutive path is [1, 2] or [2, 1].\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b>\n        2\n       / \\\n      1   3\n<b>Output:</b> 3\n<b>Explanation:</b> The longest consecutive path is [1, 2, 3] or [3, 2, 1].\n</pre>\n<p></p>\n\n<p><b>Note:</b>\nAll the values of tree nodes are in the range of [-1e7, 1e7].\n</p> \n\n\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-single-traversal-accepted">Approach #2 Single traversal [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>Find the length of Longest Consecutive Path in Binary Tree. The path can be both increasing or decreasing i,e [1,2,3,4] and [4,3,2,1] are both considered valid. The path can be child-Parent-child not necessarily parent-child.</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>We can easily see that in a tree there is exactly one  unique path one from one node to another. So, the number of paths possible will be equal to number of pairs of nodes <script type="math/tex; mode=display">{{N}\\choose{2}}</script>, where <script type="math/tex; mode=display">N</script> is the number of nodes.</p>\n<p>Brute force solution of this problem is to find the path between every two nodes and check whether it is increasing or decreasing. In this way we can find maximum length increasing or decreasing sequence.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. Total possible number of paths are <script type="math/tex; mode=display">n^2</script> and checking every path whether it is increasing or decreasing will take <script type="math/tex; mode=display">O(n)</script> for one path.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^3)</script>. <script type="math/tex; mode=display">n^2</script> paths each with <script type="math/tex; mode=display">O(n)</script> nodes.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-single-traversal-accepted">Approach #2 Single traversal [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This solution is very simple. With every node, we associate two values/variables named <script type="math/tex; mode=display">inr</script> and <script type="math/tex; mode=display">dcr</script>, where <script type="math/tex; mode=display">incr</script> represents the length of the longest incrementing branch below the current node including itself, and <script type="math/tex; mode=display">dcr</script> represents the length of the longest decrementing branch below the current node including itself.</p>\n<p>We make use of a recursive function <code>longestPath(node)</code> which returns an array of the form <script type="math/tex; mode=display">[inr, dcr]</script> for the calling node. We start off by assigning both <script type="math/tex; mode=display">inr</script> and <script type="math/tex; mode=display">dcr</script> as 1 for the current node. This is because the node itself always forms a consecutive increasing as well as decreasing path of length 1.</p>\n<p>Then, we obtain the length of the longest path for the left child of the current node using <code>longestPath[root.left]</code>. Now, if the left child is just smaller than the current node, it forms a decreasing sequence with the current node. Thus, the <script type="math/tex; mode=display">dcr</script> value for the current node is stored as  the left child\'s <script type="math/tex; mode=display">dcr</script> value + 1. But, if the left child is just larger than the current node, it forms an incrementing sequence with the current node. Thus, we update the current node\'s <script type="math/tex; mode=display">inr</script> value as <script type="math/tex; mode=display">left\\_child(inr) + 1</script>.</p>\n<p>Then, we do the same process with the right child as well. But, for obtaining the <script type="math/tex; mode=display">inr</script> and <script type="math/tex; mode=display">dcr</script> value for the current node, we need to consider the maximum value out of the two values obtained from the left and the right child for both <script type="math/tex; mode=display">inr</script> and <script type="math/tex; mode=display">dcr</script>, since we need to consider the longest sequence possible.</p>\n<p>Further, after we\'ve obtained the final updated values of <script type="math/tex; mode=display">inr</script> and <script type="math/tex; mode=display">dcr</script> for a node, we update the length of the longest consecutive path found so far as <script type="math/tex; mode=display">maxval =  \\text{max}(inr + dcr - 1)</script>.</p>\n<p>The following animation will make the process clear:</p>\n<!-- ![Longest_Sequence_Tree](https://leetcode.com/articles/Figures/549_Binary_Tree_2.gif) -->\n<p>!?!../Documents/549_Binary_Tree_Longest_Sequence_ii.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="5zMV57sH" src="https://leetcode.com/playground/5zMV57sH/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The whole tree is traversed only once.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The recursion goes upto a depth of <script type="math/tex; mode=display">n</script> in the worst case.</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '551',
    name: 'Student Attendance Record I',
    acceptance: '44.3%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            You are given a string representing an attendance record for a student. The record only contains the following three characters:\n\n<p>\n</p><ol>\n<li><b>'A'</b> : Absent. </li>\n<li><b>'L'</b> : Late.</li>\n<li> <b>'P'</b> : Present. </li>\n</ol>\n<p></p>\n\n<p>\nA student could be rewarded if his attendance record doesn't contain <b>more than one 'A' (absent)</b> or <b>more than two continuous 'L' (late)</b>.    </p>\n\n<p>You need to return whether the student could be rewarded according to his attendance record.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \"PPALLP\"\n<b>Output:</b> True\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \"PPALLL\"\n<b>Output:</b> False\n</pre>\n<p></p>\n\n\n\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-simple-solution-accepted">Approach #1 Simple Solution [Accepted]</a></li>\n<li><a href="#approach-2-better-solution-accepted">Approach #2 Better Solution [Accepted]</a></li>\n<li><a href="#approach-3-single-pass-solution-without-indexof-method-accepted">Approach #3 Single pass Solution (Without indexOf method) [Accepted]</a></li>\n<li><a href="#approach-4-using-regex-accepted">Approach #4 Using Regex [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-simple-solution-accepted">Approach #1 Simple Solution [Accepted]</h4>\n<p>One simple way of solving this problem is to count number of <script type="math/tex; mode=display">A\'s</script> in the string and check whether the string <script type="math/tex; mode=display">LLL</script> is a substring of a given string. If number of <script type="math/tex; mode=display">A\'s</script> is less than <script type="math/tex; mode=display">2</script> and <script type="math/tex; mode=display">LLL</script> is not a subtring of a given string then return <script type="math/tex; mode=display">true</script>, otherwise return <script type="math/tex; mode=display">false</script>.</p>\n<p>\n<script type="math/tex; mode=display">indexOf</script> method can be used to check substring in a string. It return the index within this string of the first occurrence of the specified character or -1, if the character does not occur.</p>\n<iframe frameborder="0" height="241" name="KwRnWGmW" src="https://leetcode.com/playground/KwRnWGmW/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Single loop and indexOf method takes <script type="math/tex; mode=display">O(n)</script> time.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-solution-accepted">Approach #2 Better Solution [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>One optimization of above method is to break the loop when count of <script type="math/tex; mode=display">A\'s</script> becomes <script type="math/tex; mode=display">2</script>.</p>\n<iframe frameborder="0" height="224" name="Eh3SunKt" src="https://leetcode.com/playground/Eh3SunKt/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Single loop and indexOf method takes <script type="math/tex; mode=display">O(n)</script> time.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</li>\n</ul>\n<hr>\n<h4 id="approach-3-single-pass-solution-without-indexof-method-accepted">Approach #3 Single pass Solution (Without indexOf method) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can solve this problem in a single pass without using indexOf method. In a single loop we can count number of <script type="math/tex; mode=display">A\'s</script> and also check the substring <script type="math/tex; mode=display">LLL</script> in a given string.</p>\n<iframe frameborder="0" height="275" name="sZFGNHqX" src="https://leetcode.com/playground/sZFGNHqX/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Single loop upto string length is used.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-regex-accepted">Approach #4 Using Regex [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>One interesting solution is to use regex to match the string. Java provides the java.util.regex package for pattern matching with regular expressions. A regular expression is a special sequence of characters that helps you match or find other strings or sets of strings, using a specialized syntax held in a pattern.</p>\n<p>Following are the regex\'s used in this solution:</p>\n<div class="codehilite"><pre><span></span>. : Matches any single character except newline.\n\n* : Matches 0 or more occurrences of the preceding expression.\n\n.* : Matches any string\n\na|b : Matches either a or b\n</pre></div>\n<p>\n<script type="math/tex; mode=display">matches</script> method is used to check whether or not the string matches the given regular expression.</p>\n<p>Regular Expression of the string containing two or more than two <script type="math/tex; mode=display">A\'s</script> will be <script type="math/tex; mode=display">.*A.*A.*</script> and the regular expression of the string containing substring <script type="math/tex; mode=display">LLL</script> will be <script type="math/tex; mode=display">.*LLL.*</script>. We can merge this two regex using <script type="math/tex; mode=display">|</script> and form a regex of string containing either more than one <script type="math/tex; mode=display">A</script> or containing substring <script type="math/tex; mode=display">LLL</script>. Then regex will look like:  <script type="math/tex; mode=display">.*(A.*A|LLL).*</script>. We will return true only when the string doesn\'t matches this regex.</p>\n<iframe frameborder="0" height="156" name="5J2tfTuD" src="https://leetcode.com/playground/5J2tfTuD/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">matches</script> method takes <script type="math/tex; mode=display">O(n)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No Extra Space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '552',
    name: 'Student Attendance Record II',
    acceptance: '31.5%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given a positive integer <b>n</b>, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 10<sup>9</sup> + 7.</p>\n\n<p>A student attendance record is a string that only contains the following three characters:</p>\n\n<p>\n</p><ol>\n<li><b>\'A\'</b> : Absent. </li>\n<li><b>\'L\'</b> : Late.</li>\n<li> <b>\'P\'</b> : Present. </li>\n</ol>\n<p></p>\n\n<p>\nA record is regarded as rewardable if it doesn\'t contain <b>more than one \'A\' (absent)</b> or <b>more than two continuous \'L\' (late)</b>.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> n = 2\n<b>Output:</b> 8 \n<b>Explanation:</b>\nThere are 8 records with length 2 will be regarded as rewardable:\n"PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL"\nOnly "AA" won\'t be regarded as rewardable owing to more than one absent times. \n</pre>\n<p></p>\n\n<p><b>Note:</b>\nThe value of <b>n</b> won\'t exceed 100,000.\n</p>\n\n\n\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-recursive-formulae-time-limit-exceeded">Approach #2 Using Recursive formulae [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-using-dynamic-programming-accepted">Approach #3 Using Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-4-dynamic-programming-with-constant-space-accepted">Approach #4 Dynamic Programming with Constant Space [Accepted]</a></li>\n<li><a href="#approach-5-using-less-variables-accepted">Approach #5 Using less variables [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>In the brute force approach, we actually form every possible string comprising of the letters "A", "P", "L" and check if the string is rewardable by checking it against the given criterias. In order to form every possible string, we make use of a recursive <code>gen(string, n)</code> function. At every call of this function, we append the letters "A", "P" and "L" to the input string, reduce the required length by 1 and call the same function again for all the three newly generated strings.</p>\n<p>!?!../Documents/552_Student_Attendance_Record_II.json:1000,563!?!</p>\n<iframe frameborder="0" height="479" name="8H9pueM6" src="https://leetcode.com/playground/8H9pueM6/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(3^n)</script>. Exploring <script type="math/tex; mode=display">3^n</script> combinations.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n^n)</script>. Recursion tree can grow upto depth <script type="math/tex; mode=display">n</script> and each node contains string of length <script type="math/tex; mode=display">O(n)</script>.</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-recursive-formulae-time-limit-exceeded">Approach #2 Using Recursive formulae [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The given problem can be solved easily if we can develop a recurring relation for it.</p>\n<p>Firstly, assume the problem to be considering only the characters <script type="math/tex; mode=display">L</script> and <script type="math/tex; mode=display">P</script> in the strings. i.e. The strings can contain only <script type="math/tex; mode=display">L</script> and <script type="math/tex; mode=display">P</script>. The effect of <script type="math/tex; mode=display">A</script> will be taken into account later on.</p>\n<p>In order to develop the relation, let\'s assume that <script type="math/tex; mode=display">f[n]</script> represents the number of possible rewardable strings(with <script type="math/tex; mode=display">L</script> and <script type="math/tex; mode=display">P</script> as the only characters) of length <script type="math/tex; mode=display">n</script>. Then, we can easily determine the value of <script type="math/tex; mode=display">f[n]</script> if we know the values of the counts for smaller values of <script type="math/tex; mode=display">n</script>. To see how it works, let\'s examine the figure below:</p>\n<p><img alt="Recurrence" src="https://leetcode.com/articles/Figures/552_Student_Attendence_II.PNG"></p>\n<p>The above figure depicts the division of the rewardable string of length <script type="math/tex; mode=display">n</script> into two strings of length <script type="math/tex; mode=display">n-1</script> and ending with <script type="math/tex; mode=display">L</script> or <script type="math/tex; mode=display">P</script>. The string ending with <script type="math/tex; mode=display">P</script> of length <script type="math/tex; mode=display">n</script> is always rewardable provided the string of length <script type="math/tex; mode=display">n-1</script> is rewardable. Thus, this string accounts for a factor of <script type="math/tex; mode=display">f[n-1]</script> to <script type="math/tex; mode=display">f[n]</script>.</p>\n<p>For the first string ending with <script type="math/tex; mode=display">L</script>, the rewardability is dependent on the further strings of length <script type="math/tex; mode=display">n-3</script>. Thus, we consider all the rewardable strings of length <script type="math/tex; mode=display">n-3</script> now. Out of the four combinations possible at the end, the fourth combination, ending with a <script type="math/tex; mode=display">LL</script> at the end leads to an unawardable string. But, since we\'ve considered only rewardable strings of length <script type="math/tex; mode=display">n-3</script>, for the last string to be rewardable at length <script type="math/tex; mode=display">n-3</script> and unawardable at length <script type="math/tex; mode=display">n-1</script>, it must be preceded by a <script type="math/tex; mode=display">P</script> before the <script type="math/tex; mode=display">LL</script>.</p>\n<p>Thus, accounting for the first string again, all the rewardable strings of length <script type="math/tex; mode=display">n-1</script>, except the strings of length <script type="math/tex; mode=display">n-4</script> followed by <script type="math/tex; mode=display">PLL</script>, can contribute to a rewardable string of length <script type="math/tex; mode=display">n</script>. Thus, this string accounts for a factor of <script type="math/tex; mode=display">f[n-1] - f[n-4]</script> to <script type="math/tex; mode=display">f[n]</script>.</p>\n<p>Thus, the recurring relation becomes:</p>\n<p>\n<script type="math/tex; mode=display">f[n] = 2f[n-1] - f[n-4]</script>\n</p>\n<p>We store all the <script type="math/tex; mode=display">f[i]</script> values in an array. In order to compute <script type="math/tex; mode=display">f[i]</script>, we make use of a recursive function <code>func(n)</code> which makes use of the above recurrence relation.</p>\n<p>Now, we need to put the factor of character <script type="math/tex; mode=display">A</script> being present in the given string. We know, atmost one <script type="math/tex; mode=display">A</script> is allowed to be presnet in a rewardable string. Now, consider the two cases.</p>\n<ol>\n<li>\n<p>No <script type="math/tex; mode=display">A</script> is present: In this case, the number of rewardable strings is the same as <script type="math/tex; mode=display">f[n]</script>.</p>\n</li>\n<li>\n<p>A single <script type="math/tex; mode=display">A</script> is present: Now, the single <script type="math/tex; mode=display">A</script> can be present at any of the <script type="math/tex; mode=display">n</script> positions. If the <script type="math/tex; mode=display">A</script> is present at the <script type="math/tex; mode=display">i^{th}</script> position in the given string, in the form: "&lt;(i-1) characters&gt;, A, &lt;(n-i) characters&gt;", the total number of rewardable strings is given by: <script type="math/tex; mode=display">f[i-1] * f[n-i]</script>. Thus, the total number of such substrings is given by: <script type="math/tex; mode=display">\\sum_{i=1}^{n} (f[i-1] * f[n-i])</script>.</p>\n</li>\n</ol>\n<iframe frameborder="0" height="496" name="5oz4CZCn" src="https://leetcode.com/playground/5oz4CZCn/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(2^n)</script>. method <script type="math/tex; mode=display">func</script> will take <script type="math/tex; mode=display">2^n</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">f</script> array is used of size <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-dynamic-programming-accepted">Approach #3 Using Dynamic Programming [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we calculated the values of <script type="math/tex; mode=display">f[i]</script> everytime using the recursive function, which goes till its root depth everytime. But, we can reduce a large number of redundant calculations, if we use the results obtained for previous <script type="math/tex; mode=display">f[j]</script> values directly to obtain <script type="math/tex; mode=display">f[i]</script> as  <script type="math/tex; mode=display">f[i] = 2f[i-1] + f[i-4]</script>.</p>\n<iframe frameborder="0" height="343" name="mPZsFUjT" src="https://leetcode.com/playground/mPZsFUjT/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. One loop to fill <script type="math/tex; mode=display">f</script> array and one to calculate <script type="math/tex; mode=display">sum</script>\n</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">f</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-dynamic-programming-with-constant-space-accepted">Approach #4 Dynamic Programming with Constant Space [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can observe that the number and position of <script type="math/tex; mode=display">P</script>\'s in the given string is irrelevant. Keeping into account this fact, we can obtain a state diagram that represents the transitions between the possible states as shown in the figure below:</p>\n<p><img alt="State_Diagram" src="https://leetcode.com/articles/Figures/552_State_Diagram.PNG"></p>\n<p>This state diagram contains the states based only upon whether an <script type="math/tex; mode=display">A</script> is present in the string or not, and on the number of <script type="math/tex; mode=display">L</script>\'s that occur at the trailing edge of the string formed till now. The state transition occurs whenver we try to append a new character to the end of the current string.</p>\n<p>Based on the above state diagram, we keep a track of the number of unique transitions from which a rewardable state can be achieved. We start off with a string of length 0 and keep on adding a new character to the end of the string till we achieve a length of <script type="math/tex; mode=display">n</script>. At the end, we sum up the number of transitions possible to reach each rewardable state to obtain the required result.</p>\n<p>We can use variables corresponding to the states. <script type="math/tex; mode=display">axly</script> represents the number of strings of length <script type="math/tex; mode=display">i</script> containing <script type="math/tex; mode=display">x</script>\n<script type="math/tex; mode=display">a\'s</script> and ending with <script type="math/tex; mode=display">y</script>\n<script type="math/tex; mode=display">l\'s</script>.</p>\n<p>Below code is inspired by <a href="http://leetcode.com/stefanpochmann">@stefanpochmann</a>.</p>\n<iframe frameborder="0" height="428" name="3Eeni8XC" src="https://leetcode.com/playground/3Eeni8XC/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Single loop to update the states.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant Extra Space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-using-less-variables-accepted">Approach #5 Using less variables [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach discussed, we\'ve made use of six extra temporary variables just to keep a track of the change in the current state. The same result can be obtained by using a lesser number of temporary variables too.</p>\n<iframe frameborder="0" height="343" name="3GPeuNgd" src="https://leetcode.com/playground/3GPeuNgd/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Single loop to update the states.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant Extra Space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '553',
    name: 'Optimal Division',
    acceptance: '54.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a list of <b>positive integers</b>, the adjacent integers will perform the float division. For example, [2,3,4] -&gt; 2 / 3 / 4.</p>\n\n<p>However, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the <b>maximum</b> result, and return the corresponding expression in string format. <b>Your expression should NOT contain redundant parenthesis.</b></p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> [1000,100,10,2]\n<b>Output:</b> "1000/(100/10/2)"\n<b>Explanation:</b>\n1000/(100/10/2) = 1000/((100/10)/2) = 200\nHowever, the bold parenthesis in "1000/(<b>(</b>100/10<b>)</b>/2)" are redundant, <br>since they don\'t influence the operation priority. So you should return "1000/(100/10/2)". \n\nOther cases:\n1000/(100/10)/2 = 50\n1000/(100/(10/2)) = 50\n1000/100/10/2 = 0.5\n1000/100/(10/2) = 2\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><ol>\n<li>The length of the input array is [1, 10].</li>\n<li>Elements in the given array will be in range [2, 1000].</li>\n<li>There is only one optimal division for each test case.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-using-memorization-accepted">Approach #2 Using Memorization [Accepted]</a></li>\n<li><a href="#approach-3-using-some-math-accepted">Approach #3 Using some Math [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Brute force of this problem is to divide the list into two parts <script type="math/tex; mode=display">left</script> and <script type="math/tex; mode=display">right</script> and call function for these two parts. We will iterate <script type="math/tex; mode=display">i</script> from <script type="math/tex; mode=display">start</script> to <script type="math/tex; mode=display">end</script> so that <script type="math/tex; mode=display">left=(start,i)</script> and <script type="math/tex; mode=display">right=(i+1,end)</script>.</p>\n<p>\n<script type="math/tex; mode=display">left</script> and <script type="math/tex; mode=display">right</script> parts return their maximum and minimum value and corresponding strings.</p>\n<p>Minimum value can be found by dividing minimum of left by maximum of right i.e. <script type="math/tex; mode=display">minVal=left.min/right.max</script>.</p>\n<p>Similarly,Maximum value can be found by dividing maximum of left value by minimum of right value. i.e. <script type="math/tex; mode=display">maxVal=left.max/right.min</script>.</p>\n<p>Now, how to add parenthesis? As associativity of division operator is from left to right i.e. by default left most divide should be done first, we need not have to add paranthesis to the left part, but we must add parenthesis to the right part.</p>\n<p>eg- "2/(3/4)" will be formed as leftPart+"/"+"("+rightPart+")", assuming leftPart is "2" and rightPart is"3/4".</p>\n<p>One more point, we also don\'t require parenthesis to right part when it contains single digit.</p>\n<p>eg- "2/3", here left part is "2" and right part is "3" (contains single digit) . 2/(3) is not valid.</p>\n<iframe frameborder="0" height="515" name="CAbJyzm4" src="https://leetcode.com/playground/CAbJyzm4/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n!)</script>. Number of permutations of expression after applying brackets will be in <script type="math/tex; mode=display">O(n!)</script> where <script type="math/tex; mode=display">n</script> is the number of items in the list.</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(n^2)</script>. Depth of recursion tree will be <script type="math/tex; mode=display">O(n)</script> and each node contains string of maximum length <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-memorization-accepted">Approach #2 Using Memorization [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the above approach we called optimal function recursively for ever <script type="math/tex; mode=display">start</script> and <script type="math/tex; mode=display">end</script>. We can notice that there are many redundant calls in the above approach, we can reduce these calls by using memorization to store the result of different function calls. Here, <script type="math/tex; mode=display">memo</script> array is used for this purpose.</p>\n<iframe frameborder="0" height="515" name="xFgr7Cpd" src="https://leetcode.com/playground/xFgr7Cpd/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. <script type="math/tex; mode=display">memo</script> array of size <script type="math/tex; mode=display">n^2</script> is filled and filling of each cell of the <script type="math/tex; mode=display">memo</script> array takes <script type="math/tex; mode=display">O(n)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^3)</script>. <script type="math/tex; mode=display">memo</script> array of size <script type="math/tex; mode=display">n^2</script> where each cell of array contains string of length <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-some-math-accepted">Approach #3 Using some Math [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Using some simple math we can find the easy solution of this problem. Consider the input in the form of [a,b,c,d], now we have to set priority of\noperations to maximize a/b/c/d. We know that to maximize fraction <script type="math/tex; mode=display">p/q</script>, <script type="math/tex; mode=display">q</script>(denominator) should be minimized. So, to maximize <script type="math/tex; mode=display">a/b/c/d</script>  we have to first minimize b/c/d. Now our objective turns to minimize the expression b/c/d.</p>\n<p>There are two possible combinations of this expression, b/(c/d) and (b/c)/d.</p>\n<div class="codehilite"><pre><span></span>b/(c/d)        (b/c)/d = b/c/d\n(b*d)/c        b/(d*c)\nd/c            1/(d*c)\n</pre></div>\n<p>Obviously, <script type="math/tex; mode=display">d/c > 1/(d*c)</script> for <script type="math/tex; mode=display">d>1</script>.</p>\n<p>You can see that second combination will always be less than first one for numbers greater than <script type="math/tex; mode=display">1</script>. So, the answer will be a/(b/c/d).\nSimilarly for expression like a/b/c/d/e/f... answer will be a/(b/c/d/e/f...).</p>\n<iframe frameborder="0" height="309" name="wUbJEUre" src="https://leetcode.com/playground/wUbJEUre/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Single loop to traverse <script type="math/tex; mode=display">nums</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">res</script> variable is used to store the result.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '554',
    name: 'Brick Wall',
    acceptance: '46.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the <b>top</b> to the <b>bottom</b> and cross the <b>least</b> bricks. </p>\n\n<p>\nThe brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right. \n</p>\n\n<p>If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks. </p>\n\n<p><b>You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks. </b></p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> \n[[1,2,2,1],\n [3,1,2],\n [1,3,2],\n [2,4],\n [3,1,2],\n [1,3,1,1]]\n<b>Output:</b> 2\n<b>Explanation:</b> \n<img src="https://leetcode.com/static/images/problemset/brick_wall.png" width="30%">\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The width sum of bricks in different rows are the same and won\'t exceed INT_MAX.</li>\n<li>The number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won\'t exceed 20,000. </li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-forcetime-limit-exceeded">Approach #2 Better Brute Force[Time LImit Exceeded]</a></li>\n<li><a href="#approach-3-using-hashmap-accepted">Approach #3 Using HashMap [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>In this approach, we consider the given wall as being made up of virtual bricks each of width 1. We traverse over the width of the wall only in terms of these virtual bricks.</p>\n<p>Firstly, we need to determine the total number of virtual bricks. For this, we determine the width of the given wall by summing up the widths of the bricks in the first row. This width is stored in <script type="math/tex; mode=display">sum</script>. Thus, we need to traverse over the widthe <script type="math/tex; mode=display">sum</script> times now in terms of 1 unit in each iteration.</p>\n<p>We traverse over the virtual bricks in a column by column fashion. For keeping a track of the actual position at which we are currently in any row, we make use of a <script type="math/tex; mode=display">pos</script> array. <script type="math/tex; mode=display">pos[i]</script> refers to the index of the brick in the <script type="math/tex; mode=display">i^{th}</script> row, which is being treated as the virtual brick in the current column\'s traversal. Further, we maintain a <script type="math/tex; mode=display">count</script> variable to keep a track of the number of bricks cut if we draw a line down at the current position.</p>\n<p>For every row considered during the column-by-column traversal, we need to check if we\'ve hit an actual brick boundary. This is done by updating the brick\'s width after the traversal. If we don\'t hit an actual brick boundary, we need to increment <script type="math/tex; mode=display">count</script> to reflect that drawing a line at this point leads to cutting off 1 more brick. But, if we hit an actual brick boundary, we increment the value of <script type="math/tex; mode=display">pos[i]</script>, with <script type="math/tex; mode=display">i</script> referring to the current row\'s index. But, now if we draw a line down through this boundary, we need not increment the <script type="math/tex; mode=display">count</script>.</p>\n<p>We repeat the same process for every column of width equal to a virtual brick, and determine the minimum value of <script type="math/tex; mode=display">count</script> obtained from all such traversals.</p>\n<p>The following animation makes the process clearer:</p>\n<!--![Brick_Wall](https://leetcode.com/articles/Figures/554_Brick_Wall_1.gif)-->\n<p>!?!../Documents/554_Brick_Wall1.json:866,487!?!</p>\n<iframe frameborder="0" height="428" name="fruhzBr8" src="https://leetcode.com/playground/fruhzBr8/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n*m)</script>. We traverse over the width(<script type="math/tex; mode=display">n</script>) of the wall <script type="math/tex; mode=display">m</script> times, where <script type="math/tex; mode=display">m</script> is the height of the wall.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m)</script>. <script type="math/tex; mode=display">pos</script> array of size <script type="math/tex; mode=display">m</script> is used, where <script type="math/tex; mode=display">m</script> is the height of the wall.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-forcetime-limit-exceeded">Approach #2 Better Brute Force[Time LImit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, instead of traversing over the columns in terms of 1 unit each time, we traverse over the columns in terms of the width of the smallest brick encountered while traversing the current column. Thus, we update <script type="math/tex; mode=display">pos</script> array and <script type="math/tex; mode=display">sums</script> appropriately depending on the width of the smallest brick. Rest of the process remains the same as the first approach.</p>\n<p>The optimization achieved can be viewed by considering this example:</p>\n<div class="codehilite"><pre><span></span>[[100, 50, 50],\n[50, 100],\n[150]]\n</pre></div>\n<p>In this case, we directly jump over the columns in terms of widths of 50 units each time, rather than making traversals over widths incrementing by 1 unit each time.</p>\n<iframe frameborder="0" height="496" name="e58vTtJR" src="https://leetcode.com/playground/e58vTtJR/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n*m)</script>. In worst case, we traverse over the length(<script type="math/tex; mode=display">n</script>) of the wall <script type="math/tex; mode=display">m</script> times, where <script type="math/tex; mode=display">m</script> is the height of the wall.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m)</script>. <script type="math/tex; mode=display">pos</script> array of size <script type="math/tex; mode=display">m</script> is used, where <script type="math/tex; mode=display">m</script> is the height of the wall.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-hashmap-accepted">Approach #3 Using HashMap [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, we make use of a HashMap <script type="math/tex; mode=display">map</script> which is used to store entries in the form: <script type="math/tex; mode=display">(sum, count)</script>. Here, <script type="math/tex; mode=display">sum</script> refers to the cumulative sum of the bricks\' widths encountered in the current row, and <script type="math/tex; mode=display">count</script> refers to the number of times the corresponding sum is obtained. Thus, <script type="math/tex; mode=display">sum</script> in a way, represents the positions of the bricks\'s boundaries relative to the leftmost boundary.</p>\n<p>Let\'s look at the process first. We traverse over every row of the given wall. For every brick considered, we find the <script type="math/tex; mode=display">sum</script> corresponding to the sum of the bricks\' widths encountered so far in the current row. If this <script type="math/tex; mode=display">sum</script>\'s entry doesn\'t exist in the <script type="math/tex; mode=display">map</script>, we create a corresponding entry with an initial <script type="math/tex; mode=display">count</script> of 1. If the <script type="math/tex; mode=display">sum</script> already exists as a key, we increment its corresponding <script type="math/tex; mode=display">count</script> value.</p>\n<p>This is done based on the following observation. We will never obtain the same value of <script type="math/tex; mode=display">sum</script> twice while traversing over a particular row. Thus, if the <script type="math/tex; mode=display">sum</script> value is repeated while traversing over the rows, it means some row\'s brick boundary coincides with some previous row\'s brick boundary. This fact is accounted for by incrementing the corresponding <script type="math/tex; mode=display">count</script> value.</p>\n<p>But, for every row, we consider the sum only upto the second last brick, since the last boundary isn\'t a valid boundary for the solution.</p>\n<p>At the end, we can obtain the maximum <script type="math/tex; mode=display">count</script> value to determine the minimum number of bricks that need to be cut to draw a vetical line through them.</p>\n<p>The following animation makes the process clear:</p>\n<!-- ![Brick_Wall](https://leetcode.com/articles/Figures/554_Brick_Wall_2.gif) -->\n<p>!?!../Documents/554_Brick_Wall2.json:866,487!?!</p>\n<iframe frameborder="0" height="377" name="miHSNYBN" src="https://leetcode.com/playground/miHSNYBN/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We traverse over the complete bricks only once. <script type="math/tex; mode=display">n</script> is the total number of bricks in a wall.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m)</script>. <script type="math/tex; mode=display">map</script> will contain atmost <script type="math/tex; mode=display">m</script> entries, where <script type="math/tex; mode=display">m</script> refers to the width of the wall.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '555',
    name: 'Split Concatenated Strings ',
    acceptance: '37.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a list of strings, you could concatenate these strings together into a loop, where for each string you could choose to reverse it or not. Among all the possible loops, you need to find the lexicographically biggest string after cutting the loop, which will make the looped string into a regular one.</p>\n\n<p>Specifically, to find the lexicographically biggest string, you need to experience two phases: \n</p><ol>\n<li>Concatenate all the strings into a loop, where you can reverse some strings or not and connect them in the same order as given.</li>\n<li>Cut and make one breakpoint in any place of the loop, which will make the looped string into a regular one starting from the character at the cutpoint. </li>\n</ol>\n<p></p>\n\n<p>And your job is to find the lexicographically biggest one among all the possible regular strings.</p>\n\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> "abc", "xyz"\n<b>Output:</b> "zyxcba"\n<b>Explanation:</b> You can get the looped string "-abcxyz-", "-abczyx-", "-cbaxyz-", "-cbazyx-", <br>where \'-\' represents the looped status. <br>The answer string came from the fourth looped one, <br>where you could cut from the middle character \'a\' and get "zyxcba".\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The input strings will only contain lowercase letters.</li>\n<li>The total length of all the strings will not over 1,000.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-depth-first-search-time-limit-exceeded">Approach #1 Depth First Search [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-breadth-first-search-memory-limit-exceeded">Approach #2 Breadth First Search [Memory Limit Exceeded]</a></li>\n<li><a href="#approach-3-optimized-solution-accepted">Approach #3 Optimized Solution [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<p>We are given a list of strings: <script type="math/tex; mode=display">s_1, s_2, s_3,.., s_n</script>. We need to concatenate all these strings in a circular fashion in the same given order, but we can reverse every individual string before concatenating. Now, we need to make a cut in the final concatenated string such that the new string formed is the largest one possible in the lexicographic sense</p>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-depth-first-search-time-limit-exceeded">Approach #1 Depth First Search [Time Limit Exceeded]</h4>\n<p>The simplest solution is to try forming every possible concatenated string by making use of the given strings and then forming every possible cut in each such final concatenated string.</p>\n<p>To do so, we can make use of a recursive function <code>dfs</code> which appends the current string to the concatenated string formed till now and calls itself with the new concatenated string.  It also appends the reversed current string to the current concatenated string and calls itself. The concatenation of strings goes in the manner of a Depth First Search.\nThus, after reaching the full depth of every branch traversal, we obtain a new concatenated string as illustrated in the animation below. We can apply all the possible cuts to these strings and find the lexicographically largest string out of all of them.</p>\n<p>!?!../Documents/555_Split_Assembled_Strings.json:1000,563!?!</p>\n<iframe frameborder="0" height="394" name="HVWgAzK8" src="https://leetcode.com/playground/HVWgAzK8/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(2^n)</script>. Size of Recursion tree can grow upto <script type="math/tex; mode=display">2^n</script> where <script type="math/tex; mode=display">n</script> is the number of strings in the list.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Depth of Recursion tree will be <script type="math/tex; mode=display">n</script>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-breadth-first-search-memory-limit-exceeded">Approach #2 Breadth First Search [Memory Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Exploring all strings can also be done using BFS method. A Queue <script type="math/tex; mode=display">queue</script> is maintained which stores the strings formed till now after concatenation of the next string and also by concatenation of reverse of next string. Every time we remove a string from the front of the queue, we add two strings to the back of the queue(one by concatenating the next string directly and another by concatenating the next string after reversing).</p>\n<p>When all the strings are traversed queue contains <script type="math/tex; mode=display">O(2^n)</script> strings, which correspond to every possible valid string which can be formed by doing the concatenations. We check every string into the queue after circularly rotating by placing the cuts at every possible location. While doing this, we keep a track of the lexicographically largest string.</p>\n<p>This animation will depict the method:</p>\n<p>!?!../Documents/555_Split_Assembled_Strings1.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="5MoksFZL" src="https://leetcode.com/playground/5MoksFZL/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(2^n)</script>. <script type="math/tex; mode=display">2^n</script> possible strings will be formed where <script type="math/tex; mode=display">n</script> is the number of strings in the list.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(2^n)</script>. <script type="math/tex; mode=display">queue</script>\'s size can grow upto <script type="math/tex; mode=display">2^n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-optimized-solution-accepted">Approach #3 Optimized Solution [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In order to understand how this solution works, firstly we\'ll look at some of the properties of the transformation involved. The first point to note is that the relative ordering of the strings doesn\'t change after applying the transformations(i.e. reversing and applying cuts).</p>\n<p>The second property will be explained taking the help of an example. Consider the given list of strings: <script type="math/tex; mode=display">[s_1, s_2, s_3,..,s_j,..s_n]</script>. Now, assume that we choose <script type="math/tex; mode=display">s_j</script> to be the string on which the current cut is placed leading to the formation of two substrings from <script type="math/tex; mode=display">s_j</script>, namely, say <script type="math/tex; mode=display">s_{jpre}</script>, <script type="math/tex; mode=display">s_{jpost}</script>. Thus, the concatenated string formed by such a cut will be: <script type="math/tex; mode=display">[s_{jpost}, s_{j+1},..., s_n, s_{1rev}, s_{2rev},.., s_{(jpre)rev}]</script>. Here, <script type="math/tex; mode=display">s_{irev}</script> means the reversed <script type="math/tex; mode=display">s_i</script> string. </p>\n<p>The concatenated string formed follows the same pattern irrespective of where the cut is placed in <script type="math/tex; mode=display">s_j</script>. But still, the relative ordering of the strings persists, even if we include the reverse operation as well. </p>\n<p>Now, if we consider only a single cut for the time being, in string <script type="math/tex; mode=display">s_j</script>(not reversed) as discussed above, and allow for the reverse operation among the remaining strings, the lexicographically largest concatenated string will be given by: <script type="math/tex; mode=display">[s_{jpost}, \\text{max}(s_{j+1},s_{(j+1)rev}) ,..., \\text{max}(s_{n},s_{(n)rev}), \\text{max}(s_{1},s_{(1)rev}), ..., s_{(jpre)rev}]</script>. Here, <script type="math/tex; mode=display">\\text{max}</script> refers to the lexicographic maximum operation. </p>\n<p>Thus, if a particular string <script type="math/tex; mode=display">s_j</script> is finalized for the cut, the largest lexicographic concatenated string is dependent only on whether the string <script type="math/tex; mode=display">s_j</script> is reversed or not, and also on the position of the cut. This happens because the reverse/not reverse operation for the rest of the strings is fixed for a chosen <script type="math/tex; mode=display">s_j</script> as shown above and thus, doesn\'t impact the final result.</p>\n<p>Based on the above observations, we follow the given procedure. For every given string, we replace the string with the lexicographically larger string out of the original string and the reversed one. After this, we pick up every new string(chosen as the string on which the cuts will be applied), and apply a cut at all the positions of the currently picked string and form the full concantenated string keeping the rest of the newly formed strings intact. We also reverse the current string and follow the same process. While doing this, we keep a track of the largest lexicographic string found so far.</p>\n<p>For a better understanding of the procedure, watch this animation:</p>\n<p>!?!../Documents/555_Split_Assembled_Strings2.json:1000,563!?!</p>\n<iframe frameborder="0" height="496" name="A2jShPos" src="https://leetcode.com/playground/A2jShPos/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. where <script type="math/tex; mode=display">n</script> is the total number of characters in a list.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">t</script> and <script type="math/tex; mode=display">res</script> of size <script type="math/tex; mode=display">n</script> are used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Alibaba'],
  },
  {
    id: '556',
    name: 'Next Greater Element III',
    acceptance: '29.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a positive <b>32-bit</b> integer <b>n</b>, you need to find the smallest <b>32-bit</b> integer which has exactly the same digits existing in the integer <b>n</b> and is greater in value than n. If no such positive <b>32-bit</b> integer exists, you need to return -1.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> 12\n<b>Output:</b> 21\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> 21\n<b>Output:</b> -1\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-linear-solution-accepted">Approach #2 Linear Solution [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>To solve the given problem, we treat the given number as a string, <script type="math/tex; mode=display">s</script>. In this approach, we find out every possible permutation of list formed by the elements of the string <script type="math/tex; mode=display">s</script> formed. We form a list of strings, <script type="math/tex; mode=display">list</script>, containing all the permutations possible. Then, we sort the given <script type="math/tex; mode=display">list</script> to find out the permutation which is just larger than the given one. But this one will be a very naive approach, since it requires us to find out every possible permutation which will take really long time.</p>\n<iframe frameborder="0" height="515" name="UBNhHzjo" src="https://leetcode.com/playground/UBNhHzjo/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n!)</script>. A total of <script type="math/tex; mode=display">n!</script> permutations are possible for a number consisting of <script type="math/tex; mode=display">n</script> digits.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n!)</script>. A total of <script type="math/tex; mode=display">n!</script> permutations are possible for a number consisting of <script type="math/tex; mode=display">n</script> digits, with each permutation consisting of <script type="math/tex; mode=display">n</script> digits.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-linear-solution-accepted">Approach #2 Linear Solution [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this case as well, we consider the given number <script type="math/tex; mode=display">n</script> as a character array <script type="math/tex; mode=display">a</script>.\nFirst, we observe that for any given sequence that is in descending order, no next larger permutation is possible.\n For example, no next permutation is possible for the following array:\n <code>[9, 5, 4, 3, 1]</code></p>\n<p>We need to find the first pair of two successive numbers <script type="math/tex; mode=display">a[i]</script> and <script type="math/tex; mode=display">a[i-1]</script>, from the right, which satisfy\n <script type="math/tex; mode=display">a[i] > a[i-1]</script>. Now, no rearrangements to the right of <script type="math/tex; mode=display">a[i-1]</script> can create a larger permutation since that subarray consists of numbers in descending order.\n Thus, we need to rearrange the numbers to the right of <script type="math/tex; mode=display">a[i-1]</script> including itself.</p>\n<p>Now, what kind of rearrangement will produce the next larger number? We want to create the permutation just larger than the current one. Therefore, we need to replace the number <script type="math/tex; mode=display">a[i-1]</script> with the number which is just larger than itself among the numbers lying to its right section, say <script type="math/tex; mode=display">a[j]</script>.</p>\n<p><img alt="Next Greater Element " src="https://leetcode.com/media/original_images/31_nums_graph.png"></p>\n<p>We swap the numbers <script type="math/tex; mode=display">a[i-1]</script> and <script type="math/tex; mode=display">a[j]</script>. We now have the correct number at index <script type="math/tex; mode=display">i-1</script>. But still the current permutation isn\'t the permutation\n    that we are looking for. We need the smallest permutation that can be formed by using the numbers only to the right of <script type="math/tex; mode=display">a[i-1]</script>. Therefore, we need to place those\n     numbers in ascending order to get their smallest permutation.</p>\n<p>But, recall that while scanning the numbers from the right, we simply kept decrementing the index\n      until we found the pair <script type="math/tex; mode=display">a[i]</script> and <script type="math/tex; mode=display">a[i-1]</script> where,  <script type="math/tex; mode=display">a[i] > a[i-1]</script>. Thus, all numbers to the right of <script type="math/tex; mode=display">a[i-1]</script> were already sorted in descending order.\n      Furthermore, swapping <script type="math/tex; mode=display">a[i-1]</script> and <script type="math/tex; mode=display">a[j]</script> didn\'t change that order.\n      Therefore, we simply need to reverse the numbers following <script type="math/tex; mode=display">a[i-1]</script> to get the next smallest lexicographic permutation.</p>\n<p>The following animation will make things clearer:</p>\n<!--![Next Permutation](https://leetcode.com/media/original_images/31_Next_Permutation.gif)-->\n<p>!?!../Documents/556_Next_Greater_Element_III.json!?!</p>\n<iframe frameborder="0" height="515" name="uSrWDrPW" src="https://leetcode.com/playground/uSrWDrPW/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. In worst case, only two scans of the whole array are needed. Here, <script type="math/tex; mode=display">n</script> refers to the number of digits in the given number.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. An array <script type="math/tex; mode=display">a</script> of size <script type="math/tex; mode=display">n</script> is used, where <script type="math/tex; mode=display">n</script> is the number of digits in the given number.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '557',
    name: 'Reverse Words in a String III',
    acceptance: '59.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "Let\'s take LeetCode contest"\n<b>Output:</b> "s\'teL ekat edoCteeL tsetnoc"\n</pre>\n<p></p>\n\n<p><b>Note:</b>\nIn the string, each word is separated by single space and there will not be any extra space in the string.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-simple-solutionaccepted">Approach #1 Simple Solution[Accepted]</a></li>\n<li><a href="#approach-2-without-using-pre-defined-split-and-reverse-function-accepted">Approach #2 Without using pre-defined split and reverse function [Accepted]</a></li>\n<li><a href="#approach-3-using-stringbuilder-and-reverse-method-accepted">Approach #3 Using StringBuilder and reverse method [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-simple-solutionaccepted">Approach #1 Simple Solution[Accepted]</h4>\n<p>The first method is really simple. We simply split up the given string based on whitespaces and put the individual words in an array of strings. Then, we reverse each individual string and concatenate the result. We return the result after removing the additional whitespaces at the end.</p>\n<iframe frameborder="0" height="207" name="DjRyo9vA" src="https://leetcode.com/playground/DjRyo9vA/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. where <script type="math/tex; mode=display">n</script> is the length of the string.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">res</script> of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-without-using-pre-defined-split-and-reverse-function-accepted">Approach #2 Without using pre-defined split and reverse function [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can create our own split and reverse function. Split function splits the string based on the delimiter " "(space) and returns the array of words. Reverse function returns the string after reversing the characters.</p>\n<iframe frameborder="0" height="515" name="oxasWgHd" src="https://leetcode.com/playground/oxasWgHd/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n)</script>. where <script type="math/tex; mode=display">n</script> is the length of the string.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">res</script> of size <script type="math/tex; mode=display">n</script> is used.</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-stringbuilder-and-reverse-method-accepted">Approach #3 Using StringBuilder and reverse method [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of using split method, we can use temporary string <script type="math/tex; mode=display">word</script> to store the word. We simply append the characters to the <script type="math/tex; mode=display">word</script> until <code>\' \'</code> character is not found. On getting <code>\' \'</code> we append the reverse of the <script type="math/tex; mode=display">word</script> to the resultant string <script type="math/tex; mode=display">result</script>. Also after completion of loop , we still have to append the <script type="math/tex; mode=display">reverse</script> of the <script type="math/tex; mode=display">word</script>(last word) to the <script type="math/tex; mode=display">result</script> string. </p>\n<p>Below code is inspired by <a href="http://leetcode.com/apolloX">@ApolloX</a>.</p>\n<iframe frameborder="0" height="343" name="Xt8eMTKv" src="https://leetcode.com/playground/Xt8eMTKv/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Single loop upto <script type="math/tex; mode=display">n</script> is there, where <script type="math/tex; mode=display">n</script> is the length of the string.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">result</script> and <script type="math/tex; mode=display">word</script> size will grow upto <script type="math/tex; mode=display">n</script>.</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Zappos'],
  },
  {
    id: '560',
    name: 'Subarray Sum Equals K',
    acceptance: '40.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given an array of integers and an integer <b>k</b>, you need to find the total number of continuous subarrays whose sum equals to <b>k</b>.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>nums = [1,1,1], k = 2\n<b>Output:</b> 2\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The length of the array is in range [1, 20,000].</li>\n<li>The range of numbers in the array is [-1000, 1000] and the range of the integer <b>k</b> is [-1e7, 1e7].</li>\n</ol>\n<p></p>\n\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-cummulative-sum-accepted">Approach #2 Using Cummulative sum [Accepted]</a></li>\n<li><a href="#approach-3-without-space-accepted">Approach #3 Without space [Accepted]</a></li>\n<li><a href="#approach-4-using-hashmap-accepted">Approach #4 Using hashmap [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The simplest method is to consider every possible subarray of the given <script type="math/tex; mode=display">nums</script> array, find the sum of the elements of each of those subarrays and check for the equality of the sum obtained with the given <script type="math/tex; mode=display">k</script>. Whenver the sum equals <script type="math/tex; mode=display">k</script>, we can increment the <script type="math/tex; mode=display">count</script> used to store the required result.</p>\n<iframe frameborder="0" height="309" name="uzdLhWrz" src="https://leetcode.com/playground/uzdLhWrz/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. Considering every possible subarray takes <script type="math/tex; mode=display">O(n^2)</script> time. For each of the subarray we calculate the sum taking <script type="math/tex; mode=display">O(n)</script> time in the worst case, taking a total of <script type="math/tex; mode=display">O(n^3)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-cummulative-sum-accepted">Approach #2 Using Cummulative sum [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of determining the sum of elements everytime for every new subarray considered, we can make use of a cumulative sum array , <script type="math/tex; mode=display">sum</script>. Then, in order to calculate the sum of elements lying between two indices, we can subtract the cumulative sum corresponding to the two indices to obtain the sum directly, instead of iterating over the subarray to obtain the sum.</p>\n<p>In this implementation, we make use of a cumulative sum array, <script type="math/tex; mode=display">sum</script>, such that <script type="math/tex; mode=display">sum[i]</script> is used to store the cumulative sum of <script type="math/tex; mode=display">nums</script> array upto the element corresponding to the <script type="math/tex; mode=display">(i-1)^{th}</script> index. Thus, to determine the sum of elements for the subarray <script type="math/tex; mode=display">nums[i:j]</script>, we can directly use <script type="math/tex; mode=display">sum[j+1] - sum[i]</script>.</p>\n<iframe frameborder="0" height="326" name="YnknRnC6" src="https://leetcode.com/playground/YnknRnC6/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Considering every possible subarray takes <script type="math/tex; mode=display">O(n^2)</script> time. Finding out the sum of any subarray takes <script type="math/tex; mode=display">O(1)</script> time after the initial processing of <script type="math/tex; mode=display">O(n)</script> for creating the cumulative sum array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Cumulative sum array <script type="math/tex; mode=display">sum</script> of size <script type="math/tex; mode=display">n+1</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-without-space-accepted">Approach #3 Without space [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of considering all the <script type="math/tex; mode=display">start</script> and <script type="math/tex; mode=display">end</script> points and then finding the sum for each subarray corresponding to those points, we can directly find the sum on the go while considering different <script type="math/tex; mode=display">end</script> points. i.e. We can choose a particular <script type="math/tex; mode=display">start</script> point and while iterating over the <script type="math/tex; mode=display">end</script> points, we can add the element corresponding to the <script type="math/tex; mode=display">end</script> point to the sum formed till now. Whenver the <script type="math/tex; mode=display">sum</script> equals the required <script type="math/tex; mode=display">k</script> value, we can update the <script type="math/tex; mode=display">count</script> value. We do so while iterating over all the <script type="math/tex; mode=display">end</script> indices possible for every <script type="math/tex; mode=display">start</script> index. Whenver, we update the <script type="math/tex; mode=display">start</script> index, we need to reset the <script type="math/tex; mode=display">sum</script> value to 0.</p>\n<iframe frameborder="0" height="292" name="MGuUEEUy" src="https://leetcode.com/playground/MGuUEEUy/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. We need to consider every subarray possible.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-hashmap-accepted">Approach #4 Using hashmap [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The idea behind this approach is as follows: If the cumulative sum(repreesnted by <script type="math/tex; mode=display">sum[i]</script> for sum upto <script type="math/tex; mode=display">i^{th}</script> index) upto two indices is the same, the sum of the elements lying in between those indices is zero. Extending the same thought further, if the cumulative sum upto two indices, say <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> is at a difference of <script type="math/tex; mode=display">k</script> i.e. if <script type="math/tex; mode=display">sum[i] - sum[j] = k</script>, the sum of elements lying between indices <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> is <script type="math/tex; mode=display">k</script>.</p>\n<p>Based on these thoughts, we make use of a hashmap <script type="math/tex; mode=display">map</script> which is used to store the cumulative sum upto all the indices possible along with the number of times the same sum occurs. We store the data in the form: <script type="math/tex; mode=display">(sum_i, no. of occurences of sum_i)</script>. We traverse over the array <script type="math/tex; mode=display">nums</script> and keep on finding the cumulative sum. Every time we encounter a new sum, we make a new entry in the hashmap corresponding to that sum. If the same sum occurs again, we increment the count corresponding to that sum in the hashmap. Further, for every sum encountered, we also determine the number of times the sum <script type="math/tex; mode=display">sum-k</script> has occured already, since it will determine the number of times a subarray with sum <script type="math/tex; mode=display">k</script> has occured upto the current index. We increment the <script type="math/tex; mode=display">count</script> by the same amount. </p>\n<p>After the complete array has been traversed, the <script type="math/tex; mode=display">count</script> gives the required result.</p>\n<p>The animation below depicts the process.</p>\n<p>!?!../Documents/560_Subarray.json:1000,563!?!</p>\n<iframe frameborder="0" height="292" name="S6xciAtN" src="https://leetcode.com/playground/S6xciAtN/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The entire <script type="math/tex; mode=display">nums</script> array is traversed only once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Hashmap <script type="math/tex; mode=display">map</script> can contain upto <script type="math/tex; mode=display">n</script> distinct entries in the worst case.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '561',
    name: 'Array Partition I',
    acceptance: '66.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array of <b>2n</b> integers, your task is to group these integers into <b>n</b> pairs of integer, say (a<sub>1</sub>, b<sub>1</sub>), (a<sub>2</sub>, b<sub>2</sub>), ..., (a<sub>n</sub>, b<sub>n</sub>) which makes sum of min(a<sub>i</sub>, b<sub>i</sub>) for all i from 1 to n as large as possible.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,4,3,2]\n\n<b>Output:</b> 4\n<b>Explanation:</b> n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li><b>n</b> is a positive integer, which is in the range of [1, 10000].</li>\n<li>All the integers in the array will be in the range of [-10000, 10000].</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-sorting-accepted">Approach #2 Using Sorting [Accepted]</a></li>\n<li><a href="#approach-3-using-extra-array-accepted">Approach #3 Using Extra Array [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The simplest solution is to consider every possible set of pairings possible by using the elements of the <script type="math/tex; mode=display">nums</script> array. For generating all the possible pairings, we make use of a function <code>permute(nums, current_index)</code>. This function creates all the possible permutations of the elements of the given array.</p>\n<p>To do so, <code>permute</code> takes the index of the current element <script type="math/tex; mode=display">current_index</script> as one of the arguments. Then, it swaps the current element with every other element in the array, lying towards its right, so as to generate a new ordering of the array elements. After the swapping has been done, it makes another call to  <code>permute</code> but this time with the index of the next element in the array. While returning back, we reverse the swapping done in the current function call.</p>\n<p>Thus, when we reach the end of the array, a new ordering of the array\'s elements is generated. We consider the elements to be taken for the pairings such that the first element of every pair comes from the first half of the new array and the second element comes from the last half of the array. Thus, we sum up the minimum elements out of all these possible pairings and find out the maximum sum out of them.</p>\n<p>The animation below depicts the ways the permutations are generated.</p>\n<p>!?!../Documents/561_Array.json:1000,563!?!</p>\n<iframe frameborder="0" height="513" name="yuWmjysn" src="https://leetcode.com/playground/yuWmjysn/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n!)</script>. A total of <script type="math/tex; mode=display">n!</script> permutations are possible for <script type="math/tex; mode=display">n</script> elements in the array.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-sorting-accepted">Approach #2 Using Sorting [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In order to understand this approach, let us look at the problem from a different perspective. We need to form the pairings of the array\'s elements such that the overall sum of the minimum out of such pairings is maximum. Thus, we can look at the operation of choosing the minimum out of the pairing, say <script type="math/tex; mode=display">(a, b)</script> as incurring a loss of <script type="math/tex; mode=display">a - b</script>(if <script type="math/tex; mode=display">a> b</script>), in the maximum sum possible.</p>\n<p>The total sum will now be maximum if the overall loss incurred from such pairings is minimized. This minimization of loss in every pairing is possible only if the numbers chosen for the pairings lie closer to each other than to the other elements of the array.</p>\n<p>Taking this into consideration, we can sort the elements of the given array and form the pairings of the elements directly in the sorted order. This will lead to the pairings of elements with minimum difference between them leading to the maximization of the required sum.</p>\n<iframe frameborder="0" height="224" name="d5X9zosv" src="https://leetcode.com/playground/d5X9zosv/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script>. Sorting takes <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script> time. We iterate over the array only once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-extra-array-accepted">Approach #3 Using Extra Array [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This approach is somewhat related to the sorting approach. Since the range of elements in the given array is limited, we can make use of a hashmap <script type="math/tex; mode=display">arr</script>, such that <script type="math/tex; mode=display">arr[i]</script> stores the frequency of occurence of <script type="math/tex; mode=display">(i-10000)^{th}</script> element. This subtraction is done so as to be able to map the numbers in the range <script type="math/tex; mode=display">-10000 &leq; i &leq; -1</script> onto the hashmap.</p>\n<p>Thus, now instead of sorting the array\'s elements, we can directly traverse the hashmap in an ascending order. But, any element could also occur multiple times in the given array. We need to take this factor into account. </p>\n<p>For this, consider an example: <code>nums: [a, b, a, b, b, a]</code>. The sorted order of this array will be <code>nums_sorted: [a, a, a, b, b, b]</code>. (We aren\'t actually sorting the array in this approach, but the sorted array is taken just for demonstration). From the previous approach, we know that the required set of pairings is <script type="math/tex; mode=display">(a,a), (a,b), (b,b)</script>. Now, we can see that while choosing the minimum elements, <script type="math/tex; mode=display">a</script> will be chosen twice and <script type="math/tex; mode=display">b</script> will be chosen once only. This happens because the number of <script type="math/tex; mode=display">a</script>\'s to be chosen has already been determined by the frequency of <script type="math/tex; mode=display">a</script>, leaving the rest of the places to be filled by <script type="math/tex; mode=display">b</script>. This is because, for the correct result we need to consider the elements in the ascending order. Thus, the lower number always gets priority to be added to the end result.</p>\n<p>But, if the sorted elements take the form: <code>nums_sorted: [a, a, b, b, b, b]</code>, the correct pairing will be <script type="math/tex; mode=display">(a,a), (b,b), (b,b)</script>. Again, in this case the number of <script type="math/tex; mode=display">a</script>\'s chosen is already predetermined, but since the number of <script type="math/tex; mode=display">a</script>\'s is odd, it doesn\'t impact the choice of <script type="math/tex; mode=display">b</script> in the final sum.</p>\n<p>Thus, based on the above discussion, we traverse the hashmap <script type="math/tex; mode=display">arr</script>. If the current element is occuring <script type="math/tex; mode=display">freq_i</script> number of times, and one of the elements is left to be paired with other elements in the right region(considering a virtual sorted array), we consider the current element <script type="math/tex; mode=display">\\left \\lceil\\frac{freq_i}{2}\\right \\rceil</script> number of times and the next element occuring in the array <script type="math/tex; mode=display">\\left \\lfloor\\frac{freq_j}{2}\\right \\rfloor</script> number of times for the final sum. To propagate the impact of this left over chosen number, we make use of a flag <script type="math/tex; mode=display">d</script>. This flag is set to 1 if there is a leftover element from the current set which will be considered one more time. The same extra element already considered is taken into account while choosing an element from the next set.</p>\n<p>While traversing the hashmap, we determine the correct number of times each element needs to be considered as discussed above. Note that the flag <script type="math/tex; mode=display">d</script> and the <script type="math/tex; mode=display">sum</script> remains unchanged if the current element of the hashmap doesn\'t exist in the array.</p>\n<p>Below code is inspired by <a href="https://leetcode.com/fallcreek">@fallcreek</a></p>\n<iframe frameborder="0" height="309" name="tzs4t7Hu" src="https://leetcode.com/playground/tzs4t7Hu/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The whole hashmap <script type="math/tex; mode=display">arr</script> of size <script type="math/tex; mode=display">n</script> is traversed only once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. A hashmap <script type="math/tex; mode=display">arr</script> of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '562',
    name: 'Longest Line of Consecutive One in Matrix ',
    acceptance: '41.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            Given a 01 matrix <b>M</b>, find the longest line of consecutive one in the matrix. The line could be horizontal, vertical, diagonal or anti-diagonal.\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b>\n[[0,1,1,0],\n [0,1,1,0],\n [0,0,0,1]]\n<b>Output:</b> 3\n</pre>\n<p></p>\n\n<p>\n<b>Hint:</b>\nThe number of elements in the given matrix will not exceed 10,000.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-using-3d-dynamic-programming-accepted">Approach #2 Using 3D Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-3-using-2d-dynamic-programming-accepted">Approach #3 Using 2D Dynamic Programming [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The brute force approach is really simple. We directly traverse along every valid line in the given matrix: i.e. Horizontal, Vertical, Diagonal aline above and below the middle diagonal, Anti-diagonal line above and below the middle anti-diagonal. Each time during the traversal, we keep on incrementing the <script type="math/tex; mode=display">count</script> if we encounter continuous 1\'s. We reset the <script type="math/tex; mode=display">count</script> for any discontinuity encountered. While doing this, we also keep a track of the maximum <script type="math/tex; mode=display">count</script> found so far.</p>\n<iframe frameborder="0" height="515" name="eyvFH9Kd" src="https://leetcode.com/playground/eyvFH9Kd/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. We traverse along the entire matrix 4 times.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-3d-dynamic-programming-accepted">Approach #2 Using 3D Dynamic Programming [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of traversing over the same matrix multiple times, we can keep a track of the 1\' along all the lines possible while traversing the matrix once only. In order to do so, we make use of a <script type="math/tex; mode=display">m x n x 4</script>$ sized <script type="math/tex; mode=display">dp</script> array. Here, <script type="math/tex; mode=display">dp[0]</script>, <script type="math/tex; mode=display">dp[1]</script>, <script type="math/tex; mode=display">dp[2]</script> ,<script type="math/tex; mode=display">dp[3]</script> are used to store the maximum number of continuous 1\'s found so far along the Horizontal, Vertical, Diagonal and Anti-diagonal lines respectively. e.g. <script type="math/tex; mode=display">dp[i][j][0]</script> is used to store the number of continuous 1\'s found so far(till we reach the element <script type="math/tex; mode=display">M[i][j]</script>), along the horizontal lines only.</p>\n<p>Thus, we traverse the matrix <script type="math/tex; mode=display">M</script> in a row-wise fashion only but, keep updating the entries for every <script type="math/tex; mode=display">dp</script> appropriately. </p>\n<p>The following image shows the filled <script type="math/tex; mode=display">dp</script> values for this matrix:</p>\n<div class="codehilite"><pre><span></span> 0 1 1 0\n\n 0 1 1 0\n\n 0 0 1 1\n</pre></div>\n<p><img alt="Longest_Line" src="https://leetcode.com/articles/Figures/562_Longest_Line.PNG"></p>\n<p>While filling up the <script type="math/tex; mode=display">dp</script>, we can keep a track of the length of the longest consecutive line of 1\'s.</p>\n<p>Watch this animation for complete process:</p>\n<p>!?!../Documents/562_Longest_Line.json:1000,563!?!</p>\n<iframe frameborder="0" height="411" name="piAseSco" src="https://leetcode.com/playground/piAseSco/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. We traverse the entire matrix once only.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m*n)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">4*m*n</script> is used, where <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> are the number of rows ans coloumns of the matrix.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-2d-dynamic-programming-accepted">Approach #3 Using 2D Dynamic Programming [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the previous approach, we can observe that the current <script type="math/tex; mode=display">dp</script> entry is dependent only on the entries of the just previous corresponding <script type="math/tex; mode=display">dp</script> row. Thus, instead of maintaining a 2-D <script type="math/tex; mode=display">dp</script> matrix for each kind of line of 1\'s possible, we can use a 1-d array for each one of them, and update the corresponding entries in the same row during each row\'s traversal. Taking this into account, the previous 3-D <script type="math/tex; mode=display">dp</script> matrix shrinks to a 2-D <script type="math/tex; mode=display">dp</script> matrix now. The rest of the procedure remains same as the previous approach.</p>\n<iframe frameborder="0" height="496" name="4Wj5XMZ9" src="https://leetcode.com/playground/4Wj5XMZ9/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. The entire matrix is traversed once only.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">4*n</script> is used, where <script type="math/tex; mode=display">n</script> is the number of columns of the matrix.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '563',
    name: 'Binary Tree Tilt',
    acceptance: '47.1%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>Given a binary tree, return the tilt of the <b>whole tree</b>.</p>\n\n<p>The tilt of a <b>tree node</b> is defined as the <b>absolute difference</b> between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.</p>\n\n<p>The tilt of the <b>whole tree</b> is defined as the sum of all nodes' tilt.</p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> \n         1\n       /   \\\n      2     3\n<b>Output:</b> 1\n<b>Explanation:</b> \nTilt of node 2 : 0\nTilt of node 3 : 0\nTilt of node 1 : |2-3| = 1\nTilt of binary tree : 0 + 0 + 1 = 1\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><ol>\n<li>The sum of node values in any subtree won't exceed the range of 32-bit integer. </li>\n<li>All the tilt values won't exceed the range of 32-bit integer.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>From the problem statement, it is clear that we need to find the tilt value at every node of the given tree and add up all the tilt values to obtain the final result. To find the tilt value at any node, we need to subtract the sum of all the nodes in its left subtree and the sum of all the nodes in its right subtree. </p>\n<p>Thus, to find the solution, we make use of a recursive function <code>traverse</code> which when called from any node, returns the sum of the nodes below the current node including itself. With the help of such sum values for the right and left subchild of any node, we can directly obtain the tilt value corresponding to that node.</p>\n<p>The below animation depicts how the value passing and tilt calculation:</p>\n<p>!?!../Documents/563_Binary.json:1000,563!?!</p>\n<iframe frameborder="0" height="496" name="CGp6bPXz" src="https://leetcode.com/playground/CGp6bPXz/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time complexity : <script type="math/tex; mode=display">O(n)</script>. where <script type="math/tex; mode=display">n</script> is the number of nodes. Each node is visited once.</li>\n<li>Space complexity : <script type="math/tex; mode=display">O(n)</script>. In worst case when the tree is skewed depth of tree will be <script type="math/tex; mode=display">n</script>. In average case depth will be <script type="math/tex; mode=display">logn</script>.</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Indeed'],
  },
  {
    id: '564',
    name: 'Find the Closest Palindrome',
    acceptance: '17.5%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given an integer n, find the closest integer (not including itself), which is a palindrome. </p>\n\n<p>The \'closest\' is defined as absolute difference minimized between two integers.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "123"\n<b>Output:</b> "121"\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The input <b>n</b> is a positive integer represented by string, whose length will not exceed 18.</li>\n<li>If there is a tie, return the smaller one as answer.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-forcetime-limit-exceeded">Approach #1 Brute Force[Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-mathaccepted">Approach #2 Using Math[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-forcetime-limit-exceeded">Approach #1 Brute Force[Time Limit Exceeded]</h4>\n<p>The simplest solution is to consider every possible number smaller than the given number <script type="math/tex; mode=display">n</script>, starting by decrementing 1 from the given number and go on in descending order. Similarly, we can consider every possible number greater than <script type="math/tex; mode=display">n</script> starting by incrementing 1 from the given number and going in ascending order. We can continue doing so in an alternate manner till we find a number which is a palindrome.</p>\n<iframe frameborder="0" height="377" name="DvreVK8V" src="https://leetcode.com/playground/DvreVK8V/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(\\sqrt{n})</script>. Upto <script type="math/tex; mode=display">2*\\sqrt{n}</script> numbers could be generated in the worst case.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-mathaccepted">Approach #2 Using Math[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>To understand this method, let\'s start with a simple illustration. Assume that the number given to us is "abcxy". One way to convert this number into a palindrome is to replicate one half of the string to the other half. If we try replicating the second half to the first half, the new palindrome obtained will be "yxcxy" which lies at an absolute of <script type="math/tex; mode=display">\\left|10000(a-y) + 1000(b-x)\\right|</script> from the original number. But, if we replicate the first half to the second half of the string, we obtain "abcba", which lies at an absolute difference of <script type="math/tex; mode=display">\\left|10(x-b) + (y-a)\\right|</script>. Trying to change <script type="math/tex; mode=display">c</script> additionaly in either case would incur an additional value of atleast 100 in the absolute difference.</p>\n<p>From the above illustration, we can conclude that if replication is used to generate the palindromic number, we should always replicate the first half to the second half. In this implementation, we\'ve stored such a number in <script type="math/tex; mode=display">a</script> at a difference of <script type="math/tex; mode=display">diff1</script> from <script type="math/tex; mode=display">n</script>.</p>\n<p>But, there exists another case as well, where the digit at the middle index is incremented or decremented. In such cases, it could be profitable to make changes to the central digit only since such changes could lead to a palindrome formation nearer to the original digit. e.g. 10987. Using the above criteria, the palindrome obtained will be 10901 which is at a more difference from 10987 than 11011. A similar situation occurs if a 0 occurs at the middle digit. But, again as discussed previously, we need to consider only the first half digits to obtain the new palindrome. This special effect occurs with 0 or 9 at the middle digit since, only decrementing 0 and incrementing 9 at that digit place can lead to the change in the rest of the digits towards their left. In any other case, the situation boils down to the one discussed in the first paragraph.</p>\n<p>Now, whenever we find a 0 near the middle index, in order to consider the palindromes which are lesser than <script type="math/tex; mode=display">n</script>, we subtract a 1 from the first half of the number to obtain a new palindromic half e.g. If the given number <script type="math/tex; mode=display">n</script> is 20001, we subtract a 1 from 200 creating a number of the form 199xx. To obtain the new palindrome, we replicate the first half to obtain 19991. Taking another example of  10000, (with a 1 at the MSB), we subtract a 1 from 100 creating 099xx as the new number transforming to a 9999 as the new palindrome. This number is stored in <script type="math/tex; mode=display">b</script> having a difference of <script type="math/tex; mode=display">diff2</script> from <script type="math/tex; mode=display">n</script>\n</p>\n<p>Similar treatment needs to be done with a 9 at the middle digit, except that this time we need to consider the numbers larger than the current number. For this, we add a 1 to the first half. e.g. Taking the number 10987, we add a 1 to 109 creating a number of the form 110xx(11011 is the new palindrome). This palindrome is stored in <script type="math/tex; mode=display">c</script> having a difference of <script type="math/tex; mode=display">diff3</script> from <script type="math/tex; mode=display">n</script>.</p>\n<p>Out of these three palindromes, we can choose the one with a minimum difference from <script type="math/tex; mode=display">n</script>. Further, in case of a tie, we need to return the smallest palindrome obtained. For resolving this tie\'s conflict, we can observe that a tie is possible only if one number is larger than <script type="math/tex; mode=display">n</script> and another is lesser than <script type="math/tex; mode=display">n</script>. Further, we know that the number <script type="math/tex; mode=display">b</script> is obtained by decreasing <script type="math/tex; mode=display">n</script>. Thus, in case of conflict between <script type="math/tex; mode=display">b</script> and any other number, we need to choose <script type="math/tex; mode=display">b</script>. Similarly, <script type="math/tex; mode=display">c</script> is obtained by increasing <script type="math/tex; mode=display">n</script>. Thus, in case of a tie between <script type="math/tex; mode=display">c</script> and any other number, we need to choose the number other than <script type="math/tex; mode=display">c</script>.</p>\n<iframe frameborder="0" height="515" name="Y6G9NDDf" src="https://leetcode.com/playground/Y6G9NDDf/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(l)</script>. Scanning, insertion, deletion,, mirroring takes <script type="math/tex; mode=display">O(l)</script>, where <script type="math/tex; mode=display">l</script> is the length of the string.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(l)</script>. Temporary variables are used to store the strings.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Yelp'],
  },
  {
    id: '565',
    name: 'Array Nesting',
    acceptance: '49.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below.</p>\n\n<p>Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> A = [5,4,0,3,1,6,2]\n<b>Output:</b> 6\n<b>Explanation:</b> \nA[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.\n\nOne of the longest S[K]:\nS[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>N is an integer within the range [1, 20,000].</li>\n<li>The elements of A are all distinct.</li>\n<li>Each element of A is an integer within the range [0, N-1].</li>\n</ol>\n<p></p>\n\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-visited-array-accepted">Approach #2 Using Visited Array [Accepted]</a></li>\n<li><a href="#approach-3-without-using-extra-space-accepted">Approach #3 Without Using Extra Space [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The simplest method is to iterate over all the indices of the given <script type="math/tex; mode=display">nums</script> array. For every index <script type="math/tex; mode=display">i</script> chosen, we find the element <script type="math/tex; mode=display">nums[i]</script> and increment the <script type="math/tex; mode=display">count</script> for a new element added for the current index <script type="math/tex; mode=display">i</script>. Since <script type="math/tex; mode=display">nums[i]</script> has to act as the new index for finding the next element belonging to the set corresponding to the index <script type="math/tex; mode=display">i</script>, the new index is <script type="math/tex; mode=display">j=nums[i]</script>.</p>\n<p>We continue this process of index updation and keep on incrementing the <script type="math/tex; mode=display">count</script> for new elements added to the set corresponding to the index <script type="math/tex; mode=display">i</script>. Now, since all the elements in <script type="math/tex; mode=display">nums</script> lie in the range <script type="math/tex; mode=display">(0,..., N-1)</script>, the new indices generated will never lie outside the array size limits. But, we\'ll always reach a point where the current element becomes equal to the element  <script type="math/tex; mode=display">nums[i]</script> with which we started the nestings in the first place. Thus, after this, the new indices generated will be just the repetitions of the previously generated ones, and thus would not lead to an increase in the size of the current set. Thus, this condition of the current number being equal to the starting number acts as the terminating condition for <script type="math/tex; mode=display">count</script> incrementation for a particular index.</p>\n<p>We do the same process for every index chosen as the starting index. At the end, the maximum value of <script type="math/tex; mode=display">count</script> obtained gives the size of the largest set.</p>\n<iframe frameborder="0" height="326" name="K6QuRdnw" src="https://leetcode.com/playground/K6QuRdnw/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. In worst case, for example- <code>[1,2,3,4,5,0]</code>, loop body will be executed <script type="math/tex; mode=display">n^2</script> times.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-visited-array-accepted">Approach #2 Using Visited Array [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we observed that in the worst case, all the elements of the <script type="math/tex; mode=display">nums</script> array are added to the sets corresponding to all the starting indices. But, all these sets correspond to the same set of elements only, leading to redundant calculations.</p>\n<p>We consider a simple example and see how this problem can be resolved. From the figure below, we can see that the elements in the current nesting shown by arrows form a cycle. Thus, the same elements will be added to the current set irrespective of the first element chosen to be added to the set out of these marked elements.</p>\n<p><img alt="Array_Nesting" src="https://leetcode.com/articles/Figures/565/Array_Nesting.PNG"></p>\n<p>Thus, when we add an element <script type="math/tex; mode=display">nums[j]</script> to a set corresponding to any of the indices, we mark its position as visited in a <script type="math/tex; mode=display">visited</script> array. This is done so that whenever this index is chosen as the starting index in the future, we do not go for redundant <script type="math/tex; mode=display">count</script> calculations, since we\'ve already considered the elements linked with this index, which will be added to a new(duplicate) set.</p>\n<p>By doing so, we ensure that the duplicate sets aren\'t considered again and again.</p>\n<p>Further, we can also observe that no two elements at indices <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> will lead to a jump to the same index <script type="math/tex; mode=display">k</script>, since it would require <script type="math/tex; mode=display">nums[i] = nums[j] = k</script>, which isn\'t possible since all the elements are distinct. Also, because of the same reasoning, no element outside any cycle could lead to an element inside the cycle. Because of this, the use of <script type="math/tex; mode=display">visited</script> array goes correctly. </p>\n<iframe frameborder="0" height="394" name="XQA6FiH7" src="https://leetcode.com/playground/XQA6FiH7/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Every element of the <script type="math/tex; mode=display">nums</script> array will be considered atmost once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">visited</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-without-using-extra-space-accepted">Approach #3 Without Using Extra Space [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, the <script type="math/tex; mode=display">visited</script> array is used just to keep a track of the elements of the array which have already been visited. Instead of making use of a separate array to keep track of the same, we can mark the visited elements in the original array <script type="math/tex; mode=display">nums</script> itself. Since, the range of the elements can only be between 1 to 20,000, we can put a very large integer value <script type="math/tex; mode=display">\\text{Integer.MAX_VALUE}</script> at the position which has been visited. The rest process of traversals remains the same as in the last approach.</p>\n<iframe frameborder="0" height="394" name="7DmKnygx" src="https://leetcode.com/playground/7DmKnygx/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Every element of the <script type="math/tex; mode=display">nums</script> array will be considered atmost once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant Space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Apple'],
  },
  {
    id: '566',
    name: 'Reshape the Matrix',
    acceptance: '58.2%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data.\n</p>\n\n<p>\nYou're given a matrix represented by a two-dimensional array, and two <b>positive</b> integers <b>r</b> and <b>c</b> representing the <b>row</b> number and <b>column</b> number of the wanted reshaped matrix, respectively.</p>\n\n <p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <b>row-traversing</b> order as they were.\n</p>\n\n<p>\nIf the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \nnums = \n[[1,2],\n [3,4]]\nr = 1, c = 4\n<b>Output:</b> \n[[1,2,3,4]]\n<b>Explanation:</b><br>The <b>row-traversing</b> of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \nnums = \n[[1,2],\n [3,4]]\nr = 2, c = 4\n<b>Output:</b> \n[[1,2],\n [3,4]]\n<b>Explanation:</b><br>There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The height and width of the given matrix is in range [1, 100].</li>\n<li>The given r and c are all positive.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-queue-accepted">Approach #1 Using queue [Accepted]</a></li>\n<li><a href="#approach-2-without-using-extra-space-accepted">Approach #2 Without using extra Space [Accepted]</a></li>\n<li><a href="#approach-3-using-division-and-modulus-accepted">Approach #3  Using division and modulus [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-queue-accepted">Approach #1 Using queue [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The simplest method is to extract all the elements of the given matrix by reading the elements in a row-wise fashion. In this implementation, we use a queue to put the extracted elements. Then, we can take out the elements of the queue formed in a serial order and arrange the elements in the resultant required matrix in a row-by-row order again.</p>\n<p>The formation of the resultant matrix won\'t be possible if the number of elements in the original matrix isn\'t equal to the number of elements in the resultant matrix.</p>\n<iframe frameborder="0" height="428" name="QiYrHtjz" src="https://leetcode.com/playground/QiYrHtjz/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. We traverse over <script type="math/tex; mode=display">m*n</script> elements twice. Here, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> refer to the number of rows and columns of the given matrix respectively.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m*n)</script>. The queue formed will be of size <script type="math/tex; mode=display">m*n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-without-using-extra-space-accepted">Approach #2 Without using extra Space [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of unnecessarily using the queue as in the brute force approach, we can keep putting the numbers in the resultant matrix directly while iterating over the given matrix in a row-by-row order. While putting the numbers in the resultant array, we fix a particular row and keep on incrementing the column numbers only till we reach the end of the required columns indicated by <script type="math/tex; mode=display">c</script>. At this moment, we update the row index by incrementing it and reset the column index to start from 0 again. Thus, we can save the space consumed by the queue for storing the data that just needs to be copied into a new array.</p>\n<iframe frameborder="0" height="394" name="JvBHJ8mJ" src="https://leetcode.com/playground/JvBHJ8mJ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. We traverse the entire matrix of size <script type="math/tex; mode=display">m*n</script> once only. Here, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> refers to the number of rows and columns in the given matrix.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m*n)</script>. The resultant matrix of size <script type="math/tex; mode=display">m*n</script> is used. </p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-division-and-modulus-accepted">Approach #3  Using division and modulus [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we needed to keep a track of when we reached the end of columns for the resultant matrix and needed to update the current row and column number for putting the extracted elements by checking the current indices every time. Instead of doing these limit checks at every step, we can make use of maths to help ease the situation. </p>\n<p>The idea behind this approach is as follows. Do you know how a 2-D array is stored in the main memory(which is 1-D  in nature)? It is internally represented as a 1-D array only. The element <script type="math/tex; mode=display">nums[i][j]</script> of <script type="math/tex; mode=display">nums</script> array is represented in the form of a one dimensional array by using the index in the form: <script type="math/tex; mode=display">nums[n*i + j]</script>, where <script type="math/tex; mode=display">m</script> is the number of columns in the given matrix. Looking at the same in the reverse order, while putting the elements in the elements in the resultant matrix, we can make use of a <script type="math/tex; mode=display">count</script> variable which gets incremented for every element traversed as if we are putting the elements in a 1-D resultant array. But, to convert the <script type="math/tex; mode=display">count</script> back into 2-D matrix indices with a column count of <script type="math/tex; mode=display">c</script>, we can obtain the indices as <script type="math/tex; mode=display">res[count/c][count\\%c]</script> where <script type="math/tex; mode=display">count/c</script> is the row number and <script type="math/tex; mode=display">count\\%c</script> is the coloumn number. Thus, we can save the extra checking required at each step.</p>\n<iframe frameborder="0" height="309" name="3U3C5txm" src="https://leetcode.com/playground/3U3C5txm/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. We traverse the entire matrix of size <script type="math/tex; mode=display">m*n</script> once only. Here, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> refers to the number of rows and columns in the given matrix.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m*n)</script>. The resultant matrix of size <script type="math/tex; mode=display">m*n</script> is used. </p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Mathworks'],
  },
  {
    id: '567',
    name: 'Permutation in String',
    acceptance: '36.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            Given two strings <b>s1</b> and <b>s2</b>, write a function to return true if <b>s2</b> contains the permutation of <b>s1</b>. In other words, one of the first string\'s permutations is the <b>substring</b> of the second string.\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>s1 = "ab" s2 = "eidbaooo"\n<b>Output:</b>True\n<b>Explanation:</b> s2 contains one permutation of s1 ("ba").\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b>s1= "ab" s2 = "eidboaoo"\n<b>Output:</b> False\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The input strings only contain lower case letters.</li>\n<li>The length of both given strings is in range [1, 10,000].</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-sorting-time-limit-exceeded">Approach #2 Using sorting [Time Limit Exceeded]:</a></li>\n<li><a href="#approach-3-using-hashmap-time-limit-exceeded">Approach #3 Using Hashmap [Time Limit Exceeded]</a></li>\n<li><a href="#approach-4-using-array-accepted">Approach #4 Using Array [Accepted]</a></li>\n<li><a href="#approach-5-sliding-window-accepted">Approach #5 Sliding Window  [Accepted]:</a></li>\n<li><a href="#approach-6-optimized-sliding-window-accepted">Approach #6 Optimized Sliding Window [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The simplest method is to generate all the permutations of the short string  and to check if the generated permutation is a substring of the longer string.</p>\n<p>In order to generate all the possible pairings, we make use of a function <code>permute(string_1, string_2, current_index)</code>. This function creates all the possible permutations of the short string <script type="math/tex; mode=display">s1</script>.</p>\n<p>To do so, permute takes the index of the current element <script type="math/tex; mode=display">current_index</script> as one of the arguments. Then, it swaps the current element with every other element in the array, lying towards its right, so as to generate a new ordering of the array elements. After the swapping has been done, it makes another call to permute but this time with the index of the next element in the array. While returning back, we reverse the swapping done in the current function call.</p>\n<p>Thus, when we reach the end of the array, a new ordering of the array\'s elements is generated. The following animation depicts the process of generating the permutations.</p>\n<p>!?!../Documents/561_Array.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="p3HAqkFZ" src="https://leetcode.com/playground/p3HAqkFZ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n!)</script>. We match all the permutations of the short string <script type="math/tex; mode=display">s1</script>, of length <script type="math/tex; mode=display">s1</script>, with <script type="math/tex; mode=display">s2</script>. Here, <script type="math/tex; mode=display">n</script> refers to the length of <script type="math/tex; mode=display">s1</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n^2)</script>. The depth of the recursion tree is <script type="math/tex; mode=display">n</script>(<script type="math/tex; mode=display">n</script> refers to the length of the short string <script type="math/tex; mode=display">s1</script>). Every node of the recursion tree contains a string of max. length <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-sorting-time-limit-exceeded">Approach #2 Using sorting [Time Limit Exceeded]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>The idea behind this approach is that one string will be a permutation of another string only if both of them contain the same characters the same number of times. One string <script type="math/tex; mode=display">x</script> is a permutation of other string <script type="math/tex; mode=display">y</script> only if <script type="math/tex; mode=display">sorted(x)=sorted(y)</script>. </p>\n<p>In order to check this, we can sort the two strings and compare them.  We sort the short string <script type="math/tex; mode=display">s1</script> and all the substrings of <script type="math/tex; mode=display">s2</script>, sort them and compare them with the sorted <script type="math/tex; mode=display">s1</script> string. If the two match completely, <script type="math/tex; mode=display">s1</script>\'s permutation is a substring of <script type="math/tex; mode=display">s2</script>, otherwise not.</p>\n<iframe frameborder="0" height="326" name="zWvWj8oK" src="https://leetcode.com/playground/zWvWj8oK/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(l_1log(l_1)+(l_2-l_1)l_1log(l_1)\\big)</script>. where <script type="math/tex; mode=display">l_1</script> is the length of string <script type="math/tex; mode=display">l_1</script> and <script type="math/tex; mode=display">l_2</script> is the length of string <script type="math/tex; mode=display">l_2</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(l_1)</script>. <script type="math/tex; mode=display">t</script> array is used .</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-hashmap-time-limit-exceeded">Approach #3 Using Hashmap [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>As discussed above, one string will be a permutation of another string only if both of them contain the same charaters with the same frequency. We can consider every possible substring in the long string <script type="math/tex; mode=display">s2</script> of the same length as that of <script type="math/tex; mode=display">s1</script> and check the frequency of occurence of the characters appearing in the two. If the frequencies of every letter match exactly, then only <script type="math/tex; mode=display">s1</script>\'s permutation can be a substring of <script type="math/tex; mode=display">s2</script>. </p>\n<p>In order to implement this approach, instead of sorting and then comparing the elements for equality, we make use of a hashmap <script type="math/tex; mode=display">s1map</script> which stores the frequency of occurence of all the characters in the short string <script type="math/tex; mode=display">s1</script>. We consider every possible substring of <script type="math/tex; mode=display">s2</script> of the same length as that of <script type="math/tex; mode=display">s1</script>, find its corresponding hashmap as well, namely <script type="math/tex; mode=display">s2map</script>. Thus, the substrings considered can be viewed as a window of length as that of <script type="math/tex; mode=display">s1</script> iterating over <script type="math/tex; mode=display">s2</script>. If the two hashmaps obtained are identical for any such window, we can conclude that <script type="math/tex; mode=display">s1</script>\'s permutation is a substring of <script type="math/tex; mode=display">s2</script>, otherwise not.</p>\n<iframe frameborder="0" height="513" name="SvwMjwJX" src="https://leetcode.com/playground/SvwMjwJX/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(l_1+26*l_1*(l_2-l_1))</script>. hashmap contains atmost 26 keys. where <script type="math/tex; mode=display">l_1</script> is the length of string <script type="math/tex; mode=display">l_1</script> and <script type="math/tex; mode=display">l_2</script> is the length of string <script type="math/tex; mode=display">l_2</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. hashmap contains atmost 26 key-value pairs.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-array-accepted">Approach #4 Using Array [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of making use of a special HashMap datastructure just to store the frequency of occurence of characters, we can use a simpler array data structure to store the frequencies. Given strings contains only lowercase alphabets (\'a\' to \'z\'). So we need to take an array of size 26.The rest of the process remains the same as the last approach.</p>\n<iframe frameborder="0" height="496" name="48H3F2LJ" src="https://leetcode.com/playground/48H3F2LJ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(l_1+26*l_1*(l_2-l_1))</script>,  where <script type="math/tex; mode=display">l_1</script> is the length of string <script type="math/tex; mode=display">l_1</script> and <script type="math/tex; mode=display">l_2</script> is the length of string <script type="math/tex; mode=display">l_2</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. <script type="math/tex; mode=display">s1map</script> and <script type="math/tex; mode=display">s2map</script> of size 26 is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-sliding-window-accepted">Approach #5 Sliding Window  [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of generating the hashmap afresh for every window considered in <script type="math/tex; mode=display">s2</script>, we can create the hashmap just once for the first window in <script type="math/tex; mode=display">s2</script>. Then, later on when we slide the window, we know that we add one preceding character and add a new succeeding character to the new window considered. Thus, we can update the hashmap by just updating the indices associated with those two characters only. Again, for every updated hashmap, we compare all the elements of the hashmap for equality to get the required result.</p>\n<iframe frameborder="0" height="496" name="o4pqWwhn" src="https://leetcode.com/playground/o4pqWwhn/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(l_1+26*(l_2-l_1))</script>,  where <script type="math/tex; mode=display">l_1</script> is the length of string <script type="math/tex; mode=display">l_1</script> and <script type="math/tex; mode=display">l_2</script> is the length of string <script type="math/tex; mode=display">l_2</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-6-optimized-sliding-window-accepted">Approach #6 Optimized Sliding Window [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>The last approach can be optimized, if instead of comparing all the elements of the hashmaps for every updated <script type="math/tex; mode=display">s2map</script> corresponding to every window of <script type="math/tex; mode=display">s2</script> considered, we keep a track of the number of elements which were already matching in the earlier hashmap and update just the count of matching elements when we shift the window towards the right.</p>\n<p>To do so, we maintain a <script type="math/tex; mode=display">count</script> variable, which stores the number of characters(out of the 26 alphabets), which have the same frequency of occurence in <script type="math/tex; mode=display">s1</script> and the current window in <script type="math/tex; mode=display">s2</script>. When we slide the window, if the deduction of the last element and the addition of the new element leads to a new frequency match of any of the characters, we increment the <script type="math/tex; mode=display">count</script> by 1. If not, we keep the <script type="math/tex; mode=display">count</script> intact. But, if a character whose frequency was the same earlier(prior to addition and removal) is added, it now leads to a frequency mismatch which is taken into account by decrementing the same <script type="math/tex; mode=display">count</script> variable. If, after the shifting of the window, the <script type="math/tex; mode=display">count</script> evaluates to 26, it means all the characters match in frequency totally. So, we return a True in that case immediately.</p>\n<iframe frameborder="0" height="515" name="T5J3SxqR" src="https://leetcode.com/playground/T5J3SxqR/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(l_1+(l_2-l_1))</script>. where <script type="math/tex; mode=display">l_1</script> is the length of string <script type="math/tex; mode=display">l_1</script> and <script type="math/tex; mode=display">l_2</script> is the length of string <script type="math/tex; mode=display">l_2</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Microsoft'],
  },
  {
    id: '568',
    name: 'Maximum Vacation Days ',
    acceptance: '38.8%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>\nLeetCode wants to give one of its best employees the option to travel among <b>N</b> cities to collect algorithm problems. But all work and no play makes Jack a dull boy, you could take vacations in some particular cities and weeks. Your job is to schedule the traveling to maximize the number of vacation days you could take, but there are certain rules and restrictions you need to follow.\n</p>\n\n<p><b>Rules and restrictions:</b><br>\n</p><ol>\n<li>You can only travel among <b>N</b> cities, represented by indexes from 0 to N-1. Initially, you are in the city indexed 0 on <b>Monday</b>.</li>\n<li>The cities are connected by flights. The flights are represented as a <b>N*N</b> matrix (not necessary symmetrical), called <b>flights</b> representing the airline status from the city i to the city j. If there is no flight from the city i to the city j, <b>flights[i][j] = 0</b>; Otherwise, <b>flights[i][j] = 1</b>. Also, <b>flights[i][i] = 0</b> for all i.</li>\n<li>You totally have <b>K</b> weeks (<b>each week has 7 days</b>) to travel. You can only take flights at most once <b>per day</b> and can only take flights on each week's <b>Monday</b> morning. Since flight time is so short, we don't consider the impact of flight time.</li>\n<li>For each city, you can only have restricted vacation days in different weeks, given an <b>N*K</b> matrix called <b>days</b> representing this relationship. For the value of <b>days[i][j]</b>, it represents the maximum days you could take vacation in the city <b>i</b> in the week <b>j</b>.</li>\n</ol>\n<p></p>\n\n<p>You're given the <b>flights</b> matrix and <b>days</b> matrix, and you need to output the maximum vacation days you could take during <b>K</b> weeks.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[1,3,1],[6,0,3],[3,3,3]]\n<b>Output:</b> 12\n<b>Explanation:</b> <br>Ans = 6 + 3 + 3 = 12. <br>\nOne of the best strategies is:\n1st week : fly from city 0 to city 1 on Monday, and play 6 days and work 1 day. <br>(Although you start at city 0, we could also fly to and start at other cities since it is Monday.) \n2nd week : fly from city 1 to city 2 on Monday, and play 3 days and work 4 days.\n3rd week : stay at city 2, and play 3 days and work 4 days.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b>flights = [[0,0,0],[0,0,0],[0,0,0]], days = [[1,1,1],[7,7,7],[7,7,7]]\n<b>Output:</b> 3\n<b>Explanation:</b> <br>Ans = 1 + 1 + 1 = 3. <br>\nSince there is no flights enable you to move to another city, you have to stay at city 0 for the whole 3 weeks. <br>For each week, you only have one day to play and six days to work. <br>So the maximum number of vacation days is 3.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b>flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[7,0,0],[0,7,0],[0,0,7]]\n<b>Output:</b> 21\n<b>Explanation:</b><br>Ans = 7 + 7 + 7 = 21<br>\nOne of the best strategies is:\n1st week : stay at city 0, and play 7 days. \n2nd week : fly from city 0 to city 1 on Monday, and play 7 days.\n3rd week : fly from city 1 to city 2 on Monday, and play 7 days.\n</pre>\n<p></p>\n\n\n<p><b>Note:</b><br>\n</p><ol>\n<li><b>N and K</b> are positive integers, which are in the range of [1, 100].</li>\n<li>In the matrix <b>flights</b>, all the values are integers in the range of [0, 1].</li>\n<li>In the matrix <b>days</b>, all the values are integers in the range [0, 7].</li>\n<li>You could stay at a city beyond the number of vacation days, but you should <b>work</b> on the extra days, which won't be counted as vacation days.</li>\n<li>If you fly from the city A to the city B and take the vacation on that day, the deduction towards vacation days will count towards the vacation days of city B in that week.</li>\n<li>We don't consider the impact of flight hours towards the calculation of vacation days.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-depth-first-search-time-limit-exceeded">Approach #1 Using Depth First Search [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-dfs-with-memoization-accepted">Approach #2 Using DFS with memoization [Accepted]:</a></li>\n<li><a href="#approach-3-using-2-d-dynamic-programming-accepted">Approach #3 Using 2-D Dynamic Programming [Accepted]:</a></li>\n<li><a href="#approach-4-using-1-d-dynamic-programming-accepted">Approach #4 Using 1-D Dynamic Programming [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-depth-first-search-time-limit-exceeded">Approach #1 Using Depth First Search [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the brute force approach, we make use of a recursive function <script type="math/tex; mode=display">dfs</script>, which returns the number of vacations which can be taken startring from <script type="math/tex; mode=display">cur\\_city</script> as the current city and <script type="math/tex; mode=display">weekno</script> as the starting week. </p>\n<p>In every function call, we traverse over all the cities(represented by <script type="math/tex; mode=display">i</script>) and find out all the cities which are connected to the current city, <script type="math/tex; mode=display">cur\\_city</script>. Such a city is represented by a 1 at the corresponding <script type="math/tex; mode=display">flights[cur\\_city][i]</script> position. Now, for the current city, we can either travel to the city which is connected to it or we can stay in the same city. Let\'s say the city to which we change our location from the current city be represented by <script type="math/tex; mode=display">j</script>. Thus, after changing the city, we need to find the number of vacations which we can take from the new city as the current city and the incremented week as the new starting week. This count of vacations can be represented as: <script type="math/tex; mode=display">days[j][weekno] + dfs(flights, days, j, weekno + 1)</script>. </p>\n<p>Thus, for the current city, we obtain a number of vacations by choosing different cities as the next cities. Out of all of these vacations coming from different cities, we can find out the maximum number of vacations that need to be returned for every <script type="math/tex; mode=display">dfs</script> function call.</p>\n<iframe frameborder="0" height="377" name="7nvGhHgq" src="https://leetcode.com/playground/7nvGhHgq/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^k)</script>. Depth of Recursion tree will be <script type="math/tex; mode=display">k</script> and each node contains <script type="math/tex; mode=display">n</script> branches in the worst case. Here <script type="math/tex; mode=display">n</script> represents the number of cities and <script type="math/tex; mode=display">k</script> is the total number of weeks.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(k)</script>. The depth of the recursion tree is <script type="math/tex; mode=display">k</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-dfs-with-memoization-accepted">Approach #2 Using DFS with memoization [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we make a number of redundant function calls, since the same function call of the form <code>dfs(flights, days, cur_city, weekno)</code> can be made multiple number of times with the same <script type="math/tex; mode=display">cur\\_city</script> and <script type="math/tex; mode=display">weekno</script>. These redundant calls can be pruned off if we make use of memoization. </p>\n<p>In order to remove these redundant function calls, we make use of a 2-D memoization array <script type="math/tex; mode=display">memo</script>. In this array, <script type="math/tex; mode=display">memo[i][j]</script> is used to store the number of vacactions that can be taken using the <script type="math/tex; mode=display">i^{th}</script> city as the current city and the <script type="math/tex; mode=display">j^{th}</script> week as the starting week. This result is equivalent to that obtained using the function call: <code>dfs(flights, days, i, j)</code>. Thus, if the <script type="math/tex; mode=display">memo</script> entry corresponding to the current function call already contains a valid value, we can directly obtain the result from this array instead of going deeper into recursion.</p>\n<iframe frameborder="0" height="445" name="JawnLfLv" src="https://leetcode.com/playground/JawnLfLv/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2k)</script>. <script type="math/tex; mode=display">memo</script> array of size <script type="math/tex; mode=display">n*k</script> is filled and each cell filling takes O(n) time .</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n*k)</script>. <script type="math/tex; mode=display">memo</script> array of size <script type="math/tex; mode=display">n*k</script> is used. Here <script type="math/tex; mode=display">n</script> represents the number of cities and <script type="math/tex; mode=display">k</script> is the total number of weeks.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-2-d-dynamic-programming-accepted">Approach #3 Using 2-D Dynamic Programming [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>The idea behind this approach is as follows. The maximum number of vacations that can be taken given we start from the <script type="math/tex; mode=display">i^{th}</script> city in the <script type="math/tex; mode=display">j^{th}</script> week is not dependent on the the vacations that can be taken in the earlier weeks. It only depends on the number of vacations that can be taken in the upcoming weeks and also on the connections between the various cities(<script type="math/tex; mode=display">flights</script>).</p>\n<p>Therefore, we can make use of a 2-D <script type="math/tex; mode=display">dp</script>, in which <script type="math/tex; mode=display">dp[i][k]</script> represents the maximum number of vacations which can be taken starting from the <script type="math/tex; mode=display">i^{th}</script> city in the <script type="math/tex; mode=display">k^{th}</script> week. This <script type="math/tex; mode=display">dp</script> is filled in the backward manner(in terms of the week number).</p>\n<p>While filling up the entry for <script type="math/tex; mode=display">dp[i][k]</script>, we need to consider the following cases:</p>\n<ol>\n<li>\n<p>We start from the <script type="math/tex; mode=display">i^{th}</script> city in the <script type="math/tex; mode=display">k^{th}</script> week and stay in the same city for the <script type="math/tex; mode=display">(k+1)^{th}</script> week. Thus, the factor to be considered for updating the <script type="math/tex; mode=display">dp[i][k]</script> entry will be given by: <script type="math/tex; mode=display">days[i][k] + dp[i, k+1]</script>.</p>\n</li>\n<li>\n<p>We start from the <script type="math/tex; mode=display">i^{th}</script> city in the <script type="math/tex; mode=display">k^{th}</script> week and move to the <script type="math/tex; mode=display">j^{th}</script> city in the <script type="math/tex; mode=display">(k+1)^{th}</script> week. But, for changing the city in this manner, we need to be able to move from the <script type="math/tex; mode=display">i^{th}</script> city to the <script type="math/tex; mode=display">j^{th}</script> city i.e. <script type="math/tex; mode=display">flights[i][j]</script> should be 1 for such <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script>. </p>\n</li>\n</ol>\n<p>But, while changing the city from <script type="math/tex; mode=display">i^{th}</script> city in the <script type="math/tex; mode=display">k^{th}</script> week, we can move to any <script type="math/tex; mode=display">j^{th}</script> city such that a connection exists between the <script type="math/tex; mode=display">i^{th}</script> city and the <script type="math/tex; mode=display">j^{th}</script> city i.e. <script type="math/tex; mode=display">flights[i][j]=1</script>. But, in order to maximize the number of vacations that can be taken starting from the <script type="math/tex; mode=display">i^{th}</script> city in the <script type="math/tex; mode=display">k^{th}</script> week, we need to choose the destination city that leads to maximum no. of vacations. Thus, the factor to be considered here, is given by: <script type="math/tex; mode=display">\\text{max}days[j][k] + days[j, k+1]</script>, for all <script type="math/tex; mode=display">i</script>, <script type="math/tex; mode=display">j</script>, <script type="math/tex; mode=display">k</script> satisfying <script type="math/tex; mode=display">flights[i][j] = 1</script>, <script type="math/tex; mode=display">0 &leq; i,j &leq; n, where </script>n$$ refers to the number of cities.</p>\n<p>At the end, we need to find the maximum out of these two factors to update the <script type="math/tex; mode=display">dp[i][k]</script> value.</p>\n<p>In order to fill the <script type="math/tex; mode=display">dp</script> values, we start by filling the entries for the last week and proceed backwards. At last, the value of <script type="math/tex; mode=display">dp[0][0]</script> gives the required result.</p>\n<p>The following animation illustrates the process of filling the <script type="math/tex; mode=display">dp</script> array.</p>\n<p>!?!../Documents/568_Maximum_Vacation_Days.json:1000,563!?!</p>\n<p>Below code is inspired by <a href="http://leetcode.com/hackerhuang">@hackerhuang</a></p>\n<iframe frameborder="0" height="343" name="hLAaTwUh" src="https://leetcode.com/playground/hLAaTwUh/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2k)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n*k</script> is filled and each cell filling takes O(n) time. Here <script type="math/tex; mode=display">n</script> represents the number of cities and <script type="math/tex; mode=display">k</script> is the total number of weeks.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n*k)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n*k</script> is used. </p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-1-d-dynamic-programming-accepted">Approach #4 Using 1-D Dynamic Programming [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>As can be observed in the previous approach, in order to update the <script type="math/tex; mode=display">dp</script> entries for <script type="math/tex; mode=display">i^{th}</script> week, we only need the values corresponding to <script type="math/tex; mode=display">(i+1)^{th}</script> week along with the <script type="math/tex; mode=display">days</script> and <script type="math/tex; mode=display">flights</script> array. Thus, instead of using a 2-D <script type="math/tex; mode=display">dp</script> array, we can omit the dimension corresponding to the weeks and make use of a 1-D <script type="math/tex; mode=display">dp</script> array. </p>\n<p>Now, <script type="math/tex; mode=display">dp[i]</script> is used to store the number of vacations that provided that we start from the <script type="math/tex; mode=display">i^{th}</script> city in the current week. The procedure remains the same as that of the previous approach, except that we make the updations in the same <script type="math/tex; mode=display">dp</script> row again and again. In order to store the <script type="math/tex; mode=display">dp</script> values corresponding to the current week temporarily, we make use of a <script type="math/tex; mode=display">temp</script> array so that the original <script type="math/tex; mode=display">dp</script> entries corresponding to <script type="math/tex; mode=display">week+1</script> aren\'t altered.</p>\n<iframe frameborder="0" height="394" name="6eAfgP4u" src="https://leetcode.com/playground/6eAfgP4u/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2k)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n*k</script> is filled and each cell filling takes O(n) time. Here <script type="math/tex; mode=display">n</script> represents the number of cities and <script type="math/tex; mode=display">k</script> is the total number of weeks.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(k)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">nk</script> is used. </p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '569',
    name: 'Median Employee Salary ',
    acceptance: '35.0%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nThe <code>Employee</code> table holds all employees. The employee table has three columns: Employee Id, Company Name, and Salary.</p>\n\n<pre>+-----+------------+--------+\n|Id   | Company    | Salary |\n+-----+------------+--------+\n|1    | A          | 2341   |\n|2    | A          | 341    |\n|3    | A          | 15     |\n|4    | A          | 15314  |\n|5    | A          | 451    |\n|6    | A          | 513    |\n|7    | B          | 15     |\n|8    | B          | 13     |\n|9    | B          | 1154   |\n|10   | B          | 1345   |\n|11   | B          | 1221   |\n|12   | B          | 234    |\n|13   | C          | 2345   |\n|14   | C          | 2645   |\n|15   | C          | 2645   |\n|16   | C          | 2652   |\n|17   | C          | 65     |\n+-----+------------+--------+\n</pre>\n\n<p>Write a SQL query to find the median salary of each company. Bonus points if you can solve it without using any built-in SQL functions.</p>\n\n<pre>+-----+------------+--------+\n|Id   | Company    | Salary |\n+-----+------------+--------+\n|5    | A          | 451    |\n|6    | A          | 513    |\n|12   | B          | 234    |\n|9    | B          | 1154   |\n|14   | C          | 2645   |\n+-----+------------+--------+\n</pre>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-the-definition-of-median-accepted">Approach #1: Using the definition of median [Accepted]</a></li>\n<li><a href="#approach-2-sort-and-then-select-the-median-accepted">Approach #2: Sort and then select the median [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-the-definition-of-median-accepted">Approach #1: Using the definition of <em>median</em> [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>By the definition of <em>median</em>, the count of the bigger numbers than itself should be equal to the count of the smaller ones in an <em>odd</em> array.</p>\n<p><strong>Algorithm</strong></p>\n<p>Take array [1,3,2] for example, is the first number 1 the median? No, because this array only have 3 elements but there are 2 of them (3, 2) are greater than 1. To continue, we know 3 is not the median as well since there are 2 elements smaller. But for the last element 2, there are equal amount of bigger and smaller numbers. So it is the median in this array!</p>\n<p>What if an array has <em>even</em> amount of distinct values, the median is the average of the middle <em>two elements</em> next to each other  after sorting this array.  It is not hard to understand that for either of these two elements, the difference (absolute value) of its bigger and smaller number than itself in this array is 1, which is the exactly frequency of a element in the distinct array.</p>\n<p>So in general, the median\'s frequency should be equal or grater than the absolute difference of its bigger elements and small ones in an array no matter whether it has odd or even amount of numbers and whether they are distinct. This rule is the key, and it is represented as the following code.</p>\n<div class="codehilite"><pre><span></span><span class="k">SUM</span><span class="p">(</span><span class="k">CASE</span>\n    <span class="k">WHEN</span> <span class="n">Employee</span><span class="p">.</span><span class="n">Salary</span> <span class="o">=</span> <span class="k">alias</span><span class="p">.</span><span class="n">Salary</span> <span class="k">THEN</span> <span class="mi">1</span>\n    <span class="k">ELSE</span> <span class="mi">0</span>\n<span class="k">END</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="k">ABS</span><span class="p">(</span><span class="k">SUM</span><span class="p">(</span><span class="n">SIGN</span><span class="p">(</span><span class="n">Employee</span><span class="p">.</span><span class="n">Salary</span> <span class="o">-</span> <span class="k">alias</span><span class="p">.</span><span class="n">Salary</span><span class="p">)))</span>\n</pre></div>\n<p>Thus, this approach is as following in MySQL code.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">Employee</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span> <span class="n">Employee</span><span class="p">.</span><span class="n">Company</span><span class="p">,</span> <span class="n">Employee</span><span class="p">.</span><span class="n">Salary</span>\n<span class="k">FROM</span>\n    <span class="n">Employee</span><span class="p">,</span>\n    <span class="n">Employee</span> <span class="k">alias</span>\n<span class="k">WHERE</span>\n    <span class="n">Employee</span><span class="p">.</span><span class="n">Company</span> <span class="o">=</span> <span class="k">alias</span><span class="p">.</span><span class="n">Company</span>\n<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">Employee</span><span class="p">.</span><span class="n">Company</span> <span class="p">,</span> <span class="n">Employee</span><span class="p">.</span><span class="n">Salary</span>\n<span class="k">HAVING</span> <span class="k">SUM</span><span class="p">(</span><span class="k">CASE</span>\n    <span class="k">WHEN</span> <span class="n">Employee</span><span class="p">.</span><span class="n">Salary</span> <span class="o">=</span> <span class="k">alias</span><span class="p">.</span><span class="n">Salary</span> <span class="k">THEN</span> <span class="mi">1</span>\n    <span class="k">ELSE</span> <span class="mi">0</span>\n<span class="k">END</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="k">ABS</span><span class="p">(</span><span class="k">SUM</span><span class="p">(</span><span class="n">SIGN</span><span class="p">(</span><span class="n">Employee</span><span class="p">.</span><span class="n">Salary</span> <span class="o">-</span> <span class="k">alias</span><span class="p">.</span><span class="n">Salary</span><span class="p">)))</span>\n<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">Employee</span><span class="p">.</span><span class="n">Id</span>\n<span class="p">;</span>\n</pre></div>\n<blockquote>\n<p>Note: In MySQL 5.6, this code runs fine, but if you are using MySQL 5.7+, please use <code>ANY_VALUE(Employee.Id)</code> instead of <code>Employee.Id</code> in the SELECT statement. Otherwise, you may encouter the following error message:\nError Code: 1055. Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column \'Employee.Id\' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by.\nFor more details on how to user <code>ANY_VALUE(arg)</code>, please refer to this <a href="https://dev.mysql.com/doc/refman/5.7/en/miscellaneous-functions.html#function_any-value">link</a>.</p>\n</blockquote>\n<hr>\n<h4 id="approach-2-sort-and-then-select-the-median-accepted">Approach #2: Sort and then select the <em>median</em> [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>In general, we can just pick the middle one(s) to get the <em>median</em> if the records are ranked by <strong>salary</strong>. But how can we get them sorted particularly MySQL does not have the build-in rank function, and these are several companies in this case.</p>\n<p><strong>Algorithm</strong></p>\n<p>By adding a virtual column to simulate the ranking, we can sort these records by <strong>salary</strong> and pick up the middle one(s). Here we need to use the session variable to achieve this goal.</p>\n<p>This approach is more efficient than the first one since it does not calculate all the <strong>salary</strong> one by one in the table.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> \n    <span class="n">Id</span><span class="p">,</span> <span class="n">Company</span><span class="p">,</span> <span class="n">Salary</span>\n<span class="k">FROM</span>\n    <span class="p">(</span><span class="k">SELECT</span> \n        <span class="n">e</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span>\n            <span class="n">e</span><span class="p">.</span><span class="n">Salary</span><span class="p">,</span>\n            <span class="n">e</span><span class="p">.</span><span class="n">Company</span><span class="p">,</span>\n            <span class="k">IF</span><span class="p">(</span><span class="o">@</span><span class="n">prev</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">Company</span><span class="p">,</span> <span class="o">@</span><span class="n">Rank</span><span class="p">:</span><span class="o">=@</span><span class="n">Rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">@</span><span class="n">Rank</span><span class="p">:</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">rank</span><span class="p">,</span>\n            <span class="o">@</span><span class="n">prev</span><span class="p">:</span><span class="o">=</span><span class="n">e</span><span class="p">.</span><span class="n">Company</span>\n    <span class="k">FROM</span>\n        <span class="n">Employee</span> <span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="k">SELECT</span> <span class="o">@</span><span class="n">Rank</span><span class="p">:</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">@</span><span class="n">prev</span><span class="p">:</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">AS</span> <span class="n">temp</span>\n    <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">e</span><span class="p">.</span><span class="n">Company</span> <span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">Salary</span> <span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">Id</span><span class="p">)</span> <span class="n">Ranking</span>\n        <span class="k">INNER</span> <span class="k">JOIN</span>\n    <span class="p">(</span><span class="k">SELECT</span> \n        <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">totalcount</span><span class="p">,</span> <span class="n">Company</span> <span class="k">AS</span> <span class="n">name</span>\n    <span class="k">FROM</span>\n        <span class="n">Employee</span> <span class="n">e2</span>\n    <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">e2</span><span class="p">.</span><span class="n">Company</span><span class="p">)</span> <span class="n">companycount</span> <span class="k">ON</span> <span class="n">companycount</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">Ranking</span><span class="p">.</span><span class="n">Company</span>\n<span class="k">WHERE</span>\n    <span class="n">Rank</span> <span class="o">=</span> <span class="n">FLOOR</span><span class="p">((</span><span class="n">totalcount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>\n        <span class="k">OR</span> <span class="n">Rank</span> <span class="o">=</span> <span class="n">FLOOR</span><span class="p">((</span><span class="n">totalcount</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '570',
    name: 'Managers with at Least 5 Direct Reports ',
    acceptance: '55.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>The <code>Employee</code> table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.</p>\n\n<pre>+------+----------+-----------+----------+\n|Id    |Name \t  |Department |ManagerId |\n+------+----------+-----------+----------+\n|101   |John \t  |A \t      |null      |\n|102   |Dan \t  |A \t      |101       |\n|103   |James \t  |A \t      |101       |\n|104   |Amy \t  |A \t      |101       |\n|105   |Anne \t  |A \t      |101       |\n|106   |Ron \t  |B \t      |101       |\n+------+----------+-----------+----------+\n</pre>\n\n<p>Given the <code>Employee</code> table, write a SQL query that finds out managers with at least 5 direct report. For the above table, your SQL query should return:\n</p>\n\n<pre>+-------+\n| Name  |\n+-------+\n| John  |\n+-------+\n</pre>\n\n<p><b>Note:</b><br>\nNo one would report to himself.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-join-and-a-temporary-table-accepted">Approach: Using JOIN and a temporary table [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-join-and-a-temporary-table-accepted">Approach: Using <code>JOIN</code> and a temporary table [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>First, we can get the Id of the manager having more than 5 direct reports just using this <em>ManagerId</em> column.</p>\n<p>Then, we can get the name of this manager by join that table with the <strong>Employee</strong> table.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">Name</span>\n<span class="k">FROM</span>\n    <span class="n">Employee</span> <span class="k">AS</span> <span class="n">t1</span> <span class="k">JOIN</span>\n    <span class="p">(</span><span class="k">SELECT</span>\n        <span class="n">ManagerId</span>\n    <span class="k">FROM</span>\n        <span class="n">Employee</span>\n    <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">ManagerId</span>\n    <span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">ManagerId</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="k">AS</span> <span class="n">t2</span>\n    <span class="k">ON</span> <span class="n">t1</span><span class="p">.</span><span class="n">Id</span> <span class="o">=</span> <span class="n">t2</span><span class="p">.</span><span class="n">ManagerId</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '571',
    name: 'Find Median Given Frequency of Numbers ',
    acceptance: '36.2%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nThe <code>Numbers</code> table keeps the value of number and its frequency.\n</p>\n<pre>+----------+-------------+\n|  Number  |  Frequency  |\n+----------+-------------|\n|  0       |  7          |\n|  1       |  1          |\n|  2       |  3          |\n|  3       |  1          |\n+----------+-------------+\n</pre>\n<p>\nIn this table, the numbers are <code>0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 3</code>, so the median is <code>(0 + 0) / 2 = 0</code>.\n</p>\n\n<pre>+--------+\n| median |\n+--------|\n| 0.0000 |\n+--------+\n</pre>\n\n<p>\nWrite a query to find the median of all numbers and name the result as <code>median</code>.\n</p>\n          ',
    solutionHtml: '\n            <br>\n            \n          ',
    tags: ['Pinterest'],
  },
  {
    id: '572',
    name: 'Subtree of Another Tree',
    acceptance: '40.7%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>\nGiven two non-empty binary trees <b>s</b> and <b>t</b>, check whether tree <b>t</b> has exactly the same structure and node values with a subtree of <b>s</b>. A subtree of <b>s</b> is a tree consists of a node in <b>s</b> and all of this node's descendants. The tree <b>s</b> could also be considered as a subtree of itself.\n</p>\n\n<p><b>Example 1:</b><br>\n\nGiven tree s:\n</p><pre>     3\n    / \\\n   4   5\n  / \\\n 1   2\n</pre>\nGiven tree t:\n<pre>   4 \n  / \\\n 1   2\n</pre>\nReturn <b>true</b>, because t has the same structure and node values with a subtree of s.\n<p></p>\n\n<p><b>Example 2:</b><br>\n\nGiven tree s:\n</p><pre>     3\n    / \\\n   4   5\n  / \\\n 1   2\n    /\n   0\n</pre>\nGiven tree t:\n<pre>   4\n  / \\\n 1   2\n</pre>\nReturn <b>false</b>.\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-preorder-traversal-accepted">Approach #1 Using Preorder Traversal [Accepted]</a></li>\n<li><a href="#approach-2-by-comparison-of-nodes-accepted">Approach #2 By Comparison of Nodes  [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-preorder-traversal-accepted">Approach #1 Using Preorder Traversal [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can find the preorder traversal of the given tree <script type="math/tex; mode=display">s</script> and <script type="math/tex; mode=display">t</script>, given by, say <script type="math/tex; mode=display">s_{preorder}</script> and <script type="math/tex; mode=display">t_{preorder}</script> respectively(represented in the form of a string). Now, we can check if <script type="math/tex; mode=display">t_{preorder}</script> is a substring of <script type="math/tex; mode=display">s_{preorder}</script>. </p>\n<p>But, in order to use this approach, we need to treat the given tree in a different manner. Rather than assuming a <script type="math/tex; mode=display">null</script> value for the childern of the leaf nodes, we need to treat the left and right child as a <script type="math/tex; mode=display">lnull</script> and <script type="math/tex; mode=display">rnull</script> value respectively. This is done to ensure that the <script type="math/tex; mode=display">t_{preorder}</script> doesn\'t become a substring of <script type="math/tex; mode=display">s_{preorder}</script> even in cases when <script type="math/tex; mode=display">t</script> isn\'t a subtree of <script type="math/tex; mode=display">s</script>. </p>\n<p>You can also note that we\'ve added a \'#\' before every considering every value. If this isn\'t done, the trees of the form <code>s:[23, 4, 5]</code> and <code>t:[3, 4, 5]</code> will also give a true result since the preorder string of the <code>t("23 4 lnull rull 5 lnull rnull")</code> will be a substring of the preorder string of <code>s("3 4 lnull rull 5 lnull rnull")</code>. Adding a \'#\' before the node\'s value solves this problem.</p>\n<p align="center"><img alt="Preorder_null" src="https://leetcode.com/articles/Figures/572_Subtree_1.PNG"></p>\n<p align="center"><img alt="Preorder_lnull_rnull" src="https://leetcode.com/articles/Figures/572_Subtree_2.PNG"></p>\n<iframe frameborder="0" height="513" name="cagXWqSv" src="https://leetcode.com/playground/cagXWqSv/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m^2+n^2+m*n)</script>. A total of <script type="math/tex; mode=display">n</script> nodes of the tree <script type="math/tex; mode=display">s</script> and <script type="math/tex; mode=display">m</script> nodes of tree <script type="math/tex; mode=display">t</script> are traversed. Assuming string concatenation takes <script type="math/tex; mode=display">O(k)</script> time for strings of length <script type="math/tex; mode=display">k</script> and <code>indexOf</code> takes <script type="math/tex; mode=display">O(m*n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(max(m,n))</script>. The depth of the recursion tree can go upto <script type="math/tex; mode=display">n</script> for tree <script type="math/tex; mode=display">t</script> and <script type="math/tex; mode=display">m</script> for tree <script type="math/tex; mode=display">s</script> in worst case.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-by-comparison-of-nodes-accepted">Approach #2 By Comparison of Nodes  [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of creating an inorder traversal, we can treat every node of the given tree <script type="math/tex; mode=display">t</script> as the root, treat it as a subtree and compare the corresponding subtree with the given subtree <script type="math/tex; mode=display">s</script> for equality. For checking the equality, we can compare the all the nodes of the two subtrees. </p>\n<p>For doing this, we make use a function <code>traverse(s,t)</code> which traverses over the given tree <script type="math/tex; mode=display">s</script> and treats every node as the root of the subtree currently being considered. It also checks the two subtrees currently being considered for their equality. In order to check the equality of the two subtrees, we make use of <code>equals(x,y)</code> function, which takes <script type="math/tex; mode=display">x</script> and <script type="math/tex; mode=display">y</script>, which are the roots of the two subtrees to be compared as the inputs and returns True or False depending on whether the two are equal or not. It compares all the nodes of the two subtrees for equality. Firstly, it checks whether the roots of the two trees for equality and then calls itself recursively for the left subtree and the right subtree.</p>\n<p>The follwowing animation depicts an abstracted view of the process:</p>\n<p>!?!../Documents/572_Subtree.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="A6ipy4aH" src="https://leetcode.com/playground/A6ipy4aH/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. In worst case(skewed tree) <code>traverse</code> function takes <script type="math/tex; mode=display">O(m*n)</script> time. </p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of the recursion tree can go upto <script type="math/tex; mode=display">n</script>. <script type="math/tex; mode=display">n</script> refers to the number of nodes in <script type="math/tex; mode=display">s</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Facebook', 'eBay'],
  },
  {
    id: '573',
    name: 'Squirrel Simulation ',
    acceptance: '52.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            There\'s a tree, a squirrel, and several nuts. Positions are represented by the cells in a 2D grid. Your goal is to find the <b>minimal</b> distance for the squirrel to collect all the nuts and put them under the tree one by one. The squirrel can only take at most <b>one nut</b> at one time and can move in four directions - up, down, left and right, to the adjacent cell. The distance is represented by the number of moves. \n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \nHeight : 5\nWidth : 7\nTree position : [2,2]\nSquirrel : [4,4]\nNuts : [[3,0], [2,5]]\n<b>Output:</b> 12\n<b>Explanation:</b>\n<img src="https://leetcode.com/static/images/problemset/squirrel_simulation.png" width="40%">\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>All given positions won\'t overlap.</li>\n<li>The squirrel can take at most one nut at one time.</li>\n<li>The given positions of nuts have no order.</li>\n<li>Height and width are positive integers. 3 &lt;= height * width &lt;= 10,000.</li>\n<li>The given positions contain at least one nut, only one tree and one squirrel.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-simple-solution-accepted">Approach #1 Simple Solution [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-simple-solution-accepted">Approach #1 Simple Solution [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We know, the distance between any two points(tree, squirrel, nut) is given by the absolute difference between the corresponding x-coordinates and the corresponding y-coordinates. </p>\n<p>Now, in order to determine the required minimum distance, we need to observe a few points. Firstly, the order in which the nuts are picked doesn\'t affect the final result, except one of the nuts which needs to be visited first from the squirrel\'s starting position. For the rest of the nuts, it is mandatory to go from the tree to the nut and then come back as well. </p>\n<p>For the first visited nut, the saving obtained, given by <script type="math/tex; mode=display">d</script>, is the difference between the distance between the tree and the current nut &amp; the distance between the current nut and the squirrel. This is because for this nut, we need not travel from the tree to the nut, but need to travel an additional distance from the squirrel\'s original position to the nut.</p>\n<p>While traversing over the <script type="math/tex; mode=display">nuts</script> array and adding the to-and-fro distance, we find out the saving, <script type="math/tex; mode=display">d</script>, which can be obtained if the squirrel goes to the current nut first. Out of all the nuts, we find out the nut which maximizes the saving and then deduct this maximum saving from the sum total of the to-and-fro distance of all the nuts.</p>\n<p>Note that the first nut to be picked needs not necessarily be the nut closest to the squirrel\'s start point, but it\'s the one which maximizes the savings.</p>\n<p align="center"><img alt="Squirrel_Nuts" src="https://leetcode.com/articles/Figures/573_Squirrel.PNG"></p>\n<iframe frameborder="0" height="309" name="ETPUcUyj" src="https://leetcode.com/playground/ETPUcUyj/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We need to traverse over the whole <script type="math/tex; mode=display">nuts</script> array once. <script type="math/tex; mode=display">n</script> refers to the size of <script type="math/tex; mode=display">nuts</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Square'],
  },
  {
    id: '574',
    name: 'Winning Candidate ',
    acceptance: '32.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Table: <code>Candidate</code></p>\n<pre>+-----+---------+\n| id  | Name    |\n+-----+---------+\n| 1   | A       |\n| 2   | B       |\n| 3   | C       |\n| 4   | D       |\n| 5   | E       |\n+-----+---------+  \n</pre>\n<p>Table: <code>Vote</code></p>\n<pre>+-----+--------------+\n| id  | CandidateId  |\n+-----+--------------+\n| 1   |     2        |\n| 2   |     4        |\n| 3   |     3        |\n| 4   |     2        |\n| 5   |     5        |\n+-----+--------------+\nid is the auto-increment primary key,\nCandidateId is the id appeared in Candidate table.\n</pre>\n\n<p>Write a sql to find the name of the winning candidate, the above example will return the winner <code>B</code>.</p>\n\n<pre>+------+\n| Name |\n+------+\n| B    |\n+------+\n</pre>\n\n<p><b>Notes:</b><br>\n</p><ol>\n<li>You may assume <b>there is no tie</b>, in other words there will be <b>at most one</b> winning candidate.</li>\n</ol><p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-join-and-a-temporary-table-accepted">Approach: Using JOIN and a temporary table [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-join-and-a-temporary-table-accepted">Approach: Using <code>JOIN</code> and a temporary table [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Query in the <strong>Vote</strong> table to get the winner\'s id and then join it with the <strong>Candidate</strong> table to get the name.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">name</span> <span class="k">AS</span> <span class="s1">\'Name\'</span>\n<span class="k">FROM</span>\n    <span class="n">Candidate</span>\n        <span class="k">JOIN</span>\n    <span class="p">(</span><span class="k">SELECT</span>\n        <span class="n">Candidateid</span>\n    <span class="k">FROM</span>\n        <span class="n">Vote</span>\n    <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">Candidateid</span>\n    <span class="k">ORDER</span> <span class="k">BY</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">DESC</span>\n    <span class="k">LIMIT</span> <span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">winner</span>\n<span class="k">WHERE</span>\n    <span class="n">Candidate</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">winner</span><span class="p">.</span><span class="n">Candidateid</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '575',
    name: 'Distribute Candies',
    acceptance: '58.4%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            Given an integer array with <b>even</b> length, where different numbers in this array represent different <b>kinds</b> of candies. Each number means one candy of the corresponding kind. You need to distribute these candies <b>equally</b> in number to brother and sister. Return the maximum number of <b>kinds</b> of candies the sister could gain. \n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> candies = [1,1,2,2,3,3]\n<b>Output:</b> 3\n<b>Explanation:</b>\nThere are three different kinds of candies (1, 2 and 3), and two candies for each kind.\nOptimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. \nThe sister has three different kinds of candies. \n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> candies = [1,1,2,3]\n<b>Output:</b> 2\n<b>Explanation:</b> For example, the sister has candies [2,3] and the brother has candies [1,1]. \nThe sister has two different kinds of candies, the brother has only one kind of candies. \n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><ol>\n<li>The length of the given array is in range [2, 10,000], and will be even.</li>\n<li>The number in given array is in range [-100,000, 100,000].</li>\n<ol>\n<p></p>\n          </ol></ol>',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]:</a></li>\n<li><a href="#approach-3-using-sortingaccepted">Approach #3  Using sorting[Accepted]</a></li>\n<li><a href="#approach-4-using-set-accepted">Approach #4 Using set [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The brute force approach is really simple. We can generate all the permutations of the given <script type="math/tex; mode=display">nums</script> array representing the candies and determine the number of unique elements in the first half of the generated array.</p>\n<p>In order to determine the number of unique elements in the first half of the array, we put all the required elements in a set and count the number of elements in the set. We count such unique elements in the first half of the generated arrays for all the permutations possible and return the size of the largest set.</p>\n<iframe frameborder="0" height="515" name="BjLCxvkM" src="https://leetcode.com/playground/BjLCxvkM/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n!)</script>. A total of <script type="math/tex; mode=display">n!</script> permutations are possible for <script type="math/tex; mode=display">nums</script> array of size <script type="math/tex; mode=display">n</script>. </p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of the recursion tree can go upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>Before looking into the idea behind this approach, firstly we need to observe one point. The maximum no. of unique candies which the girl can obtain could be atmost <script type="math/tex; mode=display">n/2</script>, where <script type="math/tex; mode=display">n</script> refers to the number of candies. Further, in case the number of unique candies are below <script type="math/tex; mode=display">n/2</script>, to maximize the number of unique candies that the girl will obtain, we\'ll assign all the unique candies to the girl. Thus, in such a case, the number of unique candies the girl gets is equal to the total number of unique candies in the given <script type="math/tex; mode=display">candies</script> array. </p>\n<p>Now, let\'s look at the idea behind this approach. We need to find the total number of unique candies in the given <script type="math/tex; mode=display">candies</script> array. One way to find the number of unique candies is to traverse over the given <script type="math/tex; mode=display">candies</script> array. Whenever we encounter an element, say <script type="math/tex; mode=display">candies[j]</script>, we can mark all the elements which are the same as <script type="math/tex; mode=display">candies[j]</script> as invalid and increment the count of unique elements by 1.</p>\n<p>Thus, we need to do such markings for all the elements of <script type="math/tex; mode=display">candies</script> array. At the end, <script type="math/tex; mode=display">count</script> gives the required number of unique candies that can be given to the girl. Further, the value to be returned is given by: <script type="math/tex; mode=display">\\text{min}(\\frac{n}{2}, count)</script>. Instead of finding the <script type="math/tex; mode=display">\\text{min}</script>, we can stop the traversal over the given <script type="math/tex; mode=display">candies</script> array as soon as the <script type="math/tex; mode=display">count</script> exceeds <script type="math/tex; mode=display">\\frac{n}{2}</script>. </p>\n<iframe frameborder="0" height="309" name="ttcdibF7" src="https://leetcode.com/playground/ttcdibF7/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. We traverse over all the elements of <script type="math/tex; mode=display">candies</script> for every new element found. In the worst case, we do so for every element of <script type="math/tex; mode=display">candies</script> array. <script type="math/tex; mode=display">n</script> refers to the size of <script type="math/tex; mode=display">candies</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-sortingaccepted">Approach #3  Using sorting[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can sort the given <script type="math/tex; mode=display">candies</script> array and find out the elements which are unique by comparing the adjacent elements of the sorted array. For every new element found(which isn\'t the same as the previous element), we need to update the <script type="math/tex; mode=display">count</script>. At the end, we can return the required result as <script type="math/tex; mode=display">\\text{min}(n/2, count)</script>, as discussed in the previous approach.</p>\n<iframe frameborder="0" height="224" name="757QK7we" src="https://leetcode.com/playground/757QK7we/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nlogn)</script>. Sorting takes <script type="math/tex; mode=display">O(nlogn)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-set-accepted">Approach #4 Using set [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Another way to find the number of unique elements is to traverse over all the elements of the given <script type="math/tex; mode=display">candies</script> array and keep on putting the elements in a set. By the property of a set, it will contain only unique elements. At the end, we can count the number of elements in the set, given by, say <script type="math/tex; mode=display">count</script>. The value to be returned will again be given by <script type="math/tex; mode=display">\\text{min}(count, n/2)</script>, as discussed in previous approaches. Here, <script type="math/tex; mode=display">n</script> refers to the size of the <script type="math/tex; mode=display">candies</script> array.</p>\n<iframe frameborder="0" height="224" name="ahWVHEov" src="https://leetcode.com/playground/ahWVHEov/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The entire <script type="math/tex; mode=display">candies</script> array is traversed only once. Here, <script type="math/tex; mode=display">n</script> refers to the size of <script type="math/tex; mode=display">candies</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">set</script> will be of size <script type="math/tex; mode=display">n</script> in the worst case.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['LiveRamp'],
  },
  {
    id: '576',
    name: 'Out of Boundary Paths',
    acceptance: '30.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>There is an <b>m</b> by <b>n</b> grid with a ball. Given the start coordinate <b>(i,j)</b> of the ball, you can move the ball to <b>adjacent</b> cell or cross the grid boundary in four directions (up, down, left, right). However, you can <b>at most</b> move <b>N</b> times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 10<sup>9</sup> + 7.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>m = 2, n = 2, N = 2, i = 0, j = 0\n<b>Output:</b> 6\n<b>Explanation:</b>\n<img src="https://leetcode.com/static/images/problemset/out_of_boundary_paths_1.png" width="40%">\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b>m = 1, n = 3, N = 3, i = 0, j = 1\n<b>Output:</b> 12\n<b>Explanation:</b>\n<img src="https://leetcode.com/static/images/problemset/out_of_boundary_paths_2.png" width="37%">\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>Once you move the ball out of boundary, you cannot move it back.</li>\n<li>The length and height of the grid is in range [1,50].</li>\n<li>N is in range [0,50].</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-recursion-with-memoization-accepted">Approach #2 Recursion with memoization [Accepted]</a></li>\n<li><a href="#approach-3-dynamic-programming-accepted">Approach #3 Dynamic Programming [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the brute force approach, we try to take one step in every direction and decrement the number of pending moves for each step taken. Whenever we reach out of the boundary while taking the steps, we deduce that one extra path is available to take the ball out. </p>\n<p>In order to implement the same, we make use of a recursive function <code>findPaths(m,n,N,i,j)</code> which takes the current number of moves(<script type="math/tex; mode=display">N</script>) along with the current position(<script type="math/tex; mode=display">(i,j)</script> as some of the parameters and returns the number of moves possible to take the ball out with the current pending moves from the current position. Now, we take a step in every direction and update the corresponding indices involved along with the current number of pending moves. </p>\n<p>Further, if we run out of moves at any moment, we return a 0 indicating that the current set of moves doesn\'t take the ball out of boundary.</p>\n<iframe frameborder="0" height="224" name="Q7b3GKsJ" src="https://leetcode.com/playground/Q7b3GKsJ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(4^n)</script>. Size of recursion tree will be <script type="math/tex; mode=display">4^n</script>. Here, <script type="math/tex; mode=display">n</script> refers to the number of moves allowed.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of the recursion tree can go upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-recursion-with-memoization-accepted">Approach #2 Recursion with memoization [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the brute force approach, while going through the various branches of the recursion tree, we could reach the same position with the same number of moves left. </p>\n<p>Thus, a lot of redundant function calls are made with the same set of parameters leading to a useless increase in runtime. We can remove this redundancy by making use of a memoization array, <script type="math/tex; mode=display">memo</script>. <script type="math/tex; mode=display">memo[i][j][k]</script> is used to store the number of possible moves leading to a path out of the boundary if the current position is given by the indices <script type="math/tex; mode=display">(i, j)</script> and number of moves left is <script type="math/tex; mode=display">k</script>. </p>\n<p>Thus, now if a function call with some parameters is repeated, the <script type="math/tex; mode=display">memo</script> array will already contain valid values corresponding to that function call resulting in pruning of the search space.</p>\n<iframe frameborder="0" height="411" name="o22neiZb" src="https://leetcode.com/playground/o22neiZb/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n*N)</script>. We need to fill the <script type="math/tex; mode=display">memo</script> array once with dimensions <script type="math/tex; mode=display">m</script>x<script type="math/tex; mode=display">n</script>x<script type="math/tex; mode=display">N</script>. Here, <script type="math/tex; mode=display">m</script>, <script type="math/tex; mode=display">n</script> refer to the number of rows and columns of the given grid respectively. <script type="math/tex; mode=display">N</script> refers to the total number of allowed moves.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m*n*N)</script>. <script type="math/tex; mode=display">memo</script> array of size <script type="math/tex; mode=display">m*n*N</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-dynamic-programming-accepted">Approach #3 Dynamic Programming [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The idea behind this approach is that if we can reach some position in <script type="math/tex; mode=display">x</script> moves, we can reach all its adjacent positions in <script type="math/tex; mode=display">x+1</script> moves. Based on this idea, we make use of a 2-D <script type="math/tex; mode=display">dp</script> array to store the number of ways in which a particular position can be reached. <script type="math/tex; mode=display">dp[i][j]</script> refers to the number of ways the position corresponding to the indices <script type="math/tex; mode=display">(i,j)</script> can be reached given some particular number of moves.</p>\n<p>Now, if the current <script type="math/tex; mode=display">dp</script> array stores the number of ways the various positions can be reached by making use of <script type="math/tex; mode=display">x-1</script> moves, in order to determine the number of ways the position <script type="math/tex; mode=display">(i,j)</script> can be reached by making use of <script type="math/tex; mode=display">x</script> moves, we need to update the corresponding <script type="math/tex; mode=display">dp</script> entry as <script type="math/tex; mode=display">dp[i][j] = dp[i-1][j] + dp[i+1][j] + dp[i][j-1] + dp[i][j+1]</script> taking care of boundary conditions. This happens because we can reach the index <script type="math/tex; mode=display">(i,j)</script> from any of the four adjacent positions and the total number of ways of reaching the index <script type="math/tex; mode=display">(i,j)</script> in <script type="math/tex; mode=display">x</script> moves is the sum of the ways of reaching the adjacent positions in <script type="math/tex; mode=display">x-1</script> moves. </p>\n<p>But, if we alter the <script type="math/tex; mode=display">dp</script> array, now some of the entries will correspond to <script type="math/tex; mode=display">x-1</script> moves and the updated ones will correspond to <script type="math/tex; mode=display">x</script> moves. Thus, we need to find a way to tackle this issue. So, instead of updating the <script type="math/tex; mode=display">dp</script> array for the current(<script type="math/tex; mode=display">x</script>) moves, we make use of a temporary 2-D array <script type="math/tex; mode=display">temp</script> to store the updated results for <script type="math/tex; mode=display">x</script> moves, making use of the results obtained for <script type="math/tex; mode=display">dp</script> array corresponding to <script type="math/tex; mode=display">x-1</script> moves. After all the entries for all the positions have been considered for <script type="math/tex; mode=display">x</script> moves, we update the <script type="math/tex; mode=display">dp</script> array based on <script type="math/tex; mode=display">temp</script>. Thus, <script type="math/tex; mode=display">dp</script> now contains the entries corresponding to <script type="math/tex; mode=display">x</script> moves.</p>\n<p>Thus, we start off by considering zero move available for which we make an initial entry of <script type="math/tex; mode=display">dp[x][y] = 1</script>(<script type="math/tex; mode=display">(x,y)</script> is the initial position), since we can reach only this position in zero move. Then, we increase the number of moves to 1 and update all the <script type="math/tex; mode=display">dp</script> entries appropriately. We do so for all the moves possible from 1 to N. </p>\n<p>In order to update <script type="math/tex; mode=display">count</script>, which indicates the total number of possible moves which lead an out of boundary path, we need to perform the update only when we reach the boundary. We update the count as <script type="math/tex; mode=display">count = count + dp[i][j]</script>, where <script type="math/tex; mode=display">(i,j)</script> corresponds to one of the boundaries. But, if <script type="math/tex; mode=display">(i,j)</script> is simultaneously a part of multiple boundaries, we need to add the <script type="math/tex; mode=display">dp[i][j]</script> factor multiple times(same as the number of boundaries to which <script type="math/tex; mode=display">(i,j)</script> belongs).</p>\n<p>After we are done with all the <script type="math/tex; mode=display">N</script> moves, <script type="math/tex; mode=display">count</script> gives the required result.</p>\n<p>The following animation illustrates the process:</p>\n<p>!?!../Documents/576_Boundary_Paths.json:1000,563!?!</p>\n<iframe frameborder="0" height="513" name="MvuV89Mf" src="https://leetcode.com/playground/MvuV89Mf/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(N*m*n)</script>. We need to fill the <script type="math/tex; mode=display">dp</script>$ array with dimensions <script type="math/tex; mode=display">m</script>x<script type="math/tex; mode=display">n</script>\n<script type="math/tex; mode=display">N</script> times. Here <script type="math/tex; mode=display">m</script>x<script type="math/tex; mode=display">n</script> refers to the size of the grid and <script type="math/tex; mode=display">N</script> refers to the number of moves available.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m*n)</script>. <script type="math/tex; mode=display">dp</script> and <script type="math/tex; mode=display">temp</script> array of size <script type="math/tex; mode=display">m</script>x<script type="math/tex; mode=display">n</script> are used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Baidu'],
  },
  {
    id: '577',
    name: 'Employee Bonus ',
    acceptance: '50.0%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>\nSelect all employee's name and bonus whose bonus is &lt; 1000.\n</p>\n<p>\nTable:<code>Employee </code>\n</p>\n\n<pre>+-------+--------+-----------+--------+\n| empId |  name  | supervisor| salary |\n+-------+--------+-----------+--------+\n|   1   | John   |  3        | 1000   |\n|   2   | Dan    |  3        | 2000   |\n|   3   | Brad   |  null     | 4000   |\n|   4   | Thomas |  3        | 4000   |\n+-------+--------+-----------+--------+\nempId is the primary key column for this table.\n</pre>\n\n<p>\nTable: <code>Bonus</code></p>\n<pre>+-------+-------+\n| empId | bonus |\n+-------+-------+\n| 2     | 500   |\n| 4     | 2000  |\n+-------+-------+\nempId is the primary key column for this table.\n</pre>\n<p>\nExample ouput: \n</p>\n<pre>+-------+-------+\n| name  | bonus |\n+-------+-------+\n| John  | null  |\n| Dan   | 500   |\n| Brad  | null  |\n+-------+-------+\n</pre>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-outer-join-and-where-clause-accepted">Approach: Using OUTER JOIN and WHERE clause [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-outer-join-and-where-clause-accepted">Approach: Using <code>OUTER JOIN</code> and <code>WHERE</code> clause [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Join table <strong>Employee</strong> with <strong>Bonus</strong> and then use <code>WHERE</code> clause to get the required records.</p>\n<p><strong>Algorithm</strong></p>\n<p>Since foreign key <strong>Bonus.empId</strong> refers to <strong>Employee.empId</strong> and some employees do not have bonus records, we can use <code>OUTER JOIN</code> to link these two tables as the first step.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">Employee</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">Bonus</span><span class="p">.</span><span class="n">bonus</span>\n<span class="k">FROM</span>\n    <span class="n">Employee</span>\n        <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span>\n    <span class="n">Bonus</span> <span class="k">ON</span> <span class="n">Employee</span><span class="p">.</span><span class="n">empid</span> <span class="o">=</span> <span class="n">Bonus</span><span class="p">.</span><span class="n">empid</span>\n<span class="p">;</span>\n</pre></div>\n<blockquote>\n<p>Note: "LEFT OUTER JOIN" could be written as "LEFT JOIN".</p>\n</blockquote>\n<p>The output to run this code with the sample data is as below.</p>\n<div class="codehilite"><pre><span></span>| name   | bonus |\n|--------|-------|\n| Dan    | 500   |\n| Thomas | 2000  |\n| Brad   |       |\n| John   |       |\n</pre></div>\n<p>The bonus value for \'Brad\' and \'John\' is empty, which is actually <code>NULL</code> in the database. "Conceptually, NULL means “a missing unknown value” and it is treated somewhat differently from other values." Check the <a href="https://dev.mysql.com/doc/refman/5.7/en/working-with-null.html">Working with NULL Values</a> in MySQL manual for more details. In addition, we have to use <code>IS NULL</code> or <code>IS NOT NULL</code> to compare a value with <code>NULL</code>.</p>\n<p>At last, we can add a <code>WHERE</code> clause with the proper conditions to filter these records.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">Employee</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">Bonus</span><span class="p">.</span><span class="n">bonus</span>\n<span class="k">FROM</span>\n    <span class="n">Employee</span>\n        <span class="k">LEFT</span> <span class="k">JOIN</span>\n    <span class="n">Bonus</span> <span class="k">ON</span> <span class="n">Employee</span><span class="p">.</span><span class="n">empid</span> <span class="o">=</span> <span class="n">Bonus</span><span class="p">.</span><span class="n">empid</span>\n<span class="k">WHERE</span>\n    <span class="n">bonus</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="k">OR</span> <span class="n">bonus</span> <span class="k">IS</span> <span class="k">NULL</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: ['Netsuite'],
  },
  {
    id: '578',
    name: 'Get Highest Answer Rate Question ',
    acceptance: '28.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGet the highest answer rate question from a table <code>survey_log</code> with these columns:\n<b>uid</b>, <b>action</b>, <b>question_id</b>, <b>answer_id</b>, <b>q_num</b>, <b>timestamp</b>.\n</p>\n\n<p>\nuid means user id; action has these kind of values: "show", "answer", "skip";\nanswer_id is not null when action column is "answer", while is null for "show" and "skip";\nq_num is the numeral order of the question in current session.\n</p>\n\n<p>Write a sql query to identify the question which has the highest answer rate.</p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b>\n+------+-----------+--------------+------------+-----------+------------+\n| uid  | action    | question_id  | answer_id  | q_num     | timestamp  |\n+------+-----------+--------------+------------+-----------+------------+\n| 5    | show      | 285          | null       | 1         | 123        |\n| 5    | answer    | 285          | 124124     | 1         | 124        |\n| 5    | show      | 369          | null       | 2         | 125        |\n| 5    | skip      | 369          | null       | 2         | 126        |\n+------+-----------+--------------+------------+-----------+------------+\n<b>Output:</b>\n+-------------+\n| survey_log  |\n+-------------+\n|    285      |\n+-------------+\n<b>Explanation:</b>\nquestion 285 has answer rate 1/1, while question 369 has 0/1 answer rate, so output 285.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\nThe highest answer rate meaning is: answer number\'s ratio in show number in the same question.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-i-using-sub-query-and-sum-function-accepted">Approach I: Using sub-query and SUM() function [Accepted]</a></li>\n<li><a href="#approach-ii-using-sub-query-and-countif-function-accepted">Approach II: Using sub-query and COUNT(IF...) function [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-i-using-sub-query-and-sum-function-accepted">Approach I: Using sub-query and <code>SUM()</code> function [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Calculate the answered times / show times for each question.</p>\n<p><strong>Algorithm</strong></p>\n<p>First, we can use <code>SUM()</code> to get the total number of answered times as well as the show times for each question using a sub-query as below.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">question_id</span><span class="p">,</span>\n    <span class="k">SUM</span><span class="p">(</span><span class="k">CASE</span>\n        <span class="k">WHEN</span> <span class="n">action</span> <span class="o">=</span> <span class="s1">\'answer\'</span> <span class="k">THEN</span> <span class="mi">1</span>\n        <span class="k">ELSE</span> <span class="mi">0</span>\n    <span class="k">END</span><span class="p">)</span> <span class="k">AS</span> <span class="n">num_answer</span><span class="p">,</span>\n    <span class="k">SUM</span><span class="p">(</span><span class="k">CASE</span>\n        <span class="k">WHEN</span> <span class="n">action</span> <span class="o">=</span> <span class="s1">\'show\'</span> <span class="k">THEN</span> <span class="mi">1</span>\n        <span class="k">ELSE</span> <span class="mi">0</span>\n    <span class="k">END</span><span class="p">)</span> <span class="k">AS</span> <span class="n">num_show</span>\n<span class="k">FROM</span>\n    <span class="n">survey_log</span>\n<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">question_id</span>\n<span class="p">;</span>\n</pre></div>\n<div class="codehilite"><pre><span></span>| question_id | num_answer | num_show |\n|-------------|------------|----------|\n| 285         | 1          | 1        |\n| 369         | 0          | 1        |\n</pre></div>\n<p>Then we can calculate the answer rate by its definition.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="n">question_id</span> <span class="k">as</span> <span class="n">survey_log</span>\n<span class="k">FROM</span>\n<span class="p">(</span>\n    <span class="k">SELECT</span> <span class="n">question_id</span><span class="p">,</span>\n         <span class="k">SUM</span><span class="p">(</span><span class="k">case</span> <span class="k">when</span> <span class="n">action</span><span class="o">=</span><span class="ss">"answer"</span> <span class="k">THEN</span> <span class="mi">1</span> <span class="k">ELSE</span> <span class="mi">0</span> <span class="k">END</span><span class="p">)</span> <span class="k">as</span> <span class="n">num_answer</span><span class="p">,</span>\n        <span class="k">SUM</span><span class="p">(</span><span class="k">case</span> <span class="k">when</span> <span class="n">action</span><span class="o">=</span><span class="ss">"show"</span> <span class="k">THEN</span> <span class="mi">1</span> <span class="k">ELSE</span> <span class="mi">0</span> <span class="k">END</span><span class="p">)</span> <span class="k">as</span> <span class="n">num_show</span><span class="p">,</span>    \n    <span class="k">FROM</span> <span class="n">survey_log</span>\n    <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">question_id</span>\n<span class="p">)</span> <span class="k">as</span> <span class="n">tbl</span>\n<span class="k">ORDER</span> <span class="k">BY</span> <span class="p">(</span><span class="n">num_answer</span> <span class="o">/</span> <span class="n">num_show</span><span class="p">)</span> <span class="k">DESC</span>\n<span class="k">LIMIT</span> <span class="mi">1</span>\n</pre></div>\n<h4 id="approach-ii-using-sub-query-and-countif-function-accepted">Approach II: Using sub-query and <code>COUNT(IF...)</code> function [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This solution is very straight forward: use the <code>COUNT()</code> function to sum the answer and show time combining with the <code>IF()</code> function.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> \n    <span class="n">question_id</span> <span class="k">AS</span> <span class="s1">\'survey_log\'</span>\n<span class="k">FROM</span>\n    <span class="n">survey_log</span>\n<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">question_id</span>\n<span class="k">ORDER</span> <span class="k">BY</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">answer_id</span><span class="p">)</span> <span class="o">/</span> <span class="k">COUNT</span><span class="p">(</span><span class="k">IF</span><span class="p">(</span><span class="n">action</span> <span class="o">=</span> <span class="s1">\'show\'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">DESC</span>\n<span class="k">LIMIT</span> <span class="mi">1</span><span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '579',
    name: 'Find Cumulative Salary of an Employee ',
    acceptance: '27.2%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>The <b>Employee</b> table holds the salary information in a year.</p>\n\n<p>Write a SQL to get the cumulative sum of an employee's salary over a period of 3 months but exclude the most recent month.</p>\n\n<p>The result should be displayed by 'Id' ascending, and then by 'Month' descending.</p> \n\n<p><b>Example</b><br>\n<b>Input</b>\n</p><pre>| Id | Month | Salary |\n|----|-------|--------|\n| 1  | 1     | 20     |\n| 2  | 1     | 20     |\n| 1  | 2     | 30     |\n| 2  | 2     | 30     |\n| 3  | 2     | 40     |\n| 1  | 3     | 40     |\n| 3  | 3     | 60     |\n| 1  | 4     | 60     |\n| 3  | 4     | 70     |\n</pre>\n\n<b>Output</b>\n<pre>\n| Id | Month | Salary |\n|----|-------|--------|\n| 1  | 3     | 90     |\n| 1  | 2     | 50     |\n| 1  | 1     | 20     |\n| 2  | 1     | 20     |\n| 3  | 3     | 100    |\n| 3  | 2     | 40     |\n</pre>\n<p></p>\n\n<b>Explanation</b>\n<p>Employee '1' has 3 salary records for the following 3 months except the most recent month '4': salary 40 for month '3', 30 for month '2' and 20 for month '1'<br>\nSo the cumulative sum of salary of this employee over 3 months is 90(40+30+20), 50(30+20) and 20 respectively.</p> \n<pre>| Id | Month | Salary |\n|----|-------|--------|\n| 1  | 3     | 90     |\n| 1  | 2     | 50     |\n| 1  | 1     | 20     |\n</pre>\n\nEmployee '2' only has one salary record (month '1') except its most recent month '2'.\n<pre>| Id | Month | Salary |\n|----|-------|--------|\n| 2  | 1     | 20     |\n</pre><p></p>\nEmploy '3' has two salary records except its most recent pay month '4': month '3' with 60 and month '2' with 40. So the cumulative salary is as following.\n<pre>| Id | Month | Salary |\n|----|-------|--------|\n| 3  | 3     | 100    |\n| 3  | 2     | 40     |\n</pre><p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-outer-join-and-temporary-tables-accepted">Approach: Using OUTER JOIN and temporary tables [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-outer-join-and-temporary-tables-accepted">Approach: Using <code>OUTER JOIN</code> and temporary tables [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Solve this issue by two steps. The first one is to get the cumulative sum of an employee\'s salary over a period of 3 months, and then exclude the most recent month from the result.</p>\n<p><strong>Algorithm</strong></p>\n<p>If you feel hard to work out how to get the cumulative sum of an employee\'s salary over a period of 3 months, think about 2 months as a start. By joining this <strong>Employee</strong> table with itself, you can get salary information for one more month.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="o">*</span>\n<span class="k">FROM</span>\n    <span class="n">Employee</span> <span class="n">E1</span>\n        <span class="k">LEFT</span> <span class="k">JOIN</span>\n    <span class="n">Employee</span> <span class="n">E2</span> <span class="k">ON</span> <span class="p">(</span><span class="n">E2</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">E1</span><span class="p">.</span><span class="n">id</span>\n        <span class="k">AND</span> <span class="n">E2</span><span class="p">.</span><span class="k">month</span> <span class="o">=</span> <span class="n">E1</span><span class="p">.</span><span class="k">month</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>\n<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">E1</span><span class="p">.</span><span class="n">id</span> <span class="k">ASC</span> <span class="p">,</span> <span class="n">E1</span><span class="p">.</span> <span class="k">month</span> <span class="k">DESC</span>\n</pre></div>\n<table>\n<thead>\n<tr>\n<th>Id</th>\n<th>Month</th>\n<th>Salary</th>\n<th>Id</th>\n<th>Month</th>\n<th>Salary</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>4</td>\n<td>60</td>\n<td>1</td>\n<td>3</td>\n<td>40</td>\n</tr>\n<tr>\n<td>1</td>\n<td>3</td>\n<td>40</td>\n<td>1</td>\n<td>2</td>\n<td>30</td>\n</tr>\n<tr>\n<td>1</td>\n<td>2</td>\n<td>30</td>\n<td>1</td>\n<td>1</td>\n<td>20</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>20</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>2</td>\n<td>30</td>\n<td>2</td>\n<td>1</td>\n<td>20</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1</td>\n<td>20</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>4</td>\n<td>70</td>\n<td>3</td>\n<td>3</td>\n<td>60</td>\n</tr>\n<tr>\n<td>3</td>\n<td>3</td>\n<td>60</td>\n<td>3</td>\n<td>2</td>\n<td>40</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2</td>\n<td>40</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>&gt;Note:</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>&gt; - The blank value in the output is actually <code>NULL</code> in the database.</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>&gt; - The first three columns are from E1, and the rest ones are from E2.</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>Then we can add the salary to get the cumulative sum for 2 months.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">E1</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>\n    <span class="n">E1</span><span class="p">.</span><span class="k">month</span><span class="p">,</span>\n    <span class="p">(</span><span class="n">IFNULL</span><span class="p">(</span><span class="n">E1</span><span class="p">.</span><span class="n">salary</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">IFNULL</span><span class="p">(</span><span class="n">E2</span><span class="p">.</span><span class="n">salary</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">AS</span> <span class="n">Salary</span>\n<span class="k">FROM</span>\n    <span class="n">Employee</span> <span class="n">E1</span>\n        <span class="k">LEFT</span> <span class="k">JOIN</span>\n    <span class="n">Employee</span> <span class="n">E2</span> <span class="k">ON</span> <span class="p">(</span><span class="n">E2</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">E1</span><span class="p">.</span><span class="n">id</span>\n        <span class="k">AND</span> <span class="n">E2</span><span class="p">.</span><span class="k">month</span> <span class="o">=</span> <span class="n">E1</span><span class="p">.</span><span class="k">month</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>\n<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">E1</span><span class="p">.</span><span class="n">id</span> <span class="k">ASC</span> <span class="p">,</span> <span class="n">E1</span><span class="p">.</span><span class="k">month</span> <span class="k">DESC</span>\n</pre></div>\n<div class="codehilite"><pre><span></span>| id | month | Salary |\n|----|-------|--------|\n| 1  | 4     | 100    |\n| 1  | 3     | 70     |\n| 1  | 2     | 50     |\n| 1  | 1     | 20     |\n| 2  | 2     | 50     |\n| 2  | 1     | 20     |\n| 3  | 4     | 130    |\n| 3  | 3     | 100    |\n| 3  | 2     | 40     |\n</pre></div>\n<p>Similarly, you can join this table one more time to get the cumulative sum for 3 months.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">E1</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>\n    <span class="n">E1</span><span class="p">.</span><span class="k">month</span><span class="p">,</span>\n    <span class="p">(</span><span class="n">IFNULL</span><span class="p">(</span><span class="n">E1</span><span class="p">.</span><span class="n">salary</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">IFNULL</span><span class="p">(</span><span class="n">E2</span><span class="p">.</span><span class="n">salary</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">IFNULL</span><span class="p">(</span><span class="n">E3</span><span class="p">.</span><span class="n">salary</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">AS</span> <span class="n">Salary</span>\n<span class="k">FROM</span>\n    <span class="n">Employee</span> <span class="n">E1</span>\n        <span class="k">LEFT</span> <span class="k">JOIN</span>\n    <span class="n">Employee</span> <span class="n">E2</span> <span class="k">ON</span> <span class="p">(</span><span class="n">E2</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">E1</span><span class="p">.</span><span class="n">id</span>\n        <span class="k">AND</span> <span class="n">E2</span><span class="p">.</span><span class="k">month</span> <span class="o">=</span> <span class="n">E1</span><span class="p">.</span><span class="k">month</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>\n        <span class="k">LEFT</span> <span class="k">JOIN</span>\n    <span class="n">Employee</span> <span class="n">E3</span> <span class="k">ON</span> <span class="p">(</span><span class="n">E3</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">E1</span><span class="p">.</span><span class="n">id</span>\n        <span class="k">AND</span> <span class="n">E3</span><span class="p">.</span><span class="k">month</span> <span class="o">=</span> <span class="n">E1</span><span class="p">.</span><span class="k">month</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>\n<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">E1</span><span class="p">.</span><span class="n">id</span> <span class="k">ASC</span> <span class="p">,</span> <span class="n">E1</span><span class="p">.</span><span class="k">month</span> <span class="k">DESC</span>\n<span class="p">;</span>\n</pre></div>\n<div class="codehilite"><pre><span></span>| id | month | Salary |\n|----|-------|--------|\n| 1  | 4     | 130    |\n| 1  | 3     | 90     |\n| 1  | 2     | 50     |\n| 1  | 1     | 20     |\n| 2  | 2     | 50     |\n| 2  | 1     | 20     |\n| 3  | 4     | 170    |\n| 3  | 3     | 100    |\n| 3  | 2     | 40     |\n</pre></div>\n<p>In addition, we have to exclude the most recent month as required. If we have a temp table including every id and most recent month like below, then we can easily opt out these months by join it with the above table.</p>\n<div class="codehilite"><pre><span></span>| id | month |\n|----|-------|\n| 1  | 4     |\n| 2  | 2     |\n| 3  | 4     |\n</pre></div>\n<p>Here is the code to generate this table.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">id</span><span class="p">,</span> <span class="k">MAX</span><span class="p">(</span><span class="k">month</span><span class="p">)</span> <span class="k">AS</span> <span class="k">month</span>\n<span class="k">FROM</span>\n    <span class="n">Employee</span>\n<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">id</span>\n<span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>\n<span class="p">;</span>\n</pre></div>\n<p>At last, we can join them together and get the desired cumulative sum of an employee\'s salary over a period of 3 months excluding the most recent one.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">E1</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>\n    <span class="n">E1</span><span class="p">.</span><span class="k">month</span><span class="p">,</span>\n    <span class="p">(</span><span class="n">IFNULL</span><span class="p">(</span><span class="n">E1</span><span class="p">.</span><span class="n">salary</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">IFNULL</span><span class="p">(</span><span class="n">E2</span><span class="p">.</span><span class="n">salary</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">IFNULL</span><span class="p">(</span><span class="n">E3</span><span class="p">.</span><span class="n">salary</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">AS</span> <span class="n">Salary</span>\n<span class="k">FROM</span>\n    <span class="p">(</span><span class="k">SELECT</span>\n        <span class="n">id</span><span class="p">,</span> <span class="k">MAX</span><span class="p">(</span><span class="k">month</span><span class="p">)</span> <span class="k">AS</span> <span class="k">month</span>\n    <span class="k">FROM</span>\n        <span class="n">Employee</span>\n    <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">id</span>\n    <span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">maxmonth</span>\n        <span class="k">LEFT</span> <span class="k">JOIN</span>\n    <span class="n">Employee</span> <span class="n">E1</span> <span class="k">ON</span> <span class="p">(</span><span class="n">maxmonth</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">E1</span><span class="p">.</span><span class="n">id</span>\n        <span class="k">AND</span> <span class="n">maxmonth</span><span class="p">.</span><span class="k">month</span> <span class="o">&gt;</span> <span class="n">E1</span><span class="p">.</span><span class="k">month</span><span class="p">)</span>\n        <span class="k">LEFT</span> <span class="k">JOIN</span>\n    <span class="n">Employee</span> <span class="n">E2</span> <span class="k">ON</span> <span class="p">(</span><span class="n">E2</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">E1</span><span class="p">.</span><span class="n">id</span>\n        <span class="k">AND</span> <span class="n">E2</span><span class="p">.</span><span class="k">month</span> <span class="o">=</span> <span class="n">E1</span><span class="p">.</span><span class="k">month</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>\n        <span class="k">LEFT</span> <span class="k">JOIN</span>\n    <span class="n">Employee</span> <span class="n">E3</span> <span class="k">ON</span> <span class="p">(</span><span class="n">E3</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">E1</span><span class="p">.</span><span class="n">id</span>\n        <span class="k">AND</span> <span class="n">E3</span><span class="p">.</span><span class="k">month</span> <span class="o">=</span> <span class="n">E1</span><span class="p">.</span><span class="k">month</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>\n<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">id</span> <span class="k">ASC</span> <span class="p">,</span> <span class="k">month</span> <span class="k">DESC</span>\n<span class="p">;</span>\n</pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>month</th>\n<th>Salary</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>3</td>\n<td>90</td>\n</tr>\n<tr>\n<td>1</td>\n<td>2</td>\n<td>50</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>20</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1</td>\n<td>20</td>\n</tr>\n<tr>\n<td>3</td>\n<td>3</td>\n<td>100</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2</td>\n<td>40</td>\n</tr>\n</tbody>\n</table>\n<p>Note: Thank <a href="https://discuss.leetcode.com/user/xiaxin">@xiaxin</a> for providing this elegant solution.</p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '580',
    name: 'Count Student Number in Departments ',
    acceptance: '38.5%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>A university uses 2 data tables, <b><i>student</i></b> and <b><i>department</i></b>, to store data about its students and the departments associated with each major. </p>\n\n<p>Write a query to print the respective department name and number of students majoring in each department for all departments in the <b><i>department</i></b> table (even ones with no current students).</p>\n\n<p>Sort your results by descending number of students; if two or more departments have the same number of students, then sort those departments alphabetically by department name.</p>\n\n<p>The <b><i>student</i></b> is described as follow:</p>\n\n<pre>| Column Name  | Type      |\n|--------------|-----------|\n| student_id   | Integer   |\n| student_name | String    |\n| gender       | Character |\n| dept_id      | Integer   |\n</pre>\n\n<p>where student_id is the student's ID number, student_name is the student's name, gender is their gender, and dept_id is the department ID associated with their declared major.</p>\n\n<p>And the <b><i>department</i></b> table is described as below:</p>\n<pre>| Column Name | Type    |\n|-------------|---------|\n| dept_id     | Integer |\n| dept_name   | String  |\n</pre>\n\n<p>where dept_id is the department's ID number and dept_name is the department name.</p>\n\n<p>Here is an example <b>input</b>:<br>\n\n<b><i>student</i></b> table:</p>\n\n<pre>| student_id | student_name | gender | dept_id |\n|------------|--------------|--------|---------|\n| 1          | Jack         | M      | 1       |\n| 2          | Jane         | F      | 1       |\n| 3          | Mark         | M      | 2       |\n</pre>\n\n<p><b><i>department</i></b> table:</p>\n<pre>| dept_id | dept_name   |\n|---------|-------------|\n| 1       | Engineering |\n| 2       | Science     |\n| 3       | Law         |\n</pre>\n\n<p>The <b>Output</b> should be:</p>\n<pre>| dept_name   | student_number |\n|-------------|----------------|\n| Engineering | 2              |\n| Science     | 1              |\n| Law         | 0              |\n</pre>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-outer-join-and-countexpression-accepted">Approach: Using OUTER JOIN and COUNT(expression) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-outer-join-and-countexpression-accepted">Approach: Using <code>OUTER JOIN</code> and <code>COUNT(expression)</code> [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Use <code>GROUP BY</code> function can measure student number in a department, and then use <code>COUNT</code> function to count the number of records of each department.</p>\n<p><strong>Algorithm</strong></p>\n<p>We can use <code>OUTER JOIN</code> to query all departments. The problem is to display \'0\' for departments without no current students. Some people will write the following query using <code>COUNT(*)</code>.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">dept_name</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">student_number</span>\n<span class="k">FROM</span>\n    <span class="n">department</span>\n        <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span>\n    <span class="n">student</span> <span class="k">ON</span> <span class="n">department</span><span class="p">.</span><span class="n">dept_id</span> <span class="o">=</span> <span class="n">student</span><span class="p">.</span><span class="n">dept_id</span>\n<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">department</span><span class="p">.</span><span class="n">dept_name</span>\n<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">student_number</span> <span class="k">DESC</span> <span class="p">,</span> <span class="n">department</span><span class="p">.</span><span class="n">dept_name</span>\n<span class="p">;</span>\n</pre></div>\n<p>Unfortunately, it wrongly displays \'1\' for departments like \'Law\' without current students for the sample input.</p>\n<div class="codehilite"><pre><span></span>| dept_name   | student_number |\n|-------------|----------------|\n| Engineering | 2              |\n| Law         | 1              |\n| Science     | 1              |\n</pre></div>\n<p>Instead, <code>COUNT(expression)</code> could be used because it does not take account if <code>expression is null</code>. You can refer to the <a href="https://dev.mysql.com/doc/refman/5.7/en/counting-rows.html">MySQL manual</a> for the details.</p>\n<p>Thus, here is a right solution after fixing the issue above.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">dept_name</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">student_id</span><span class="p">)</span> <span class="k">AS</span> <span class="n">student_number</span>\n<span class="k">FROM</span>\n    <span class="n">department</span>\n        <span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span>\n    <span class="n">student</span> <span class="k">ON</span> <span class="n">department</span><span class="p">.</span><span class="n">dept_id</span> <span class="o">=</span> <span class="n">student</span><span class="p">.</span><span class="n">dept_id</span>\n<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">department</span><span class="p">.</span><span class="n">dept_name</span>\n<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">student_number</span> <span class="k">DESC</span> <span class="p">,</span> <span class="n">department</span><span class="p">.</span><span class="n">dept_name</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: ['Twitter'],
  },
  {
    id: '581',
    name: 'Shortest Unsorted Continuous Subarray',
    acceptance: '29.3%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given an integer array, you need to find one <b>continuous subarray</b> that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too. </p> \n\n<p>You need to find the <b>shortest</b> such subarray and output its length.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [2, 6, 4, 8, 10, 9, 15]\n<b>Output:</b> 5\n<b>Explanation:</b> You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>Then length of the input array is in range [1, 10,000].</li>\n<li>The input array may contain duplicates, so ascending order here means <b>&lt;=</b>. </li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-using-sorting-accepted">Approach #3 Using Sorting [Accepted]</a></li>\n<li><a href="#approach-4-using-stack-accepted">Approach #4 Using Stack [Accepted]:</a></li>\n<li><a href="#approach-5-without-using-extra-space-accepted">Approach #5 Without Using Extra Space [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the brute force approach, we consider every possible subarray that can be formed from the given array <script type="math/tex; mode=display">nums</script>. For every subarray <script type="math/tex; mode=display">nums[i:j]</script> considered, we need to check whether this is the smallest unsorted subarray or not. Thus, for every such subarray considered, we find out the maximum and minimum values lying in that subarray given by <script type="math/tex; mode=display">max</script> and <script type="math/tex; mode=display">min</script> respectively.</p>\n<p>If the subarrays <script type="math/tex; mode=display">nums[0:i-1]</script> and <script type="math/tex; mode=display">nums[j:n-1]</script> are correctly sorted, then only <script type="math/tex; mode=display">nums[i:j]</script> could be the required subrray. Further, the elements in <script type="math/tex; mode=display">nums[0:i-1]</script> all need to be lesser than the <script type="math/tex; mode=display">min</script> for satisfying the required condition. Similarly, all the elements in <script type="math/tex; mode=display">nums[j:n-1]</script> need to be larger than <script type="math/tex; mode=display">max</script>. We check for these conditions for every possible <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> selected.</p>\n<p>Further, we also need to check if <script type="math/tex; mode=display">nums[0:i-1]</script> and <script type="math/tex; mode=display">nums[j:n-1]</script> are sorted correctly. If all the above conditions are satisfied, we determine the length of the unsorted subarray as <script type="math/tex; mode=display">j-i</script>. We do the same process for every subarray chosen and determine the length of the smallest unsorted subarray found.</p>\n<iframe frameborder="0" height="515" name="SdybCxt5" src="https://leetcode.com/playground/SdybCxt5/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. Three nested loops are there.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, we make use of an idea based on selection sort. We can traverse over the given <script type="math/tex; mode=display">nums</script> array choosing the elements <script type="math/tex; mode=display">nums[i]</script>. For every such element chosen, we try to determine its correct position in the sorted array. For this, we compare <script type="math/tex; mode=display">nums[i]</script> with every <script type="math/tex; mode=display">nums[j]</script>, such that <script type="math/tex; mode=display">i < j < n</script>. Here, <script type="math/tex; mode=display">n</script> refers to the length of <script type="math/tex; mode=display">nums</script> array.</p>\n<p>If any <script type="math/tex; mode=display">nums[j]</script> happens to be lesser than <script type="math/tex; mode=display">nums[i]</script>, it means both <script type="math/tex; mode=display">nums[i]</script> and <script type="math/tex; mode=display">nums[j]</script> aren\'t at their correct position for the sorted array. Thus, we need to swap the two elements to bring them at their correct positions. Here, instead of swapping, we just note the position of <script type="math/tex; mode=display">nums[i]</script>(given by <script type="math/tex; mode=display">i</script>) and <script type="math/tex; mode=display">nums[j]</script>(given by <script type="math/tex; mode=display">j</script>). These two elements now mark the boundary of the unsorted subarray(atleast for the time being).</p>\n<p>Thus, out of all the <script type="math/tex; mode=display">nums[i]</script> chosen, we determine the leftmost <script type="math/tex; mode=display">nums[i]</script> which isn\'t at its correct position. This marks the left boundary of the smallest unsorted subarray(<script type="math/tex; mode=display">l</script>). Similarly, out of all the <script type="math/tex; mode=display">nums[j]</script>\'s considered for all <script type="math/tex; mode=display">nums[i]</script>\'s we determine the rightmost <script type="math/tex; mode=display">nums[j]</script> which isn\'t at its correct position. This marks the right boundary of the smallest unsorted subarray(<script type="math/tex; mode=display">r</script>).</p>\n<p><img alt="Unsorted_subarray" src="https://leetcode.com/articles/Figures/581/Unsorted_subarray_1.PNG"></p>\n<p>Thus, we can determine the length of the smallest unsorted subarray as <script type="math/tex; mode=display">r - l + 1</script>.</p>\n<iframe frameborder="0" height="292" name="g9YJRHj4" src="https://leetcode.com/playground/g9YJRHj4/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Two nested loops are there.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-sorting-accepted">Approach #3 Using Sorting [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Another very simple idea is as follows. We can sort a copy of the given array <script type="math/tex; mode=display">nums</script>, say given by <script type="math/tex; mode=display">nums\\_sorted</script>. Then, if we compare the elements of <script type="math/tex; mode=display">nums</script> and <script type="math/tex; mode=display">nums\\_sorted</script>, we can determine the leftmost and rightmost elements which mismatch. The subarray lying between them is, then, the required shorted unsorted subarray.</p>\n<iframe frameborder="0" height="309" name="H3PB4vbF" src="https://leetcode.com/playground/H3PB4vbF/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nlogn)</script>. Sorting takes <script type="math/tex; mode=display">nlogn</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. We are making copy of original array.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-stack-accepted">Approach #4 Using Stack [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>The idea behind this approach is also based on selective sorting. We need to determine the correct position of the minimum and the maximum element in the unsorted subarray to determine the boundaries of the required unsorted subarray.</p>\n<p>To do so, in this implementation, we make use of a <script type="math/tex; mode=display">stack</script>. We traverse over the <script type="math/tex; mode=display">nums</script> array starting from the beginning. As we go on facing elements in ascending order(a rising slope), we keep on pushing the elements\' indices over the <script type="math/tex; mode=display">stack</script>. This is done because such elements are in the correct sorted order(as it seems till now). As soon as we encounter a falling slope, i.e. an element <script type="math/tex; mode=display">nums[j]</script> which is smaller than the element on the top of the <script type="math/tex; mode=display">stack</script>, we know that <script type="math/tex; mode=display">nums[j]</script> isn\'t at its correct position.</p>\n<p>In order to determine the correct position of <script type="math/tex; mode=display">nums[j]</script>, we keep on popping the elemnents from the top of the <script type="math/tex; mode=display">stack</script> until we reach the stage where the element(corresponding to the index) on the top of the <script type="math/tex; mode=display">stack</script> is lesser than <script type="math/tex; mode=display">nums[j]</script>. Let\'s say the popping stops when the index on <script type="math/tex; mode=display">stack</script>\'s top is <script type="math/tex; mode=display">k</script>. Now, <script type="math/tex; mode=display">nums[j]</script> has found its correct position. It needs to lie at an index <script type="math/tex; mode=display">k + 1</script>.</p>\n<p>We follow the same process while traversing over the whole array, and determine the value of minimum such <script type="math/tex; mode=display">k</script>. This marks the left boundary of the unsorted subarray.</p>\n<p>Similarly, to find the right boundary of the unsorted subarray, we traverse over the <script type="math/tex; mode=display">nums</script> array backwards. This time we keep on pushing the elements if we see a falling slope. As soon as we find a rising slope, we trace forwards now and determine the larger element\'s correct position. We do so for the complete array and thus, determine the right boundary.</p>\n<p>We can look at the figure below for reference. We can observe that the slopes directly indicate the relative ordering. We can also observe that the point <script type="math/tex; mode=display">b</script> needs to lie just after index 0 marking the left boundary and the point <script type="math/tex; mode=display">a</script> needs to lie just before index 7 marking the right boundary of the unsorted subarray.</p>\n<p><img alt="Unsorted_subarray" src="https://leetcode.com/articles/Figures/581/Unsorted_subarray_2.PNG"></p>\n<p>Below code is inpired by <a href="http://leetcode.com/fallcreek">@fallcreek</a></p>\n<iframe frameborder="0" height="377" name="tjLosXGs" src="https://leetcode.com/playground/tjLosXGs/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Stack of size <script type="math/tex; mode=display">n</script> is filled.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Stack size grows upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-without-using-extra-space-accepted">Approach #5 Without Using Extra Space [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>The idea behind this method is that the correct position of the minimum element in the unsorted subarray helps to determine the required left boundary. Similarly, the correct position of the maximum element in the unsorted subarray helps to determine the required right boundary.</p>\n<p>Thus, firstly we need to determine when the correctly sorted array goes wrong. We keep a track of this by observing rising slope starting from the beginning of the array. Whenever the slope falls, we know that the unsorted array has surely started. Thus, now we determine the minimum element found till the end of the array <script type="math/tex; mode=display">nums</script>, given by <script type="math/tex; mode=display">min</script>.</p>\n<p>Similarly, we scan the array <script type="math/tex; mode=display">nums</script> in the reverse order and when the slope becomes rising instead of falling, we start looking for the maximum element till we reach the beginning of the array, given by <script type="math/tex; mode=display">max</script>.</p>\n<p>Then, we traverse over <script type="math/tex; mode=display">nums</script> and determine the correct position of <script type="math/tex; mode=display">min</script> and <script type="math/tex; mode=display">max</script> by comparing these elements with the other array elements. e.g. To determine the correct position of <script type="math/tex; mode=display">min</script>, we know the initial portion of <script type="math/tex; mode=display">nums</script> is already sorted. Thus, we need to find the first element which is just larger than <script type="math/tex; mode=display">min</script>. Similarly, for <script type="math/tex; mode=display">max</script>\'s position, we need to find the first element which is just smaller than <script type="math/tex; mode=display">max</script> searching in <script type="math/tex; mode=display">nums</script> backwards.</p>\n<p>We can take this figure for reference again:</p>\n<p><img alt="Unsorted_subarray" src="https://leetcode.com/articles/Figures/581/Unsorted_subarray_2.PNG"></p>\n<p>We can observe that the point <script type="math/tex; mode=display">b</script> needs to lie just after index 0 marking the left boundary and the point <script type="math/tex; mode=display">a</script> needs to lie just before index 7 marking the right boundary of the unsorted subarray.</p>\n<iframe frameborder="0" height="515" name="vgbmarrv" src="https://leetcode.com/playground/vgbmarrv/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Four <script type="math/tex; mode=display">O(n)</script> loops are used.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google', 'LiveRamp'],
  },
  {
    id: '582',
    name: 'Kill Process ',
    acceptance: '50.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given <b>n</b> processes, each process has a unique <b>PID (process id)</b> and its <b>PPID (parent process id)</b>. \n\n</p><p>Each process only has one parent process, but may have one or more children processes. This is just like a tree structure.  Only one process has PPID that is 0, which means this process has no parent process. All the PIDs will be distinct positive integers.</p>\n\n<p>We use two list of integers to represent a list of processes, where the first list contains PID for each process and the second list contains the corresponding PPID. </p>\n \n<p>Now given the two lists, and a PID representing a process you want to kill, return a list of PIDs of processes that will be killed in the end. You should assume that when a process is killed, all its children processes will be killed. No order is required for the final answer.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \npid =  [1, 3, 10, 5]\nppid = [3, 0, 5, 3]\nkill = 5\n<b>Output:</b> [5,10]\n<b>Explanation:</b> \n           3\n         /   \\\n        1     5\n             /\n            10\nKill 5 will also kill 10.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The given kill id is guaranteed to be one of the given PIDs.</li>\n<li>n &gt;= 1.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-depth-first-search-time-limit-exceeded">Approach #1 Depth First Search [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-tree-simulation-accepted">Approach #2 Tree Simulation [Accepted]</a></li>\n<li><a href="#approach-3-hashmap-depth-first-search-accepted">Approach #3 HashMap + Depth First Search  [Accepted]</a></li>\n<li><a href="#approach-4-hashmap-breadth-first-search-accepted">Approach #4 HashMap + Breadth First Search [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-depth-first-search-time-limit-exceeded">Approach #1 Depth First Search [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Since killing a process leads to killing all its children processes, the simplest solution is to traverse over the <script type="math/tex; mode=display">ppid</script> array and find out all the children of the process to be killed. Further, for every child chosen to be killed we recursively make call to the <code>killProcess</code> function now treating this child as the new parent to be killed. In every such call, we again traverse over the <script type="math/tex; mode=display">ppid</script> array now considering the id of the child process, and continue in the same fashion. Further, at every step, for every process chosen to be killed, it is added to the list <script type="math/tex; mode=display">l</script> that needs to be returned at the end.</p>\n<iframe frameborder="0" height="309" name="aMxgv45H" src="https://leetcode.com/playground/aMxgv45H/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^n)</script>. <script type="math/tex; mode=display">O(n^n)</script> function calls will be made in the worst case</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of the recursion tree can go upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-tree-simulation-accepted">Approach #2 Tree Simulation [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can view the given process relationships in the form of a tree. We can construct the tree in such a way that every node stores information about its own value as well as the list of all its direct children nodes. Thus, now, once the tree has been generated, we can simply start off by killing the required node, and recursively killing the children of each node encountered rather than traversing over the whole <script type="math/tex; mode=display">ppid</script> array for every node as done in the previous approach.</p>\n<p>In order to implement this, we\'ve made use of a <script type="math/tex; mode=display">Node</script> class which represents a node of a tree. Each node represents a process. Thus, every node stores its own value(<script type="math/tex; mode=display">Node.val</script>) and the list of all its direct children(<script type="math/tex; mode=display">Node.children</script>). We traverse over the whole <script type="math/tex; mode=display">pid</script> array and create nodes for all of them. Then, we traverse over the <script type="math/tex; mode=display">ppid</script> array, and make the parent nodes out of them, and at the same time add all their direct children nodes in their <script type="math/tex; mode=display">Node.children</script> list. In this way, we convert the given process structure into a tree structure. </p>\n<p>Now, that we\'ve obtained the tree structure, we can add the node to be killed to the return list <script type="math/tex; mode=display">l</script>. Now, we can directly obtain all the direct children of this node from the tree, and add its direct children to the return list. For every node added to the return list, we repeat the same process of obtaining the children recursively. </p>\n<iframe frameborder="0" height="515" name="3vVYTuvw" src="https://leetcode.com/playground/3vVYTuvw/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We need to traverse over the <script type="math/tex; mode=display">ppid</script> and <script type="math/tex; mode=display">pid</script> array of size <script type="math/tex; mode=display">n</script> once. The <code>getAllChildren</code> function also takes atmost <script type="math/tex; mode=display">n</script> time, since no node can be a child of two nodes.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">map</script> of size <script type="math/tex; mode=display">n</script> is used. </p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-hashmap-depth-first-search-accepted">Approach #3 HashMap + Depth First Search  [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of making the tree structure, we can directly make use of a data structure which stores a particular process value and the list of its direct children. For this, in the current implementation, we make use of a hashmap <script type="math/tex; mode=display">map</script>, which stores the data in the form <script type="math/tex; mode=display">{parent: [list of all its direct children]}</script>.</p>\n<p>Thus, now, by traversing just once over the <script type="math/tex; mode=display">ppid</script> array, and adding the corresponding <script type="math/tex; mode=display">pid</script> values to the children list at the same time, we can obtain a better structure storing the parent-children relationship.</p>\n<p>Again, similar to the previous approach, now we can add the process to be killed to the return list, and keep on adding its children to the return list in a recursive manner by obtaining the child information from the structure created previously.</p>\n<p>!?!../Documents/582_Kill_Process.json:1000,563!?!</p>\n<iframe frameborder="0" height="462" name="RqpXvrnt" src="https://leetcode.com/playground/RqpXvrnt/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We need to traverse over the <script type="math/tex; mode=display">ppid</script> array of size <script type="math/tex; mode=display">n</script> once. The <code>getAllChildren</code> function also takes atmost <script type="math/tex; mode=display">n</script> time, since no node can be a child of two nodes.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">map</script> of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-hashmap-breadth-first-search-accepted">Approach #4 HashMap + Breadth First Search [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can also make use of Breadth First Search to obtain all the children(direct+indirect) of a particular node, once the data structure of the form <script type="math/tex; mode=display">(process: [list of all its direct children]</script> has been obtained. The process of obtaining the data structure is the same as in the previous approach. </p>\n<p>In order to obtain all the child processes to be killed for a particular parent chosen to be killed, we can make use of Breadth First Search. For this, we add the node to be killed to a <script type="math/tex; mode=display">queue</script>. Then, we remove an element from the front of the <script type="math/tex; mode=display">queue</script> and add it to the return list. Further, for every element removed from the front of the queue, we add all its direct children(obtained from the data structure created) to the end of the queue. We keep on doing so till the queue becomes empty.</p>\n<p>!?!../Documents/582_Kill_Process_BFS.json:1000,563!?!</p>\n<iframe frameborder="0" height="462" name="XkRcahEn" src="https://leetcode.com/playground/XkRcahEn/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We need to traverse over the <script type="math/tex; mode=display">ppid</script> array of size <script type="math/tex; mode=display">n</script> once. Also, atmost <script type="math/tex; mode=display">n</script> additions/removals are done from the <script type="math/tex; mode=display">queue</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">map</script> of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '583',
    name: 'Delete Operation for Two Strings',
    acceptance: '44.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven two words <i>word1</i> and <i>word2</i>, find the minimum number of steps required to make <i>word1</i> and <i>word2</i> the same, where in each step you can delete one character in either string.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "sea", "eat"\n<b>Output:</b> 2\n<b>Explanation:</b> You need one step to make "sea" to "ea" and another step to make "eat" to "ea".\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The length of given words won\'t exceed 500.</li>\n<li>Characters in given words can only be lower-case letters.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-longest-common-subsequence-time-limit-exceeded">Approach #1 Using Longest Common Subsequence [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-longest-common-subsequence-with-memoization-accepted">Approach #2 Longest Common Subsequence with Memoization [Accepted]</a></li>\n<li><a href="#approach-3-using-longest-common-subsequence-dynamic-programming-accepted">Approach #3 Using Longest Common Subsequence- Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-4-without-using-lcs-dynamic-programmming-accepted">Approach #4 Without using LCS Dynamic Programmming [Accepted]:</a></li>\n<li><a href="#approach-5-1-d-dynamic-programming-accepted">Approach #5 1-D Dynamic Programming [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-longest-common-subsequence-time-limit-exceeded">Approach #1 Using Longest Common Subsequence [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In order to determine the minimum number of delete operations needed, we can make use of the length of the longest common sequence among the two given strings <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script>, say given by <script type="math/tex; mode=display">lcs</script>. If we can find this <script type="math/tex; mode=display">lcs</script> value, we can easily determine the required result as <script type="math/tex; mode=display">m + n - 2*lcs</script>. Here, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> refer to the length of the two given strings <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script>.</p>\n<p>The above equation works because in case of complete mismatch(i.e. if the two strings can\'t be equalized at all), the total number of delete operations required will be <script type="math/tex; mode=display">m + n</script>. Now, if there is a common sequence among the two strings of length <script type="math/tex; mode=display">lcs</script>, we need to do <script type="math/tex; mode=display">lcs</script> lesser deletions in both the strings leading to a total of <script type="math/tex; mode=display">2lcs</script> lesser deletions, which then leads to the above equation.</p>\n<p>In order to find the length of the longest common sequence, we make use of a recursive function <code>lcs(s1,s2,i,j)</code> which returns the length of the longest common sequence among the strings <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> considering their lengths upto <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> respectively. For evaluating the function, we check if the characters <script type="math/tex; mode=display">s1[m-1]</script> and <script type="math/tex; mode=display">s2[n-1]</script> for equality. If they match, we can consider the corresponding strings upto 1 lesser lengths since the last characters have already been considered and add 1 to the result to be returned for strings of 1 lesser lengths. Thus, we make the function call <code>lcs(s1, s2, i-1, j-1)</code>. </p>\n<p>If the last characters don\'t match, we have two options, either we can consider the second last character of <script type="math/tex; mode=display">s1</script> and the last character of <script type="math/tex; mode=display">s2</script>, or we can consider the second last character of <script type="math/tex; mode=display">s2</script> and the last character of <script type="math/tex; mode=display">s1</script>. We need to consider the larger result obtained out of the two considerations for getting the required length. </p>\n<p>Thus, the function call <code>lcs(s1,s2,m,n)</code> returns the required <script type="math/tex; mode=display">lcs</script> value.</p>\n<iframe frameborder="0" height="309" name="QCLZ3ajV" src="https://leetcode.com/playground/QCLZ3ajV/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(2^{max(m,n)})</script>. Size of recursion tree will be <script type="math/tex; mode=display">2^(m+n)</script>. Here, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> refer to the lengths of <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> respectively.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(\\text{max}(m,n))</script>. The depth of the recursion tree will go upto <script type="math/tex; mode=display">\\text{max}(m,n)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-longest-common-subsequence-with-memoization-accepted">Approach #2 Longest Common Subsequence with Memoization [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can observe that in the last approach, while determining the <script type="math/tex; mode=display">lcs</script> value, a lot of redundant function calls are made, since the same <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> values to be used for the function calls could be obtained going through many different paths. We can remove this redundancy by making use of a <script type="math/tex; mode=display">memo</script> array to store the value to be returned for these function calls if they have been called once with the corresponding parameters. Thus, <script type="math/tex; mode=display">memo[i][j]</script> is used to store the result for the function call <code>lcs(s1,s2,i,j)</code>.</p>\n<p>Thus, by returning the already stored values from the <script type="math/tex; mode=display">memo</script> array, we can prune the search space to a great extent.</p>\n<iframe frameborder="0" height="377" name="dPT69gpC" src="https://leetcode.com/playground/dPT69gpC/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. <script type="math/tex; mode=display">memo</script> array of size <script type="math/tex; mode=display">m</script>x<script type="math/tex; mode=display">n</script> needs to be filled once. Here, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> refer to the length of the strings <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> respectively.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m*n)</script>. <script type="math/tex; mode=display">memo</script> array of size <script type="math/tex; mode=display">m</script>x<script type="math/tex; mode=display">n</script> is used. Also, The depth of the recursion tree will go upto <script type="math/tex; mode=display">\\text{max}(m,n)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-longest-common-subsequence-dynamic-programming-accepted">Approach #3 Using Longest Common Subsequence- Dynamic Programming [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Another method to obtain the value of <script type="math/tex; mode=display">lcs</script> is to make use of Dynamic Programming. We\'ll look at the implemenation and carry-on alongside the idea behind it.</p>\n<p>We make use of a 2-D <script type="math/tex; mode=display">dp</script>, in which <script type="math/tex; mode=display">dp[i][j]</script> represents the length of the longest common subsequence among the strings <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> considering their lengths upto <script type="math/tex; mode=display">(i-1)^{th}</script> index and <script type="math/tex; mode=display">(j-1)^{th}</script> index only respectively. We fill the <script type="math/tex; mode=display">dp</script> array in row-by-row order.</p>\n<p>In order to fill the entry for <script type="math/tex; mode=display">dp[i][j]</script>, we can have two cases:</p>\n<ol>\n<li>\n<p>The characters <script type="math/tex; mode=display">s1[i-1]</script> and <script type="math/tex; mode=display">s2[j-1]</script> match with each other. In this case, the entry for <script type="math/tex; mode=display">dp[i][j]</script> will be one more than the entry obtained for the strings considering their lengths upto one lesser index, since the matched character adds one to the length of LCS formed till the current indices. Thus, the <script type="math/tex; mode=display">dp[i][j]</script> entry is updated as <script type="math/tex; mode=display">dp[i][j] = 1 + dp[i-1][j-1]</script>. Note that <script type="math/tex; mode=display">dp[i-1][j-1]</script> has been used because the matched character belongs to both <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script>.</p>\n</li>\n<li>\n<p>The characters <script type="math/tex; mode=display">s1[i-1]</script> and <script type="math/tex; mode=display">s2[j-1]</script> don\'t match with each other. In this case, we can\'t increment the current entry as compared to entries corresponding to the previous indices, but we need to replicate the previous entry again to indicate that the length of LCS upto the current indices also remains the same. But, which entry to pick up? Now, since the current character hasn\'t matched, we have got two options. We can remove the current character from consideration from either <script type="math/tex; mode=display">s1</script> or <script type="math/tex; mode=display">s2</script> and use the corresponding <script type="math/tex; mode=display">dp</script> entries given by <script type="math/tex; mode=display">dp[i-1][j]</script> and <script type="math/tex; mode=display">dp[i][j-1]</script> respectively. Since we are considering the length of LCS upto the current indices we need to pick up the larger entry out of these two to update the current <script type="math/tex; mode=display">dp</script> entry.</p>\n</li>\n</ol>\n<p>At the end, again, we obtain the number of deletions required as <script type="math/tex; mode=display">m + n - 2*dp[m][n]</script>, where <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> refer to the lengths of <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script>. <script type="math/tex; mode=display">dp[m][n]</script> now refers to the length of LCS among the two given strings.</p>\n<p>!?!../Documents/583_Delete1.json:1000,563!?!</p>\n<iframe frameborder="0" height="326" name="xQZCgSyw" src="https://leetcode.com/playground/xQZCgSyw/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. We need to fill in the <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">m</script>x<script type="math/tex; mode=display">n</script>. Here, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> refer to the lengths of <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m*n)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">m</script>x<script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-without-using-lcs-dynamic-programmming-accepted">Approach #4 Without using LCS Dynamic Programmming [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of finding the length of LCS and then determining the number of deletions required, we can make use of Dynamic Programming to directly determine the number of deletions required till the current indices of the strings.</p>\n<p>In order to do so, we make use of a 2-D <script type="math/tex; mode=display">dp</script> array. Now, <script type="math/tex; mode=display">dp[i][j]</script> refers to the number of deletions required to equalize the two strings if we consider the strings\' length upto <script type="math/tex; mode=display">(i-1)^{th}</script> index and <script type="math/tex; mode=display">(j-1)^{th}</script> index for <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> respectively. Again, we fill in the <script type="math/tex; mode=display">dp</script> array in a row-by-row order. Now, in order to fill the entry for <script type="math/tex; mode=display">dp[i][j]</script>, we need to consider two cases only:</p>\n<ol>\n<li>\n<p>The characters <script type="math/tex; mode=display">s1[i-1]</script> and <script type="math/tex; mode=display">s2[j-1]</script> match with each other. In this case, we need to replicate the entry corresponding to <script type="math/tex; mode=display">dp[i-1][j-1]</script> itself. This is because, the matched character doesn\'t need to be deleted from any of the strings.</p>\n</li>\n<li>\n<p>The characters <script type="math/tex; mode=display">s1[i-1]</script> and <script type="math/tex; mode=display">s2[j-1]</script> don\'t match with each other. In this case, we need to delete either the current character of <script type="math/tex; mode=display">s1</script> or <script type="math/tex; mode=display">s2</script>. Thus, an increment of 1 needs to be done relative to the entries corresponding to the previous indices. The two options available at this moment are <script type="math/tex; mode=display">dp[i-1][j]</script> and <script type="math/tex; mode=display">dp[i][j-1]</script>. Since, we are keeping track of the minimum number of deletions required, we pick up the minimum out of these two values.</p>\n</li>\n</ol>\n<p>At the end, <script type="math/tex; mode=display">dp[m][n]</script> gives the required minimum number of deletions. Here, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> refer to the lengths of <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script>.</p>\n<p>!?!../Documents/583_Delete2.json:1000,563!?!</p>\n<iframe frameborder="0" height="326" name="aPU8b3Fd" src="https://leetcode.com/playground/aPU8b3Fd/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. We need to fill in the <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">m</script>x<script type="math/tex; mode=display">n</script>. Here, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> refer to the lengths of <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m*n)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">m</script>x<script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-1-d-dynamic-programming-accepted">Approach #5 1-D Dynamic Programming [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can observe that in the last approach, in order to update the current <script type="math/tex; mode=display">dp</script> entries, we need only the values of the previous row of <script type="math/tex; mode=display">dp</script>. Thus, rather than using a 2-D array, we can do the same job by making use of a 1-D <script type="math/tex; mode=display">dp</script> array.</p>\n<p>Thus, now, <script type="math/tex; mode=display">dp[i]</script> refers to the number of deletions that need to be made in order to equalize the strings <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script> if we consider string <script type="math/tex; mode=display">s1</script> upto the <script type="math/tex; mode=display">(i-1)^{th}</script> index and string <script type="math/tex; mode=display">s2</script> upto the last to current index of <script type="math/tex; mode=display">s2</script>. </p>\n<p>Now, we make the updations for the current row in an array <script type="math/tex; mode=display">temp</script> of the same size as <script type="math/tex; mode=display">dp</script>, and use the <script type="math/tex; mode=display">dp</script> entries as if they correspond to the previous row\'s entries. When, the whole <script type="math/tex; mode=display">temp</script> array has been filled, we copy it the <script type="math/tex; mode=display">dp</script> array so that <script type="math/tex; mode=display">dp</script> array now reflects the new row\'s entries.</p>\n<iframe frameborder="0" height="360" name="jfeuFUeS" src="https://leetcode.com/playground/jfeuFUeS/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. We need to fill in the <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n</script>, <script type="math/tex; mode=display">m</script> times. Here, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> refer to the lengths of <script type="math/tex; mode=display">s1</script> and <script type="math/tex; mode=display">s2</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '584',
    name: 'Find Customer Referee ',
    acceptance: '60.6%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>Given a table <code>customer</code> holding customers information and the referee.</p>\n\n<pre>+------+------+-----------+\n| id   | name | referee_id|\n+------+------+-----------+\n|    1 | Will |      NULL |\n|    2 | Jane |      NULL |\n|    3 | Alex |         2 |\n|    4 | Bill |      NULL |\n|    5 | Zack |         1 |\n|    6 | Mark |         2 |\n+------+------+-----------+\n</pre>\n\n<p>Write a query to return the list of customers <b>NOT</b> referred by the person with id '2'.</p>\n\n<p>For the sample data above, the result is:</p>\n<pre>+------+\n| name |\n+------+\n| Will |\n| Jane |\n| Bill |\n| Zack |\n+------+\n</pre>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-and-is-null-accepted">Approach: Using &lt;&gt;(!=) and IS NULL [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-and-is-null-accepted">Approach: Using <code>&lt;&gt;</code>(<code>!=</code>) and <code>IS NULL</code> [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Some people come out the following solution by intuition.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">customer</span> <span class="k">WHERE</span> <span class="n">referee_Id</span> <span class="o">&lt;&gt;</span> <span class="mi">2</span><span class="p">;</span>\n</pre></div>\n<p>However, this query will only return one result:Zack although there are 4 customers not referred by Jane (including Jane herself). All the customers who were referred by nobody at all (<code>NULL</code> value in the referee_id column) don’t show up. But why?</p>\n<p><strong>Algorithm</strong></p>\n<p>MySQL uses three-valued logic -- TRUE, FALSE and UNKNOWN. Anything compared to NULL evaluates to the third value: UNKNOWN. That “anything” includes NULL itself! That’s why MySQL provides the <code>IS NULL</code> and <code>IS NOT NULL</code> operators to specifically check for NULL.</p>\n<p>Thus, one more condition \'referee_id IS NULL\' should be added to the WHERE clause as below.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">customer</span> <span class="k">WHERE</span> <span class="n">referee_id</span> <span class="o">&lt;&gt;</span> <span class="mi">2</span> <span class="k">OR</span> <span class="n">referee_id</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">;</span>\n</pre></div>\n<p>or</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">customer</span> <span class="k">WHERE</span> <span class="n">referee_id</span> <span class="o">!=</span> <span class="mi">2</span> <span class="k">OR</span> <span class="n">referee_id</span> <span class="k">IS</span> <span class="no">NULL</span><span class="p">;</span>\n</pre></div>\n<p><strong>Tips</strong></p>\n<p>The following solution is also wrong for the same reason as mentioned above. The key is to always use <code>IS NULL</code> or <code>IS NOT NULL</code> operators to specifically check for NULL value.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">customer</span> <span class="k">WHERE</span> <span class="n">referee_id</span> <span class="o">=</span> <span class="k">NULL</span> <span class="k">OR</span> <span class="n">referee_id</span> <span class="o">&lt;&gt;</span> <span class="mi">2</span><span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '585',
    name: 'Investments in 2016 ',
    acceptance: '44.9%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Write a query to print the sum of all total investment values in 2016 (<b>TIV_2016</b>), to a scale of 2 decimal places, for all policy holders who meet the following criteria:</p>\n\n<ol>\n<li>Have the same <b>TIV_2015</b> value as one or more other policyholders.</li>\n<li>Are not located in the same city as any other policyholder (i.e.: the (latitude, longitude) attribute pairs must be unique).</li>\n</ol>\n\n<p><b>Input Format:</b><br>\nThe <b><i>insurance</i></b> table is described as follows:</p>\n\n<pre>| Column Name | Type          |\n|-------------|---------------|\n| PID         | INTEGER(11)   |\n| TIV_2015    | NUMERIC(15,2) |\n| TIV_2016    | NUMERIC(15,2) |\n| LAT         | NUMERIC(5,2)  |\n| LON         | NUMERIC(5,2)  |\n</pre>\n\n<p>where <b>PID</b> is the policyholder's policy ID, <b>TIV_2015</b> is the total investment value in 2015, <b>TIV_2016</b> is the total investment value in 2016, <b>LAT</b> is the latitude of the policy holder's city, and <b>LON</b> is the longitude of the policy holder's city.</p>\n\n<p><b>Sample Input</b></p>\n\n<pre>| PID | TIV_2015 | TIV_2016 | LAT | LON |\n|-----|----------|----------|-----|-----|\n| 1   | 10       | 5        | 10  | 10  |\n| 2   | 20       | 20       | 20  | 20  |\n| 3   | 10       | 30       | 20  | 20  |\n| 4   | 10       | 40       | 40  | 40  |\n</pre>\n\n<p><b>Sample Output</b></p>\n<pre>| TIV_2016 |\n|----------|\n| 45.00    |\n</pre>\n\n<p><b>Explanation</b></p>\n\n<pre>The first record in the table, like the last record, meets both of the two criteria.\nThe <b>TIV_2015</b> value '10' is as the same as the third and forth record, and its location unique.\n\nThe second record does not meet any of the two criteria. Its <b>TIV_2015</b> is not like any other policyholders.\n\nAnd its location is the same with the third record, which makes the third record fail, too.\n\nSo, the result is the sum of <b>TIV_2016</b> of the first and last record, which is 45.</pre>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-group-by-and-count-accepted">Approach: Using GROUP BY and COUNT [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-group-by-and-count-accepted">Approach: Using <code>GROUP BY</code> and <code>COUNT</code> [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>To decide whether a value in a column is unique or not, we can use <code>GROUP BY</code> and <code>COUNT</code>.</p>\n<p><strong>Algorithm</strong></p>\n<p>Check whether the value of a record\'s <strong>TIV_2015</strong> is unique, if it is not unique, and at the same time, its location (LAT, LON) pair is unique, then this record meeting the criteria. So it should be counted in the sum.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="k">SUM</span><span class="p">(</span><span class="n">insurance</span><span class="p">.</span><span class="n">TIV_2016</span><span class="p">)</span> <span class="k">AS</span> <span class="n">TIV_2016</span>\n<span class="k">FROM</span>\n    <span class="n">insurance</span>\n<span class="k">WHERE</span>\n    <span class="n">insurance</span><span class="p">.</span><span class="n">TIV_2015</span> <span class="k">IN</span>\n    <span class="p">(</span>\n      <span class="k">SELECT</span>\n        <span class="n">TIV_2015</span>\n      <span class="k">FROM</span>\n        <span class="n">insurance</span>\n      <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">TIV_2015</span>\n      <span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>\n    <span class="p">)</span>\n    <span class="k">AND</span> <span class="n">CONCAT</span><span class="p">(</span><span class="n">LAT</span><span class="p">,</span> <span class="n">LON</span><span class="p">)</span> <span class="k">IN</span>\n    <span class="p">(</span>\n      <span class="k">SELECT</span>\n        <span class="n">CONCAT</span><span class="p">(</span><span class="n">LAT</span><span class="p">,</span> <span class="n">LON</span><span class="p">)</span>\n      <span class="k">FROM</span>\n        <span class="n">insurance</span>\n      <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">LAT</span> <span class="p">,</span> <span class="n">LON</span>\n      <span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>\n    <span class="p">)</span>\n<span class="p">;</span>\n</pre></div>\n<blockquote>\n<p>Tips: Concat the <strong>LAT</strong> and <strong>LON</strong> as a whole to represent the location information.</p>\n</blockquote>\n<p>Note: These two criteria should be met without an order, so if you attempt to filter data using criteria #1 first and then criteria #2, you will get a wrong result.</p>\n<p>Taking the sample input as an example, the data set will be as following after taking the first criteria.</p>\n<table>\n<thead>\n<tr>\n<th>PID</th>\n<th>TIV_2015</th>\n<th>TIV_2016</th>\n<th>LAT</th>\n<th>LON</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>10</td>\n<td>5</td>\n<td>10</td>\n<td>10</td>\n</tr>\n<tr>\n<td>3</td>\n<td>10</td>\n<td>30</td>\n<td>20</td>\n<td>20</td>\n</tr>\n<tr>\n<td>4</td>\n<td>10</td>\n<td>40</td>\n<td>40</td>\n<td>40</td>\n</tr>\n</tbody>\n</table>\n<p>Then, the second criteria cannot filter any records on this data set. So the result is 75(5+30+40), which is obviously wrong since the location of record with PID \'3\' is actually the same with the record having been filtered by the first criteria.</p>\n<table>\n<thead>\n<tr>\n<th>PID</th>\n<th>TIV_2015</th>\n<th>TIV_2016</th>\n<th>LAT</th>\n<th>LON</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2</td>\n<td>20</td>\n<td>20</td>\n<td>20</td>\n<td>20</td>\n</tr>\n<tr>\n<td>3</td>\n<td>10</td>\n<td>30</td>\n<td>20</td>\n<td>20</td>\n</tr>\n</tbody>\n</table>\n</div>\n          ',
    tags: ['Twitter'],
  },
  {
    id: '586',
    name: 'Customer Placing the Largest Number of Orders ',
    acceptance: '56.8%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>Query the <b>customer_number</b> from the <b><i>orders</i></b> table for the customer who has placed the largest number of orders.</p>\n\n<p>It is guaranteed that exactly one customer will have placed more orders than any other customer.</p>\n\n<p>The <b><i>orders</i></b> table is defined as follows:</p>\n\n<pre>| Column            | Type      |\n|-------------------|-----------|\n| order_number (PK) | int       |\n| customer_number   | int       |\n| order_date        | date      |\n| required_date     | date      |\n| shipped_date      | date      |\n| status            | char(15)  |\n| comment           | char(200) |\n</pre>\n\n<p><b>Sample Input</b></p>\n<pre>| order_number | customer_number | order_date | required_date | shipped_date | status | comment |\n|--------------|-----------------|------------|---------------|--------------|--------|---------|\n| 1            | 1               | 2017-04-09 | 2017-04-13    | 2017-04-12   | Closed |         |\n| 2            | 2               | 2017-04-15 | 2017-04-20    | 2017-04-18   | Closed |         |\n| 3            | 3               | 2017-04-16 | 2017-04-25    | 2017-04-20   | Closed |         |\n| 4            | 3               | 2017-04-18 | 2017-04-28    | 2017-04-25   | Closed |         |\n</pre>\n\n<p><b>Sample Output</b></p>\n<pre>| customer_number |\n|-----------------|\n| 3               |\n</pre>\n\n<p><b>Explanation</b></p>\n<pre>The customer with number '3' has two orders, which is greater than either customer '1' or '2' because each of them  only has one order. <br>So the result is customer_number '3'.\n</pre>\n\n<p><i><b>Follow up:</b> What if more than one customer have the largest number of orders, can you find all the customer_number in this case?</i></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-limit-accepted">Approach: Using LIMIT [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-limit-accepted">Approach: Using <code>LIMIT</code> [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>First, we can select the <b>customer_number</b> and the according count of orders using <code>GROUP BY</code>.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">customer_number</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>\n<span class="k">FROM</span>\n    <span class="n">orders</span>\n<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">customer_number</span>\n</pre></div>\n<table>\n<thead>\n<tr>\n<th>customer_number</th>\n<th>COUNT(*)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<p>Then, the <b>customer_number</b> of first record is the result after sorting them by order count descending.</p>\n<table>\n<thead>\n<tr>\n<th>customer_number</th>\n<th>COUNT(*)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<p>In MySQL, the <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html">LIMIT</a> clause can be used to constrain the number of rows returned by the SELECT statement. It takes one or two nonnegative numeric arguments, the first of which specifies the offset of the first row to return, and the second specifies the maximum number of rows to return. The offset of the initial row is 0 (not 1).</p>\n<p>It can be used with only one argument, which specifies the number of rows to return from the beginning of the result set. So <code>LIMIT 1</code> will return the first record.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">customer_number</span>\n<span class="k">FROM</span>\n    <span class="n">orders</span>\n<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">customer_number</span>\n<span class="k">ORDER</span> <span class="k">BY</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">DESC</span>\n<span class="k">LIMIT</span> <span class="mi">1</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: ['Twitter'],
  },
  {
    id: '587',
    name: 'Erect the Fence',
    acceptance: '32.6%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>There are some trees, where each tree is represented by (x,y) coordinate in a two-dimensional garden. Your job is to fence the entire garden using the <b>minimum length</b> of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Your task is to help find the coordinates of trees which are exactly located on the fence perimeter.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\n<b>Output:</b> [[1,1],[2,0],[4,2],[3,3],[2,4]]\n<b>Explanation:</b>\n<img src="https://leetcode.com/static/images/problemset/erect_the_fence_1.png" width="30%">\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [[1,2],[2,2],[4,2]]\n<b>Output:</b> [[1,2],[2,2],[4,2]]\n<b>Explanation:</b>\n<img src="https://leetcode.com/static/images/problemset/erect_the_fence_2.png" width="30%">\nEven you only have trees in a line, you need to use rope to enclose them. \n</pre>\n<p></p>\n\n<p> Note: \n</p><ol>\n<li>All trees should be enclosed together. You cannot cut the rope to enclose trees that will separate them in more than one group.</li>\n<li>All input integers will range from 0 to 100. </li>\n<li>The garden has at least one tree. </li>\n<li>All coordinates are distinct. </li>\n<li>Input points have <b>NO</b> order. No order required for output.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#summary">Summary</a></li>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-jarvis-algorithm-accepted">Approach #1 Jarvis Algorithm [Accepted]</a></li>\n<li><a href="#approach-2-graham-scan-accepted">Approach #2 Graham Scan [Accepted]</a></li>\n<li><a href="#approach-3-monotone-chain-accepted">Approach #3 Monotone Chain [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="summary">Summary</h2>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-jarvis-algorithm-accepted">Approach #1 Jarvis Algorithm [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The idea behind Jarvis Algorithm is really simple. We start with the leftmost point among the given set of points and try to wrap up all the given points considering the boundary points in counterclockwise direction. </p>\n<p>This means that for every point <script type="math/tex; mode=display">p</script> considered, we try to find out a point <script type="math/tex; mode=display">q</script>, such that this point <script type="math/tex; mode=display">q</script> is the most counterclockwise relative to <script type="math/tex; mode=display">p</script> than all the other points. For checking this, we make use of <code>orientation()</code> function in the current implementation. This function takes three arguments <script type="math/tex; mode=display">p</script>, the current point added in the hull; <script type="math/tex; mode=display">q</script>, the next point being considered to be added in the hull; <script type="math/tex; mode=display">r</script>, any other point in the given point space. This function returns a negative value if the point <script type="math/tex; mode=display">q</script> is more counterclockwise to <script type="math/tex; mode=display">p</script> than the point <script type="math/tex; mode=display">r</script>. </p>\n<p>The following figure shows the concept. The point <script type="math/tex; mode=display">q</script> is more counterclockwise to <script type="math/tex; mode=display">p</script> than the point <script type="math/tex; mode=display">r</script>. </p>\n<p><img alt="Erect_Fence" src="https://leetcode.com/articles/Figures/587_Erect_Fence_Jarvis.PNG"></p>\n<p>From the above figure, we can observe that in order for the points <script type="math/tex; mode=display">p</script>, <script type="math/tex; mode=display">q</script> and <script type="math/tex; mode=display">r</script> need to be traversed in the same order in a counterclockwise direction, the cross product of the vectors <script type="math/tex; mode=display">\\vec{pq}</script> and <script type="math/tex; mode=display">\\vec{qr}</script> should be in a direction out of the plane of the screen i.e. it should be positive.</p>\n<p>\n<script type="math/tex; mode=display">\\vec{pq} </script>x<script type="math/tex; mode=display"> \\vec{qr} > 0</script>\n</p>\n<p>\n<script type="math/tex; mode=display">\\begin{vmatrix} (q_x-p_x) & (q_y-p_y) \\\\ (r_x-q_x) & (r_y-p_y) \\end{vmatrix} > 0</script>\n</p>\n<p>\n<script type="math/tex; mode=display">(q_x - p_x)*(r_y - q_y) - (q_y - p_y)*(r_x - q_x) > 0</script>\n</p>\n<p>\n<script type="math/tex; mode=display">(q_y - p_y)*(r_x - q_x) - (r_y - q_y)*(q_x - p_x) < 0</script>\n</p>\n<p>The above result is being calculated by the <code>orientation()</code> function.</p>\n<p>Thus, we scan over all the points <script type="math/tex; mode=display">r</script> and find out the point <script type="math/tex; mode=display">q</script> which is the most counterclockwise relative to <script type="math/tex; mode=display">p</script> and add it to the convex hull. Further, if there exist two points(say <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script>) with the same relative orientation to <script type="math/tex; mode=display">p</script>, i.e. if the points <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> are collinear relative to <script type="math/tex; mode=display">p</script>, we need to consider the point <script type="math/tex; mode=display">i</script> which lies in between the two points <script type="math/tex; mode=display">p</script> and <script type="math/tex; mode=display">j</script>. For considering such a situation, we\'ve made use of a function <code>inBetween()</code> in the current implementation. Even after finding out a point <script type="math/tex; mode=display">q</script>, we need to consider all the other points which are collinear to <script type="math/tex; mode=display">q</script> relative to <script type="math/tex; mode=display">p</script> so as to be able to consider all the points lying on the boundary.</p>\n<p>Thus, we keep on including the points in the hull till we reach the beginning point. </p>\n<p>The following animation depicts the process for a clearer understanding.</p>\n<p>!?!../Documents/587_Erect_Fence_1.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="ho9e8Hs9" src="https://leetcode.com/playground/ho9e8Hs9/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m*n)</script>. For every point on the hull we examine all the other points to determine the next point. Here n is number of input points and m is number of output or hull points ($$m &amp;leq; n). </p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m)</script>. List <script type="math/tex; mode=display">hull</script> grows upto size <script type="math/tex; mode=display">m</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-graham-scan-accepted">Approach #2 Graham Scan [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Graham Scan Algorithm is also a standard algorithm for finding the convex hull of a given set of points. Consider the animation below to follow along with the discussion. </p>\n<p>!?!../Documents/587_Erect_Fence_2.json:1000,563!?!</p>\n<p>The method works as follows. Firsly we select an initial point(<script type="math/tex; mode=display">bm</script>) to start the hull with. This point is chosen as the point with the lowest y-coordinate. In case of a tie, we need to choose the point with the lowest x-coordinate, from among all the given set of points. This point is indicated as point 0 in the animation. Then, we sort the given set of points based on their polar angles formed w.r.t. a vertical line drawn throught the intial point. </p>\n<p>This sorting of the points gives us a rough idea of the way in which we should consider the points to be included in the hull while considering the boundary in counter-clockwise order. In order to sort the points, we make use of <code>orientation</code> function which is the same as discussed in the last approach. The points with a lower polar angle relative to the vertical line come first in the sorted array. In case, if the orientation of two points happens to be the same, the points are sorted based on their distance from the beginning point(<script type="math/tex; mode=display">bm</script>). Later on we\'ll be considering the points in the sorted array in the same order. Because of this, we need to do the sorting based on distance for points collinear relative to <script type="math/tex; mode=display">bm</script>, so that all the collinear points lying on the hull are included in the boundary.</p>\n<p>But, we need to consider another important case. In case, the collinear points lie on the closing(last) edge of the hull, we need to consider the points such that the points which lie farther from the initial point <script type="math/tex; mode=display">bm</script> are considered first. Thus, after sorting the array, we traverse the sorted array from the end and reverse the order of the points which are collinear and lie towards the end of the sorted array, since these will be the points which will be considered at the end while forming the hull and thus, will be considered at the end. Thus, after these preprocessing steps, we\'ve got the points correctly arranged in the way that they need to be considered while forming the hull.</p>\n<p>Now, as per the algorithm, we start off by considering the line formed by the first two points(0 and 1 in the animation) in the sorted array. We push the points on this line onto a <script type="math/tex; mode=display">stack</script>. After this, we start traversing over the sorted <script type="math/tex; mode=display">points</script> array from the third point onwards. If the current point being considered appears after taking a left turn(or straight path) relative to the previous line(line\'s direction), we push the point onto the stack, indicating that the point has been temporarily added to the hull boundary.</p>\n<p>This checking of left or right turn is done by making use of <code>orientation</code> again. An orientation greater than 0, considering the points on the line and the current point, indicates a counterclockwise direction or a right turn. A negative orientation indicates a left turn similarly.</p>\n<p>If the current point happens to be occuring by taking a right turn from the previous line\'s direction, it means that the last point included in the hull was incorrect, since it needs to lie inside the boundary and not on the boundary(as is indicated by point 4 in the animation). Thus, we pop off the last point from the stack and consider the second last line\'s direction with the current point. </p>\n<p>Thus, the same process continues, and the popping keeps on continuing till we reach a state where the current point can be included in the hull by taking a right turn. Thus, in this way, we ensure that the hull includes only the boundary points and not the points inside the boundary. After all the points have been traversed, the points lying in the stack constitute the boundary of the convex hull. </p>\n<p>The below code is inspired by <a href="http://leetcode.com/yuxiangmusic">@yuxiangmusic</a> solution.</p>\n<iframe frameborder="0" height="515" name="FRb4Wch9" src="https://leetcode.com/playground/FRb4Wch9/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script>. Sorting the given points takes <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script> time. Further, after sorting the points can be considered in two cases, while being pushed onto the <script type="math/tex; mode=display">stack</script> or while popping from the <script type="math/tex; mode=display">stack</script>. Atmost, every point is touched twice(both push and pop) taking <script type="math/tex; mode=display">2n</script>(<script type="math/tex; mode=display">O(n)</script>) time in the worst case.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Stack size grows upto <script type="math/tex; mode=display">n</script> in worst case.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-monotone-chain-accepted">Approach #3 Monotone Chain [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The idea behing Monotone Chain Algorithm is somewhat similar to Graham Scan Algorithm. It mainly differs in the order in which the points are considered while being included in the hull. Instead of sorting the points based on their polar angles as in Graham Scan, we sort the points on the basis of their x-coordinate values. If two points have the same x-coordinate values, the points are sorted based on their y-coordinate values. The reasoning behind this will be explained soon.</p>\n<p>In this algorithm, we consider the hull as being comprised of two sub-boundaries- The upper hull and the lower hull. We form the two portions in a slightly different manner. </p>\n<p>We traverse over the sorted <script type="math/tex; mode=display">points</script> array after adding the initial two points in the hull temporarily(which are pushed over the stack <script type="math/tex; mode=display">hull</script>). For every new point considered, we check if the current point lies in the counter-clockwise direction relative to the last two points. If so, the current point is staightaway pushed onto <script type="math/tex; mode=display">hull</script>. If not(indicated by a positive <code>orientation</code>), we again get the inference that the last point on the <script type="math/tex; mode=display">hull</script> needs to lie inside the boundary and not on the boundary. Thus, we keep on popping the points from <script type="math/tex; mode=display">hull</script> till the current point lies in a counterclockwise direction relative to the top two points on the <script type="math/tex; mode=display">hull</script>. </p>\n<p>Note that this time, we need not consider the case of collinear points explicitly, since the points have already been sorted based on their x-coordinate values. So, the collinear points, if any, will implicitly be considered in the correct order.</p>\n<p>Doing so, we reach a state such that we reach the point with the largest x-coordinate. But, the hull isn\'t complete yet. The portion of the hull formed till now constitutes the lower poriton of the hull. Now, we need to form the upper portion of the hull.</p>\n<p>Thus, we continue the process of finding the next counterclockwise points and popping in case of a conflict, but this time we consider the points in the reverse order of their x-coordinate values. For this, we can simply traverse over the sorted <script type="math/tex; mode=display">points</script> array in the reverse order. We append the new upper hull values obtained to the previous <script type="math/tex; mode=display">hull</script> itself. At the end, <script type="math/tex; mode=display">hull</script> gives the points on the required boundary.</p>\n<p>The following animation depicts the process for a better understanding of the process:</p>\n<p>!?!../Documents/587_Erect_Fence_3.json:1000,563!?!</p>\n<iframe frameborder="0" height="479" name="vworasPc" src="https://leetcode.com/playground/vworasPc/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script>. Sorting the given points takes <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script> time. Further, after sorting the points can be considered in two cases, while being pushed onto the <script type="math/tex; mode=display">hull</script> or while popping from the <script type="math/tex; mode=display">hull</script>. Atmost, every point is touched twice(both push and pop) taking <script type="math/tex; mode=display">2n</script>(<script type="math/tex; mode=display">O(n)</script>) time in the worst case.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">hull</script> stack can grow upto size <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '588',
    name: 'Design In-Memory File System ',
    acceptance: '35.9%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Design an in-memory file system to simulate the following functions:</p>\n\n<p><code>ls</code>: Given a path in string format. If it is a file path, return a list that only contains this file\'s name. If it is a directory path, return the list of file and directory names <b>in this directory</b>. Your output (file and directory names together) should in <b>lexicographic order</b>.</p>\n\n<p><code>mkdir</code>: Given a <b>directory path</b> that does not exist, you should make a new directory according to the path. If the middle directories in the path don\'t exist either, you should create them as well. This function has void return type. </p>\n\n<p><code>addContentToFile</code>: Given a <b>file path</b> and <b>file content</b> in string format. If the file doesn\'t exist, you need to create that file containing given content. If the file already exists, you need to <b>append</b> given content to original content. This function has void return type.</p>\n\n<p><code>readContentFromFile</code>: Given a <b>file path</b>, return its <b>content</b> in string format.</p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> \n["FileSystem","ls","mkdir","addContentToFile","ls","readContentFromFile"]\n[[],["/"],["/a/b/c"],["/a/b/c/d","hello"],["/"],["/a/b/c/d"]]\n<b>Output:</b>\n[null,[],null,null,["a"],"hello"]\n<b>Explanation:</b>\n<img src="https://leetcode.com/static/images/problemset/filesystem.png" width="66%" alt="filesystem">\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>You can assume all file or directory paths are absolute paths which begin with <code>/</code> and do not end with <code>/</code> except that the path is just <code>"/"</code>.</li>\n<li>You can assume that all operations will be passed valid parameters and users will not attempt to retrieve file content or list a directory or file that does not exist.</li>\n<li>You can assume that all directory names and file names only contain lower-case letters, and same names won\'t exist in the same directory.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-separate-directory-and-file-listaccepted">Approach #1 Using separate Directory and File List[Accepted]</a></li>\n<li><a href="#approach-2-using-unified-directory-and-file-listaccepted">Approach #2 Using unified Directory and File List[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-separate-directory-and-file-listaccepted">Approach #1 Using separate Directory and File List[Accepted]</h4>\n<p>We start our discussion by looking at the directory structure used. The root directory acts as the base of the directory structure. Each directory contains two hashmaps namely <script type="math/tex; mode=display">dirs</script> and <script type="math/tex; mode=display">files</script>. The <script type="math/tex; mode=display">dirs</script> contains data in the form <script type="math/tex; mode=display">[(subdirectory_1\\_name: subdirectory_{1\\_structure}), (subdirectory_2\\_name: subdirectory_{2\\_structure})...]</script>. The <script type="math/tex; mode=display">files</script> contains data in the form <script type="math/tex; mode=display">[(file_1: file_{1\\_contents}), (file_2: file_{2\\_contents})...]</script>. This directory structure is shown below with a sample showing just the first two levels.</p>\n<p><img alt="Design_Memory" src="https://leetcode.com/articles/Figures/588_Design_In_Memory.PNG"></p>\n<p>Now, we\'ll discuss how we implement the various commands required.</p>\n<ol>\n<li>\n<p><code>ls</code>: In this case, we start off by initializing <script type="math/tex; mode=display">t</script>, a temporary directory pointer, to the root directory. We split the input directory path based on <code>/</code> and obtain the individual levels of directory names in a <script type="math/tex; mode=display">d</script> array. Then, we traverse over the tree directory structure based on the individual directories found and we keep on updating the <script type="math/tex; mode=display">t</script> directory pointer to point to the new level of directory(child) as we go on entering deeper into the directory structure. At the end, we will stop at either the end level directory or at the file name depending upon the input given. If the last level in the input happens to be a file name, we simply need to return the file name. So, we directly return the last entry in the <script type="math/tex; mode=display">d</script> array. If the last level entry happens to be a directory, we can obtain its subdirectory list from the list of keys in its <script type="math/tex; mode=display">dirs</script> hashmap. Similarly, we can obtain the list of files in the last directory from the keys in the corresponding <script type="math/tex; mode=display">files</script> hashmap. We append the two lists obtained, sort them and return the sorted appended list.</p>\n</li>\n<li>\n<p><code>mkdir</code>: In response to this command, as in case of <code>ls</code>, we start entering the directory structure level by level. Whenever we reach a state where a directory mentioned in the path of <code>mkdir</code> doesn\'t exist, we create a new entry in the last valid directory\'s <script type="math/tex; mode=display">dirs</script> structure and initialize its subdirectory list as an empty list. We keep on doing so till we reach the end level directory.</p>\n</li>\n<li>\n<p><code>addContentToFile</code>: In response to this command as well, as in case of <code>ls</code>, we start entering the directory structure level by  level. When we reach the level of the file name, we check if the file name already exists in the <script type="math/tex; mode=display">files</script> keys. If it exists, we concatenate the current contents to the contents of the file(in the value section of the corresponding file). If it doesn\'t exist, we create a new entry in the current directory\'s <script type="math/tex; mode=display">files</script> and initialize its contents with the current contents.</p>\n</li>\n<li>\n<p><code>readContentFromFile</code>: As the previous cases, we reach the last directory level by traversing through the directory structure level by level. Then, in the last directory, we search for the file name entry in the corresponding <script type="math/tex; mode=display">files</script>\' keys  and return its corresponding value as the contents of the file.</p>\n</li>\n</ol>\n<iframe frameborder="0" height="515" name="EUzUEgvo" src="https://leetcode.com/playground/EUzUEgvo/shared" width="100%"></iframe>\n<p><strong>Performance Analysis</strong></p>\n<ul>\n<li>\n<p>The time complexity of executing an <code>ls</code> command is <script type="math/tex; mode=display">O\\big(m+n+klog(k)\\big)</script>. Here, <script type="math/tex; mode=display">m</script> refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. <script type="math/tex; mode=display">n</script> refers to the depth of the last directory level in the given input for <code>ls</code>. This factor is taken because we need to enter <script type="math/tex; mode=display">n</script> levels of the tree structure to reach the last level. <script type="math/tex; mode=display">k</script> refers to the number of entries(files+subdirectories) in the last level directory(in the current input). We need to sort these names giving a factor of <script type="math/tex; mode=display">klog(k)</script>.</p>\n</li>\n<li>\n<p>The time complexity of executing an <code>mkdir</code> command is <script type="math/tex; mode=display">O(m+n)</script>. Here, <script type="math/tex; mode=display">m</script> refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. <script type="math/tex; mode=display">n</script> refers to the depth of the last directory level in the <code>mkdir</code> input. This factor is taken because we need to enter <script type="math/tex; mode=display">n</script> levels of the tree structure to reach the last level.</p>\n</li>\n<li>\n<p>The time complexity of both <code>addContentToFile</code> and <code>readContentFromFile</code> is <script type="math/tex; mode=display">O(m+n)</script>. Here, <script type="math/tex; mode=display">m</script> refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. <script type="math/tex; mode=display">n</script> refers to the depth of the file name in the current input. This factor is taken because we need to enter <script type="math/tex; mode=display">n</script> levels of the tree structure to reach the level where the files\'s contents need to be added/read from.</p>\n</li>\n<li>\n<p>The advantage of this scheme of maintaining the directory structure is that it is expandable to include even more commands easily. For example, <code>rmdir</code> to remove a directory given an input directory path. We need to simply reach to the destined directory level and remove the corresponding directory entry from the corresponding <script type="math/tex; mode=display">dirs</script> keys.</p>\n</li>\n<li>\n<p>Renaming files/directories is also very simple, since all we need to do is to create a temporary copy of the directory structure/file with a new name and delete the last entry.</p>\n</li>\n<li>\n<p>Relocating a hierarchichal subdirectory structure from one directory to the other is also very easy, since, all we need to do is obtain the address for the corresponding subdirectory class, and assign the same at the new positon in the new directory structure.</p>\n</li>\n<li>\n<p>Extracting only directories or files list on any path is easy in this case, since we maintain separate entires for <script type="math/tex; mode=display">dirs</script> and <script type="math/tex; mode=display">files</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-unified-directory-and-file-listaccepted">Approach #2 Using unified Directory and File List[Accepted]</h4>\n<p>This design differs from the first design in that the current data structure for a Directory contains a unified <script type="math/tex; mode=display">files</script> hashmap, which contains the list of all the files and subdirectories in the current directory. Apart from this, we contain an entry <script type="math/tex; mode=display">isfile</script>, which when True indicates that the current <script type="math/tex; mode=display">files</script> entry is actually corresponding to a file, otherwise it represents a directory. Further, since we are considering the directory and files\' entries in the same manner, we need an entry for <script type="math/tex; mode=display">content</script>, which contains the contents of the current file(if <script type="math/tex; mode=display">isfile</script> entry is True in the current case). For entries corresponding to directories, the <script type="math/tex; mode=display">content</script> field is kept empty.</p>\n<p>The following figure shows the directory structure for the same example as in the case above, for the first two levels of the hierarchical structure. </p>\n<p><img alt="Design_In_Memory" src="https://leetcode.com/articles/Figures/588_Design_In_Memory_3.PNG"></p>\n<p>The implementation of all the commands remains the same as in the last design, except that we need to make entries in the same <script type="math/tex; mode=display">files</script> hashmap for both files and directories, corresponding to <code>addContentToFile</code> and <code>mkdir</code> respectively. Further, for <code>ls</code>, we need not extract entries separately for the files and directories, since they are unified in the current case, and can be obtained in a single go.</p>\n<p>This approach is inspired by <a href="http://leetcode.com/shwangao">@shawngao</a></p>\n<iframe frameborder="0" height="515" name="a7jiya7b" src="https://leetcode.com/playground/a7jiya7b/shared" width="100%"></iframe>\n<p><strong>Performance Analysis</strong></p>\n<ul>\n<li>\n<p>The time complexity of executing an <code>ls</code> command is <script type="math/tex; mode=display">O\\big(m+n+klog(k)\\big)</script>. Here, <script type="math/tex; mode=display">m</script> refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. <script type="math/tex; mode=display">n</script> refers to the depth of the last directory level in the given input for <code>ls</code>. This factor is taken because we need to enter <script type="math/tex; mode=display">n</script> levels of the tree structure to reach the last level. <script type="math/tex; mode=display">k</script> refers to the number of entries(files+subdirectories) in the last level directory(in the current input). We need to sort these names giving a factor of <script type="math/tex; mode=display">klog(k)</script>.</p>\n</li>\n<li>\n<p>The time complexity of executing an <code>mkdir</code> command is <script type="math/tex; mode=display">O(m+n)</script>. Here, <script type="math/tex; mode=display">m</script> refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. <script type="math/tex; mode=display">n</script> refers to the depth of the last directory level in the <code>mkdir</code> input. This factor is taken because we need to enter <script type="math/tex; mode=display">n</script> levels of the tree structure to reach the last level.</p>\n</li>\n<li>\n<p>The time complexity of both <code>addContentToFile</code> and <code>readContentFromFile</code> is <script type="math/tex; mode=display">O(m+n)</script>. Here, <script type="math/tex; mode=display">m</script> refers to the length of the input string. We need to scan the input string once to split it and determine the various levels. <script type="math/tex; mode=display">n</script> refers to the depth of the file name in the current input. This factor is taken because we need to enter <script type="math/tex; mode=display">n</script> levels of the tree structure to reach the level where the files\'s contents need to be added/read from.</p>\n</li>\n<li>\n<p>The advantage of this scheme of maintaining the directory structure is that it is expandable to include even more commands easily. For example, <code>rmdir</code> to remove a directory given an input directory path. We need to simply reach to the destined directory level and remove the corresponding directory entry from the corresponding <script type="math/tex; mode=display">dirs</script> keys.</p>\n</li>\n<li>\n<p>Renaming files/directories is also very simple, since all we need to do is to create a temporary copy of the directory structure/file with a new name and delete the last entry.</p>\n</li>\n<li>\n<p>Relocating a hierarchichal subdirectory structure from one directory to the other is also very easy, since, all we need to do is obtain the address for the corresponding subdirectory class, and assign the same at the new positon in the new directory structure.</p>\n</li>\n<li>\n<p>If the number of directories is very large, we waste redundant space for <script type="math/tex; mode=display">isfile</script> and <script type="math/tex; mode=display">content</script>, which wasn\'t needed in the first design.</p>\n</li>\n<li>\n<p>A problem with the current design could occur if we want to list only the directories(and not the files), on any given path. In this case, we need to traverse over the whole contents of the current directory, check for each entry, whether it is a file or a directory, and then extract the required data.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Baidu'],
  },
  {
    id: '591',
    name: 'Tag Validator',
    acceptance: '30.4%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:</p><p>\n</p><ol>\n<li>The code must be wrapped in a <b>valid closed tag</b>. Otherwise, the code is invalid.</li>\n<li>A <b>closed tag</b> (not necessarily valid) has exactly the following format : <code>&lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;</code>. Among them, <code>&lt;TAG_NAME&gt;</code> is the start tag, and <code>&lt;/TAG_NAME&gt;</code> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is <b>valid</b> if and only if the TAG_NAME and TAG_CONTENT are valid.</li>\n<li>A <b>valid</b> <code>TAG_NAME</code> only contain <b>upper-case letters</b>, and has length in range [1,9]. Otherwise, the <code>TAG_NAME</code> is <b>invalid</b>.</li>\n<li>A <b>valid</b> <code>TAG_CONTENT</code> may contain other <b>valid closed tags</b>, <b>cdata</b> and any characters (see note1) <b>EXCEPT</b> unmatched <code>&lt;</code>, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the <code>TAG_CONTENT</code> is <b>invalid</b>.</li>\n<li>A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.</li>\n<li>A <code>&lt;</code> is unmatched if you cannot find a subsequent <code>&gt;</code>. And when you find a <code>&lt;</code> or <code>&lt;/</code>, all the subsequent characters until the next <code>&gt;</code> should be parsed as TAG_NAME  (not necessarily valid).</li>\n<li>The cdata has the following format : <code>&lt;![CDATA[CDATA_CONTENT]]&gt;</code>. The range of <code>CDATA_CONTENT</code> is defined as the characters between <code>&lt;![CDATA[</code> and the <b>first subsequent</b> <code>]]&gt;</code>. </li>\n<li><code>CDATA_CONTENT</code> may contain <b>any characters</b>. The function of cdata is to forbid the validator to parse <code>CDATA_CONTENT</code>, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as <b>regular characters</b>. </li>\n</ol>\n\n<p><b>Valid Code Examples:</b><br>\n</p><pre><b>Input:</b> "&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;/DIV&gt;"<br>\n<b>Output:</b> True<br>\n<b>Explanation:</b> <br>\nThe code is wrapped in a closed tag : &lt;DIV&gt; and &lt;/DIV&gt;. <br>\nThe TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. <br>\nAlthough CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag.<br>\nSo TAG_CONTENT is valid, and then the code is valid. Thus return true.<br>\n\n<b>Input:</b> "&lt;DIV&gt;&gt;&gt;  ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]&lt;/DIV&gt;"<br>\n<b>Output:</b> True<br>\n<b>Explanation:</b><br>\nWe first separate the code into : start_tag|tag_content|end_tag.<br>\nstart_tag -&gt; <b>"&lt;DIV&gt;"</b><br>\nend_tag -&gt; <b>"&lt;/DIV&gt;"</b><br>\ntag_content could also be separated into : text1|cdata|text2.<br>\ntext1 -&gt; <b>"&gt;&gt;  ![cdata[]] "</b><br>\ncdata -&gt; <b>"&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;"</b>, where the CDATA_CONTENT is <b>"&lt;div&gt;]&gt;"</b><br>\ntext2 -&gt; <b>"]]&gt;&gt;]"</b><br>\n\nThe reason why start_tag is NOT <b>"&lt;DIV&gt;&gt;&gt;"</b> is because of the rule 6.\nThe reason why cdata is NOT <b>"&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;"</b> is because of the rule 7.\n</pre>\n<p></p>\n\n<p><b>Invalid Code Examples:</b><br>\n</p><pre><b>Input:</b> "&lt;A&gt;  &lt;B&gt; &lt;/A&gt;   &lt;/B&gt;"\n<b>Output:</b> False\n<b>Explanation:</b> Unbalanced. If "&lt;A&gt;" is closed, then "&lt;B&gt;" must be unmatched, and vice versa.\n\n<b>Input:</b> "&lt;DIV&gt;  div tag is not closed  &lt;DIV&gt;"\n<b>Output:</b> False\n\n<b>Input:</b> "&lt;DIV&gt;  unmatched &lt;  &lt;/DIV&gt;"\n<b>Output:</b> False\n\n<b>Input:</b> "&lt;DIV&gt; closed tags with invalid tag name  &lt;b&gt;123&lt;/b&gt; &lt;/DIV&gt;"\n<b>Output:</b> False\n\n<b>Input:</b> "&lt;DIV&gt; unmatched tags with invalid tag name  &lt;/1234567890&gt; and &lt;CDATA[[]]&gt;  &lt;/DIV&gt;"\n<b>Output:</b> False\n\n<b>Input:</b> "&lt;DIV&gt;  unmatched start tag &lt;B&gt;  and unmatched end tag &lt;/C&gt;  &lt;/DIV&gt;"\n<b>Output:</b> False\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>For simplicity, you could assume the input code (including the <b>any characters</b> mentioned above) only contain <code>letters</code>, <code>digits</code>, <code>\'&lt;\'</code>,<code>\'&gt;\'</code>,<code>\'/\'</code>,<code>\'!\'</code>,<code>\'[\'</code>,<code>\']\'</code> and <code>\' \'</code>.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-stack-accepted">Approach #1  Using Stack [Accepted]</a></li>\n<li><a href="#approach-2-using-regex-accepted">Approach #2  Using Regex [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-stack-accepted">Approach #1  Using Stack [Accepted]</h4>\n<p>Summarizing the given problem, we can say that we need to determine whether a tag is valid or not, by checking the following properties.</p>\n<ol>\n<li>\n<p>The code should be wrapped in valid closed tag.</p>\n</li>\n<li>\n<p>The <code>TAG_NAME</code> should be valid.</p>\n</li>\n<li>\n<p>The <code>TAG_CONTENT</code> should be valid.</p>\n</li>\n<li>\n<p>The <strong>cdata</strong> should be valid.</p>\n</li>\n<li>\n<p>All the tags should be closed. i.e. each start-tag should have a corresponding end-tag and vice-versa and the order of the tags should be correct as well.</p>\n</li>\n</ol>\n<p>In order to check the validity of all these, firstly, we need to identify which parts of the given <script type="math/tex; mode=display">code</script> string act as which part from the above mentioned categories. To understand how it\'s done, we\'ll go through the implementation and the reasoning behind it step by step.</p>\n<p>We iterate over the given <script type="math/tex; mode=display">code</script> string. Whenever a <code>&lt;</code> is encountered(unless we are currently inside <code>&lt;![CDATA[...]]&gt;</code>), it indicates the beginning of either a <code>TAG_NAME</code>(start tag or end tag) or the beginning of cdata as per the conditions given in the problem statement. </p>\n<p>If the character immediately following this <code>&lt;</code> is an <code>!</code>, the characters following this <code>&lt;</code> can\'t be a part of a valid <code>TAG_NAME</code>, since only upper-case letters(in case of a start tag) or <code>/</code> followed by upper-case letters(in the case of an end tag). Thus, the choice now narrows down to only <strong>cdata</strong>. Thus, we need to check if the current bunch of characters following <code>&lt;!</code>(including it) constitute a valid <strong>cdata</strong>. For doing this, firstly we find out the first matching <code>]]&gt;</code> following the current <code>&lt;!</code> to mark the ending of <strong>cdata</strong>. If no such matching <code>]]&gt;</code> exists, the <script type="math/tex; mode=display">code</script> string is considered as invalid. Apart from this, the <code>&lt;!</code> should also be immediately followed by <code>CDATA[</code> for the <strong>cdata</strong> to be valid. The characters lying inside the  <code>&lt;![CDATA[</code> and <code>]]&gt;</code> do not have any constraints on them.</p>\n<p>If the character immediately following the <code>&lt;</code> encountered isn\'t an <code>!</code>, this <code>&lt;</code> can only mark the beginnning of <code>TAG_NAME</code>. Now, since a valid start tag can\'t contain anything except upper-case letters, if a <code>/</code> is found after <code>&lt;</code>, the <code>&lt;/</code> pair indicates the beginning of an end tag. Now, when a <code>&lt;</code> refers to the beginning of a <code>TAG_NAME</code>(either start-tag or end-tag), we find out the first closing <code>&gt;</code> following the <code>&lt;</code> to find out the substring(say <script type="math/tex; mode=display">s</script>), that constitutes the <code>TAG_NAME</code>. This <script type="math/tex; mode=display">s</script> should satisfy all the criterion to constitute a valid <code>TAG_NAME</code>. Thus, for every such <script type="math/tex; mode=display">s</script>, we check if it contains all upper-case letters and also check its length(It should be between 1 to 9). If any of the criteria isn\'t fulfilled, <script type="math/tex; mode=display">s</script> doesn\'t constitue a valid <code>TAG_NAME</code>. Hence, the <script type="math/tex; mode=display">code</script> string turns out to be invalid as well.</p>\n<p>Apart from checking the validity of the <code>TAG_NAME</code>, we also need to ensure that the tags always exist in pairs. i.e. for every start-tag, a corresponding end-tag should always exist. Further, we can note that in case of multiple <code>TAG_NAME</code>\'s, the <code>TAG_NAME</code> whose start-tag comes later than the other ones, should have its end-tag appearing before the end-tags of those other <code>TAG_NAME</code>\'s. i.e. the tag which starts later should end first. </p>\n<p>From this, we get the intuition that we can make use of a <script type="math/tex; mode=display">stack</script> to check the existence of matching start and end-tags. Thus, whenever we find out a valid start-tag, as mentioned above, we push its <code>TAG_NAME</code> string onto a <script type="math/tex; mode=display">stack</script>. Now, whenever an end-tag is found, we compare its <code>TAG_NAME</code> with the <code>TAG_NAME</code> at the top the <script type="math/tex; mode=display">stack</script> and remove this element from the <script type="math/tex; mode=display">stack</script>. If the two don\'t match, this implies that either the current end-tag has no corresponding start-tag or there is a problem with the ordering of the tags. The two need to match for the tag-pair to be valid, since there can\'t exist an end-tag without a corresponding start-tag and vice-versa. Thus, if a match isn\'t found, we can conclude that the given <script type="math/tex; mode=display">code</script> string is invalid.</p>\n<p>Now, after the complete <script type="math/tex; mode=display">code</script> string has been traversed, the <script type="math/tex; mode=display">stack</script> should be empty if all the start-tags have their corresponding end-tags as well. If the <script type="math/tex; mode=display">stack</script> isn\'t empty, this implies that some start-tag doesn\'t have the corresponding end-tag, violating the closed-tag\'s validity condition.</p>\n<p>Further, we also need to ensure that the given <script type="math/tex; mode=display">code</script> is completely enclosed within closed tags. For this, we need to ensure that the first <strong>cdata</strong> found is also inside the closed tags. Thus, when we find a possibility of the presence of <strong>cdata</strong>, we proceed further only if we\'ve already found a start tag, indicated by a non-empty stack. Further, to ensure that no data lies after the last end-tag, we need to ensure that the <script type="math/tex; mode=display">stack</script> doesn\'t become empty before we reach the end of the given <script type="math/tex; mode=display">code</script> string, since an empty <script type="math/tex; mode=display">stack</script> indicates that the last end-tag has been encountered.</p>\n<p>The following animation depicts the process.</p>\n<p>!?!../Documents/Tag_Validator_Stack.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="cELPrQEw" src="https://leetcode.com/playground/cELPrQEw/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We traverse over the given <script type="math/tex; mode=display">code</script> string of length <script type="math/tex; mode=display">n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The stack can grow upto a size of <script type="math/tex; mode=display">n/3</script> in the worst case. e.g. In case of <code>&lt;A&gt;&lt;B&gt;&lt;C&gt;&lt;D&gt;</code>, <script type="math/tex; mode=display">n</script>=12 and number of tags = 12/3 = 4.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-regex-accepted">Approach #2  Using Regex [Accepted]</h4>\n<p>Instead of manually checking the given <script type="math/tex; mode=display">code</script> string for checking the validity of <code>TAG_NAME</code>, <code>TAG_CONTENT</code> and <strong>cdata</strong>, we can make use of an inbuilt java fuunctionality known as regular expressions.</p>\n<p>A regular expression is a special sequence of characters that helps you match or find other strings or sets of strings, using a specialized syntax held in a pattern. They can be used to search, edit, or manipulate text and data. The most common quantifiers used in regular expressions are listed below. A quantifier after a token (such as a character) or group specifies how often that preceding element is allowed to occur.</p>\n<p><code>?</code> The question mark indicates zero or one occurrences of the preceding element. For example, colou?r matches both "color" and "colour".</p>\n<p><code>*</code> The asterisk indicates zero or more occurrences of the preceding element. For example, ab*c matches "ac", "abc", "abbc", "abbbc", and so on.</p>\n<p><code>+</code> The plus sign indicates one or more occurrences of the preceding element. For example, ab+c matches "abc", "abbc", "abbbc", and so on, but not "ac".</p>\n<p><code>{n}</code> The preceding item is matched exactly <strong>n</strong> times.</p>\n<p><code>{min,}</code> The preceding item is matched <strong>min</strong> or more times.</p>\n<p><code>{min,max}</code> The preceding item is matched at least <strong>min</strong> times, but not more than <strong>max</strong> times.</p>\n<p><code>|</code> A vertical bar separates alternatives. For example, gray|grey can match "gray" or "grey".</p>\n<p><code>()</code> Parentheses are used to define the scope and precedence of the operators (among other uses). For example, gray|grey and gr(a|e)y are equivalent patterns which both describe the set of "gray" or "grey".</p>\n<p><code>[...]</code> Matches any single character in brackets.</p>\n<p><code>[^...]</code>    Matches any single character not in brackets.</p>\n<p>Thus, by making use of regex, we can directly check the validity of the <script type="math/tex; mode=display">code</script> string directly(except the nesting of the inner tags) by using the regex expression below:</p>\n<p><code>&lt;([A-Z]{1,9})&gt;([^&lt;]*((&lt;\\/?[A-Z]{1,9}&gt;)|(&lt;!\\[CDATA\\[(.*?)]]&gt;))?[^&lt;]*)*&lt;\\/\\1&gt;</code></p>\n<p>The image below shows the portion of the string that each part of the expression helps to match:</p>\n<p align="center"><img alt="Regex" src="https://leetcode.com/articles/Figures/591/591_Tag_Validator.PNG"></p>\n<p>But, if we make use of back-referencing as mentioned above, the matching process takes a very large amount of CPU time. Thus, we use the regex only to check the validity of the <code>TAG_CONTENT</code>, <code>TAG_NAME</code> and the <strong>cdata</strong>. We check the presence of the outermost closed tags by making use of a <script type="math/tex; mode=display">stack</script> as done in the last approach.</p>\n<p>The rest of the process remains the same as in the last approach, except that we need not manually check the validity of <code>TAG_CONTENT</code>, <code>TAG_NAME</code> and the <strong>cdata</strong>, since it is already done by the regex expression. We only need to check the presence of inner closed tags.</p>\n<p>Check <a href="http://regexr.com/">this</a> link for testing any regular expression on a sample text.</p>\n<iframe frameborder="0" height="515" name="vvcbT3rc" src="https://leetcode.com/playground/vvcbT3rc/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : Regular Expressions are/can be implemented in the form of Finite State Machines. Thus, the time complexity is dependent on the internal representation. In case of any suggestions, please comment below.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The stack can grow upto a size of <script type="math/tex; mode=display">n/3</script> in the worst case. e.g. In case of <code>&lt;A&gt;&lt;B&gt;&lt;C&gt;&lt;D&gt;</code>, <script type="math/tex; mode=display">n</script>=12 and number of tags = 12/3 = 4.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Microsoft'],
  },
  {
    id: '592',
    name: 'Fraction Addition and Subtraction',
    acceptance: '46.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a string representing an expression of fraction addition and subtraction, you need to return the calculation result in string format. The final result should be <a href="https://en.wikipedia.org/wiki/Irreducible_fraction">irreducible fraction</a>. If your final result is an integer, say <code>2</code>, you need to change it to the format of fraction that has denominator <code>1</code>. So in this case, <code>2</code> should be converted to <code>2/1</code>.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>"-1/2+1/2"\n<b>Output:</b> "0/1"\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b>"-1/2+1/2+1/3"\n<b>Output:</b> "1/3"\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b>"1/3-1/2"\n<b>Output:</b> "-1/6"\n</pre>\n<p></p>\n\n<p><b>Example 4:</b><br>\n</p><pre><b>Input:</b>"5/3+1/3"\n<b>Output:</b> "2/1"\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The input string only contains <code>\'0\'</code> to <code>\'9\'</code>, <code>\'/\'</code>, <code>\'+\'</code> and <code>\'-\'</code>. So does the output.</li>\n<li>Each fraction (input and output) has format <code>±numerator/denominator</code>. If the first input fraction or the output is positive, then <code>\'+\'</code> will be omitted.</li>\n<li>The input only contains valid <b>irreducible fractions</b>, where the <b>numerator</b> and <b>denominator</b> of each fraction will always be in the range [1,10]. If the denominator is 1, it means this fraction is actually an integer in a fraction format defined above.</li> \n<li>The number of given fractions will be in the range [1,10].</li>\n<li>The numerator and denominator of the <b>final result</b> are guaranteed to be valid and in the range of 32-bit int.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-lcmaccepted">Approach #1  Using LCM[Accepted]</a></li>\n<li><a href="#approach-2-using-gcdaccepted">Approach #2  Using GCD[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-lcmaccepted">Approach #1  Using LCM[Accepted]</h4>\n<p>The first obvious step to be undertaken is to split the given string into individual fractions. We split the string based on <code>+</code> and <code>-</code> sign. We store the signs in the order in which they appear in the string in <script type="math/tex; mode=display">sign</script> array. Further, after getting the individual fractions, we further split the fractions based on <code>/</code> sign. Thus, we obtain the individual numerator and denominator parts. We store the same in <script type="math/tex; mode=display">num</script> and <script type="math/tex; mode=display">den</script> arrays respectively.</p>\n<p>Now, we\'ve got the data ready to be worked upon. In order to see the method we\'ve used in this implementation, we\'ll take an example and understand the way we work on it.</p>\n<p>Let\'s say, the given fraction is:</p>\n<p>\n<script type="math/tex; mode=display">\\frac{3}{2} + \\frac{5}{3} -\\frac{7}{6}</script>\n</p>\n<p>We need to equalize all the denominators so as to be able to add and subtract the numerators easily. The nearest value the denominators can be scaled upto is the LCM of all the denominators. Thus, we need to find the LCM of all the denominators and then multiply all the denominators with appropriate integer factors to make them equal to the LCM. But, in order to keep the individual fraction values unchanged, we need to multiply the individual numerators also with the same factors. </p>\n<p>In order to find the LCM, we can go as follows. We use the method <script type="math/tex; mode=display">lcm(a,b,c) = lcm( lcm(a,b), c)</script>. Thus, if we can compute the lcm of two denominators, we can keep on repeating the process iteratively over the denominators to get the overall lcm. To find the lcm of two numbers <script type="math/tex; mode=display">a</script> and <script type="math/tex; mode=display">b</script>, we use <script type="math/tex; mode=display">lcm(a,b) = (a*b)/gcd(a,b)</script>. For the above example, the <script type="math/tex; mode=display">lcm</script> turns out to be 6.</p>\n<p>Thus, we scale up the denominators to 6 as follows:</p>\n<p>\n<script type="math/tex; mode=display">\\frac{3*3}{2*3} + \\frac{5*2}{3*2} -\\frac{7}{6}</script>\n</p>\n<p>Thus, we can observe that, the scaling factor for a fraction <script type="math/tex; mode=display">\\frac{num}{den}</script> is given by: <script type="math/tex; mode=display">{num*x}/{den*x}</script>, where <script type="math/tex; mode=display">x</script> is the corresponding scaling factor. Note that, <script type="math/tex; mode=display">den*x=lcm</script>. Thus, <script type="math/tex; mode=display">x=lcm/den</script>. Thus, we find out the corresponding scaling factor <script type="math/tex; mode=display">x_i</script> for each fraction.</p>\n<p>After this, we can directly add or subtract the new scaled numerators.</p>\n<p>In the current example, we obtain <script type="math/tex; mode=display">\\frac{12}{6}</script> as the result. Now, we need to convert this into an irreducible fraction. Thus, if we obtain <script type="math/tex; mode=display">\\frac{num_i}{den_i}</script> as the final result, we need to find a largest factor <script type="math/tex; mode=display">y</script>, which divides both <script type="math/tex; mode=display">num_i</script> and <script type="math/tex; mode=display">den_i</script>. Such a number, as we know, is the gcd of <script type="math/tex; mode=display">num_i</script> and <script type="math/tex; mode=display">den_i</script>.</p>\n<p>Thus, to convert the result <script type="math/tex; mode=display">\\frac{num_i}{den_i}</script>, we divide both the numerator and denominator by the gcd of the two numbers <script type="math/tex; mode=display">y</script> to obtain the final irreducible <script type="math/tex; mode=display">\\frac{num_i/y}{den_i/y}</script>.</p>\n<p>Note: A problem with this approach is that we find the lcm of all the denominators in a single go and then reduce the overall fraction at the end. Thus, the lcm value could become very large and could lead to an overflow. But, this solution suffices for the current range of numbers.</p>\n<iframe frameborder="0" height="515" name="8oKguDZy" src="https://leetcode.com/playground/8oKguDZy/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nlogx)</script>. Euclidean GCD algorithm takes <script type="math/tex; mode=display">O(log(a.b))</script> time for finding gcd of two numbers <script type="math/tex; mode=display">a</script> and <script type="math/tex; mode=display">b</script>. Here <script type="math/tex; mode=display">n</script> refers to the number of fractions in the input string and <script type="math/tex; mode=display">x</script> is the maximum possible value of denominator.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Size of <script type="math/tex; mode=display">num</script>, <script type="math/tex; mode=display">den</script> and <script type="math/tex; mode=display">sign</script> list grows upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-gcdaccepted">Approach #2  Using GCD[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We know that we can continue the process of evaluating the given fractions by considering pairs of fractions at a time and continue the process considering the result obtained and the new fraction to be evaluated this time. We make use of this observation, and thus, instead of segregating the signs, numerators and denominators first, we directly start scanning the given strings and operate on the fractions obtained till now whenever a new sign is encountered.</p>\n<p>We operate on the pairs of fractions, and keep on reducing the result obtained to irreducible fractions on the way. By doing this, we can reduce the chances of the problem of potential overflow possible in case the denominators lead to a large value of lcm.</p>\n<p>We also observed from the last approach, that we need to equalize the denominators of a pair of fractions say:</p>\n<p>\n<script type="math/tex; mode=display">\\frac{a}{b} + \\frac{c}{d}</script>\n</p>\n<p>We used a scaling factor of <script type="math/tex; mode=display">x</script> for the first fraction(both numerator and denominator). Here, <script type="math/tex; mode=display">x=lcm(b,d)/b</script>. For the second fraction, the scaling factor <script type="math/tex; mode=display">y</script> is given by <script type="math/tex; mode=display">y=lcm(b,d)/d</script>. Here, $<script type="math/tex; mode=display">lcm(b,d)=b*d/gcd(b,d)</script>. Thus, instead of finding the lcm and then again determining the scaling factor, we can directly use: <script type="math/tex; mode=display">x=(b*d)/(gcd(b,d)*b) = d/gcd(b,d)</script>, and <script type="math/tex; mode=display">y=(b*d)/(gcd(b,d)*d)</script>. Thus, we need to scale the numerators appropriately and add/subtract them in terms of pairs. The denominators are scaled in the same manner to the lcm of the two denominators involved.</p>\n<p>After evaluting every pair of fractions, we again reduce them to irreducible fractions by diving both the numerator and denominator of the resultant fraction by the gcd of the two.</p>\n<iframe frameborder="0" height="515" name="Nt5WV8C2" src="https://leetcode.com/playground/Nt5WV8C2/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nlogx)</script>. Euclidean GCD algorithm takes <script type="math/tex; mode=display">O(log(a.b))</script> time for finding gcd of two numbers <script type="math/tex; mode=display">a</script> and <script type="math/tex; mode=display">b</script>. Here <script type="math/tex; mode=display">n</script> refers to the number of fractions in the input string and <script type="math/tex; mode=display">x</script> is the maximum possible value of denominator.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Size of <script type="math/tex; mode=display">sign</script> list grows upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['IXL'],
  },
  {
    id: '593',
    name: 'Valid Square',
    acceptance: '40.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given the coordinates of four points in 2D space, return whether the four points could construct a square.</p>\n\n<p>The coordinate (x,y) of a point is represented by an integer array with two integers.</p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\n<b>Output:</b> True\n</pre>\n<p></p>\n\n<p> Note: \n</p><ol>\n<li>All the input integers are in the range [-10000, 10000].</li>\n<li>A valid square has four equal sides with positive length and four equal angles (90-degree angles).</li>\n<li>Input points have no order.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-using-sorting-accepted">Approach #2 Using Sorting [Accepted]</a></li>\n<li><a href="#approach-3-checking-every-case-accepted">Approach #3 Checking every case [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-accepted">Approach #1 Brute Force [Accepted]</h4>\n<p>The idea behind determining whether 4 given set of points constitute a valid square or not is really simple. Firstly, we need to determine if the sides of the qaudrilateral formed by these 4 points are equal. But checking only this won\'t suffice. Since, this condition will be satisfied even in the case of a rhombus, where all the four sides are equal but the adjacent sides aren\'t perpendicular to each other. Thus, we also need to check if the lengths of the diagonals formed between the corners of the quadrilateral are equal. If both the conditions are satisfied, then only the given set of points can be deemed appropriate for constituting a square.</p>\n<p>Now, the problem arises in determining which pairs of points act as the adjacent points on the square boundary. So, the simplest method is to consider every possible case. For the given 4 points, <script type="math/tex; mode=display">[p_0, p_1, p_2, p_3]</script>, there are a total of 4! ways in which these points can be arranged to be considered as the square\'s boundaries. We can generate every possible permutation and check if any permutation leads to the valid square arrangement of points.</p>\n<iframe frameborder="0" height="515" name="kR62YSDY" src="https://leetcode.com/playground/kR62YSDY/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script>. Constant number of permutations(<script type="math/tex; mode=display">4!</script>) are generated.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is required.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-sorting-accepted">Approach #2 Using Sorting [Accepted]</h4>\n<p>Instead of considering all the permutations of arrangements possible, we can make use of maths to simplify this problem a bit. If we sort the given set of points based on their x-coordinate values, and in the case of a tie, based on their y-coordinate value, we can obtain an arrangement, which directly reflects the arrangement of points on a valid square boundary possible.</p>\n<p>Consider the only possible cases as shown in the figure below:</p>\n<p><img alt="Valid_Square" src="https://leetcode.com/articles/Figures/593_Valid_Square_1.PNG"></p>\n<p>In each case, after sorting, we obtain the following conclusion regarding the connections of the points:</p>\n<ol>\n<li>\n<p>\n<script type="math/tex; mode=display">p_0p_1</script>, <script type="math/tex; mode=display">p_1p_3</script>, <script type="math/tex; mode=display">p_3p_2</script> and <script type="math/tex; mode=display">p_2p_0</script> form the four sides of any valid square.</p>\n</li>\n<li>\n<p>\n<script type="math/tex; mode=display">p_0p_3</script> and <script type="math/tex; mode=display">p_1p_2</script> form the diagonals of the square.</p>\n</li>\n</ol>\n<p>Thus, once the sorting of the points is done, based on the above knowledge, we can directly compare <script type="math/tex; mode=display">p_0p_1</script>, <script type="math/tex; mode=display">p_1p_3</script>, <script type="math/tex; mode=display">p_3p_2</script> and <script type="math/tex; mode=display">p_2p_0</script> for equality of lengths(corresponding to the sides); and <script type="math/tex; mode=display">p_0p_3</script> and <script type="math/tex; mode=display">p_1p_2</script> for equality of lengths(corresponding to the diagonals).</p>\n<iframe frameborder="0" height="241" name="xp6gv2NM" src="https://leetcode.com/playground/xp6gv2NM/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script>. Sorting 4 points takes constant time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is required.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-checking-every-case-accepted">Approach #3 Checking every case [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>If we consider all the permutations descripting the arrangement of points as in the brute force approach, we can come up with the following set of 24 arrangements:</p>\n<p><img alt="Valid_Square" src="https://leetcode.com/articles/Figures/593_Valid_Square_2.PNG"></p>\n<p>In this figure, the rows with the same shaded color indicate that the corresponding arrangements lead to the same set of edges and diagonals. Thus, we can see that only three unique cases exist. Thus, instead of generating all the 24 permutations, we check for the equality of edges and diagonals for only the three distinct cases.</p>\n<iframe frameborder="0" height="258" name="7wt6ZUJR" src="https://leetcode.com/playground/7wt6ZUJR/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(1)</script>. A fixed number of comparisons are done.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space required.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Pure Storage'],
  },
  {
    id: '594',
    name: 'Longest Harmonious Subsequence',
    acceptance: '40.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>We define a harmonious array is an array where the difference between its maximum value and its minimum value is <b>exactly</b> 1.</p>\n\n<p>Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible <a href="https://en.wikipedia.org/wiki/Subsequence">subsequences</a>.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,3,2,2,5,2,3,7]\n<b>Output:</b> 5\n<b>Explanation:</b> The longest harmonious subsequence is [3,2,2,2,3].\n</pre>\n<p></p>\n\n<p><b>Note:</b>\nThe length of the input array will not exceed 20,000.\n</p>\n\n\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-using-sorting-accepted">Approach #3 Using Sorting [Accepted]</a></li>\n<li><a href="#approach-4-using-hashmapaccepted">Approach #4 Using HashMap[Accepted]:</a></li>\n<li><a href="#approach-5-in-single-loop-accepted">Approach #5 In single loop [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>In the brute force solution, we consider every possible subsequence that can be formed using the elements of the given array. For every subsequence, we find the maximum and minimum values in the subsequence. If the difference between the maximum and the minimum values obtained is 1, it means the current subsequence forms a harmonious subsequence. Thus, we can consider the number of elements in this subsequence to be compared with the length of the last longest harmonious subsequence. </p>\n<p>In order to obtain all the subseqeuences possible, we make use of binary number representation of decimal numbers. For a binary number of size <script type="math/tex; mode=display">n</script>, a total of <script type="math/tex; mode=display">2^n</script> different binary numbers can be generated. We generate all these binary numbers from <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">2^n</script>. For every binary number generated, we consider the subsequence to be comprised of only those elements of <script type="math/tex; mode=display">nums</script> which have a 1 at the corresponding position in the current binary number. The following figure shows an example of the way the elements of <script type="math/tex; mode=display">nums</script> are considered in the current subsequence.</p>\n<p><img alt="Harmonic_Subsequence" src="https://leetcode.com/articles/Figures/594_Harmonic_Subsequence_Binary.PNG"></p>\n<iframe frameborder="0" height="394" name="zbivYJiH" src="https://leetcode.com/playground/zbivYJiH/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(2^n)</script>. Number of subsequences generated will be <script type="math/tex; mode=display">2^n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space required.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we created every possible subsequence, and for every such subsequence, we found out if it satisfies the harmonicity condition. Instead of doing this, we can do as follows. We can consider every element of the given <script type="math/tex; mode=display">nums</script> array one by one. For <script type="math/tex; mode=display">nums[i]</script> chosen to be the current element, we determine the <script type="math/tex; mode=display">count</script> of all the elements in the <script type="math/tex; mode=display">nums</script> array, which satisfy the harmonicity condition with <script type="math/tex; mode=display">nums[i]</script>, i.e. the <script type="math/tex; mode=display">count</script> of all such <script type="math/tex; mode=display">nums[j]</script> satisfying <script type="math/tex; mode=display">nums[i] == nums[j]</script> or <script type="math/tex; mode=display">nums[i] == nums[j] + 1</script>. When we reach the end of the array for <script type="math/tex; mode=display">nums[i]</script> being the current element, we compare this <script type="math/tex; mode=display">count</script> obtained with the result obtained from the previous traversals and update the result appropriately. When all the elements of the array have been chosen as the element to be chosen as the base for harmonicity check, we get the required length of the longest harmonic subsequence.</p>\n<p>The following animation illustrates the process:</p>\n<p>!?!../Documents/594_Harmonic_Subsequence_1.json:1000,563!?!</p>\n<iframe frameborder="0" height="428" name="2PtVgy2R" src="https://leetcode.com/playground/2PtVgy2R/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Two nested loops are there.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space required.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-sorting-accepted">Approach #3 Using Sorting [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Since we are concerned only with the count of elements which are at a difference of 1, we can use sorting to our advantage. If we sort the given <script type="math/tex; mode=display">nums</script> array, the related elements will get arranged close to each other. Thus, we can traverse over the sorted array, and find the count of similar elements and elements one larger than the current ones, which occur consecutively(all the similar elements will be lying consecutively now). Initially, this value is stored in <script type="math/tex; mode=display">prev\\_count</script> variable. Then, if we encounter an element which is just 1 larger than the last elements, we count the occurences of such elements as well. This value is stored in <script type="math/tex; mode=display">count</script> variable. </p>\n<p>Thus, now for the harmonic subsequence comprised of only these two elements is a subsequence of length <script type="math/tex; mode=display">count + prev\\_count</script>. This result is stored in <script type="math/tex; mode=display">res</script> for each subsequence found. When we move forward to considering the next set of similar consecutive elements, we need to update the <script type="math/tex; mode=display">prev\\_count</script> with the <script type="math/tex; mode=display">count</script>\'s value, since now <script type="math/tex; mode=display">count</script> will act as the count of the elements 1 lesser than the next elements encountered. The value of <script type="math/tex; mode=display">res</script> is always updated to be the larger of previous <script type="math/tex; mode=display">res</script> and the current <script type="math/tex; mode=display">count + prev\\_count</script> value.</p>\n<p>When we are done traversing over the whole array, the value of <script type="math/tex; mode=display">res</script> gives us the required result.</p>\n<iframe frameborder="0" height="462" name="u6hDRMkp" src="https://leetcode.com/playground/u6hDRMkp/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nlogn)</script>. Sorting takes <script type="math/tex; mode=display">O(nlogn)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(logn)</script>. <script type="math/tex; mode=display">logn</script> space is required by sorting in average case.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-hashmapaccepted">Approach #4 Using HashMap[Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, we make use of a hashmap <script type="math/tex; mode=display">map</script> which stores the number of times an element occurs in the array along with the element\'s value in the form <script type="math/tex; mode=display">(num: count\\_num)</script>, where <script type="math/tex; mode=display">num</script> refers to an element in the array and <script type="math/tex; mode=display">count\\_num</script> refers to the number of times this <script type="math/tex; mode=display">num</script> occurs in the <script type="math/tex; mode=display">nums</script> array. We traverse over the <script type="math/tex; mode=display">nums</script> array and fill this <script type="math/tex; mode=display">map</script> once.</p>\n<p>After this, we traverse over the keys of the <script type="math/tex; mode=display">map</script> created. For every key of the <script type="math/tex; mode=display">map</script> considered, say <script type="math/tex; mode=display">key</script>, we find out if the map contains the <script type="math/tex; mode=display">key + 1</script>. Such an element is found, since only such elements can be counted for the harmonic subsequence if <script type="math/tex; mode=display">key</script> is considered as one of the element of the harmonic subsequence. We need not care about <script type="math/tex; mode=display">key - 1</script>, because if <script type="math/tex; mode=display">key</script> is present in the harmonic subsequence, at one time either <script type="math/tex; mode=display">key + 1</script> or <script type="math/tex; mode=display">key - 1</script> only could be included in the harmonic subsequence. The case of <script type="math/tex; mode=display">key - 1</script> being in the harmonic subsequence will automatically be considered, when <script type="math/tex; mode=display">key - 1</script> is encountered as the current key. </p>\n<p>Now, whenver we find that <script type="math/tex; mode=display">key + 1</script> exists in the keys of <script type="math/tex; mode=display">map</script>, we determine the count of the current harmonic subsequence as <script type="math/tex; mode=display">count_{key} + count_{key+1}</script>, where <script type="math/tex; mode=display">count_i</script> refers to the value corresponding to the key <script type="math/tex; mode=display">i</script> in <script type="math/tex; mode=display">map</script>, which reprents the number of times <script type="math/tex; mode=display">i</script> occurs in the array <script type="math/tex; mode=display">nums</script>.</p>\n<p>Look at the animation below for a pictorial view of the process:</p>\n<p>!?!../Documents/594_Harmonic_Subsequence_2.json:1000,563!?!</p>\n<iframe frameborder="0" height="292" name="goJjGNub" src="https://leetcode.com/playground/goJjGNub/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. One loop is required to fill <script type="math/tex; mode=display">map</script> and one for traversing the <script type="math/tex; mode=display">map</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. In worst case map size grows upto size <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-in-single-loop-accepted">Approach #5 In single loop [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of filling the <script type="math/tex; mode=display">map</script> first and then traversing over the <script type="math/tex; mode=display">map</script> to determine the lengths of the harmonic subsequences encountered, we can traverse over the <script type="math/tex; mode=display">nums</script> array, and while doing the traversals, we can determine the lengths of the harmonic subsequences possible till the current index of the <script type="math/tex; mode=display">nums</script> array. </p>\n<p>The method of finding the length of harmonic subsequence remains the same as the last approach. But, this time, we need to consider the existence of both <script type="math/tex; mode=display">key + 1</script> and <script type="math/tex; mode=display">key - 1</script> exclusively and determine the counts corresponding to both the cases. This is needed now because it could be possible that <script type="math/tex; mode=display">key</script> has already been added to the <script type="math/tex; mode=display">map</script> and later on <script type="math/tex; mode=display">key - 1</script> is encountered. In this case, if we consider the presence of <script type="math/tex; mode=display">key + 1</script> only, we\'ll go in the wrong direction.</p>\n<p>Thus, we consider the <script type="math/tex; mode=display">count</script>s corresponding to both the cases separately for every <script type="math/tex; mode=display">key</script> and determine the maximum out of them. \nThus, now the same task can be done only in a single traveral of the <script type="math/tex; mode=display">nums</script> array.</p>\n<p>See the animation below for understanding the process:</p>\n<p>!?!../Documents/594_Harmonic_Subsequence_3.json:1000,563!?!</p>\n<iframe frameborder="0" height="309" name="w3zAS2Rm" src="https://leetcode.com/playground/w3zAS2Rm/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Only one loop is there.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">map</script> size grows upto size <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['LiveRamp'],
  },
  {
    id: '595',
    name: 'Big Countries',
    acceptance: '71.8%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>There is a table <code>World</code> </p>\n<pre>+-----------------+------------+------------+--------------+---------------+\n| name            | continent  | area       | population   | gdp           |\n+-----------------+------------+------------+--------------+---------------+\n| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |\n| Albania         | Europe     | 28748      | 2831741      | 12960000      |\n| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |\n| Andorra         | Europe     | 468        | 78115        | 3712000       |\n| Angola          | Africa     | 1246700    | 20609294     | 100990000     |\n+-----------------+------------+------------+--------------+---------------+\n</pre>\n<p>\nA country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.\n</p><p>\nWrite a SQL solution to output big countries' name, population and area.\n</p>\n<p>\nFor example, according to the above table, we should output:\n</p><pre>+--------------+-------------+--------------+\n| name         | population  | area         |\n+--------------+-------------+--------------+\n| Afghanistan  | 25500100    | 652230       |\n| Algeria      | 37100000    | 2381741      |\n+--------------+-------------+--------------+\n</pre>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-i-using-where-clause-and-or-accepted">Approach I: Using WHERE clause and OR [Accepted]</a></li>\n<li><a href="#approach-ii-using-where-clause-and-union-accepted">Approach II: Using WHERE clause and UNION [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-i-using-where-clause-and-or-accepted">Approach I: Using <code>WHERE</code> clause and <code>OR</code> [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Use <code>WHERE</code> clause in SQL to filter these records and get the target countries.</p>\n<p><strong>Algorithm</strong></p>\n<p>According to the definition, a big country meets at least one of the following two conditions:\n1. It has an area of bigger than 3 million square km.\n2. It has a population of more than 25 million.</p>\n<p>So for the first condition, we can use the following code to get the big countries of this type.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="n">name</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">area</span> <span class="k">FROM</span> <span class="n">world</span> <span class="k">WHERE</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="mi">3000000</span>\n</pre></div>\n<p>In addition, we can use below code to get big countries of more than 25 million people.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="n">name</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">area</span> <span class="k">FROM</span> <span class="n">world</span> <span class="k">WHERE</span> <span class="n">population</span> <span class="o">&gt;</span> <span class="mi">25000000</span>\n</pre></div>\n<p>As most people may already come into mind, we can use <code>OR</code> to combine these two solutions for the two sub-problems together.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">name</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">area</span>\n<span class="k">FROM</span>\n    <span class="n">world</span>\n<span class="k">WHERE</span>\n    <span class="n">area</span> <span class="o">&gt;</span> <span class="mi">3000000</span> <span class="k">OR</span> <span class="n">population</span> <span class="o">&gt;</span> <span class="mi">25000000</span>\n<span class="p">;</span>\n</pre></div>\n<h4 id="approach-ii-using-where-clause-and-union-accepted">Approach II: Using <code>WHERE</code> clause and <code>UNION</code> [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The idea of this approach is the same as the first one. However, we use <code>UNION</code> instead of <code>OR</code>.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">name</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">area</span>\n<span class="k">FROM</span>\n    <span class="n">world</span>\n<span class="k">WHERE</span>\n    <span class="n">area</span> <span class="o">&gt;</span> <span class="mi">3000000</span>\n\n<span class="k">UNION</span>\n\n<span class="k">SELECT</span>\n    <span class="n">name</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">area</span>\n<span class="k">FROM</span>\n    <span class="n">world</span>\n<span class="k">WHERE</span>\n    <span class="n">population</span> <span class="o">&gt;</span> <span class="mi">25000000</span>\n<span class="p">;</span>\n</pre></div>\n<blockquote>\n<p>Note: This solution runs a little bit faster than the first one. However, they do not have big difference.</p>\n</blockquote>\n</div>\n          ',
    tags: [],
  },
  {
    id: '596',
    name: 'Classes More Than 5 Students',
    acceptance: '27.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nThere is a table <code>courses</code> with columns: <b>student</b> and <b>class</b>\n</p><p>\nPlease list out all classes which have more than or equal to 5 students.\n</p>\n<p>\nFor example, the table:\n</p>\n<pre>+---------+------------+\n| student | class      |\n+---------+------------+\n| A       | Math       |\n| B       | English    |\n| C       | Math       |\n| D       | Biology    |\n| E       | Math       |\n| F       | Computer   |\n| G       | Math       |\n| H       | Math       |\n| I       | Math       |\n+---------+------------+\n</pre>\n<p>\nShould output:\n</p><pre>+---------+\n| class   |\n+---------+\n| Math    |\n+---------+\n</pre>\n<p></p>\n<p>\n<b>Note:</b><br>\nThe students should not be counted duplicate in each course.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-group-by-clause-and-sub-query-accepted">Approach: Using GROUP BY clause and sub-query [Accepted]</a></li>\n<li><a href="#approach-using-group-by-and-having-condition-accepted">Approach: Using GROUP BY and HAVING condition [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-group-by-clause-and-sub-query-accepted">Approach: Using <code>GROUP BY</code> clause and <strong>sub-query</strong> [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>First, we can count the student number in each class. And then select the ones have more than 5 students.</p>\n<p><strong>Algorithm</strong></p>\n<p>To get the student number in each class. We can use <code>GROUP BY</code> and <code>COUNT</code>, which is very popular used to statistic bases on some character in a table.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="k">class</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">student</span><span class="p">)</span>\n<span class="k">FROM</span>\n    <span class="n">courses</span>\n<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">class</span>\n<span class="p">;</span>\n</pre></div>\n<blockquote>\n<p>Note: We use <code>DISTINCT</code> here since the student name may duplicated in a class as it is mentioned int he problem description.</p>\n</blockquote>\n<div class="codehilite"><pre><span></span>| class    | COUNT(student) |\n|----------|----------------|\n| Biology  | 1              |\n| Computer | 1              |\n| English  | 1              |\n| Math     | 6              |\n</pre></div>\n<p>To continue, we can filter the classes by taking the above query as a sub-query.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="k">class</span>\n<span class="k">FROM</span>\n    <span class="p">(</span><span class="k">SELECT</span>\n        <span class="k">class</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">student</span><span class="p">)</span> <span class="k">AS</span> <span class="n">num</span>\n    <span class="k">FROM</span>\n        <span class="n">courses</span>\n    <span class="k">GROUP</span> <span class="k">BY</span> <span class="k">class</span><span class="p">)</span> <span class="k">AS</span> <span class="n">temp_table</span>\n<span class="k">WHERE</span>\n    <span class="n">num</span> <span class="o">&gt;=</span> <span class="mi">5</span>\n<span class="p">;</span>\n</pre></div>\n<blockquote>\n<p>Note: Make an alias of <code>COUNT(student)</code> (\'num\' in this case) so that you can use in the <code>WHERE</code> clause because it cannot be used directly over there.</p>\n</blockquote>\n<h4 id="approach-using-group-by-and-having-condition-accepted">Approach: Using <code>GROUP BY</code> and <code>HAVING</code> condition [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Using sub-query is one way to add some condition to a <code>GROUP BY</code> clause, however, using <a href="https://dev.mysql.com/doc/refman/5.7/en/group-by-handling.html"><code>HAVING</code></a> is another simpler and natural approach. So we can rewrite the above solution as below.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="k">class</span>\n<span class="k">FROM</span>\n    <span class="n">courses</span>\n<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">class</span>\n<span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">student</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '597',
    name: 'Friend Requests I: Overall Acceptance Rate ',
    acceptance: '37.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            In social network like Facebook or Twitter, people send friend requests and accept others’ requests as well. Now given two tables as below:<p></p>\n\nTable: <code>friend_request</code>\n<pre>| sender_id | send_to_id |request_date|\n|-----------|------------|------------|\n| 1         | 2          | 2016_06-01 |\n| 1         | 3          | 2016_06-01 |\n| 1         | 4          | 2016_06-01 |\n| 2         | 3          | 2016_06-02 |\n| 3         | 4          | 2016-06-09 |\n</pre><p></p>\n\nTable: <code>request_accepted</code>\n<pre>| requester_id | accepter_id |accept_date |\n|--------------|-------------|------------|\n| 1            | 2           | 2016_06-03 |\n| 1            | 3           | 2016-06-08 |\n| 2            | 3           | 2016-06-08 |\n| 3            | 4           | 2016-06-09 |\n| 3            | 4           | 2016-06-10 |\n</pre><p></p>\n\nWrite a query to find the overall acceptance rate of requests rounded to 2 decimals, which is the number of acceptance divide the number of requests.<p></p>\n\nFor the sample data above, your query should return the following result.<p></p>\n<pre>|accept_rate|\n|-----------|\n|       0.80|\n</pre><p></p>\n\n<b>Note:</b>\n<li>The accepted requests are not necessarily from the table <code>friend_request</code>. In this case, you just need to simply count the total accepted requests (no matter whether they are in the original requests), and divide it by the number of requests to get the acceptance rate.</li>\n<li>It is possible that a sender sends multiple requests to the same receiver, and a request could be accepted more than once. In this case, the ‘duplicated’ requests or acceptances are only counted once.</li>\n<li>If there is no requests at all, you should return 0.00 as the accept_rate. </li>\n<p></p>\n\n<b>Explanation:</b> There are 4 unique accepted requests, and there are 5 requests in total. So the rate is 0.80.<p></p>\n\n<b>Follow-up:</b><br>\n<li>Can you write a query to return the accept rate but for every month?</li>\n<li>How about the cumulative accept rate for every day?</li>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-round-and-ifnull-accepted">Approach: Using round and ifnull [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-round-and-ifnull-accepted">Approach: Using <code>round</code> and <code>ifnull</code> [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Count the accepted requests and then divides it by the number of all requests.</p>\n<p><strong>Algorithm</strong></p>\n<p>To get the distinct number of accepted requests, we can query from the <strong>request_accepted</strong> table.</p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="p">(</span><span class="k">select</span> <span class="k">distinct</span> <span class="n">requester_id</span><span class="p">,</span> <span class="n">accepter_id</span> <span class="k">from</span> <span class="n">request_accepted</span><span class="p">;</span>\n</pre></div>\n<p>With the same technique, we can have the total number of requests from the <strong>friend_request</strong> table:</p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="p">(</span><span class="k">select</span> <span class="k">distinct</span> <span class="n">sender_id</span><span class="p">,</span> <span class="n">send_to_id</span> <span class="k">from</span> <span class="n">friend_request</span><span class="p">;</span>\n</pre></div>\n<p>At last, divide these two numbers and <a href="https://dev.mysql.com/doc/refman/5.7/en/mathematical-functions.html#function_round"><code>round</code></a> it to a scale of 2 decimal places to get the required acceptance rate.</p>\n<p>Wait! The divisor (total number of requests) could be \'0\' if the table <strong>friend_request</strong> is empty. So, we have to utilize  <a href="https://dev.mysql.com/doc/refman/5.7/en/control-flow-functions.html#function_ifnull"><code>ifnull</code></a> to deal with this special case.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">select</span>\n<span class="n">round</span><span class="p">(</span>\n    <span class="n">ifnull</span><span class="p">(</span>\n    <span class="p">(</span><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="p">(</span><span class="k">select</span> <span class="k">distinct</span> <span class="n">requester_id</span><span class="p">,</span> <span class="n">accepter_id</span> <span class="k">from</span> <span class="n">request_accepted</span><span class="p">)</span> <span class="k">as</span> <span class="n">A</span><span class="p">)</span>\n    <span class="o">/</span>\n    <span class="p">(</span><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="p">(</span><span class="k">select</span> <span class="k">distinct</span> <span class="n">sender_id</span><span class="p">,</span> <span class="n">send_to_id</span> <span class="k">from</span> <span class="n">friend_request</span><span class="p">)</span> <span class="k">as</span> <span class="n">B</span><span class="p">),</span>\n    <span class="mi">0</span><span class="p">)</span>\n<span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">as</span> <span class="n">accept_rate</span><span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '598',
    name: 'Range Addition II',
    acceptance: '48.3%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>Given an m * n matrix <b>M</b> initialized with all <b>0</b>'s and several update operations.</p>\n<p>Operations are represented by a 2D array, and each operation is represented by an array with two <b>positive</b> integers <b>a</b> and <b>b</b>, which means <b>M[i][j]</b> should be <b>added by one</b> for all <b>0 &lt;= i &lt; a</b> and <b>0 &lt;= j &lt; b</b>. </p>\n<p>You need to count and return the number of maximum integers in the matrix after performing all the operations.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \nm = 3, n = 3\noperations = [[2,2],[3,3]]\n<b>Output:</b> 4\n<b>Explanation:</b> \nInitially, M = \n[[0, 0, 0],\n [0, 0, 0],\n [0, 0, 0]]\n\nAfter performing [2,2], M = \n[[1, 1, 0],\n [1, 1, 0],\n [0, 0, 0]]\n\nAfter performing [3,3], M = \n[[2, 2, 1],\n [2, 2, 1],\n [1, 1, 1]]\n\nSo the maximum integer in M is 2, and there are four of it in M. So return 4.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The range of m and n is [1,40000].</li>\n<li>The range of a is [1,m], and the range of b is [1,n].</li>\n<li>The range of operations size won't exceed 10,000.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-single-pass-accepted">Approach #2 Single Pass [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The simplest method is to create a actual 2-D array of size <script type="math/tex; mode=display">m</script>x<script type="math/tex; mode=display">n</script>(<script type="math/tex; mode=display">arr</script>), perform all the operations one by one on the given range of elements, and then count the number of maximum elements. Now, we know that all the operations performed always include the element at index <script type="math/tex; mode=display">(0,0)</script>. Thus, the element <script type="math/tex; mode=display">arr[0][0]</script> will always be the maximum. After performing all the operations, we can count the number of elements equal to <script type="math/tex; mode=display">arr[0][0]</script> to get the required count of the maximum elements.</p>\n<iframe frameborder="0" height="411" name="awQVAxR8" src="https://leetcode.com/playground/awQVAxR8/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(x*m*n)</script>. Array is updated <script type="math/tex; mode=display">x</script> times, where <script type="math/tex; mode=display">x</script> represents number of times operation is preformed i.e. <script type="math/tex; mode=display">ops.length</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m*n)</script>. Array of size <script type="math/tex; mode=display">m*n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-single-pass-accepted">Approach #2 Single Pass [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>As per the given problem statement, all the operations are performed on a rectangular sub-matrix of the initial all 0\'s <script type="math/tex; mode=display">M</script> matrix. The upper left corner of each such rectangle is given by the index <script type="math/tex; mode=display">(0, 0)</script> and the lower right corner for an operation <script type="math/tex; mode=display">[i, j]</script> is given by the index <script type="math/tex; mode=display">(i, j)</script>. </p>\n<p>The maximum element will be the one on which all the operations have been performed. The figure below shows an example of two operations being performed on the initial <script type="math/tex; mode=display">M</script> array. </p>\n<p><img alt="Range_Addition" src="https://leetcode.com/articles/Figures/598_Range_Addition2.PNG"></p>\n<p>From this figure, we can observe that the maximum elements will be the ones which lie in the intersection region of the rectangles representing the operations. Further, we can observe that to count the number of elements lying in this intersection region, we don\'t actually need to perform the operations, but we need to determine the lower right cornerof the intersecting region only. This corner is given by <script type="math/tex; mode=display">\\big(x, y\\big) = \\big(\\text{min}(op[0], \\text{min}(op[1])\\big)</script>, where <script type="math/tex; mode=display">\\text{min}(op[i])</script> reprsents the minimum value of <script type="math/tex; mode=display">op[i]</script> from among all the <script type="math/tex; mode=display">op[i]</script>\'s in the given set of operations.</p>\n<p>Thus, the resultant count of elements lying in the intersection is given by: <script type="math/tex; mode=display">x</script>x<script type="math/tex; mode=display">y</script>.</p>\n<iframe frameborder="0" height="224" name="eUWGJ45b" src="https://leetcode.com/playground/eUWGJ45b/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(x)</script>. Single traversal of all operations is done. <script type="math/tex; mode=display">x</script> refers to the number of operations.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. No extra space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['IXL'],
  },
  {
    id: '599',
    name: 'Minimum Index Sum of Two Lists',
    acceptance: '46.5%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nSuppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. \n</p>\n<p>\nYou need to help them find out their <b>common interest</b> with the <b>least list index sum</b>. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.\n</p>\n\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>\n["Shogun", "Tapioca Express", "Burger King", "KFC"]\n["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"]\n<b>Output:</b> ["Shogun"]\n<b>Explanation:</b> The only restaurant they both like is "Shogun".\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b>\n["Shogun", "Tapioca Express", "Burger King", "KFC"]\n["KFC", "Shogun", "Burger King"]\n<b>Output:</b> ["Shogun"]\n<b>Explanation:</b> The restaurant they both like and have the least index sum is "Shogun" with index sum 1 (0+1).\n</pre>\n<p></p>\n\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The length of both lists will be in the range of [1, 1000].</li>\n<li>The length of strings in both lists will be in the range of [1, 30].</li>\n<li>The index is starting from 0 to the list length minus 1.</li>\n<li>No duplicates in both lists.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-hashmap-accepted">Approach #1 Using HashMap [Accepted]</a></li>\n<li><a href="#approach-2-without-using-hashmap-accepted">Approach #2 Without Using HashMap [Accepted]</a></li>\n<li><a href="#approach-3-using-hashmap-linear-accepted">Approach #3 Using HashMap (linear) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-hashmap-accepted">Approach #1 Using HashMap [Accepted]</h4>\n<p>In this approach, we compare every string in <script type="math/tex; mode=display">list1</script> and <script type="math/tex; mode=display">list2</script> by traversing over the whole list <script type="math/tex; mode=display">list2</script> for every string chosen from <script type="math/tex; mode=display">list1</script>. We make use of a hashmap <script type="math/tex; mode=display">map</script>, which contains elements of the form <script type="math/tex; mode=display">(sum : list_{sum})</script>. Here, <script type="math/tex; mode=display">sum</script> refers to the sum of indices of matching elements and <script type="math/tex; mode=display">list_{sum}</script> refers to the list of matching strings whose indices\' sum equals <script type="math/tex; mode=display">sum</script>. </p>\n<p>Thus, while doing the comparisons, whenever a match between a string at <script type="math/tex; mode=display">i^{th}</script> index of <script type="math/tex; mode=display">list1</script> and <script type="math/tex; mode=display">j^{th}</script> index of <script type="math/tex; mode=display">list2</script> is found, we make an entry in the <script type="math/tex; mode=display">map</script> corresponding to the sum <script type="math/tex; mode=display">i + j</script>, if this entry isn\'t already present. If an entry with this sum already exists, we need to keep a track of all the strings which lead to the same index sum. Thus, we append the current string to the list of strings corresponding to sum <script type="math/tex; mode=display">i + j</script>.</p>\n<p>At the end, we traverse over the keys of the <script type="math/tex; mode=display">map</script> and find out the list of strings corresponding to the key reprsenting the minimum sum.</p>\n<iframe frameborder="0" height="394" name="Rxg7wbHW" src="https://leetcode.com/playground/Rxg7wbHW/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(l_1*l_2*x)</script>. Every item of <script type="math/tex; mode=display">list1</script> is compared with all the items of <script type="math/tex; mode=display">list2</script>. <script type="math/tex; mode=display">l_1</script> and <script type="math/tex; mode=display">l_2</script> are the lengths of <script type="math/tex; mode=display">list1</script> and <script type="math/tex; mode=display">list2</script> respectively. And <script type="math/tex; mode=display">x</script> refers to average string length.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(l_1*l_2*x)</script>. In worst case all items of <script type="math/tex; mode=display">list1</script> and <script type="math/tex; mode=display">list2</script> are same. In that case, hashmap size grows upto <script type="math/tex; mode=display">l_1*l_2*x</script>, where <script type="math/tex; mode=display">x</script> refers to average string length.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-without-using-hashmap-accepted">Approach #2 Without Using HashMap [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Another method could be to traverse over the various <script type="math/tex; mode=display">sum</script>(index sum) values and determine if any such string exists in <script type="math/tex; mode=display">list1</script> and <script type="math/tex; mode=display">list2</script> such that the sum of its indices in the two lists equals <script type="math/tex; mode=display">sum</script>. </p>\n<p>Now, we know that the value of index sum, <script type="math/tex; mode=display">sum</script> could range from 0 to <script type="math/tex; mode=display">m + n - 1</script>. Here, <script type="math/tex; mode=display">m</script> and <script type="math/tex; mode=display">n</script> refer to the length of lists <script type="math/tex; mode=display">list1</script> and <script type="math/tex; mode=display">list2</script> respectively. Thus, we choose every value of <script type="math/tex; mode=display">sum</script> in ascending order. For every <script type="math/tex; mode=display">sum</script> chosen, we iterate over <script type="math/tex; mode=display">list1</script>. Suppose, currently the string at <script type="math/tex; mode=display">i^{th}</script> index in <script type="math/tex; mode=display">list1</script> is being considered. Now, in order for the index sum <script type="math/tex; mode=display">sum</script> to be the one corresponding to matching strings in <script type="math/tex; mode=display">list1</script> and <script type="math/tex; mode=display">list2</script>, the string at index <script type="math/tex; mode=display">j</script> in <script type="math/tex; mode=display">list2</script> should match the string at index <script type="math/tex; mode=display">i</script> in <script type="math/tex; mode=display">list1</script>, such that <script type="math/tex; mode=display">sum = i + j</script>.</p>\n<p>Or, stating in other terms, the string at index <script type="math/tex; mode=display">j</script> in <script type="math/tex; mode=display">list2</script> should be equal to the string at index <script type="math/tex; mode=display">i</script> in <script type="math/tex; mode=display">list1</script>, such that <script type="math/tex; mode=display">j = sum - i</script>. Thus, for a particular <script type="math/tex; mode=display">sum</script> and <script type="math/tex; mode=display">i</script>(from <script type="math/tex; mode=display">list1</script>), we can directly determine that we need to check the element at index <script type="math/tex; mode=display"> j= sum - i</script> in <script type="math/tex; mode=display">list2</script>, instead of traversing over the whole <script type="math/tex; mode=display">list2</script>. </p>\n<p>Doing such checks/comparisons, iterate over all the indices of <script type="math/tex; mode=display">list1</script> for every <script type="math/tex; mode=display">sum</script> value chosen. Whenver a match occurs between <script type="math/tex; mode=display">list1</script> and <script type="math/tex; mode=display">list2</script>, we put the matching string in a list <script type="math/tex; mode=display">res</script>. </p>\n<p>We do the same process of checking the strings for all the  values of <script type="math/tex; mode=display">sum</script> in ascending order. After completing every iteration over <script type="math/tex; mode=display">list1</script> for a particular <script type="math/tex; mode=display">sum</script>, we check if the <script type="math/tex; mode=display">res</script> list is empty or not. If it is empty, we need to continue the process with the next <script type="math/tex; mode=display">sum</script> value considered. If not, the current <script type="math/tex; mode=display">res</script> gives the required list with minimum index sum. This is because we are already considering the index sum values in ascending order. So, the first list to be found is the required resultant list.</p>\n<p>The following example depicts the process:</p>\n<p>!?!../Documents/599_Min_Index_Sum.json:1000,563!?!</p>\n<iframe frameborder="0" height="309" name="HhLorCYq" src="https://leetcode.com/playground/HhLorCYq/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O((l_1+l_2)^2*x)</script>. There are two nested loops upto <script type="math/tex; mode=display">l_1+l_2</script> and string comparison takes <script type="math/tex; mode=display">x</script> time. Here, <script type="math/tex; mode=display">x</script> refers to the average string length.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(r*x)</script>. <script type="math/tex; mode=display">res</script> list is used to store the result. Assuming <script type="math/tex; mode=display">r</script> is the length of <script type="math/tex; mode=display">res</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-hashmap-linear-accepted">Approach #3 Using HashMap (linear) [Accepted]</h4>\n<p>We make use of a HashMap to solve the given problem in a different way in this approach. Firstly, we traverse over the whole <script type="math/tex; mode=display">list1</script> and create an entry for each element of <script type="math/tex; mode=display">list1</script> in a HashMap <script type="math/tex; mode=display">map</script>, of the form <script type="math/tex; mode=display">(list[i], i)</script>. Here, <script type="math/tex; mode=display">i</script> refers to the index of the <script type="math/tex; mode=display">i^{th}</script> element, and <script type="math/tex; mode=display">list[i]</script> is the <script type="math/tex; mode=display">i^{th}</script> element itself. Thus, we create a mapping from the elements of <script type="math/tex; mode=display">list1</script> to their indices.</p>\n<p>Now, we traverse over <script type="math/tex; mode=display">list2</script>. For every element ,<script type="math/tex; mode=display">list2[j]</script>, of <script type="math/tex; mode=display">list2</script> encountered, we check if the same element already exists as a key in the <script type="math/tex; mode=display">map</script>. If so, it means that the element exists in both <script type="math/tex; mode=display">list1</script> and <script type="math/tex; mode=display">list2</script>. Thus, we find out the sum of indices corresponding to this element in the two lists, given by <script type="math/tex; mode=display">sum = map.get(list[j]) + j</script>. If this <script type="math/tex; mode=display">sum</script> is lesser than the minimum sum  obtained till now, we update the resultant list to be returned, <script type="math/tex; mode=display">res</script>, with the element <script type="math/tex; mode=display">list2[j]</script> as the only entry in it. </p>\n<p>If the <script type="math/tex; mode=display">sum</script> is equal to the minimum sum obtained till now, we put an extra entry corresponding to the element <script type="math/tex; mode=display">list2[j]</script> in the <script type="math/tex; mode=display">res</script> list.</p>\n<p>Below code is inspired by <a href="http://leetcode.com/cloud.runner">@cloud.runner</a></p>\n<iframe frameborder="0" height="411" name="FatTyfy6" src="https://leetcode.com/playground/FatTyfy6/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(l_1+l_2)</script>. Every item of <script type="math/tex; mode=display">list2</script> is checked in a map of <script type="math/tex; mode=display">list1</script>. <script type="math/tex; mode=display">l_1</script> and <script type="math/tex; mode=display">l_2</script> are the lengths of <script type="math/tex; mode=display">list1</script> and <script type="math/tex; mode=display">list2</script> respectively.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(l_1*x)</script>. hashmap size grows upto <script type="math/tex; mode=display">l_1*x</script>, where <script type="math/tex; mode=display">x</script> refers to average string length.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Yelp'],
  },
  {
    id: '600',
    name: 'Non-negative Integers without Consecutive Ones',
    acceptance: '31.1%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given a positive integer n, find the number of <b>non-negative</b> integers less than or equal to n, whose binary representations do NOT contain <b>consecutive ones</b>.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> 5\n<b>Output:</b> 5\n<b>Explanation:</b> \nHere are the non-negative integers &lt;= 5 with their corresponding binary representations:\n0 : 0\n1 : 1\n2 : 10\n3 : 11\n4 : 100\n5 : 101\nAmong them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. \n</pre>\n<p></p>\n\n<p><b>Note:</b>\n1 &lt;= n &lt;= 10<sup>9</sup>\n</p>\n\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-using-bit-manipulation-accepted">Approach #3 Using Bit Manipulation [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The brute force approach is simple. We can traverse through all the numbers from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">num</script>. For every current number chosen, we can check all the consecutive positions in this number to check if the number contains two consecutive ones or not. If not, we increment the <script type="math/tex; mode=display">count</script> of the resultant numbers with no consecutive ones. </p>\n<p>To check if a <script type="math/tex; mode=display">1</script> exists at the position <script type="math/tex; mode=display">x</script>(counting from the LSB side), in the current number <script type="math/tex; mode=display">n</script>, we can proceed as follows. We can shift a binary <script type="math/tex; mode=display">1</script>\n<script type="math/tex; mode=display">x-1</script> times towards the left to get a number <script type="math/tex; mode=display">y</script> which has a <script type="math/tex; mode=display">1</script> only at the <script type="math/tex; mode=display">x^{th}</script> position. Now, logical ANDing of <script type="math/tex; mode=display">n</script> and <script type="math/tex; mode=display">y</script> will result in a logical <script type="math/tex; mode=display">1</script> output only if <script type="math/tex; mode=display">n</script> contains <script type="math/tex; mode=display">1</script> at the <script type="math/tex; mode=display">x^{th}</script> position.</p>\n<iframe frameborder="0" height="377" name="EvkBtbbs" src="https://leetcode.com/playground/EvkBtbbs/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(32*n)</script>. We test  the 32 consecutive positions of every number from <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">n</script>. Here, <script type="math/tex; mode=display">n</script> refers to given number. </p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we generated every number and then checked if it contains consecutive ones at any position or not. Instead of this, we can generate only the required kind of numbers. e.g. If we genearte numbers in the order of the number of bits in the current number, if we get a binary number <code>110</code> on the way at the step of 3-bit number generation. Now, since this number already contains two consecutive ones, it is useless to generate number with more number of bits with the current bitstream as the suffix(e.g. numbers of the form <code>1110</code> and <code>0110</code>).</p>\n<p>The current approach is based on the above idea. We can start with the LSB position, by placing a <code>0</code> and a <code>1</code> at the LSB. These two initial numbers correspond to the 1-bit numbers which don\'t contain any consecutive ones. Now, taking <code>0</code> as the initial suffix, if we want to generate two bit numbers with no two consecutive 1\'s, we can append a <code>1</code> and a <code>0</code> both in front of the initial <code>0</code> generating the numbers <code>10</code> and <code>00</code> as the two bit numbers ending with a <code>0</code> with no two consecutive 1\'s.</p>\n<p>But, when we take <code>1</code> as the initial suffix, we can append a <code>0</code> to it to generate <code>01</code> which doesn\'t contain any consecutive ones. But, adding a <code>1</code> won\'t satisfy this criteria(<code>11</code> will be generated). Thus, while generating the current number, we need to keep a track of the point that whether a <code>1</code> was added as the last prefix or not. If yes, we can\'t append a new <code>1</code> and only <code>0</code> can be appended. If a <code>0</code> was appended as the last prefix, both <code>0</code> and <code>1</code> can be appended in the new bit-pattern without creating a violating number.\nThus, we can continue forward with the 3-bit number generation only with <code>00</code>, <code>01</code> and <code>10</code> as the new suffixes  in the same manner. </p>\n<p>To get a count of numbers lesser than <script type="math/tex; mode=display">num</script>, with no two consecutive 1\'s, based on the above discussion, we make use of a recursive function <code>find(i, sum, num, prev)</code>. This function returns the count of binary numbers with <script type="math/tex; mode=display">i</script> bits with no two consecutive 1\'s. Here, <script type="math/tex; mode=display">sum</script> refers to the binary number generated till now(the prefix obtained as the input). <script type="math/tex; mode=display">num</script> refers to the given number. <script type="math/tex; mode=display">prev</script> is a boolean variable that indicates whether the last prefix added was a <code>1</code> or a <code>0</code>.</p>\n<p>If the last prefix was a <code>0</code>, we can add both <code>1</code> and <code>0</code> as the new prefix. Thus, we need to make a function call <code>find(i + 1, sum, num, false) + find(i + 1, sum + (1 &lt;&lt; i), num, true)</code>. Here, the first sub-part refers to a <code>0</code> being added at the <script type="math/tex; mode=display">i^{th}</script> position. Thus, we pass a <code>false</code> as the prefix in this case. The second sub-part refers to a <code>1</code> being added at the <script type="math/tex; mode=display">i^{th}</script> position. Thus, we pass <code>true</code> as the prefix in this case. </p>\n<p>If the last prefix was a <code>1</code>, we can add only a <code>0</code> as the new prefix. Thus, only one function call <code>find(i + 1, sum, num, false)</code> is made in this case. </p>\n<p>Further, we need to stop the number generation whenver the current input number(<script type="math/tex; mode=display">sum</script>) exceeds the given number <script type="math/tex; mode=display">num</script>. </p>\n<p><img alt="Tree" src="https://leetcode.com/articles/Figures/600_Non_Negative_2.PNG"></p>\n<iframe frameborder="0" height="292" name="QN3EABd5" src="https://leetcode.com/playground/QN3EABd5/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(x)</script>. Only <script type="math/tex; mode=display">x</script> numbers are generated. Here, <script type="math/tex; mode=display">x</script> refers to the resultant count to be returned.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(log(max\\_int)=32)</script>. The depth of recursion tree can go upto <script type="math/tex; mode=display">32</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-bit-manipulation-accepted">Approach #3 Using Bit Manipulation [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Before we discuss the idea behind this approach, we consider another simple idea that will be used in the current approach. </p>\n<p>Suppose, we need to find the count of binary numbers with <script type="math/tex; mode=display">n</script> bits such that these numbers don\'t contain consecutive 1\'s. In order to do so, we can look at the problem in a recursive fashion. Suppose <script type="math/tex; mode=display">f[i]</script> gives the count of such binary numbers with <script type="math/tex; mode=display">i</script> bits. In order to determine the value of <script type="math/tex; mode=display">f[n]</script>, which is the requirement, we can consider the cases shown below:</p>\n<p><img alt="Recursive_Function" src="https://leetcode.com/articles/Figures/600_Non_Negative_1.png"></p>\n<p>From the above figure, we can see that if we know the value of <script type="math/tex; mode=display">f[n-1]</script> and <script type="math/tex; mode=display">f[n-2]</script>, in order to generate the required binary numbers with <script type="math/tex; mode=display">n</script> bits, we can append a <code>0</code> to all the binary numbers contained in <script type="math/tex; mode=display">f[n-1]</script> without creating an invalid number. These numbers give a factor of <script type="math/tex; mode=display">f[n-1]</script> to be included in <script type="math/tex; mode=display">f[n]</script>. But, we can\'t append a <code>1</code> to all these numbers, since it could lead to the presence of two consecutive ones in the newly generated numbers. Thus, for the currently generated numbers to end with a <code>1</code>, we need to ensure that the second last position is always <code>0</code>. Thus, we need to fix a <code>01</code> at the end of all the numbers contained in <script type="math/tex; mode=display">f[n-2]</script>. This gives a factor of <script type="math/tex; mode=display">f[n-2]</script> to be included in <script type="math/tex; mode=display">f[n]</script>. Thus, in total, we get <script type="math/tex; mode=display">f[n] = f[n-1] + f[n-2]</script>.</p>\n<p>Now, let\'s look into the current approach. We\'ll try to understand the idea behind the approach by taking two simple examples. Firstly, we look at the case where the given number doesn\'t contain any consecutive 1\'s.Say, <script type="math/tex; mode=display">num = \\text{1010100}</script>(7 bit number). Now, we\'ll see how we can find the numbers lesser than <script type="math/tex; mode=display">num</script> with no two consecutive 1\'s. We start off with the MSB of <script type="math/tex; mode=display">nums</script>. If we fix a <script type="math/tex; mode=display">\\text{0}</script> at the MSB position, and find out the count of 6 bit numbers(corresponding to the 6 LSBs) with no two consecutive 1\'s, these 6-bit numbers will lie in the range <script type="math/tex; mode=display">\\textbf{0}\\text{000000} -> \\textbf{0}\\text{111111}</script>. For finding this count we can make use of <script type="math/tex; mode=display">f[6]</script> which we\'ll have already calculated based on the discussion above. </p>\n<p>But, even after doing this, all the numbers in the required range haven\'t been covered yet. Now, if we try to fix <script type="math/tex; mode=display">\\text{1}</script> at the MSB, the numbers considered will lie in the range <script type="math/tex; mode=display">\\textbf{1}\\text{000000} -> \\textbf{1}\\text{111111}</script>. As we can see, this covers the numbers in the range <script type="math/tex; mode=display">\\textbf{1}\\text{000000} -> \\textbf{1}\\text{010100}</script>, but it covers the numbers in the range beyond limit as well. Thus, we can\'t fix <script type="math/tex; mode=display">\\text{1}</script> at the MSB and consider all the 6-bit numbers at the LSBs. </p>\n<p>For covering the pending range, we fix <script type="math/tex; mode=display">\\text{1}</script> at the MSB, and move forward to proceed with the second digit(counting from MSB). Now, since we\'ve already got a <script type="math/tex; mode=display">\\text{0}</script> at this position, we can\'t substitute a <script type="math/tex; mode=display">\\text{1}</script> here, since doing so will lead to generation of numbers exceeding <script type="math/tex; mode=display">num</script>. Thus, the only option left here is to substitute a <script type="math/tex; mode=display">\\text{0}</script> at the second position. But, if we do so, and consider the 5-bit numbers(at the 5 LSBs) with no two consecutive 1\'s, these new numbers will fall in the range <script type="math/tex; mode=display">\\textbf{10}\\text{00000} -> \\textbf{10}\\text{11111}</script>. But, again we can observe that considering these numbers leads to exceeding the required range. Thus, we can\'t consider all the 5-bit numbers for the required count by fixing <script type="math/tex; mode=display">\\text{0}</script> at the second position. </p>\n<p>Thus, now, we fix <script type="math/tex; mode=display">\\text{0}</script> at the second position and proceed further. Again, we encounter a <script type="math/tex; mode=display">\\text{1}</script> at the third position. Thus, as discussed above, we can fix a <script type="math/tex; mode=display">\\text{0}</script> at this position and find out the count of 4-bit consecutive numbers with no two consecutive 1\'s(by varying only the 4 LSB bits). We can obtain this value from <script type="math/tex; mode=display">f[4]</script>. Thus, now the numbers in the range <script type="math/tex; mode=display">\\textbf{100}\\text{0000} -> \\textbf{100}\\text{1111}</script> have been covered up. </p>\n<p>Again, as discussed above, now we fix a <script type="math/tex; mode=display">\\text{1}</script> at the third position, and proceed with the fourth bit. It is a <script type="math/tex; mode=display">\\text{0}</script>. So, we need to fix it as such as per the above discussion, and proceed with the fifth bit. It is a <script type="math/tex; mode=display">\\text{1}</script>. So, we fix a <script type="math/tex; mode=display">\\text{0}</script> here and consider all the numbers by varying the two LSBs for finding the required count of numbers in the range <script type="math/tex; mode=display">\\textbf{10101}\\text{00} -> \\textbf{10101}\\text{11}</script>. Now, we proceed to the sixth bit, find a <script type="math/tex; mode=display">\\text{0}</script> there. So, we fix <script type="math/tex; mode=display">\\text{0}</script> at the sixth position and proceed to the seventh bit which is again <script type="math/tex; mode=display">\\text{0}</script>. So, we fix a <script type="math/tex; mode=display">\\text{0}</script> at the seventh position as well.</p>\n<p>Now, we can see, that based on the above procedure, the numbers in the range <script type="math/tex; mode=display">\\textbf{1}\\text{000000} -> \\textbf{1}\\text{111111}</script>, <script type="math/tex; mode=display">\\textbf{100}\\text{0000} -> \\textbf{100}\\text{1111}</script>,  <script type="math/tex; mode=display">\\textbf{100}\\text{0000} -> \\textbf{100}\\text{1111}</script> have been considered and the counts for these ranges have been obtained as <script type="math/tex; mode=display">f[6]</script>, <script type="math/tex; mode=display">f[4]</script> and <script type="math/tex; mode=display">f[2]</script> respectively. Now, only <script type="math/tex; mode=display">\\text{1010100}</script> is pending to be considered in the required count. Since, it doesn\'t contain any consecutive 1\'s, we add a 1 to the total count obtained till now to consider this number. Thus, the result returned is <script type="math/tex; mode=display">f[6] + f[4] + f[2] + 1</script>.</p>\n<p>!?!../Documents/600_Non_Negative1.json:1000,563!?!</p>\n<p>Now, we look at the case, where <script type="math/tex; mode=display">num</script> contains some consecutive 1\'s. The idea will be the same as the last example, with the only exception taken when the two consecutive 1\'s are encountered. Let\'s say, <script type="math/tex; mode=display">num = \\text{1011010}</script>(7 bit number). Now, as per the last discussion, we start with the MSB. We find a <script type="math/tex; mode=display">\\text{1}</script> at this position. Thus, we initially fix a <script type="math/tex; mode=display">\\text{0}</script> at this position to consider the numbers in the range <script type="math/tex; mode=display">\\textbf{0}\\text{000000} -> \\textbf{0}\\text{111111}</script>, by varying the 6 LSB bits only. The count of the required numbers in this range is again given by <script type="math/tex; mode=display">f[6]</script>.</p>\n<p>Now, we fix a <script type="math/tex; mode=display">\\text{1}</script> at the MSB and move on to the second bit. It is a <script type="math/tex; mode=display">\\text{0}</script>, so we have no choice but to fix <script type="math/tex; mode=display">\\text{0}</script> at this position and to proceed with the third bit. It is a <script type="math/tex; mode=display">\\text{1}</script>, so we fix a <script type="math/tex; mode=display">\\text{0}</script> here, considering the numbers in the range <script type="math/tex; mode=display">\\textbf{100}\\text{0000} -> \\textbf{100}\\text{1111}</script>. This accounts for a factor of <script type="math/tex; mode=display">f[4]</script>. Now, we fix a <script type="math/tex; mode=display">\\text{1}</script> at the third positon, and proceed with the fourth bit. It is a <script type="math/tex; mode=display">\\text{1}</script>(consecutive to the previous <script type="math/tex; mode=display">\\text{1}</script>). Now, initially we fix a <script type="math/tex; mode=display">\\text{0}</script> at the fourth position, considering the numbers in the range <script type="math/tex; mode=display">\\textbf{1010}\\text{000} -> \\textbf{1010}\\text{111}</script>. This adds a factor of <script type="math/tex; mode=display">f[3]</script> to the required count. </p>\n<p>Now, we can see that till now the numbers in the range <script type="math/tex; mode=display">\\textbf{0}\\text{000000} -> \\textbf{0}\\text{111111}</script>, <script type="math/tex; mode=display">\\textbf{100}\\text{0000} -> \\textbf{100}\\text{1111}</script>, <script type="math/tex; mode=display">\\textbf{1010}\\text{000} -> \\textbf{1010}\\text{111}</script> have been considered. But, if we try to consider any number larger than <script type="math/tex; mode=display">\\text{1010111}</script>, it leads to the presence of two consecutive 1\'s in the new number at the third and fourth position. Thus, all the valid numbers upto <script type="math/tex; mode=display">num</script> have been considered with this, giving a resultant count of <script type="math/tex; mode=display">f[6] + f[4] + f[3]</script>.</p>\n<p>!?!../Documents/600_Non_Negative2.json:1000,563!?!</p>\n<p>Thus, summarizing the above discussion, we can say that we start scanning the given number <script type="math/tex; mode=display">num</script> from its MSB. For every 1 encountered at the <script type="math/tex; mode=display">i^{th}</script> bit position(counting from 0 from LSB), we add a factor of <script type="math/tex; mode=display">f[i]</script> to the resultant count. For every 0 encountered, we don\'t add any factor. We also keep a track of the last bit checked. If we happen to find two consecutive 1\'s at any time, we add the factors for the positions of both the 1\'s and stop the traversal immediately. If we don\'t find any two consecutive 1\'s, we proceed till reaching the LSB and add an extra 1 to account for the given number <script type="math/tex; mode=display">num</script> as well, since the procedure discussed above considers numbers upto <script type="math/tex; mode=display">num</script> without including itself.</p>\n<iframe frameborder="0" height="462" name="NbrrZGdh" src="https://leetcode.com/playground/NbrrZGdh/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(log_2(max\\_int)=32)</script>. One loop to fill <script type="math/tex; mode=display">f</script> array and one loop to check all bits of <script type="math/tex; mode=display">num</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(log_2(max\\_int)=32)</script>. <script type="math/tex; mode=display">f</script> array of size 32 is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Pocket Gems'],
  },
  {
    id: '601',
    name: 'Human Traffic of Stadium',
    acceptance: '34.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>X city built a new stadium, each day many people visit it and the stats are saved as these columns: <b>id</b>, <b>date</b>, <b>people</b>\n</p><p>\nPlease write a query to display the records which have 3 or more consecutive rows and the  amount of people more than 100(inclusive).\n</p>\n \nFor example, the table <code>stadium</code>:\n<pre>+------+------------+-----------+\n| id   | date       | people    |\n+------+------------+-----------+\n| 1    | 2017-01-01 | 10        |\n| 2    | 2017-01-02 | 109       |\n| 3    | 2017-01-03 | 150       |\n| 4    | 2017-01-04 | 99        |\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-08 | 188       |\n+------+------------+-----------+\n</pre>\n<p>\nFor the sample data above, the output is:\n</p>\n<pre>+------+------------+-----------+\n| id   | date       | people    |\n+------+------------+-----------+\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-08 | 188       |\n+------+------------+-----------+\n</pre>\n<p>\n<b>Note:</b><br>\nEach day only have one row record, and the dates are increasing with id increasing.\n</p> \n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-join-and-where-clause-accepted">Approach: Using JOIN and WHERE clause [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-join-and-where-clause-accepted">Approach: Using <code>JOIN</code> and <code>WHERE</code> clause [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Select the days with more than 100 people attending the stadium, and join this temp table with itself. We might get the solution after using complex conditions in a <code>WHERE</code> clause.</p>\n<p><strong>Algorithm</strong></p>\n<p>The first step is to get the days with 100 people and join this table with itself.</p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="k">distinct</span> <span class="n">t1</span><span class="p">.</span><span class="o">*</span>\n<span class="k">from</span> <span class="n">stadium</span> <span class="n">t1</span><span class="p">,</span> <span class="n">stadium</span> <span class="n">t2</span><span class="p">,</span> <span class="n">stadium</span> <span class="n">t3</span>\n<span class="k">where</span> <span class="n">t1</span><span class="p">.</span><span class="n">people</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="k">and</span> <span class="n">t2</span><span class="p">.</span><span class="n">people</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="k">and</span> <span class="n">t3</span><span class="p">.</span><span class="n">people</span> <span class="o">&gt;=</span> <span class="mi">100</span>\n<span class="p">;</span>\n</pre></div>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>date</th>\n<th>people</th>\n<th>id</th>\n<th>date</th>\n<th>people</th>\n<th>id</th>\n<th>date</th>\n<th>people</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2017-01-02</td>\n<td>109</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2017-01-03</td>\n<td>150</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2017-01-05</td>\n<td>145</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2017-01-06</td>\n<td>1455</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>7</td>\n<td>2017-01-07</td>\n<td>199</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n<tr>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n<td>8</td>\n<td>2017-01-08</td>\n<td>188</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>Note:\n- There are 6 days with more than 100 people. So there are 216(6<em>6</em>6) records in total after  <a href="https://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a>.\n- The first 3 columns are from t1, and the next 3 ones are from t2, and the last 3 are from t3.</p>\n</blockquote>\n<p>Considering t1, t2 and t3 are identical, we can take one of them to consider what conditions we should add to filter the data and get the final result. Taking t1 for example, it could exist in the beginning of the consecutive 3 days, or the middle, or the last.</p>\n<ul>\n<li>t1 in the beginning: <code>(t1.id - t2.id = 1 and t1.id - t3.id = 2 and t2.id - t3.id =1)  -- t1, t2, t3</code></li>\n<li>t1 in the middle: <code>(t2.id - t1.id = 1 and t2.id - t3.id = 2 and t1.id - t3.id =1) -- t2, t1, t3</code></li>\n<li>t1 in the end: <code>(t3.id - t2.id = 1 and t2.id - t1.id =1 and t3.id - t1.id = 2) -- t3, t2, t1</code></li>\n</ul>\n<p>So if we add these conditions in the SQL code, we can get this.</p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="n">t1</span><span class="p">.</span><span class="o">*</span>\n<span class="k">from</span> <span class="n">stadium</span> <span class="n">t1</span><span class="p">,</span> <span class="n">stadium</span> <span class="n">t2</span><span class="p">,</span> <span class="n">stadium</span> <span class="n">t3</span>\n<span class="k">where</span> <span class="n">t1</span><span class="p">.</span><span class="n">people</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="k">and</span> <span class="n">t2</span><span class="p">.</span><span class="n">people</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="k">and</span> <span class="n">t3</span><span class="p">.</span><span class="n">people</span> <span class="o">&gt;=</span> <span class="mi">100</span>\n<span class="k">and</span>\n<span class="p">(</span>\n      <span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">and</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t3</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">and</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t3</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1">-- t1, t2, t3</span>\n    <span class="k">or</span>\n    <span class="p">(</span><span class="n">t2</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">and</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t3</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">and</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t3</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1">-- t2, t1, t3</span>\n    <span class="k">or</span>\n    <span class="p">(</span><span class="n">t3</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">and</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span><span class="mi">1</span> <span class="k">and</span> <span class="n">t3</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">-- t3, t2, t1</span>\n<span class="p">)</span>\n<span class="p">;</span>\n</pre></div>\n<div class="codehilite"><pre><span></span>| id | date       | people |\n|----|------------|--------|\n| 7  | 2017-01-07 | 199    |\n| 6  | 2017-01-06 | 1455   |\n| 8  | 2017-01-08 | 188    |\n| 7  | 2017-01-07 | 199    |\n| 5  | 2017-01-05 | 145    |\n| 6  | 2017-01-06 | 1455   |\n</pre></div>\n<p>You may notice some records duplicates since they appear in different positions. So, we can use <code>DISTINCT</code> to deal with it.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="k">distinct</span> <span class="n">t1</span><span class="p">.</span><span class="o">*</span>\n<span class="k">from</span> <span class="n">stadium</span> <span class="n">t1</span><span class="p">,</span> <span class="n">stadium</span> <span class="n">t2</span><span class="p">,</span> <span class="n">stadium</span> <span class="n">t3</span>\n<span class="k">where</span> <span class="n">t1</span><span class="p">.</span><span class="n">people</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="k">and</span> <span class="n">t2</span><span class="p">.</span><span class="n">people</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="k">and</span> <span class="n">t3</span><span class="p">.</span><span class="n">people</span> <span class="o">&gt;=</span> <span class="mi">100</span>\n<span class="k">and</span>\n<span class="p">(</span>\n      <span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">and</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t3</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">and</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t3</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1">-- t1, t2, t3</span>\n    <span class="k">or</span>\n    <span class="p">(</span><span class="n">t2</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">and</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t3</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">and</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t3</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1">-- t2, t1, t3</span>\n    <span class="k">or</span>\n    <span class="p">(</span><span class="n">t3</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">and</span> <span class="n">t2</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span><span class="mi">1</span> <span class="k">and</span> <span class="n">t3</span><span class="p">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">-- t3, t2, t1</span>\n<span class="p">)</span>\n<span class="k">order</span> <span class="k">by</span> <span class="n">t1</span><span class="p">.</span><span class="n">id</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '602',
    name: 'Friend Requests II: Who Has the Most Friends ',
    acceptance: '42.1%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            In social network like Facebook or Twitter, people send friend requests and accept others' requests as well.<p></p>\nTable <code>request_accepted</code> holds the data of friend acceptance, while <b>requester_id</b> and <b>accepter_id</b> both are the id of a person.\n<p></p>\n<pre>| requester_id | accepter_id | accept_date|\n|--------------|-------------|------------|\n| 1            | 2           | 2016_06-03 |\n| 1            | 3           | 2016-06-08 |\n| 2            | 3           | 2016-06-08 |\n| 3            | 4           | 2016-06-09 |\n</pre>\n \nWrite a query to find the the people who has most friends and the most friends number. For the sample data above, the result is:\n<pre>| id | num |\n|----|-----|\n| 3  | 3   |\n</pre>\n \n<b>Note:</b>\n<li>It is guaranteed there is only 1 people having the most friends.</li>\n<li>The friend request could only been accepted once, which mean there is no multiple records with the same <b>requester_id</b> and <b>accepter_id</b> value.\n<p></p>\n \n<b>Explanation:</b><br>\nThe person with id '3' is a friend of people '1', '2' and '4', so he has 3 friends in total, which is the most number than any others.<p></p>\n \n<b>Follow-up:</b><br> In the real world, multiple people could have the same most number of friends, can you find all these people in this case?\n\n          </li>",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-union-requester_id-and-accepter_id-accepted">Approach: Union requester_id and accepter_id [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-union-requester_id-and-accepter_id-accepted">Approach: Union <em>requester_id</em> and <em>accepter_id</em> [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Being friends is bidirectional, so if one person accepts a request from another person, both of them will have one more friend.</p>\n<p>Thus, we can union column <em>requester_id</em> and <em>accepter_id</em>, and then count the number of the occurrence of each person.</p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="n">requester_id</span> <span class="k">as</span> <span class="n">ids</span> <span class="k">from</span> <span class="n">request_accepted</span>\n<span class="k">union</span> <span class="k">all</span>\n<span class="k">select</span> <span class="n">accepter_id</span> <span class="k">from</span> <span class="n">request_accepted</span><span class="p">;</span>\n</pre></div>\n<blockquote>\n<p>Note: Here we should use <code>union all</code> instead of <code>union</code> because <code>union all</code> will keep all the records even the \'duplicated\' one.</p>\n</blockquote>\n<p>Taking the sample as an example, the output is:</p>\n<table>\n<thead>\n<tr>\n<th>ids</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n</tr>\n<tr>\n<td>3</td>\n</tr>\n<tr>\n<td>2</td>\n</tr>\n<tr>\n<td>3</td>\n</tr>\n<tr>\n<td>3</td>\n</tr>\n<tr>\n<td>4</td>\n</tr>\n</tbody>\n</table>\n<p>Then it will be fairly easy to get the \'ids\' with most occurrence using the same technique as mentioned in problem <a href="https://leetcode.com/problems/count-student-number-in-departments/#/description">580. Customer Placing the Largest Number of Orders</a>.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="n">ids</span> <span class="k">as</span> <span class="n">id</span><span class="p">,</span> <span class="n">cnt</span> <span class="k">as</span> <span class="n">num</span>\n<span class="k">from</span>\n<span class="p">(</span>\n<span class="k">select</span> <span class="n">ids</span><span class="p">,</span> <span class="nf">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">as</span> <span class="n">cnt</span>\n   <span class="k">from</span>\n   <span class="p">(</span>\n        <span class="k">select</span> <span class="n">requester_id</span> <span class="k">as</span> <span class="n">ids</span> <span class="k">from</span> <span class="n">request_accepted</span>\n        <span class="k">union</span> <span class="k">all</span>\n        <span class="k">select</span> <span class="n">accepter_id</span> <span class="k">from</span> <span class="n">request_accepted</span>\n    <span class="p">)</span> <span class="k">as</span> <span class="n">tbl1</span>\n   <span class="k">group</span> <span class="k">by</span> <span class="n">ids</span>\n   <span class="p">)</span> <span class="k">as</span> <span class="n">tbl2</span>\n<span class="k">order</span> <span class="k">by</span> <span class="n">cnt</span> <span class="k">desc</span>\n<span class="k">limit</span> <span class="mi">1</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '603',
    name: 'Consecutive Available Seats ',
    acceptance: '54.8%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            Several friends at a cinema ticket office would like to reserve consecutive available seats.<br>\nCan you help to query all the consecutive available seats order by the seat_id using the following <code>cinema</code> table?\n\n<pre>| seat_id | free |\n|---------|------|\n| 1       | 1    |\n| 2       | 0    |\n| 3       | 1    |\n| 4       | 1    |\n| 5       | 1    |\n</pre><p></p>\n\nYour query should return the following result for the sample case above.<p></p>\n<pre>| seat_id |\n|---------|\n| 3       |\n| 4       |\n| 5       |\n</pre>\n\n<b>Note</b>:\n<li>The seat_id is an auto increment int, and free is bool ('1' means free, and '0' means occupied.).</li>\n<li>Consecutive available seats are more than 2(inclusive) seats consecutively available.</li>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-self-join-and-absaccepted">Approach: Using self join and abs()[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-self-join-and-absaccepted">Approach: Using self <code>join</code> and <code>abs()</code>[Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>There is only one table in this problem, so we probably need to use <strong>self join</strong> for this relative complex problem.</p>\n<p><strong>Algorithm</strong></p>\n<p>First, let\'s see what we have after joining this table with itself.</p>\n<blockquote>\n<p>Note: The result of join two tables is the <a href="https://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a> of these two tables.</p>\n</blockquote>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="n">a</span><span class="p">.</span><span class="n">seat_id</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="k">free</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">seat_id</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="k">free</span>\n<span class="k">from</span> <span class="n">cinema</span> <span class="n">a</span> <span class="k">join</span> <span class="n">cinema</span> <span class="n">b</span><span class="p">;</span>\n</pre></div>\n<table>\n<thead>\n<tr>\n<th>seat_id</th>\n<th>free</th>\n<th>seat_id</th>\n<th>free</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>2</td>\n<td>0</td>\n</tr>\n<tr>\n<td>2</td>\n<td>0</td>\n<td>2</td>\n<td>0</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1</td>\n<td>2</td>\n<td>0</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1</td>\n<td>2</td>\n<td>0</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1</td>\n<td>2</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>0</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>0</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>0</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1</td>\n<td>5</td>\n<td>1</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1</td>\n<td>5</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>To find the consecutive available seats, the value in the a.seat_id should be more(or less) than the value b.seat_id, and both of them should be free.</p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="n">a</span><span class="p">.</span><span class="n">seat_id</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="k">free</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">seat_id</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="k">free</span>\n<span class="k">from</span> <span class="n">cinema</span> <span class="n">a</span> <span class="k">join</span> <span class="n">cinema</span> <span class="n">b</span>\n  <span class="k">on</span> <span class="k">abs</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">seat_id</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">seat_id</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>\n  <span class="k">and</span> <span class="n">a</span><span class="p">.</span><span class="k">free</span> <span class="o">=</span> <span class="k">true</span> <span class="k">and</span> <span class="n">b</span><span class="p">.</span><span class="k">free</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>\n</pre></div>\n<table>\n<thead>\n<tr>\n<th>seat_id</th>\n<th>free</th>\n<th>seat_id</th>\n<th>free</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>4</td>\n<td>1</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3</td>\n<td>1</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1</td>\n<td>4</td>\n<td>1</td>\n</tr>\n<tr>\n<td>4</td>\n<td>1</td>\n<td>5</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>At last, choose the concerned column seat_id, and display the result ordered by seat_id.</p>\n<blockquote>\n<p>Note: You may notice that the seat with <em>seat_id</em> \'4\' appears twice in this table. This is because seat \'4\' next to \'3\' and also next to \'5\'. So we need to use <code>distinct</code> to filter the duplicated records.</p>\n</blockquote>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="k">distinct</span> <span class="n">a</span><span class="p">.</span><span class="n">seat_id</span>\n<span class="k">from</span> <span class="n">cinema</span> <span class="n">a</span> <span class="k">join</span> <span class="n">cinema</span> <span class="n">b</span>\n  <span class="k">on</span> <span class="k">abs</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">seat_id</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">seat_id</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>\n  <span class="k">and</span> <span class="n">a</span><span class="p">.</span><span class="k">free</span> <span class="o">=</span> <span class="k">true</span> <span class="k">and</span> <span class="n">b</span><span class="p">.</span><span class="k">free</span> <span class="o">=</span> <span class="k">true</span>\n<span class="k">order</span> <span class="k">by</span> <span class="n">a</span><span class="p">.</span><span class="n">seat_id</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '604',
    name: 'Design Compressed String Iterator ',
    acceptance: '32.6%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>\nDesign and implement a data structure for a compressed string iterator. It should support the following operations: <code>next</code> and <code>hasNext</code>.\n</p>\n\n<p>\nThe given compressed string will be in the form of each letter followed by a positive integer representing the number of this letter existing in the original uncompressed string.\n</p>\n\n<p>\n<code>next()</code> - if the original string still has uncompressed characters, return the next letter; Otherwise return a white space.<br>\n<code>hasNext()</code> - Judge whether there is any letter needs to be uncompressed.\n</p>\n\n<p>\n<b>Note:</b><br>\nPlease remember to <b>RESET</b> your class variables declared in StringIterator, as static/class variables are <b>persisted across multiple test cases</b>. Please see <a href=\"https://leetcode.com/faq/#different-output\">here</a> for more details.\n</p>\n\n\n<p><b>Example:</b>\n</p><pre>StringIterator iterator = new StringIterator(\"L1e2t1C1o1d1e1\");\n\niterator.next(); // return 'L'\niterator.next(); // return 'e'\niterator.next(); // return 'e'\niterator.next(); // return 't'\niterator.next(); // return 'C'\niterator.next(); // return 'o'\niterator.next(); // return 'd'\niterator.hasNext(); // return true\niterator.next(); // return 'e'\niterator.hasNext(); // return false\niterator.next(); // return ' '\n</pre>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-uncompressing-the-string-time-limit-exceeded">Approach #1 Uncompressing the String [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-pre-computation-accepted">Approach #2  Pre-Computation [Accepted]</a></li>\n<li><a href="#approach-3-demand-computation-accepted">Approach #3  Demand-Computation [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<h4 id="approach-1-uncompressing-the-string-time-limit-exceeded">Approach #1 Uncompressing the String [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, we make use of precomputation. We already form the uncompressed string and append the uncompressed letters for each compressed letter in the <script type="math/tex; mode=display">compressedString</script> to the <script type="math/tex; mode=display">res</script> stringbuilder. To find the uncompressed strings to be stored in <script type="math/tex; mode=display">res</script>, we traverse over the given <script type="math/tex; mode=display">compressedString</script>. Whenver we find an alphabet, we find the number following it by making use of decimal mathematics. Thus, we get the two elements(alphabet and the count) required for forming the current constituent of the uncompressed string.</p>\n<p>Now, we\'ll look at how the <code>next()</code> and <code>hasNext()</code> operations are performed:</p>\n<ol>\n<li>\n<p><code>next()</code>: We start off by checking if the compressed string has more uncompressed letters pending. If not, <code>hasNext()</code> returns a False value and <code>next()</code> returns a \' \'. Otherwise, we return the letter pointed by <script type="math/tex; mode=display">ptr</script>, which indicates the next letter to be returned. Before returning the letter, we also update the <script type="math/tex; mode=display">ptr</script> to point to the next letter in <script type="math/tex; mode=display">res</script>.</p>\n</li>\n<li>\n<p><code>hasNext()</code>: If the pointer <script type="math/tex; mode=display">ptr</script> reaches beyond the end of <script type="math/tex; mode=display">res</script> array, it indicates that no more uncompressed letters are left beyond the current index pointed by <script type="math/tex; mode=display">ptr</script>. Thus, we return a False in this case. Otherwise, we return a True value.</p>\n</li>\n</ol>\n<iframe frameborder="0" height="479" name="fddFPkFm" src="https://leetcode.com/playground/fddFPkFm/shared" width="100%"></iframe>\n<p><strong>Performance Analysis</strong></p>\n<ul>\n<li>\n<p>We precompute the elements of the uncompressed string. Thus, the space required in this case is <script type="math/tex; mode=display">O(m)</script>, where <script type="math/tex; mode=display">m</script> refers to the length of the uncompressed string.</p>\n</li>\n<li>\n<p>The time required for precomputation is <script type="math/tex; mode=display">O(m)</script> since we need to generate the uncompressed string of length <script type="math/tex; mode=display">m</script>.</p>\n</li>\n<li>\n<p>Once the precomputation has been done, the time required for performing <code>next()</code> and <code>hasNext()</code> is <script type="math/tex; mode=display">O(1)</script> for both.</p>\n</li>\n<li>\n<p>This approach can be easily extended to include <code>previous()</code>, <code>last()</code> and <code>find()</code> operations. All these operations require the use an index only and thus, take <script type="math/tex; mode=display">O(1)</script> time. Operations like <code>hasPrevious()</code> can also be easily included.</p>\n</li>\n<li>\n<p>Since, once the precomputation has been done, <code>next()</code> requires <script type="math/tex; mode=display">O(1)</script> time, this approach is useful if <code>next()</code> operation needs to be performed a large number of times. However, if <code>hasNext()</code> is performed most of the times, this approach isn\'t much advantageous since precomputation needs to be done anyhow.</p>\n</li>\n<li>\n<p>A potential problem with this approach could arise if the length of the uncompressed string is very large. In such a case, the size of the complete uncompressed string could become so large that it can\'t fit in the memory limits, leading to memory overflow.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-pre-computation-accepted">Approach #2  Pre-Computation [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, firstly, we split the given <script type="math/tex; mode=display">compressedString</script> based on  numbers(0-9) and store the values(alphabets) obtained in <script type="math/tex; mode=display">chars</script> array. We also split the <script type="math/tex; mode=display">compressedString</script> based on the alphabets(a-z, A-Z) and store the numbers(in the form of a string) in a <script type="math/tex; mode=display">nums</script> array(after converting the strings obtained into integers). We do the splitting by making use of regular expression matching.</p>\n<p>A regular expression is a special sequence of letters that helps you match or find other strings or sets of strings, using a specialized syntax held in a pattern. They can be used to search, edit, or manipulate text and data.</p>\n<p>This splitting using regex is done as a precomputation step. Now we\'ll look at how the <code>next()</code> and <code>hasNext()</code> operations are implemented.</p>\n<ol>\n<li>\n<p><code>next()</code>: Every time the <code>next()</code> operation is performed, firstly we check if there are any more letters to be uncompressed. We check it by making use of <code>hasNext()</code> function. If there aren\'t any more letters left, we return a \' \'. We make use of a pointer <script type="math/tex; mode=display">ptr</script> to keep a track of the letter in the <script type="math/tex; mode=display">compressedString</script> that needs to be returned next. If there are more letters left in the uncompressed string, we return the current letter pointed to by <script type="math/tex; mode=display">ptr</script>. But, before returning this letter, we also decrement the <script type="math/tex; mode=display">nums[ptr]</script> entry to indicate that the current letter is pending in the uncompressed string by one lesser count. On decrementing this entry, if it becomes zero, it indicates that no more instances of the current letter exist in the uncompressed string. Thus, we update the pointer <script type="math/tex; mode=display">ptr</script> to point to the next letter.</p>\n</li>\n<li>\n<p><code>hasNext()</code>: For performing <code>hasNext()</code> operation, we simply need to check if the <script type="math/tex; mode=display">ptr</script> has already reached beyong the end of <script type="math/tex; mode=display">chars</script> array. If so, it indicates that no more compressed letters exist in the <script type="math/tex; mode=display">compressedString</script>. Hence, we return a False value in this case. Otherwise, more compressed letters exist. Hence, we return a True value in this case.</p>\n</li>\n</ol>\n<iframe frameborder="0" height="428" name="rRUsHDy3" src="https://leetcode.com/playground/rRUsHDy3/shared" width="100%"></iframe>\n<p><strong>Performance Analysis</strong></p>\n<ul>\n<li>\n<p>The space required for storing the results of the precomputation is <script type="math/tex; mode=display">O(n)</script>, where <script type="math/tex; mode=display">n</script> refers to the length of the compressed string. The <script type="math/tex; mode=display">nums</script> and <script type="math/tex; mode=display">chars</script> array contain a total of <script type="math/tex; mode=display">n</script> elements.</p>\n</li>\n<li>\n<p>The precomputation step requires <script type="math/tex; mode=display">O(n)</script> time. Thus, if <code>hasNext()</code> operation is performed most of the times, this precomputation turns out to be non-advantageous.</p>\n</li>\n<li>\n<p>Once the precomputation has been done, <code>hasNext()</code> and <code>next()</code> requires <script type="math/tex; mode=display">O(1)</script> time. </p>\n</li>\n<li>\n<p>This approach can be extended to include the <code>previous()</code> and  <code>hasPrevious()</code> operations, but that would require making some simple modifications to the current implementation.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-demand-computation-accepted">Approach #3  Demand-Computation [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, we don\'t make use of regex for finding the individual components of the given <script type="math/tex; mode=display">compressedString</script>. We do not perform any form of precomputation. Whenever an operation needs to be performed, the required results are generated from the scratch. Thus, the operations are performed only on demand.</p>\n<p>Let\'s look at the implementation of the required operations:</p>\n<ol>\n<li>\n<p><code>next()</code>: We make use of a global pointer <script type="math/tex; mode=display">ptr</script> to keep a track of which compressed letter in the <script type="math/tex; mode=display">compressedString</script> needs to be processed next. We also make use of a global variable <script type="math/tex; mode=display">num</script> to keep a track of the number of instances of the current letter which are still pending. Whenever <code>next()</code> operation needs to be performed, firstly, we check if there are more uncompressed letters left in the <script type="math/tex; mode=display">compressedString</script>. If not, we return a \' \'. Otherwise, we check if there are more instances of the current letter still pending. If so, we directly decrement the count of instances indicated by <script type="math/tex; mode=display">nums</script> and return the current letter. But, if there aren\'t more instances pending for the current letter, we update the <script type="math/tex; mode=display">ptr</script> to point to the next letter in the <script type="math/tex; mode=display">compressedString</script>. We also update the <script type="math/tex; mode=display">num</script> by obtaining the count for the next letter from the <script type="math/tex; mode=display">compressedString</script>. This number is obtained by making use of decimal arithmetic.</p>\n</li>\n<li>\n<p><code>hasNext()</code>: If the pointer <script type="math/tex; mode=display">ptr</script> has reached beyond the last index of the <script type="math/tex; mode=display">compressedString</script> and <script type="math/tex; mode=display">num</script> becomes, it indicates that no more uncompressed letters exist in the compressed string. Hence, we return a False in this case. Otherwise, a True value is returned indicating that more compressed letters exist in the <script type="math/tex; mode=display">compressedString</script>.</p>\n</li>\n</ol>\n<iframe frameborder="0" height="479" name="nto5MsQu" src="https://leetcode.com/playground/nto5MsQu/shared" width="100%"></iframe>\n<p><strong>Performance Analysis</strong></p>\n<ul>\n<li>\n<p>Since no precomputation is done, constant space is required in this case.</p>\n</li>\n<li>\n<p>The time required to perform <code>next()</code> operation is <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n<li>\n<p>The time required for <code>hasNext()</code> operation is <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n<li>\n<p>Since no precomputations are done, and <code>hasNext()</code> requires only <script type="math/tex; mode=display">O(1)</script> time, this solution is advantageous if <code>hasNext()</code> operation is performed most of the times.</p>\n</li>\n<li>\n<p>This approach can be extended to include <code>previous()</code> and <code>hasPrevious()</code> operationsm, but this will require the use of some additional variables.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '605',
    name: 'Can Place Flowers',
    acceptance: '30.2%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.</p>\n\n<p>Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number <b>n</b>, return if <b>n</b> new flowers can be planted in it without violating the no-adjacent-flowers rule.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> flowerbed = [1,0,0,0,1], n = 1\n<b>Output:</b> True\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> flowerbed = [1,0,0,0,1], n = 2\n<b>Output:</b> False\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The input array won't violate no-adjacent-flowers rule.</li>\n<li>The input array size is in the range of [1, 20000].</li>\n<li><b>n</b> is a non-negative integer which won't exceed the input array size.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-single-scan-accepted">Approach #1 Single Scan [Accepted]</a></li>\n<li><a href="#approach-2-optimized-accepted">Approach #2 Optimized [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-single-scan-accepted">Approach #1 Single Scan [Accepted]</h4>\n<p>The solution is very simple. We can find out the extra maximum number of flowers, <script type="math/tex; mode=display">count</script>, that can be planted for the given <script type="math/tex; mode=display">flowerbed</script> arrangement. To do so, we can traverse over all the elements of the <script type="math/tex; mode=display">flowerbed</script> and find out those elements which are 0(implying an empty position). For every such element, we check if its both adjacent positions are also empty. If so, we can plant a flower at the current position without violating the no-adjacent-flowers-rule. For the first and last elements, we need not check the previous and the next adjacent positions respectively.</p>\n<p>If the <script type="math/tex; mode=display">count</script> obtained is greater than or equal to <script type="math/tex; mode=display">n</script>, the required number of flowers to be planted, we can plant <script type="math/tex; mode=display">n</script> flowers in the empty spaces, otherwise not.</p>\n<iframe frameborder="0" height="292" name="Dbm5A5CN" src="https://leetcode.com/playground/Dbm5A5CN/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. A single scan of the <script type="math/tex; mode=display">flowerbed</script> array of size <script type="math/tex; mode=display">n</script> is done.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-optimized-accepted">Approach #2 Optimized [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of finding the maximum value of <script type="math/tex; mode=display">count</script> that can be obtained, as done in the last approach, we can stop the process of checking the positions for planting the flowers as soon as <script type="math/tex; mode=display">count</script> becomes equal to <script type="math/tex; mode=display">n</script>. Doing this leads to an optimization of the first approach. If <script type="math/tex; mode=display">count</script> never becomes equal to <script type="math/tex; mode=display">n</script>, <script type="math/tex; mode=display">n</script> flowers can\'t be planted at the empty positions.</p>\n<iframe frameborder="0" height="326" name="GtCBiouS" src="https://leetcode.com/playground/GtCBiouS/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. A single scan of the <script type="math/tex; mode=display">flowerbed</script> array of size <script type="math/tex; mode=display">n</script> is done.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '606',
    name: 'Construct String from Binary Tree',
    acceptance: '49.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.</p>\n\n<p>The null node needs to be represented by empty parenthesis pair "()". And you need to omit all the empty parenthesis pairs that don\'t affect the one-to-one mapping relationship between the string and the original binary tree.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> Binary tree: [1,2,3,4]\n       1\n     /   \\\n    2     3\n   /    \n  4     \n\n<b>Output:</b> "1(2(4))(3)"\n<br><b>Explanation:</b> Originallay it needs to be "1(2(4)())(3()())", <br>but you need to omit all the unnecessary empty parenthesis pairs. <br>And it will be "1(2(4))(3)".\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> Binary tree: [1,2,3,null,4]\n       1\n     /   \\\n    2     3\n     \\  \n      4 \n\n<b>Output:</b> "1(2()(4))(3)"\n<br><b>Explanation:</b> Almost the same as the first example, <br>except we can\'t omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</a></li>\n<li><a href="#approach-2-iterative-method-using-stack-accepted">Approach #2 Iterative Method Using stack [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</h4>\n<p>This solution is very simple. We simply need to do the preorder traversal of the given Binary Tree. But, along with this, we need to make use of braces at appropriate positions. But, we also need to make sure that we omit the unnecessary braces. To do the preorder traversal, we make use of recursion. We print the current node and call the same given function for the left and the right children of the node in that order(if they exist). For every node encountered, the following cases are possible.</p>\n<p>Case 1: Both the left child and the right child exist for the current node. In this case, we need to put the braces <code>()</code> around both the left child\'s preorder traversal output and the right child\'s preorder traversal output.</p>\n<p>Case 2: None of the left or the right child exist for the current node. In this case, as shown in the figure below, considering empty braces for the null left and right children is redundant. Hence, we need not put braces for any of them.</p>\n<p align="center"><img alt="No_child" src="https://leetcode.com/articles/Figures/606/606_Case2.PNG"></p>\n<p>Case 3: Only the left child exists for the current node. As the figure below shows, putting empty braces for the right child in this case is unnecessary while considering the preorder traversal. This is because the right child will always come after the left child in the preorder traversal. Thus, omitting the empty braces for the right child also leads to same mapping between the string and the binary tree.</p>\n<p align="center"><img alt="Left_child" src="https://leetcode.com/articles/Figures/606/606_Case3.PNG"></p>\n<p>Case 4: Only the right child exists for the current node. In this case, we need to consider the empty braces for the left child. This is because, during the preorder traversal, the left child needs to be considered first. Thus, to indicate that the child following the current node is a right child we need to put a pair of empty braces for the left child. </p>\n<p align="center"><img alt="Right_child" src="https://leetcode.com/articles/Figures/606/606_Case4.PNG"></p>\n<p>Just by taking care of the cases, mentioned above, we can obtain the required output string.</p>\n<iframe frameborder="0" height="411" name="AQ3oFiCv" src="https://leetcode.com/playground/AQ3oFiCv/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The preorder traversal is done over the <script type="math/tex; mode=display">n</script> nodes of the given Binary Tree.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of the recursion tree can go upto <script type="math/tex; mode=display">n</script> in case of a skewed tree.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-iterative-method-using-stack-accepted">Approach #2 Iterative Method Using stack [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In order to solve the given problem, we can also make use of a <script type="math/tex; mode=display">stack</script>. To see how to do it, we\'ll go through the implementation and we\'ll also look at the idea behind each step.</p>\n<p>We make use of a <script type="math/tex; mode=display">stack</script> onto which various nodes of the given tree will be pushed during the process. The node at the top of the <script type="math/tex; mode=display">stack</script> represents the current node to be processed. Whenever a node has been processed once, it is marked as visited. The reasoning behind this will be discussed soon. </p>\n<p>We start off by pushing the root of the binary tree onto the <script type="math/tex; mode=display">stack</script>. Now, the root acts as the current node. For every current node encountered, firstly, we check if it has not been visited already. If not, we add it to the set of visited nodes. </p>\n<p>Since, for the preorder traversal, we know, we need to process the nodes in the order current-left-right. Thus, we add a <code>(</code> followed by the current node to the string <script type="math/tex; mode=display">s</script> to be returned. </p>\n<p>Now, if both the left and the right children of the current node exist, we need to process them in the order left-right. To do so, we need to push them onto the <script type="math/tex; mode=display">stack</script> in the reverse order, so that when they are picked up later on, their order of processing gets corrected.</p>\n<p>Since we\'ve already added <script type="math/tex; mode=display">(current\\_node</script> to the string <script type="math/tex; mode=display">s</script>, if only the right child of the current node exists, as discussed in case 4 in the last approach, we need to put a <code>()</code> in <script type="math/tex; mode=display">s</script> representing the null left node. We need not push anything onto the <script type="math/tex; mode=display">stack</script> for the left node and we can directly add the <code>()</code> to <script type="math/tex; mode=display">s</script> for this. But, we still need to push the right child onto the <script type="math/tex; mode=display">stack</script> for future processing. </p>\n<p>If only the left child exists, we need not consider the right child at all, as discussed in case 3 in the last approach. We can continue the process by just pushing the left child onto the <script type="math/tex; mode=display">stack</script>.</p>\n<p>Now, we need to note that even when a node is being processed, if it has not already been visited, it isn\'t popped off from the <script type="math/tex; mode=display">stack</script>. But, if a node that has already been processed(i.e. its children have been considered already), it is popped off from the <script type="math/tex; mode=display">stack</script> when encountered again. Such a situation will occur for a node only when the preorder traversal of both its left and right sub-trees has been completely done. Thus, we need to add a <code>)</code> to mark the end of the preorder traversal of the current node as well.</p>\n<p>Thus, at the end, we get the required pre-order traversal in the substring <script type="math/tex; mode=display">s(1:n-1)</script>. Here, <script type="math/tex; mode=display">n</script> represents the length of <script type="math/tex; mode=display">s</script>. This is because, we need not put the parentheses(redundant) at the outermost level.</p>\n<p>The following animation better depicts the process.</p>\n<p>!?!../Documents/Construct_Binary_Tree_stack.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="qvqkT2qU" src="https://leetcode.com/playground/qvqkT2qU/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">n</script> nodes are pushed and popped in a stack.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">stack</script> size can grow upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '607',
    name: 'Sales Person ',
    acceptance: '49.7%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p><b>Description</b></p>\n<p>\nGiven three tables: <code>salesperson</code>, <code>company</code>, <code>orders</code>.<br>\nOutput all the <b>names</b> in the table <code>salesperson</code>, who didn’t have sales to company 'RED'.\n</p><p>\n<b>Example</b><br>\n<b>Input</b>\n</p><p>\nTable: <code>salesperson</code>\n</p>\n<pre>+----------+------+--------+-----------------+-----------+\n| sales_id | name | salary | commission_rate | hire_date |\n+----------+------+--------+-----------------+-----------+\n|   1      | John | 100000 |     6           | 4/1/2006  |\n|   2      | Amy  | 120000 |     5           | 5/1/2010  |\n|   3      | Mark | 65000  |     12          | 12/25/2008|\n|   4      | Pam  | 25000  |     25          | 1/1/2005  |\n|   5      | Alex | 50000  |     10          | 2/3/2007  |\n+----------+------+--------+-----------------+-----------+\n</pre>\nThe table <code>salesperson</code> holds the salesperson information. Every salesperson has a <b>sales_id</b> and a <b>name</b>.<br>\n<p>\nTable: <code>company</code>\n</p>\n<pre>+---------+--------+------------+\n| com_id  |  name  |    city    |\n+---------+--------+------------+\n|   1     |  RED   |   Boston   |\n|   2     | ORANGE |   New York |\n|   3     | YELLOW |   Boston   |\n|   4     | GREEN  |   Austin   |\n+---------+--------+------------+\n</pre>\nThe table <code>company</code> holds the company information. Every company has a <b>com_id</b> and a <b>name</b>.<br>\n<p>\nTable: <code>orders</code>\n</p>\n<pre>+----------+----------+---------+----------+--------+\n| order_id |  date    | com_id  | sales_id | amount |\n+----------+----------+---------+----------+--------+\n| 1        | 1/1/2014 |    3    |    4     | 100000 |\n| 2        | 2/1/2014 |    4    |    5     | 5000   |\n| 3        | 3/1/2014 |    1    |    1     | 50000  |\n| 4        | 4/1/2014 |    1    |    4     | 25000  |\n+----------+----------+---------+----------+--------+\n</pre>\nThe table <code>orders</code> holds the sales record information, salesperson and customer  company are represented by <b>sales_id</b> and <b>com_id</b>.<br>\n\n<p>\n<b>output</b> \n</p>\n<pre>+------+\n| name | \n+------+\n| Amy  | \n| Mark | \n| Alex |\n+------+\n</pre>\n<p>\n<b>Explanation</b>\n</p><p>\nAccording to order '3' and '4' in table <code>orders</code>, it is easy to tell only salesperson 'John' and 'Alex' have sales to company 'RED',<br>so we need to output all the other <b>names</b> in table <code>salesperson</code>.\n</p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-outer-join-and-not-in-accepted">Approach: Using OUTER JOIN and NOT IN [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-outer-join-and-not-in-accepted">Approach: Using <code>OUTER JOIN</code> and <code>NOT IN</code> [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we know all the persons who have sales in this company \'RED\', it will be fairly easy to know who do not have.</p>\n<p><strong>Algorithm</strong></p>\n<p>To start, we can query the information of sales in company \'RED\' as a temporary table. And then try to build a connection between this table and the <strong>salesperson</strong> table since it has the name information.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="o">*</span>\n<span class="k">FROM</span>\n    <span class="n">orders</span> <span class="n">o</span>\n        <span class="k">LEFT</span> <span class="k">JOIN</span>\n    <span class="n">company</span> <span class="k">c</span> <span class="k">ON</span> <span class="n">o</span><span class="p">.</span><span class="n">com_id</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">com_id</span>\n<span class="k">WHERE</span>\n    <span class="k">c</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">\'RED\'</span>\n<span class="p">;</span>\n</pre></div>\n<blockquote>\n<p>Note: "LEFT OUTER JOIN" could be written as "LEFT JOIN".</p>\n</blockquote>\n<div class="codehilite"><pre><span></span>| order_id | date     | com_id | sales_id | amount | com_id | name | city   |\n|----------|----------|--------|----------|--------|--------|------|--------|\n| 3        | 3/1/2014 | 1      | 1        | 50000  | 1      | RED  | Boston |\n| 4        | 4/1/2014 | 1      | 4        | 25000  | 1      | RED  | Boston |\n</pre></div>\n<p>Obviously, the column <em>sales_id</em> exists in table <strong>salesperson</strong> so we may use it as a subquery, and then utilize the <a href="https://dev.mysql.com/doc/refman/5.7/en/any-in-some-subqueries.html"><code>NOT IN</code></a> to get the target data.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">s</span><span class="p">.</span><span class="n">name</span>\n<span class="k">FROM</span>\n    <span class="n">salesperson</span> <span class="n">s</span>\n<span class="k">WHERE</span>\n    <span class="n">s</span><span class="p">.</span><span class="n">sales_id</span> <span class="k">NOT</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span>\n            <span class="n">o</span><span class="p">.</span><span class="n">sales_id</span>\n        <span class="k">FROM</span>\n            <span class="n">orders</span> <span class="n">o</span>\n                <span class="k">LEFT</span> <span class="k">JOIN</span>\n            <span class="n">company</span> <span class="k">c</span> <span class="k">ON</span> <span class="n">o</span><span class="p">.</span><span class="n">com_id</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">com_id</span>\n        <span class="k">WHERE</span>\n            <span class="k">c</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">\'RED\'</span><span class="p">)</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '608',
    name: 'Tree Node ',
    acceptance: '54.3%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nGiven a table <code>tree</code>, <b>id</b> is identifier of the tree node and <b>p_id</b> is its parent node's <b>id</b>.\n</p>\n \n<pre>+----+------+\n| id | p_id |\n+----+------+\n| 1  | null |\n| 2  | 1    |\n| 3  | 1    |\n| 4  | 2    |\n| 5  | 2    |\n+----+------+\n</pre>\n \nEach node in the tree can be one of three types:<br>\n<li>Leaf: if the node is a leaf node.</li>\n<li>Root: if the node is the root of the tree.</li>\n<li>Inner: If the node is neither a leaf node nor a root node.</li><p></p>\n \nWrite a query to print the node id and the type of the node. Sort your output by the node id. The result for the above sample is:<p></p>\n \n<pre>+----+------+\n| id | Type |\n+----+------+\n| 1  | Root |\n| 2  | Inner|\n| 3  | Leaf |\n| 4  | Leaf |\n| 5  | Leaf |\n+----+------+\n</pre>\n<p></p>\n \n<p>\n<b>Explanation</b>\n</p>\n<p>\n</p><li>Node '1' is root node, because its parent node is NULL and it has child node '2' and '3'.</li>\n<li>Node '2' is inner node, because it has parent node '1' and child node '4' and '5'.</li>\n<li>Node '3', '4' and '5' is Leaf node, because they have parent node and they don't have child node.</li>\n<br>\nAnd here is the image of the sample tree as below:\n<p></p>\n<pre>\t\t\t  1\n\t\t\t/   \\\n                      2       3\n                    /   \\\n                  4       5\n</pre>\n\n<p>\n<b>Note</b>\n</p>\n<p>\nIf there is only one node on the tree, you only need to output its root attributes.\n</p>\n\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-i-using-union-accepted">Approach I: Using UNION [Accepted]</a></li>\n<li><a href="#approach-ii-using-flow-control-statement-case-accepted">Approach II: Using flow control statement CASE [Accepted]</a></li>\n<li><a href="#approach-iii-using-if-function-accepted">Approach III: Using IF function [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-i-using-union-accepted">Approach I: Using <code>UNION</code> [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can print the node type by judging every record by its definition in this table.\n<em> Root: it does not have a parent node at all\n</em> Inner: it is the parent node of some nodes, and it has a not NULL parent itself.\n* Leaf: rest of the cases other than above two</p>\n<p><strong>Algorithm</strong></p>\n<p>By transiting the node type definition, we can have the following code.</p>\n<p>For the root node, it does not have a parent.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">id</span><span class="p">,</span> <span class="s1">\'Root\'</span> <span class="k">AS</span> <span class="k">Type</span>\n<span class="k">FROM</span>\n    <span class="n">tree</span>\n<span class="k">WHERE</span>\n    <span class="n">p_id</span> <span class="k">IS</span> <span class="k">NULL</span>\n</pre></div>\n<p>For the leaf nodes, they do not have any children, and it has a parent.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">id</span><span class="p">,</span> <span class="s1">\'Leaf\'</span> <span class="k">AS</span> <span class="k">Type</span>\n<span class="k">FROM</span>\n    <span class="n">tree</span>\n<span class="k">WHERE</span>\n    <span class="n">id</span> <span class="k">NOT</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">DISTINCT</span>\n            <span class="n">p_id</span>\n        <span class="k">FROM</span>\n            <span class="n">tree</span>\n        <span class="k">WHERE</span>\n            <span class="n">p_id</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">)</span>\n        <span class="k">AND</span> <span class="n">p_id</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span>\n</pre></div>\n<p>For the inner nodes, they have have some children and a parent.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">id</span><span class="p">,</span> <span class="s1">\'Inner\'</span> <span class="k">AS</span> <span class="k">Type</span>\n<span class="k">FROM</span>\n    <span class="n">tree</span>\n<span class="k">WHERE</span>\n    <span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">DISTINCT</span>\n            <span class="n">p_id</span>\n        <span class="k">FROM</span>\n            <span class="n">tree</span>\n        <span class="k">WHERE</span>\n            <span class="n">p_id</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">)</span>\n        <span class="k">AND</span> <span class="n">p_id</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span>\n</pre></div>\n<p>So, one solution to the problem is to combine these cases together using <code>UNION</code>.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">id</span><span class="p">,</span> <span class="s1">\'Root\'</span> <span class="k">AS</span> <span class="k">Type</span>\n<span class="k">FROM</span>\n    <span class="n">tree</span>\n<span class="k">WHERE</span>\n    <span class="n">p_id</span> <span class="k">IS</span> <span class="k">NULL</span>\n\n<span class="k">UNION</span>\n\n<span class="k">SELECT</span>\n    <span class="n">id</span><span class="p">,</span> <span class="s1">\'Leaf\'</span> <span class="k">AS</span> <span class="k">Type</span>\n<span class="k">FROM</span>\n    <span class="n">tree</span>\n<span class="k">WHERE</span>\n    <span class="n">id</span> <span class="k">NOT</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">DISTINCT</span>\n            <span class="n">p_id</span>\n        <span class="k">FROM</span>\n            <span class="n">tree</span>\n        <span class="k">WHERE</span>\n            <span class="n">p_id</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">)</span>\n        <span class="k">AND</span> <span class="n">p_id</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span>\n\n<span class="k">UNION</span>\n\n<span class="k">SELECT</span>\n    <span class="n">id</span><span class="p">,</span> <span class="s1">\'Inner\'</span> <span class="k">AS</span> <span class="k">Type</span>\n<span class="k">FROM</span>\n    <span class="n">tree</span>\n<span class="k">WHERE</span>\n    <span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">DISTINCT</span>\n            <span class="n">p_id</span>\n        <span class="k">FROM</span>\n            <span class="n">tree</span>\n        <span class="k">WHERE</span>\n            <span class="n">p_id</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">)</span>\n        <span class="k">AND</span> <span class="n">p_id</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span>\n<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">id</span><span class="p">;</span>\n</pre></div>\n<h4 id="approach-ii-using-flow-control-statement-case-accepted">Approach II: Using flow control statement <code>CASE</code> [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The idea is similar with the above solution but the code is simpler by utilizing the flow control statements, which is effective to output differently based on different input values. In this case, we can use <a href="https://dev.mysql.com/doc/refman/5.7/en/case.html"><code>CASE</code></a> statement.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">id</span> <span class="k">AS</span> <span class="o">`</span><span class="n">Id</span><span class="o">`</span><span class="p">,</span>\n    <span class="k">CASE</span>\n        <span class="k">WHEN</span> <span class="n">tree</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">atree</span><span class="p">.</span><span class="n">id</span> <span class="k">FROM</span> <span class="n">tree</span> <span class="n">atree</span> <span class="k">WHERE</span> <span class="n">atree</span><span class="p">.</span><span class="n">p_id</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">)</span>\n          <span class="k">THEN</span> <span class="s1">\'Root\'</span>\n        <span class="k">WHEN</span> <span class="n">tree</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">atree</span><span class="p">.</span><span class="n">p_id</span> <span class="k">FROM</span> <span class="n">tree</span> <span class="n">atree</span><span class="p">)</span>\n          <span class="k">THEN</span> <span class="s1">\'Inner\'</span>\n        <span class="k">ELSE</span> <span class="s1">\'Leaf\'</span>\n    <span class="k">END</span> <span class="k">AS</span> <span class="k">Type</span>\n<span class="k">FROM</span>\n    <span class="n">tree</span>\n<span class="k">ORDER</span> <span class="k">BY</span> <span class="o">`</span><span class="n">Id</span><span class="o">`</span>\n<span class="p">;</span>\n</pre></div>\n<blockquote>\n<p>MySQL provides different flow control statements besides <code>CASE</code>. You can try to rewrite the slution above using <a href="https://dev.mysql.com/doc/refman/5.7/en/control-flow-functions.html#function_if"><code>IF</code></a> flow control statement.</p>\n</blockquote>\n<h4 id="approach-iii-using-if-function-accepted">Approach III: Using <code>IF</code> function [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Also, we can use a single <a href="https://dev.mysql.com/doc/refman/5.7/en/control-flow-functions.html#function_if"><code>IF</code></a> function instead of the complex flow control statements.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">atree</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>\n    <span class="k">IF</span><span class="p">(</span><span class="k">ISNULL</span><span class="p">(</span><span class="n">atree</span><span class="p">.</span><span class="n">p_id</span><span class="p">),</span>\n        <span class="s1">\'Root\'</span><span class="p">,</span>\n        <span class="k">IF</span><span class="p">(</span><span class="n">atree</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">p_id</span> <span class="k">FROM</span> <span class="n">tree</span><span class="p">),</span> <span class="s1">\'Inner\'</span><span class="p">,</span><span class="s1">\'Leaf\'</span><span class="p">))</span> <span class="k">Type</span>\n<span class="k">FROM</span>\n <span class="err">&nbsp;</span> <span class="err">&nbsp;</span><span class="n">tree</span> <span class="n">atree</span>\n<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">atree</span><span class="p">.</span><span class="n">id</span>\n</pre></div>\n<blockquote>\n<p>Note: This solution was inspired by <a href="https://discuss.leetcode.com/user/richarddia">@richarddia</a></p>\n</blockquote>\n</div>\n          ',
    tags: ['Twitter'],
  },
  {
    id: '609',
    name: 'Find Duplicate File in System',
    acceptance: '52.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths.</p>\n\n<p>A group of duplicate files consists of at least <b>two</b> files that have exactly the same content.</p>\n\n<p>A single directory info string in the <b>input</b> list has the following format: </p>\n<p><code>"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)"</code><br></p>\n<p>It means there are <b>n</b> files (<code>f1.txt</code>, <code>f2.txt</code> ... <code>fn.txt</code> with content <code>f1_content</code>, <code>f2_content</code> ... <code>fn_content</code>, respectively) in directory <code>root/d1/d2/.../dm</code>. Note that n &gt;= 1 and m &gt;= 0. If m = 0, it means the directory is just the root directory.</p>\n\n<p>The <b>output</b> is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format: </p>\n<p><code>"directory_path/file_name.txt"</code></p>\n\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>\n["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"]\n<b>Output:</b>  \n[["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]\n</pre>\n<p></p>\n\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>No order is required for the final output.</li>\n<li>You may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50].</li>\n<li>The number of files given is in the range of [1,20000].</li>\n<li>You may assume no files or directories share the same name in the same directory.</li>\n<li>You may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space.</li>\n</ol>\n<p></p>\n\n\n<b>Follow-up beyond contest:</b> \n<ol>\n<li> Imagine you are given a real file system, how will you search files? DFS or BFS?</li>\n<li> If the file content is very large (GB level), how will you modify your solution?</li>\n<li> If you can only read the file by 1kb each time, how will you modify your solution?</li>\n<li> What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize?</li>\n<li> How to make sure the duplicated files you find are not false positive?</li>\n</ol>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-hashmap-accepted">Approach #2 Using HashMap [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>For the brute force solution, firstly we obtain the directory paths, the filenames and file contents separately by appropriately splitting the elements of the <script type="math/tex; mode=display">paths</script> list. While doing so, we keep on creating a <script type="math/tex; mode=display">list</script> which contains the full path of every file along with the contents of the file. The <script type="math/tex; mode=display">list</script> contains data in the form <script type="math/tex; mode=display">[ [file_1\\_full\\_path, file_1\\_contents], [file_2\\_full\\_path, file_2\\_contents]..., [file_n\\_full\\_path, file_n\\_contents] ]</script>.</p>\n<p>Once this is done, we iterate over this <script type="math/tex; mode=display">list</script>. For every element <script type="math/tex; mode=display">i</script> chosen from the list, we iterate over the whole <script type="math/tex; mode=display">list</script> to find another element <script type="math/tex; mode=display">j</script> whose file contents are the same as the <script type="math/tex; mode=display">i^{th}</script> element. For every such element found, we put the <script type="math/tex; mode=display">j^{th}</script> element\'s file path in a temporary list <script type="math/tex; mode=display">l</script> and we also mark the <script type="math/tex; mode=display">j^{th}</script> element as visited so that this element isn\'t considered again in the future. Thus, when we reach the end of the array for every <script type="math/tex; mode=display">i^{th}</script> element, we obtain a list of file paths in <script type="math/tex; mode=display">l</script>, which have the same contents as the file corresponding to the <script type="math/tex; mode=display">i^{th}</script> element. If this list isn\'t empty, it indicates that there exists content duplicate to the <script type="math/tex; mode=display">i^{th}</script> element. Thus, we also need to put the <script type="math/tex; mode=display">i^{th}</script> element\'s file path in the <script type="math/tex; mode=display">l</script>. </p>\n<p>At the end of each iteration, we put this list <script type="math/tex; mode=display">l</script> obtained in the resultant list <script type="math/tex; mode=display">res</script> and reset the list <script type="math/tex; mode=display">l</script> for finding the duplicates of the next element.</p>\n<iframe frameborder="0" height="515" name="P5yYSqFy" src="https://leetcode.com/playground/P5yYSqFy/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n*x + f^2*s)</script>. Creation of <script type="math/tex; mode=display">list</script> will take <script type="math/tex; mode=display">O(n*x)</script>, where n is the number of directories and x is the average string length. Every file is compared with every other file. Let <script type="math/tex; mode=display">f</script> files are there with average size of <script type="math/tex; mode=display">s</script>, then files comparision will take <script type="math/tex; mode=display">O(f^2*s)</script>, equals can take <script type="math/tex; mode=display">O(s)</script>. Here, Worst case will be when all files are unique.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n*x)</script>. Size of lists <script type="math/tex; mode=display">res</script> and <script type="math/tex; mode=display">list</script> can grow upto <script type="math/tex; mode=display">n*x</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-hashmap-accepted">Approach #2 Using HashMap [Accepted]</h4>\n<p>In this approach, firstly we obtain the directory paths, the file names and their contents separately by appropriately splitting each string in the given <script type="math/tex; mode=display">paths</script> list. In order to find the files with duplicate contents, we make use of a HashMap <script type="math/tex; mode=display">map</script>, which stores the data in the form <script type="math/tex; mode=display">(contents, list\\_of\\_file\\_paths\\_with\\_this\\_content)</script>. Thus, for every file\'s contents, we check if the same content already exist in the hashmap. If so, we add the current file\'s path to the list of files corresponding to the current contents. Otherwise, we create a new entry in the <script type="math/tex; mode=display">map</script>, with the current contents as the key and the value being a list with only one entry(the current file\'s path).</p>\n<p>At the end, we find out the contents corresponding to which atleast two file paths exist. We obtain the resultant list <script type="math/tex; mode=display">res</script>, which is a list of lists containing these file paths corresponding to the same contents.</p>\n<p>The following animation illustrates the process for a clearer understanding.</p>\n<p>!?!../Documents/609_Find_Duplicate.json:1000,563!?!</p>\n<iframe frameborder="0" height="428" name="9pU24YeR" src="https://leetcode.com/playground/9pU24YeR/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n*x)</script>. <script type="math/tex; mode=display">n</script> strings of average length <script type="math/tex; mode=display">x</script> is parsed.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n*x)</script>. <script type="math/tex; mode=display">map</script> and <script type="math/tex; mode=display">res</script> size grows upto <script type="math/tex; mode=display">n*x</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Dropbox'],
  },
  {
    id: '610',
    name: 'Triangle Judgement ',
    acceptance: '58.3%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            A pupil Tim gets homework to identify whether three line segments could possibly form a triangle.<p></p> However, this assignment is very heavy because there are hundreds of records to calculate.<p></p>\n \nCould you help Tim by writing a query to judge whether these three sides can form a triangle, assuming table <code>triangle</code> holds the length of the three sides x, y and z.<p></p>\n \n<pre>| x  | y  | z  |\n|----|----|----|\n| 13 | 15 | 30 |\n| 10 | 20 | 15 |\n</pre>\n \nFor the sample data above, your query should return the follow result:\n<pre>| x  | y  | z  | triangle |\n|----|----|----|----------|\n| 13 | 15 | 30 | No       |\n| 10 | 20 | 15 | Yes      |\n</pre>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-casewhen-accepted">Approach: Using case...when... [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-casewhen-accepted">Approach: Using <code>case...when...</code> [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In Math, three segments can form a triangle only if the sum of any of the two segments is larger than the third one.\n(In other words, the subtraction of any of the two segments are smaller than the third one.)</p>\n<p>So, we can use this knowledge to judge with the help of the MySQL control statements <a href="https://dev.mysql.com/doc/refman/5.7/en/case.html"><code>case...when...</code></a>.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> \n    <span class="n">x</span><span class="p">,</span>\n    <span class="n">y</span><span class="p">,</span>\n    <span class="n">z</span><span class="p">,</span>\n    <span class="k">CASE</span>\n        <span class="k">WHEN</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">z</span> <span class="k">AND</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="k">AND</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="k">THEN</span> <span class="s1">\'Yes\'</span>\n        <span class="k">ELSE</span> <span class="s1">\'No\'</span>\n    <span class="k">END</span> <span class="k">AS</span> <span class="s1">\'triangle\'</span>\n<span class="k">FROM</span>\n    <span class="n">triangle</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '611',
    name: 'Valid Triangle Number',
    acceptance: '42.2%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            Given an array consists of non-negative integers,  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [2,2,3,4]\n<b>Output:</b> 3\n<b>Explanation:</b>\nValid combinations are: \n2,3,4 (using the first 2)\n2,3,4 (using the second 2)\n2,2,3\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The length of the given array won't exceed 1000.</li>\n<li>The integers in the given array are in the range of [0, 1000].</li>\n</ol>\n<p></p>\n\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-binary-search-accepted">Approach #2 Using Binary Search [Accepted]</a></li>\n<li><a href="#approach-3-linear-scan-accepted">Approach #3 Linear Scan [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The condition for the triplets <script type="math/tex; mode=display">(a, b, c)</script> representing the lengths of the sides of a triangle, to form a valid triangle, is that the sum of any two sides should always be greater than the third side alone. i.e. <script type="math/tex; mode=display">a + b > c</script>, <script type="math/tex; mode=display">b + c > a</script>, <script type="math/tex; mode=display">a + c > b</script>. </p>\n<p>The simplest method to check this is to consider every possible triplet in the given <script type="math/tex; mode=display">nums</script> array and checking if the triplet satisfies the three inequalities mentioned above. Thus, we can keep a track of the <script type="math/tex; mode=display">count</script> of the number of triplets satisfying these inequalities. When all the triplets have been considered, the <script type="math/tex; mode=display">count</script> gives the required result.</p>\n<iframe frameborder="0" height="309" name="gdURWBgv" src="https://leetcode.com/playground/gdURWBgv/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. Three nested loops are there to check every triplet.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-binary-search-accepted">Approach #2 Using Binary Search [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>If we sort the given <script type="math/tex; mode=display">nums</script> array once, we can solve the given problem in a better way. This is because, if we consider a triplet <script type="math/tex; mode=display">(a, b, c)</script> such that <script type="math/tex; mode=display">a &leq; b &leq; c</script>, we need not check all the three inequalities for checking the validity of the triangle formed by them. But, only one condition <script type="math/tex; mode=display">a + b > c</script> would suffice. This happens because <script type="math/tex; mode=display">c &geq; b</script> and <script type="math/tex; mode=display">c &geq; a</script>. Thus, adding any number to <script type="math/tex; mode=display">c</script> will always produce a sum which is greater than either <script type="math/tex; mode=display">a</script> or <script type="math/tex; mode=display">b</script> considered alone. Thus, the inequalities <script type="math/tex; mode=display">c + a > b</script> and <script type="math/tex; mode=display">c + b > a</script> are satisfied implicitly by virtue of the  property <script type="math/tex; mode=display">a < b < c</script>.</p>\n<p>From this, we get the idea that we can sort the given <script type="math/tex; mode=display">nums</script> array. Then, for every pair <script type="math/tex; mode=display">(nums[i], nums[j])</script> considered starting from the beginning of the array, such that <script type="math/tex; mode=display">j > i</script>(leading to <script type="math/tex; mode=display">nums[j] &geq; nums[i]</script>), we can find out the count of elements <script type="math/tex; mode=display">nums[k]</script>(<script type="math/tex; mode=display">k > j</script>), which satisfy the inequality <script type="math/tex; mode=display">nums[k] > nums[i] + nums[j]</script>. We can do so for every pair <script type="math/tex; mode=display">(i, j)</script> considered and get the required result.</p>\n<p>We can also observe that, since we\'ve sorted the <script type="math/tex; mode=display">nums</script> array, as we traverse towards the right for choosing the index <script type="math/tex; mode=display">k</script>(for number <script type="math/tex; mode=display">nums[k]</script>), the value of <script type="math/tex; mode=display">nums[k]</script> could increase or remain the same(doesn\'t decrease relative to the previous value). Thus, there will exist a right limit on the value of index <script type="math/tex; mode=display">k</script>, such that the elements satisfy <script type="math/tex; mode=display">nums[k] > nums[i] + nums[j]</script>. Any elements beyond this value of <script type="math/tex; mode=display">k</script> won\'t satisfy this inequality as well, which is obvious.</p>\n<p>Thus, if we are able to find this right limit value of <script type="math/tex; mode=display">k</script>(indicating the element just greater than <script type="math/tex; mode=display">nums[i] + nums[j]</script>), we can conclude that all the elements in <script type="math/tex; mode=display">nums</script> array in the range <script type="math/tex; mode=display">(j+1, k-1)</script>(both included) satisfy the required inequality. Thus, the <script type="math/tex; mode=display">count</script> of elements satisfying the inequality will be given by <script type="math/tex; mode=display">(k-1) - (j+1) + 1 = k - j - 1</script>.</p>\n<p>Since the <script type="math/tex; mode=display">nums</script> array has been sorted now, we can make use of Binary Search to find this right limit of <script type="math/tex; mode=display">k</script>. The following animation shows how Binary Search can be used to find the right limit for a simple example.</p>\n<p>!?!../Documents/Valid_Triangle_Binary.json:1000,563!?!</p>\n<p>Another point to be observed is that once we find a right limit index <script type="math/tex; mode=display">k_{(i,j)}</script> for a particular pair <script type="math/tex; mode=display">(i, j)</script> chosen, when we choose a higher value of <script type="math/tex; mode=display">j</script> for the same value of <script type="math/tex; mode=display">i</script>, we need not start searching for the right limit <script type="math/tex; mode=display">k_{(i,j+1)}</script> from the index <script type="math/tex; mode=display">j+2</script>. Instead, we can start off from the index <script type="math/tex; mode=display">k_{(i,j)}</script> directly where we left off for the last <script type="math/tex; mode=display">j</script> chosen. </p>\n<p>This holds correct because when we choose a higher value of <script type="math/tex; mode=display">j</script>(higher or equal <script type="math/tex; mode=display">nums[j]</script> than the previous one), all the <script type="math/tex; mode=display">nums[k]</script>, such that <script type="math/tex; mode=display">k < k_{(i,j)}</script> will obviously satisfy <script type="math/tex; mode=display">nums[i] + nums[j] > nums[k]</script> for the new value of <script type="math/tex; mode=display">j</script> chosen.</p>\n<p>By taking advantage of this observation, we can limit the range of Binary Search for <script type="math/tex; mode=display">k</script> to shorter values for increasing values of <script type="math/tex; mode=display">j</script> considered while choosing the pairs <script type="math/tex; mode=display">(i, j)</script>.</p>\n<iframe frameborder="0" height="462" name="UpFbPxRd" src="https://leetcode.com/playground/UpFbPxRd/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2logn)</script>. In worst case inner loop will take <script type="math/tex; mode=display">nlogn</script> (binary search applied <script type="math/tex; mode=display">n</script> times).</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(logn)</script>. Sorting takes <script type="math/tex; mode=display">O(logn)</script> space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-linear-scan-accepted">Approach #3 Linear Scan [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>As discussed in the last approach, once we sort the given <script type="math/tex; mode=display">nums</script> array, we need to find the right limit of the index <script type="math/tex; mode=display">k</script> for a pair of indices <script type="math/tex; mode=display">(i, j)</script> chosen to find the <script type="math/tex; mode=display">count</script> of elements satisfying <script type="math/tex; mode=display">nums[i] + nums[j] > nums[k]</script> for the triplet <script type="math/tex; mode=display">(nums[i], nums[j], nums[k])</script> to form a valid triangle. </p>\n<p>We can find this right limit by simply traversing the index <script type="math/tex; mode=display">k</script>\'s values starting from the index <script type="math/tex; mode=display">k=j+1</script> for a pair <script type="math/tex; mode=display">(i, j)</script> chosen and stopping at the first value of <script type="math/tex; mode=display">k</script> not satisfying the above inequality. Again, the <script type="math/tex; mode=display">count</script> of elements <script type="math/tex; mode=display">nums[k]</script> satisfying <script type="math/tex; mode=display">nums[i] + nums[j] > nums[k]</script> for the pair of indices <script type="math/tex; mode=display">(i, j)</script> chosen is given by <script type="math/tex; mode=display">k - j - 1</script> as discussed in the last approach.</p>\n<p>Further, as discussed in the last approach, when we choose a higher value of index <script type="math/tex; mode=display">j</script> for a particular <script type="math/tex; mode=display">i</script> chosen, we need not start from the index <script type="math/tex; mode=display">j + 1</script>. Instead, we can start off directly from the value of <script type="math/tex; mode=display">k</script> where we left for the last index <script type="math/tex; mode=display">j</script>. This helps to save redundant computations.</p>\n<p>The following animation depicts the process:</p>\n<p>!?!../Documents/Valid_Triangle_Linear.json:1000,563!?!</p>\n<iframe frameborder="0" height="309" name="GW5LZ3tx" src="https://leetcode.com/playground/GW5LZ3tx/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Loop of <script type="math/tex; mode=display">k</script> and <script type="math/tex; mode=display">j</script> will be executed <script type="math/tex; mode=display">O(n^2)</script> times in total, because, we do not reinitialize the value of <script type="math/tex; mode=display">k</script> for a new value of <script type="math/tex; mode=display">j</script> chosen(for the same <script type="math/tex; mode=display">i</script>). Thus the complexity will be O(n^2+n^2)=O(n^2).</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(logn)</script>. Sorting takes O(logn) space.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Expedia'],
  },
  {
    id: '612',
    name: 'Shortest Distance in a Plane ',
    acceptance: '52.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            Table <code>point_2d</code> holds the coordinates (x,y) of some unique points (more than two) in a plane.<p></p>\nWrite a query to find the shortest distance between these points rounded to  2 decimals.<p></p>\n \n<pre>| x  | y  |\n|----|----|\n| -1 | -1 |\n| 0  | 0  |\n| -1 | -2 |\n</pre><p></p>\n \nThe shortest distance is 1.00 from point (-1,-1) to (-1,2). So the output should be:<p></p>\n<pre>| shortest |\n|----------|\n| 1.00     |\n</pre><p></p>\n \n<b>Note:</b> The longest distance among all the points are less than 10000.<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-sqrt-pow-functions-and-math-knowledge-accepted">Approach 1: Using SQRT, POW() functions and math knowledge [Accepted]</a></li>\n<li><a href="#approach-2-optimize-to-avoid-reduplicate-calculations-accepted">Approach 2: Optimize to avoid reduplicate calculations [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-sqrt-pow-functions-and-math-knowledge-accepted">Approach 1: Using <code>SQRT</code>, <code>POW()</code> functions and math knowledge [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Calculate the distances between each two points and then display the smallest one.</p>\n<p><strong>Algorithm</strong></p>\n<p>The <a href="https://en.wikipedia.org/wiki/Euclidean_distance">euclidean distance</a> between two points P1(x1,y1) and P2(x2, y2) in two dimensions is defined as <script type="math/tex; mode=display">\\sqrt{(x1-x2)^2+(y1-y2)^2}</script>. So in order to get the distances, we can join this table with itself, and then utilize the built-in function <code>POW()</code> and <code>SQRT()</code> like below.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span>\n    <span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">,</span>\n    <span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span>\n    <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">,</span>\n    <span class="n">SQRT</span><span class="p">((</span><span class="n">POW</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">POW</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span> <span class="k">AS</span> <span class="n">distance</span>\n<span class="k">FROM</span>\n    <span class="n">point_2d</span> <span class="n">p1</span>\n        <span class="k">JOIN</span>\n    <span class="n">point_2d</span> <span class="n">p2</span> <span class="k">ON</span> <span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">!=</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span> <span class="k">OR</span> <span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">!=</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span>\n<span class="p">;</span>\n</pre></div>\n<blockquote>\n<p>Note:\n- The condition \'p1.x != p2.x OR p2.y != p2.y\' is to avoid calculating the distance of a point with itself.\nOtherwise, the minimum distance will be always zero.\n- The columns p1.x, p1.y, p2.x and p2.y are for demonstrating. They are not necessary for the final solution.</p>\n</blockquote>\n<p>So the output would be as below after running this code on the sample data.</p>\n<div class="codehilite"><pre><span></span>| x  | y  | x  | y  | distance           |\n|----|----|----|----|--------------------|\n| 0  | 0  | -1 | -1 | 1.4142135623730951 |\n| -1 | -2 | -1 | -1 | 1                  |\n| -1 | -1 | 0  | 0  | 1.4142135623730951 |\n| -1 | -2 | 0  | 0  | 2.23606797749979   |\n| -1 | -1 | -1 | -2 | 1                  |\n| 0  | 0  | -1 | -2 | 2.23606797749979   |\n</pre></div>\n<p>At last, choose the minimum distance and round it to 2 decimals as required.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">ROUND</span><span class="p">(</span><span class="n">SQRT</span><span class="p">(</span><span class="k">MIN</span><span class="p">((</span><span class="n">POW</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">POW</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))),</span> <span class="mi">2</span><span class="p">)</span> <span class="k">AS</span> <span class="n">shortest</span>\n<span class="k">FROM</span>\n    <span class="n">point_2d</span> <span class="n">p1</span>\n        <span class="k">JOIN</span>\n    <span class="n">point_2d</span> <span class="n">p2</span> <span class="k">ON</span> <span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">!=</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span> <span class="k">OR</span> <span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">!=</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span>\n<span class="p">;</span>\n</pre></div>\n<blockquote>\n<p>Note: To put the MIN() inside of SQRT() will slightly improve the performance.</p>\n</blockquote>\n<h4 id="approach-2-optimize-to-avoid-reduplicate-calculations-accepted">Approach 2: Optimize to avoid reduplicate calculations [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>It is unnecessary to calculate the distance between all points to all other points since some of them may already be done.\nSo how to avoid the reduplicate calculations?</p>\n<p><strong>Algorithm</strong></p>\n<p>When join the table with itself, we can claim to only calculate the distance between one point to another point in a certain rule such ponts with bigger x value.\nBy following this rule, we can avoid quite a lot of reduplicate calculations.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">t1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span>\n    <span class="n">t1</span><span class="p">.</span><span class="n">y</span><span class="p">,</span>\n    <span class="n">t2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span>\n    <span class="n">t2</span><span class="p">.</span><span class="n">y</span><span class="p">,</span>\n    <span class="n">SQRT</span><span class="p">((</span><span class="n">POW</span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">t2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">POW</span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">t2</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span> <span class="k">AS</span> <span class="n">distance</span>\n<span class="k">FROM</span>\n    <span class="n">point_2d</span> <span class="n">t1</span>\n        <span class="k">JOIN</span>\n    <span class="n">point_2d</span> <span class="n">t2</span> <span class="k">ON</span> <span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">t2</span><span class="p">.</span><span class="n">x</span> <span class="k">AND</span> <span class="n">t1</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">t2</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>\n        <span class="k">OR</span> <span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">t2</span><span class="p">.</span><span class="n">x</span> <span class="k">AND</span> <span class="n">t1</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">t2</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>\n        <span class="k">OR</span> <span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">t2</span><span class="p">.</span><span class="n">x</span> <span class="k">AND</span> <span class="n">t1</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">t2</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>\n<span class="p">;</span>\n</pre></div>\n<p>The output is as below for the sample data. You may notice that there are only 4 records, 1/3 less than the previous solution.</p>\n<div class="codehilite"><pre><span></span>| x  | y  | x  | y  | distance           |\n|----|----|----|----|--------------------|\n| -1 | -2 | -1 | -1 | 1                  |\n| -1 | -1 | 0  | 0  | 1.4142135623730951 |\n| -1 | -2 | 0  | 0  | 2.23606797749979   |\n| -1 | -1 | -1 | -2 | 1                  |\n</pre></div>\n<blockquote>\n<p>Note:\nThe best case is to compare n*(n-1)/2 times, but practically it is not always true considering two points may have same x value or y value.\nIn this case, you may notice the distance between (-1, -2) and (-1, -1) appearing twice in the first and last line in the output.</p>\n</blockquote>\n<p>Here comes the solution to select the shortest distance and round to two decimals.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">ROUND</span><span class="p">(</span><span class="n">SQRT</span><span class="p">(</span><span class="k">MIN</span><span class="p">((</span><span class="n">POW</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">POW</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))),</span><span class="mi">2</span><span class="p">)</span> <span class="k">AS</span> <span class="n">shortest</span>\n<span class="k">FROM</span>\n    <span class="n">point_2d</span> <span class="n">p1</span>\n        <span class="k">JOIN</span>\n    <span class="n">point_2d</span> <span class="n">p2</span> <span class="k">ON</span> <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span> <span class="k">AND</span> <span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>\n        <span class="k">OR</span> <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span> <span class="k">AND</span> <span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>\n        <span class="k">OR</span> <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span> <span class="k">AND</span> <span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '613',
    name: 'Shortest Distance in a Line ',
    acceptance: '69.5%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            Table <code>point</code> holds the x coordinate of some points on x-axis in a plane, which are all integers.<p></p>\nWrite a query to find the shortest distance between two points in these points.<p></p>\n \n<pre>| x   |\n|-----|\n| -1  |\n| 0   |\n| 2   |\n</pre><p></p>\n \nThe shortest distance is '1' obviously, which is from point '-1' to '0'. So the output is as below:<p></p>\n<pre>| shortest|\n|---------|\n| 1       |\n</pre><p></p>\n \n<b>Note:</b> Every point is unique, which means there is no duplicates in table <code>point</code>.<p></p>\n \n<b>Follow-up:</b> What if all these points have an id and are arranged from the left most to the right most of x axis?<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-abs-and-min-functions-accepted">Approach: Using ABS() and MIN() functions [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-abs-and-min-functions-accepted">Approach: Using <code>ABS()</code> and <code>MIN()</code> functions [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Calculate the distances between each two points first, and then display the minimum one.</p>\n<p><strong>Algorithm</strong></p>\n<p>To get the distances of each two points, we need to join this table with itself and use <code>ABS()</code> function since the distance is nonnegative.\nOne trick here is to add the condition in the join to avoid calculating the distance between a point with itself.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="k">ABS</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="k">AS</span> <span class="n">distance</span>\n<span class="k">FROM</span>\n    <span class="n">point</span> <span class="n">p1</span>\n        <span class="k">JOIN</span>\n    <span class="n">point</span> <span class="n">p2</span> <span class="k">ON</span> <span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">!=</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span>\n<span class="p">;</span>\n</pre></div>\n<blockquote>\n<p>Note: The columns p1.x, p2.x are only for demonstrating purpose, so they are not actually needed in the end.</p>\n</blockquote>\n<p>Taking the sample data for example, the output would be as below.</p>\n<div class="codehilite"><pre><span></span>| x  | x  | distance |\n|----|----|----------|\n| 0  | -1 | 1        |\n| 2  | -1 | 3        |\n| -1 | 0  | 1        |\n| 2  | 0  | 2        |\n| -1 | 2  | 3        |\n| 0  | 2  | 2        |\n</pre></div>\n<p>At last, use <code>MIN()</code> to select the smallest value in the <em>distance</em> column.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="k">MIN</span><span class="p">(</span><span class="k">ABS</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">))</span> <span class="k">AS</span> <span class="n">shortest</span>\n<span class="k">FROM</span>\n    <span class="n">point</span> <span class="n">p1</span>\n        <span class="k">JOIN</span>\n    <span class="n">point</span> <span class="n">p2</span> <span class="k">ON</span> <span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">!=</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '614',
    name: 'Second Degree Follower ',
    acceptance: '23.4%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nIn facebook, there is a <code>follow</code> table with two columns: <b>followee</b>, <b>follower</b>.\n</p><p>\nPlease write a sql query to get the amount of each follower’s follower if he/she has one.\n</p>\n<p>\nFor example:\n</p><pre>+-------------+------------+\n| followee    | follower   |\n+-------------+------------+\n|     A       |     B      |\n|     B       |     C      |\n|     B       |     D      |\n|     D       |     E      |\n+-------------+------------+\n</pre>\nshould output:\n<pre>+-------------+------------+\n| follower    | num        |\n+-------------+------------+\n|     B       |  2         |\n|     D       |  1         |\n+-------------+------------+\n</pre>\n<b>Explaination:</b><br>\nBoth B and D exist  in the follower list, when as a followee, B's follower is C and D, and D's follower is E.  A does not exist in follower list.\n<p></p>\n<p></p>\n<b>Note:</b><br>\nFollowee would not follow himself/herself in all cases.<br>\nPlease display the result in follower's alphabet order.\n<p></p>\n          ",
    solutionHtml: '\n            <br>\n            \n          ',
    tags: [],
  },
  {
    id: '615',
    name: 'Average Salary: Departments VS Company ',
    acceptance: '31.8%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            Given two tables as below, write a query to display the comparison result (higher/lower/same) of the average salary of employees in a department to the company's average salary.<p></p>\n\nTable: <code>salary</code>\n<pre>| id | employee_id | amount | pay_date   |\n|----|-------------|--------|------------|\n| 1  | 1           | 9000   | 2017-03-31 |\n| 2  | 2           | 6000   | 2017-03-31 |\n| 3  | 3           | 10000  | 2017-03-31 |\n| 4  | 1           | 7000   | 2017-02-28 |\n| 5  | 2           | 6000   | 2017-02-28 |\n| 6  | 3           | 8000   | 2017-02-28 |\n</pre><p></p>\n\nThe <b>employee_id</b> column refers to the <b>employee_id</b> in the following table <code>employee</code>.<p></p>\n<pre>| employee_id | department_id |\n|-------------|---------------|\n| 1           | 1             |\n| 2           | 2             |\n| 3           | 2             |\n</pre><p></p>\n\nSo for the sample data above, the result is:<p></p>\n<pre>| pay_month | department_id | comparison  |\n|-----------|---------------|-------------|\n| 2017-03   | 1             | higher      |\n| 2017-03   | 2             | lower       |\n| 2017-02   | 1             | same        |\n| 2017-02   | 2             | same        |\n</pre><p></p>\n\n<b>Explanation</b><p></p>\nIn March, the company's average salary is (9000+6000+10000)/3 = 8333.33...<p></p>\nThe average salary for department '1' is 9000, which is the salary of <b>employee_id</b> '1' since there is only one employee in this department. So the comparison result is 'higher' since 9000 &gt; 8333.33 obviously.<p></p>\nThe average salary of department '2' is (6000 + 10000)/2 = 8000, which is the average of <b>employee_id</b> '2' and '3'. So the comparison result is 'lower' since 8000 &lt; 8333.33.<p></p>\nWith he same formula for the average salary comparison in February, the result is 'same' since both the department '1' and '2' have the same average salary with the company, which is 7000.<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-avg-and-casewhen-accepted">Approach: Using avg() and case...when... [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-avg-and-casewhen-accepted">Approach: Using <code>avg()</code> and <code>case...when...</code> [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Solve this problem by 3 steps as below.</p>\n<p><strong>Algorithm</strong></p>\n<p>1.Calculate the company\'s average salary in every month\nMySQL has the built-in function avg() to get the average of a list of numbers. Also, we need to format the <em>pay_date</em> column for future use.</p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="k">avg</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="k">as</span> <span class="n">company_avg</span><span class="p">,</span>  <span class="n">date_format</span><span class="p">(</span><span class="n">pay_date</span><span class="p">,</span> <span class="s1">\'%Y-%m\'</span><span class="p">)</span> <span class="k">as</span> <span class="n">pay_month</span>\n<span class="k">from</span> <span class="n">salary</span>\n<span class="k">group</span> <span class="k">by</span> <span class="n">date_format</span><span class="p">(</span><span class="n">pay_date</span><span class="p">,</span> <span class="s1">\'%Y-%m\'</span><span class="p">)</span>\n<span class="p">;</span>\n</pre></div>\n<table>\n<thead>\n<tr>\n<th>company_avg</th>\n<th>pay_month</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>7000.0000</td>\n<td>2017-02</td>\n</tr>\n<tr>\n<td>8333.3333</td>\n<td>2017-03</td>\n</tr>\n</tbody>\n</table>\n<p>2.Calculate the each department\'s average salary in every month\nTo do this, we need to join the <strong>salary</strong> table with the <strong>employee</strong> table using condition <code>salary.employee_id = employee.id</code>.</p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="n">department_id</span><span class="p">,</span> <span class="k">avg</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="k">as</span> <span class="n">department_avg</span><span class="p">,</span> <span class="n">date_format</span><span class="p">(</span><span class="n">pay_date</span><span class="p">,</span> <span class="s1">\'%Y-%m\'</span><span class="p">)</span> <span class="k">as</span> <span class="n">pay_month</span>\n<span class="k">from</span> <span class="n">salary</span>\n<span class="k">join</span> <span class="n">employee</span> <span class="k">on</span> <span class="n">salary</span><span class="p">.</span><span class="n">employee_id</span> <span class="o">=</span> <span class="n">employee</span><span class="p">.</span><span class="n">employee_id</span>\n<span class="k">group</span> <span class="k">by</span> <span class="n">department_id</span><span class="p">,</span> <span class="n">pay_month</span>\n<span class="p">;</span>\n</pre></div>\n<table>\n<thead>\n<tr>\n<th>department_id</th>\n<th>department_avg</th>\n<th>pay_month</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>7000.0000</td>\n<td>2017-02</td>\n</tr>\n<tr>\n<td>1</td>\n<td>9000.0000</td>\n<td>2017-03</td>\n</tr>\n<tr>\n<td>2</td>\n<td>7000.0000</td>\n<td>2017-02</td>\n</tr>\n<tr>\n<td>2</td>\n<td>8000.0000</td>\n<td>2017-03</td>\n</tr>\n</tbody>\n</table>\n<p>3.Compare the previous numbers and display the result\nThis step might be the hardest if you have no idea on how to use MySQL flow control statement <a href="https://dev.mysql.com/doc/refman/5.7/en/case.html"><code>case...when...</code></a>.</p>\n<p>MySQL, like other programming languages, also has its flow control. Click <a href="https://dev.mysql.com/doc/refman/5.7/en/flow-control-statements.html">this link</a> to learn it.</p>\n<p>At last, combine the above two query and join them <code>on department_salary.pay_month = company_salary.pay_month</code>.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="n">department_salary</span><span class="p">.</span><span class="n">pay_month</span><span class="p">,</span> <span class="n">department_id</span><span class="p">,</span>\n<span class="k">case</span>\n  <span class="k">when</span> <span class="n">department_avg</span><span class="o">&gt;</span><span class="n">company_avg</span> <span class="k">then</span> <span class="s1">\'higher\'</span>\n  <span class="k">when</span> <span class="n">department_avg</span><span class="o">&lt;</span><span class="n">company_avg</span> <span class="k">then</span> <span class="s1">\'lower\'</span>\n  <span class="k">else</span> <span class="s1">\'same\'</span>\n<span class="k">end</span> <span class="k">as</span> <span class="n">comparison</span>\n<span class="k">from</span>\n<span class="p">(</span>\n  <span class="k">select</span> <span class="n">department_id</span><span class="p">,</span> <span class="k">avg</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="k">as</span> <span class="n">department_avg</span><span class="p">,</span> <span class="n">date_format</span><span class="p">(</span><span class="n">pay_date</span><span class="p">,</span> <span class="s1">\'%Y-%m\'</span><span class="p">)</span> <span class="k">as</span> <span class="n">pay_month</span>\n  <span class="k">from</span> <span class="n">salary</span> <span class="k">join</span> <span class="n">employee</span> <span class="k">on</span> <span class="n">salary</span><span class="p">.</span><span class="n">employee_id</span> <span class="o">=</span> <span class="n">employee</span><span class="p">.</span><span class="n">employee_id</span>\n  <span class="k">group</span> <span class="k">by</span> <span class="n">department_id</span><span class="p">,</span> <span class="n">pay_month</span>\n<span class="p">)</span> <span class="k">as</span> <span class="n">department_salary</span>\n<span class="k">join</span>\n<span class="p">(</span>\n  <span class="k">select</span> <span class="k">avg</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="k">as</span> <span class="n">company_avg</span><span class="p">,</span>  <span class="n">date_format</span><span class="p">(</span><span class="n">pay_date</span><span class="p">,</span> <span class="s1">\'%Y-%m\'</span><span class="p">)</span> <span class="k">as</span> <span class="n">pay_month</span> <span class="k">from</span> <span class="n">salary</span> <span class="k">group</span> <span class="k">by</span> <span class="n">date_format</span><span class="p">(</span><span class="n">pay_date</span><span class="p">,</span> <span class="s1">\'%Y-%m\'</span><span class="p">)</span>\n<span class="p">)</span> <span class="k">as</span> <span class="n">company_salary</span>\n<span class="k">on</span> <span class="n">department_salary</span><span class="p">.</span><span class="n">pay_month</span> <span class="o">=</span> <span class="n">company_salary</span><span class="p">.</span><span class="n">pay_month</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '616',
    name: 'Add Bold Tag in String ',
    acceptance: '39.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            Given a string <b>s</b> and a list of strings <b>dict</b>, you need to add a closed pair of bold tag <code>&lt;b&gt;</code> and <code>&lt;/b&gt;</code> to wrap the substrings in s that exist in dict. If two such substrings overlap, you need to wrap them together by only one pair of closed bold tag. Also, if two substrings wrapped by bold tags are consecutive, you need to combine them. \n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \ns = "abcxyz123"\ndict = ["abc","123"]\n<b>Output:</b>\n"&lt;b&gt;abc&lt;/b&gt;xyz&lt;b&gt;123&lt;/b&gt;"\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \ns = "aaabbcc"\ndict = ["aaa","aab","bc"]\n<b>Output:</b>\n"&lt;b&gt;aaabbc&lt;/b&gt;c"\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The given dict won\'t contain duplicates, and its length won\'t exceed 100.</li>\n<li>All the strings in input have length in range [1, 1000]. </li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-similar-to-merge-interval-problem-accepted">Approach #2 Similar to Merge Interval Problem [Accepted]</a></li>\n<li><a href="#approach-3-using-booleanmarking-arrayaccepted">Approach #3  Using Boolean(Marking) Array[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In order to proceed with the solution to the given problem, the first basic step is to identify the substrings of the given string <script type="math/tex; mode=display">s</script> which exist in the given dictionary <script type="math/tex; mode=display">dict</script>. For doing this, firstly, we add the given words in the dictionary <script type="math/tex; mode=display">dict</script> to a <script type="math/tex; mode=display">set</script>. Then, we iterate over the given string <script type="math/tex; mode=display">s</script> and consider every possible substring of <script type="math/tex; mode=display">s</script> to check if it exists in the given dictionary <script type="math/tex; mode=display">dict</script>. If so, we add the start and end index to a <script type="math/tex; mode=display">list</script>. Each element of <script type="math/tex; mode=display">dict</script> takes the form: <script type="math/tex; mode=display">[i, j]</script>. Here, <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> represent the start and the end index of the substring which matches with any word in the dictionary.</p>\n<p>By doing this, we are done with the first step. Now, the problem reduces mainly to identifying the sets of overlapping intervals from among the intervals present in the <script type="math/tex; mode=display">list</script> and adding the tags appropriately at those locations.</p>\n<p>To do so, firstly, we sort the <script type="math/tex; mode=display">list</script> based on the start indices. In case of equality of start indices, we sort the elements based on their end indices. After this, we start creating our resultant string, <script type="math/tex; mode=display">res</script>. The substring of <script type="math/tex; mode=display">s</script> from the beginning till the first start index needs to be added as such to <script type="math/tex; mode=display">res</script>. Then, we pick up the first starting index from the <script type="math/tex; mode=display">list</script>. This index acts as the position to put the opening bold tag. In order to determine the end index(for placing the closing bold tag) by considering the merging required for consecutive or overlapping intervals, for the current range considered, we check if the start index of the next interval in <script type="math/tex; mode=display">list</script> lies before or at the index one larger than end of the current interval. If so, it indicates that either there is an overlap(if the next start index lies before or at the current end index), or the existence of consecutive intervals(if the next start index lies at the current end index + 1). </p>\n<p align="center"><img alt="Interval_Overlap" src="https://leetcode.com/articles/Figures/616/616_Add_Bold_Tag.PNG"></p>\n<p>If any of these cases occur, we know that the next interval can be merged with the current one. Thus, we update the end index to point to the next interval\'s end index. We also update our current interval to the next interval and again check the overlapping or consecutive property of the new interval and its next one. We keep on updating the current interval till we reach an interval which doesn\'t satisfy any of these properties. The end index of the last interval found satisfying this property marks the position for the closing bold tag. </p>\n<p>Since, we had reached the end of the overlapping/consecutive intervals, the substring lying beyond the end index found last and the start index existing beyond this end index in the <script type="math/tex; mode=display">list</script> doesn\'t exist in the dicitionary <script type="math/tex; mode=display">dict</script>. Thus, we need to append this substring directly to the resultant string formed so far. </p>\n<p>We keep on continuing this process till the whole range till the end index of the last interval has been exhausted. The substring left beyond this point is also appended directly to the <script type="math/tex; mode=display">res</script> formed till now.</p>\n<iframe frameborder="0" height="515" name="KqCRh8Hy" src="https://leetcode.com/playground/KqCRh8Hy/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(s^3)</script>. Generating list of intervals will take <script type="math/tex; mode=display">O(s^3)</script>, where <script type="math/tex; mode=display">s</script> represents string length.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(s+d+s*l)</script>. <script type="math/tex; mode=display">res</script> size grows upto <script type="math/tex; mode=display">s</script> and <script type="math/tex; mode=display">set</script> size will be equal to the size of <script type="math/tex; mode=display">dict</script>. Here, <script type="math/tex; mode=display">d</script> refers to the size of <script type="math/tex; mode=display">dict</script>.And <script type="math/tex; mode=display">list</script> size can grow upto <script type="math/tex; mode=display">O(s*l)</script> in worst case, where <script type="math/tex; mode=display">l</script> refers to <script type="math/tex; mode=display">dict</script> size.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-similar-to-merge-interval-problem-accepted">Approach #2 Similar to Merge Interval Problem [Accepted]</h4>\n<p>In the last approach, to identify the substrings of <script type="math/tex; mode=display">s</script> which exist in the dictionary <script type="math/tex; mode=display">dict</script>, we checked every possible substring of <script type="math/tex; mode=display">s</script> to see if it exists in this. Instead of doing the identification in this manner, we can be a bit smarter. We can pick up every word of the dictionary. For every word <script type="math/tex; mode=display">d</script> of the dictionary chosen currently, say of length <script type="math/tex; mode=display">length_d</script>, it is obvious that the substrings in <script type="math/tex; mode=display">s</script> only with length <script type="math/tex; mode=display">length_d</script>, can match with the <script type="math/tex; mode=display">d</script>. Thus, instead of blindly checking for <script type="math/tex; mode=display">d</script>\'s match with every substring in <script type="math/tex; mode=display">s</script>, we check only the substrings with length <script type="math/tex; mode=display">length_d</script>. The matching substrings\' indices are again added to the <script type="math/tex; mode=display">list</script> similar to the last approach. </p>\n<p>The rest of the process remains the same as the last approach. The following animation illustrates the process for a clearer understanding.</p>\n<p>!?!../Documents/616_Add_Bold_Tag_2.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="YuNWzTbc" src="https://leetcode.com/playground/YuNWzTbc/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(l*s*x)</script>. Generating list will take <script type="math/tex; mode=display">O(l*s*x)</script>, where <script type="math/tex; mode=display">x</script> is the average string length of <script type="math/tex; mode=display">dict</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(s+s*l)</script>. <script type="math/tex; mode=display">res</script> size grows upto <script type="math/tex; mode=display">O(s)</script> and <script type="math/tex; mode=display">list</script> size can grow upto <script type="math/tex; mode=display">O(s*l)</script> in worst case. </p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-booleanmarking-arrayaccepted">Approach #3  Using Boolean(Marking) Array[Accepted]</h4>\n<p>This approach is inspired by <a href="http://leetcode.com/compton_scatter">@compton_scatter</a>.</p>\n<p>Another idea could be to merge the process of identification of the substrings in <script type="math/tex; mode=display">s</script> matching with the words in <script type="math/tex; mode=display">dict</script>. To do so, we make use of an array <script type="math/tex; mode=display">bold</script> for marking the positions of the substrings in <script type="math/tex; mode=display">s</script> which are present in <script type="math/tex; mode=display">dict</script>. A True value at <script type="math/tex; mode=display">bold[i]</script> indicates that the current character is a part of the substring which is present in <script type="math/tex; mode=display">dict</script>.</p>\n<p>We identify the substrings in <script type="math/tex; mode=display">s</script> which are present in <script type="math/tex; mode=display">dict</script> similar to the last approach, by considering only substrings of length <script type="math/tex; mode=display">length_d</script> for a dictionary word <script type="math/tex; mode=display">d</script>. Whenver such a substring is found with its beginning index as <script type="math/tex; mode=display">i</script>(and end index <script type="math/tex; mode=display">(i + length_d -1)</script>), we mark all such positions in <script type="math/tex; mode=display">bold</script> as True.</p>\n<p>Thus, in this way, whenever a overlapping or consecutive matching substrings exist in <script type="math/tex; mode=display">s</script>, a continuous sequence of True values is present in <script type="math/tex; mode=display">bold</script>. Keeping this idea in mind, we traverse over the string <script type="math/tex; mode=display">s</script> and keep on putting the current character in the resultant string <script type="math/tex; mode=display">res</script>. At every step, we also check if the <script type="math/tex; mode=display">bold</script> array contains the beginning or end of a continuous sequence of True values. At the beginnning of such a sequence, we put an opening bold tag and then keep on putting the characters of <script type="math/tex; mode=display">s</script> till we find a position corresponding to which the last sequence of continuous True values breaks(the first False value is found). We put a closing bold tag at such a position. After this, we again keep on putting the characters of <script type="math/tex; mode=display">s</script> in <script type="math/tex; mode=display">res</script> till we find the next True value and we keep on continuing the process in the same manner.</p>\n<p>The following animation illustrates the process for a better visualization of the process.</p>\n<p>!?!../Documents/616_Add_Bold_Tag_3.json:1000,563!?!</p>\n<iframe frameborder="0" height="479" name="pSbGGZyd" src="https://leetcode.com/playground/pSbGGZyd/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(l*s*x)</script>. Three nested loops are there to fill <script type="math/tex; mode=display">bold</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(s)</script>. <script type="math/tex; mode=display">res</script> and <script type="math/tex; mode=display">bold</script> size grows upto <script type="math/tex; mode=display">O(s)</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '617',
    name: 'Merge Two Binary Trees',
    acceptance: '67.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. \n</p>\n<p>\nYou need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.\n</p>\n\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \n\tTree 1                     Tree 2                  \n          1                         2                             \n         / \\                       / \\                            \n        3   2                     1   3                        \n       /                           \\   \\                      \n      5                             4   7                  \n<b>Output:</b> \nMerged tree:\n\t     3\n\t    / \\\n\t   4   5\n\t  / \\   \\ \n\t 5   4   7\n</pre>\n<p></p>\n\n\n<p><b>Note:</b>\nThe merging process must start from the root nodes of both trees.\n</p>\n\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</a></li>\n<li><a href="#approach-2-iterative-method-accepted">Approach #2 Iterative Method [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</h4>\n<p>We can traverse both the given trees in a preorder fashion. At every step, we check if the current node exists(isn\'t null) for both the trees. If so, we add the values in the current nodes of both the trees and update the value in the current node of the first tree to reflect this sum obtained. At every step, we also call the original function <code>mergeTrees()</code> with the left children and then with the right children of the current nodes of the two trees. If at any step, one of these children happens to be null, we return the child of the other tree(representing the corresponding child subtree) to be added as a child subtree to the calling parent node in the first tree. At the end, the first tree will represent the required resultant merged binary tree.</p>\n<p>The following animation illustrates the process.</p>\n<p>!?!../Documents/617_Merge_Trees_Recursion.json:1000,563!?!</p>\n<iframe frameborder="0" height="428" name="d9nZDPEJ" src="https://leetcode.com/playground/d9nZDPEJ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(m)</script>. A total of <script type="math/tex; mode=display">m</script> nodes need to be traversed. Here, <script type="math/tex; mode=display">m</script> represents the minimum number of nodes from the two given trees.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m)</script>. The depth of the recursion tree can go upto <script type="math/tex; mode=display">m</script> in the case of a skewed tree. In average case, depth will be <script type="math/tex; mode=display">O(logm)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-iterative-method-accepted">Approach #2 Iterative Method [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the current approach, we again traverse the two trees, but this time we make use of a <script type="math/tex; mode=display">stack</script> to do so instead of making use of recursion. Each entry in the <script type="math/tex; mode=display">stack</script> strores data in the form <script type="math/tex; mode=display">[node_{tree1}, node_{tree2}]</script>. Here, <script type="math/tex; mode=display">node_{tree1}</script> and <script type="math/tex; mode=display">node_{tree2}</script> are the nodes of the first tree and the second tree respectively.</p>\n<p>We start off by pushing the root nodes of both the trees onto the <script type="math/tex; mode=display">stack</script>. Then, at every step, we remove a node pair from the top of the stack. For every node pair removed, we add the values corresponding to the two nodes and update the value of the corresponding node in the first tree. Then, if the left child of the first tree exists, we push the left child(pair) of both the trees onto the stack. If the left child of the first tree doesn\'t exist, we append the left child(subtree) of the second tree to the current node of the first tree. We do the same for the right child pair as well. </p>\n<p>If, at any step, both the current nodes are null, we continue with popping the next nodes from the <script type="math/tex; mode=display">stack</script>.</p>\n<p>The following animation depicts the process.</p>\n<p>!?!../Documents/617_Merge_Trees_Stack.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="v2TK7i2x" src="https://leetcode.com/playground/v2TK7i2x/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We traverse over a total of <script type="math/tex; mode=display">n</script> nodes. Here, <script type="math/tex; mode=display">n</script> refers to the smaller of the number of nodes in the two trees.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of stack can grow upto <script type="math/tex; mode=display">n</script> in case of a skewed tree.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '618',
    name: 'Students Report By Geography ',
    acceptance: '43.2%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            A U.S graduate school has students from Asia, Europe and America. The students\' location information are stored in table <code>student</code> as below.<p></p>\n \n<pre>| name   | continent |\n|--------|-----------|\n| Jack   | America   |\n| Pascal | Europe    |\n| Xi     | Asia      |\n| Jane   | America   |\n</pre><p></p>\n \n<a href="https://en.wikipedia.org/wiki/Pivot_table"> Pivot</a> the continent column in this table so that each name is sorted alphabetically and displayed underneath its corresponding continent. The output headers should be America, Asia and Europe respectively. It is guaranteed that the student number from America is no less than either Asia or Europe.<p></p>\n \nFor the sample input, the output is:<p></p>\n<pre>| America | Asia | Europe |\n|---------|------|--------|\n| Jack    | Xi   | Pascal |\n| Jane    |      |        |\n</pre><p></p>\n \n<b>Follow-up:</b> If it is unknown which continent has the most students, can you write a query to generate the student report?<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-session-variables-and-join-accepted">Approach: Using "session variables" and join [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-session-variables-and-join-accepted">Approach: Using "session variables" and <code>join</code> [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Assign a separate auto increment row id to each of the continent, and then join them together.</p>\n<p><strong>Algorithm</strong></p>\n<p>To set the row id for each continent, we need to use session variables.\nFor example, we can use the following statement to assign a auto increment row number for students in America.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> \n    <span class="n">row_id</span><span class="p">,</span> <span class="n">America</span>\n<span class="k">FROM</span>\n    <span class="p">(</span><span class="k">SELECT</span> <span class="o">@</span><span class="n">am</span><span class="p">:</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="n">t</span><span class="p">,</span>\n    <span class="p">(</span><span class="k">SELECT</span> \n        <span class="o">@</span><span class="n">am</span><span class="p">:</span><span class="o">=@</span><span class="n">am</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">AS</span> <span class="n">row_id</span><span class="p">,</span> <span class="n">name</span> <span class="k">AS</span> <span class="n">America</span>\n    <span class="k">FROM</span>\n        <span class="n">student</span>\n    <span class="k">WHERE</span>\n        <span class="n">continent</span> <span class="o">=</span> <span class="s1">\'America\'</span>\n    <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">America</span><span class="p">)</span> <span class="k">AS</span> <span class="n">t2</span>\n<span class="p">;</span>\n</pre></div>\n<div class="codehilite"><pre><span></span>| row_id | America |\n|--------|---------|\n| 1      | Jack    |\n| 2      | Jane    |\n</pre></div>\n<p>Similarly, we can assign other dedicated row id for other continents as the following result.</p>\n<div class="codehilite"><pre><span></span>| row_id | Asia |\n|--------|------|\n| 1      | Xi   |\n\n| row_id | Europe |\n|--------|--------|\n| 1      | Jesper |\n</pre></div>\n<p>Then if we join these 3 temp tables together and using the same row_id as the condition, we can have the following table.</p>\n<div class="codehilite"><pre><span></span>| row_id | America | Asia | Europe |\n|--------|---------|------|--------|\n| 1      | Jack    | Xi   | Pascal |\n| 2      | Jane    |      |        |\n</pre></div>\n<p>One issue you may encounter is the student list for America is not complete if you use regular inner join since there are more records in this list comparing with the other two. So you may have a solution to use the <code>outer join</code>. Correct! But how to arrange the 3 tables? The trick is to put the America list in the middle so that we can use <code>right (outer) join</code> and <code>right (outer) join</code> to connect with other two tables.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> \n    <span class="n">America</span><span class="p">,</span> <span class="n">Asia</span><span class="p">,</span> <span class="n">Europe</span>\n<span class="k">FROM</span>\n    <span class="p">(</span><span class="k">SELECT</span> <span class="o">@</span><span class="k">as</span><span class="p">:</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">@</span><span class="n">am</span><span class="p">:</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">@</span><span class="n">eu</span><span class="p">:</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="n">t</span><span class="p">,</span>\n    <span class="p">(</span><span class="k">SELECT</span> \n        <span class="o">@</span><span class="k">as</span><span class="p">:</span><span class="o">=@</span><span class="k">as</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">AS</span> <span class="n">asid</span><span class="p">,</span> <span class="n">name</span> <span class="k">AS</span> <span class="n">Asia</span>\n    <span class="k">FROM</span>\n        <span class="n">student</span>\n    <span class="k">WHERE</span>\n        <span class="n">continent</span> <span class="o">=</span> <span class="s1">\'Asia\'</span>\n    <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">Asia</span><span class="p">)</span> <span class="k">AS</span> <span class="n">t1</span>\n        <span class="k">RIGHT</span> <span class="k">JOIN</span>\n    <span class="p">(</span><span class="k">SELECT</span> \n        <span class="o">@</span><span class="n">am</span><span class="p">:</span><span class="o">=@</span><span class="n">am</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">AS</span> <span class="n">amid</span><span class="p">,</span> <span class="n">name</span> <span class="k">AS</span> <span class="n">America</span>\n    <span class="k">FROM</span>\n        <span class="n">student</span>\n    <span class="k">WHERE</span>\n        <span class="n">continent</span> <span class="o">=</span> <span class="s1">\'America\'</span>\n    <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">America</span><span class="p">)</span> <span class="k">AS</span> <span class="n">t2</span> <span class="k">ON</span> <span class="n">asid</span> <span class="o">=</span> <span class="n">amid</span>\n        <span class="k">LEFT</span> <span class="k">JOIN</span>\n    <span class="p">(</span><span class="k">SELECT</span> \n        <span class="o">@</span><span class="n">eu</span><span class="p">:</span><span class="o">=@</span><span class="n">eu</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">AS</span> <span class="n">euid</span><span class="p">,</span> <span class="n">name</span> <span class="k">AS</span> <span class="n">Europe</span>\n    <span class="k">FROM</span>\n        <span class="n">student</span>\n    <span class="k">WHERE</span>\n        <span class="n">continent</span> <span class="o">=</span> <span class="s1">\'Europe\'</span>\n    <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">Europe</span><span class="p">)</span> <span class="k">AS</span> <span class="n">t3</span> <span class="k">ON</span> <span class="n">amid</span> <span class="o">=</span> <span class="n">euid</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '619',
    name: 'Biggest Single Number ',
    acceptance: '35.5%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nTable <code>number</code> contains many numbers in column <b>num</b> including duplicated ones.<br>\nCan you write a SQL query to find the biggest number, which only appears once.<br>\n</p>\n<pre>+---+\n|num|\n+---+\n| 8 |\n| 8 |\n| 3 |\n| 3 |\n| 1 |\n| 4 |\n| 5 |\n| 6 | \n</pre>\nFor the sample data above, your query should return the following result:\n<pre>+---+\n|num|\n+---+\n| 6 |\n</pre>\n<b>Note:</b><br> If there is no such number, just output <b>null</b>.<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-subquery-and-max-function-accepted">Approach: Using subquery and MAX() function [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-subquery-and-max-function-accepted">Approach: Using <strong>subquery</strong> and <code>MAX()</code> function [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Use subquery to select all the numbers appearing just one time.</p>\n<iframe frameborder="0" height="156" name="gCbEq9kC" src="https://leetcode.com/playground/gCbEq9kC/shared" width="100%"></iframe>\n<p>Then choose the biggest one using <code>MAX()</code>.\n<iframe frameborder="0" height="224" name="rYpoAo97" src="https://leetcode.com/playground/rYpoAo97/shared" width="100%"></iframe></p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '620',
    name: 'Not Boring Movies',
    acceptance: '59.4%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            X city opened a new cinema, many people would like to go to this cinema.\nThe cinema also gives out a poster indicating the movies’ ratings and descriptions. <p>\n \nPlease write a SQL query to output movies with an odd numbered ID and a description that is not 'boring'. Order the result by rating.\n</p><p>\n</p><p>\nFor example, table <code>cinema</code>:\n</p><pre>+---------+-----------+--------------+-----------+\n|   id    | movie     |  description |  rating   |\n+---------+-----------+--------------+-----------+\n|   1     | War       |   great 3D   |   8.9     |\n|   2     | Science   |   fiction    |   8.5     |\n|   3     | irish     |   boring     |   6.2     |\n|   4     | Ice song  |   Fantacy    |   8.6     |\n|   5     | House card|   Interesting|   9.1     |\n+---------+-----------+--------------+-----------+\n</pre>\nFor the example above, the output should be:\n<pre>+---------+-----------+--------------+-----------+\n|   id    | movie     |  description |  rating   |\n+---------+-----------+--------------+-----------+\n|   5     | House card|   Interesting|   9.1     |\n|   1     | War       |   great 3D   |   8.9     |\n+---------+-----------+--------------+-----------+\n</pre>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-mod-function-accepted">Approach: Using MOD() function [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-mod-function-accepted">Approach: Using <code>MOD()</code> function [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can use the <code>mod(id,2)=1</code> to determine the odd id, and then add a <code>description != \'boring\'</code> should address this problem.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">select</span> <span class="o">*</span>\n<span class="k">from</span> <span class="n">cinema</span>\n<span class="k">where</span> <span class="k">mod</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">and</span> <span class="n">description</span> <span class="o">!=</span> <span class="s1">\'boring\'</span>\n<span class="k">order</span> <span class="k">by</span> <span class="n">rating</span> <span class="k">DESC</span>\n<span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '621',
    name: 'Task Scheduler',
    acceptance: '42.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.</p>\n\n<p>However, there is a non-negative cooling interval <b>n</b> that means between two <b>same tasks</b>, there must be at least n intervals that CPU are doing different tasks or just be idle. </p>\n\n<p>You need to return the <b>least</b> number of intervals the CPU will take to finish all the given tasks.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> tasks = ["A","A","A","B","B","B"], n = 2\n<b>Output:</b> 8\n<b>Explanation:</b> A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The number of tasks is in the range [1, 10000].</li>\n<li>The integer n is in the range [0, 100].</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-sorting-accepted">Approach #1 Using Sorting [Accepted]</a></li>\n<li><a href="#approach-2-using-priority-queue-accepted">Approach #2 Using Priority-Queue [Accepted]</a></li>\n<li><a href="#approach-3-calculating-idle-slots-accepted">Approach #3 Calculating Idle slots [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-sorting-accepted">Approach #1 Using Sorting [Accepted]</h4>\n<p>Before we start off with the solution, we can note that the names of the tasks are irrelevant for obtaining the solution of the given problem. The time taken for the tasks to be finished is only dependent on the number of instances of each task and not on the names of tasks. </p>\n<p>The first solution that comes to the mind is to consider the tasks to be executed in the descending order of their number of instances. For every task executed, we can keep a track of the time at which this task was executed in order to consider the impact of cooling time in the future. We can execute all the tasks in the descending order of their number of instances and can keep on updating the number of instances pending for each task as well. After one cycle of the task list is executed, we can again start with the first task(largest count of instances) and keep on continuing the process by inserting idle cycles wherever appropriate by considering the last execution time of the task and the cooling time as well. </p>\n<p>But, there is a flaw in the above idea. Consider the case, where say the number of instances of tasks A, B, C, D, E  are 6, 1, 1, 1, 1 respectively with n=2(cooling time). If we go by the above method, firstly we give 1 round to each A, B, C, D and E. Now, only 5 instances of A are pending, but each instance will take 3 time units to complete because of cooling time. But a better way to schedule the tasks will be this: A, B, C, A, D, E, ... . In this way, by giving turn to the task A as soon as its cooling time is over, we can save a good number of clock cycles.</p>\n<p>From the above example, we are clear with one idea. It is that, the tasks with the currently maximum number of outstanding (pending)instances will contribute to a large number of idle cycles in the future, if not executed with appropriate interleavings with the other tasks. Thus, we need to re-execute such a task as soon as its cooling time is finished. </p>\n<p>Thus, based on the above ideas, firstly, we obtain a count of the number of instances of each task in <script type="math/tex; mode=display">map</script> array. Then, we start executing the tasks in the order of descending number of their initial instances. As soon as we execute the first task, we start its cooling timer as well(<script type="math/tex; mode=display">i</script>). For every task executed, we update the pending number of instances of the current task. We update the current time, <script type="math/tex; mode=display">time</script>, at every instant as well. Now, as soon as the timer, <script type="math/tex; mode=display">i</script>\'s value exceeds the cooling time, as discussed above, we again need to consider the task with the largest number of pending instances. Thus, we again sort the <script type="math/tex; mode=display">tasks</script> array with updated counts of instances and again pick up the tasks in the descending order of their number of instances. </p>\n<p>Now, the task picked up first after the sorting, will either be the first task picked up in the last iteration(which will now be picked after its cooling time has been finished) or the task picked will be the one which lies at <script type="math/tex; mode=display">(n+1)^{th}</script> position in the previous descending <script type="math/tex; mode=display">tasks</script> array. In either of the cases, the cooling time won\'t cause any conflicts(it has been considered implicitly). Further, the task most critical currently will always be picked up which was the main requirement.</p>\n<p>We stop this process, when the pending instances of all the tasks have been reduced to 0. At this moment, <script type="math/tex; mode=display">time</script> gives the required result.</p>\n<iframe frameborder="0" height="428" name="MxzSpcHY" src="https://leetcode.com/playground/MxzSpcHY/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(time)</script>. Number of iterations will be equal to resultant time <script type="math/tex; mode=display">time</script>. </p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant size array <script type="math/tex; mode=display">map</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-priority-queue-accepted">Approach #2 Using Priority-Queue [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of making use of sorting as done in the last approach, we can also make use of a Max-Heap(<script type="math/tex; mode=display">queue</script>) to pick the order in which the tasks need to be executed. But we need to ensure that the heapification occurs only after the intervals of cooling time, <script type="math/tex; mode=display">n</script>, as done in the last approach.</p>\n<p>To do so, firstly, we put only those elements from <script type="math/tex; mode=display">map</script> into the <script type="math/tex; mode=display">queue</script> which have non-zero number of instances. Then, we start picking up the largest task from the <script type="math/tex; mode=display">queue</script> for current execution. (Again, at every instant, we update the current <script type="math/tex; mode=display">time</script> as well.) We pop this element from the <script type="math/tex; mode=display">queue</script>. We also decrement its pending number of instances and if any more instances of the current task are pending, we store them(count) in a temporary <script type="math/tex; mode=display">temp</script> list, to be added later on back into the <script type="math/tex; mode=display">queue</script>. We keep on doing so, till a cycle of cooling time has been finished. After every such cycle, we add the generated <script type="math/tex; mode=display">temp</script> list back to the <script type="math/tex; mode=display">queue</script> for considering the most critical task again. </p>\n<p>We keep on doing so till the <script type="math/tex; mode=display">queue</script>(and <script type="math/tex; mode=display">temp</script>) become totally empty. At this instant, the current value of <script type="math/tex; mode=display">time</script> gives the required result.</p>\n<iframe frameborder="0" height="515" name="cAjn8Sxo" src="https://leetcode.com/playground/cAjn8Sxo/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Number of iterations will be equal to resultant time <script type="math/tex; mode=display">time</script>. </p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. <script type="math/tex; mode=display">queue</script> and <script type="math/tex; mode=display">temp</script> size will not exceed O(26).</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-calculating-idle-slots-accepted">Approach #3 Calculating Idle slots [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This approach is inpired by <a href="http://leetcode.com/zhanzq">@zhanzq</a></p>\n<p>If we are able to, somehow, determine the number of idle slots(<script type="math/tex; mode=display">idle\\_slots</script>), we can find out the time required to execute all the tasks as <script type="math/tex; mode=display">idle\\_slots + Total Number Of Tasks</script>. Thus, the idea is to find out the idle time first.</p>\n<p>To find the idle time, consider figure 1 below.</p>\n<p align="align"><img alt="Tasks" src="https://leetcode.com/articles/Figures/621_Task_Scheduler_new.PNG"></p>\n<p>From this figure, we can observe that the maximum number of idle slots will always be given by the product of the cooling time and the number of instances of the task with maximum count less 1(in case only multiple instances of the same task need to be executed, and each, then, is executed after lapse of every cooling time). The factor of 1 is deducted from the task\'s count with maximum number of instances, as is clear from the figure, is that in the last round of execution of the tasks, the idle slots need not be considered for insertion following the execution of the related task. Now, based on the count of the instances of the other tasks, we can reduce the number of idle slots from this maximum value, to determine the minimum number of idle slots needed.</p>\n<p>To do so, consider figure 2 as shown above. From the figure above, assuming the tasks are executed in row-wise order, we can see that in case the number of instances of another task equal the number of instances of the task with maximum number of instances, the number of idle slots saved is equal to its number of instances less 1 as is clear for the case of task B above. But, if the count of the number of instances, say <script type="math/tex; mode=display">i</script> is lesser than the this maximum value, the number of idle slots saved is equal to the value <script type="math/tex; mode=display">i</script> itself as is clear for the case of task C. Further, we can observe that  for any arbitrary task other than A, B or C with the count of number of instances lesser than C, this task can be easily accomodated into the idle slots or if no more idle slot is available, this task can be appended after every row of tasks without interfering with the cooling time. In the first case, subtracting its number of intances from the number of idle slots leads to obtaining the correct number of available idle slots. In the second case, which will only occur if the number of idle slots pending is already zero, it leads to negative net idle slots, which can later be considered as zero for the purpose of calculations.</p>\n<p>Thus, we can easily obtain the number of pending idle slots by subtracting appropriate number of slots from the available ones and at the end, we can obtain the total time required as the sum of pending idle slots and the total number of tasks.</p>\n<iframe frameborder="0" height="275" name="jC8vicao" src="https://leetcode.com/playground/jC8vicao/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We iterate over <script type="math/tex; mode=display">tasks</script> array only once. (<script type="math/tex; mode=display">O(n)</script>).Sorting <script type="math/tex; mode=display">tasks</script> array of length <script type="math/tex; mode=display">n</script> takes <script type="math/tex; mode=display">O\\big(26log(26)\\big)= O(1)</script> time. After this, only one iteration over 26 elements of <script type="math/tex; mode=display">map</script> is done(<script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. <script type="math/tex; mode=display">map</script> array of constant size(26) is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '623',
    name: 'Add One Row to Tree',
    acceptance: '46.7%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given the root of a binary tree, then value <code>v</code> and depth <code>d</code>, you need to add a row of nodes with value <code>v</code> at the given depth <code>d</code>. The root node is at depth 1. </p>\n\n<p>The adding rule is: given a positive integer depth <code>d</code>, for each NOT null tree nodes <code>N</code> in depth <code>d-1</code>, create two tree nodes with value <code>v</code> as <code>N's</code> left subtree root and right subtree root. And <code>N's</code> <b>original left subtree</b> should be the left subtree of the new left subtree root, its <b>original right subtree</b> should be the right subtree of the new right subtree root. If depth <code>d</code> is 1 that means there is no depth d-1 at all, then create a tree node with value <b>v</b> as the new root of the whole original tree, and the original tree is the new root's left subtree.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \nA binary tree as following:\n       4\n     /   \\\n    2     6\n   / \\   / \n  3   1 5   \n\n<b>v = 1</b>\n\n<b>d = 2</b>\n\n<b>Output:</b> \n       4\n      / \\\n     1   1\n    /     \\\n   2       6\n  / \\     / \n 3   1   5   \n\n</pre>\n<p></p>\n\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \nA binary tree as following:\n      4\n     /   \n    2    \n   / \\   \n  3   1    \n\n<b>v = 1</b>\n\n<b>d = 3</b>\n\n<b>Output:</b> \n      4\n     /   \n    2\n   / \\    \n  1   1\n /     \\  \n3       1\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The given d is in range [1, maximum depth of the given tree + 1].</li>\n<li>The given binary tree has at least one tree node.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-recursiondfs-accepted">Approach #1 Using Recursion(DFS) [Accepted]</a></li>\n<li><a href="#approach-2-using-stackdfs-accepted">Approach #2 Using stack(DFS) [Accepted]</a></li>\n<li><a href="#approach-3-using-queuebfs-accepted">Approach #3 Using queue(BFS) [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-recursiondfs-accepted">Approach #1 Using Recursion(DFS) [Accepted]</h4>\n<p>If the given depth <script type="math/tex; mode=display">d</script> happens to be equal to 1, we can directly put the whole current tree as a left child of the newly added node. Otherwise, we need to put the new node at appropriate levels. </p>\n<p>To do so, we make use of a recursive function <code>insert(val,node,depth,n)</code>. Here, <script type="math/tex; mode=display">val</script> refers to the value of the new node to be inserted, <script type="math/tex; mode=display">depth</script> refers to the depth of the node currently considered, <script type="math/tex; mode=display">node</script> refers to the node calling the current function for its child subtrees and <script type="math/tex; mode=display">n</script> refers to the height at which the new node needs to be inserted. </p>\n<p>For inserting the new node at appropriate level, we can start by making a call to <code>insert</code> with the root node and 1 as the current level. Inside every such call, we check if we\'ve reached one level prior to the level where the new node needs to be inserted. </p>\n<p>From this level, we can store the roots of the left and right subtrees of the current node temporarily, and insert the new node as the new left and right subchild of the current node, with the temporarily stored left and right subtrees as the left and right subtrees of the newly inserted left or right subchildren appropriately.</p>\n<p>But, if we haven\'t reached the destined level, we keep on continuing the recursive calling process with the left and right children of the current node respectively. At every such call, we also incrmenet the depth of the current level to reflect the depth change appropriately.</p>\n<p>The animation below illustrates the process:</p>\n<p>!?!../Documents/623_Add_One_Row_Recursion_New.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="mqAnMFzQ" src="https://leetcode.com/playground/mqAnMFzQ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. A total of <script type="math/tex; mode=display">n</script> nodes of the given tree will be considered.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of the recursion tree can go upto <script type="math/tex; mode=display">n</script> in the worst case(skewed tree).</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-stackdfs-accepted">Approach #2 Using stack(DFS) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can do the same task as discussed in the last approach by making use of a <script type="math/tex; mode=display">stack</script> as well. But, we need to make use of a new data structure, <script type="math/tex; mode=display">Node</script> here, to keep a track of the depth of the current node along with its value. </p>\n<p>We start by pushing the root <script type="math/tex; mode=display">Node</script> onto the <script type="math/tex; mode=display">stack</script>. Then, at every step we do as follows:</p>\n<ul>\n<li>\n<p>Pop an element from the <script type="math/tex; mode=display">stack</script>. </p>\n</li>\n<li>\n<p>For every Node popped, check if its depth corresponds to one prior to the depth at which the new node needs to be inserted. </p>\n</li>\n<li>\n<p>If yes, insert the new nodes appropriately as in the last approach. </p>\n</li>\n<li>\n<p>If no, we push both the left and the right child Node(value+depth) of the current node onto the <script type="math/tex; mode=display">stack</script>. </p>\n</li>\n<li>\n<p>Continue the popping and pushing process till the <script type="math/tex; mode=display">stack</script> becomes empty.</p>\n</li>\n</ul>\n<p>Look at the animation below for a better understanding.</p>\n<p>!?!../Documents/623_Add_One_Row_Stack_new.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="6Gut8kVG" src="https://leetcode.com/playground/6Gut8kVG/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. A total of <script type="math/tex; mode=display">n</script> nodes of the given tree will be considered.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of the <script type="math/tex; mode=display">stack</script> can go upto <script type="math/tex; mode=display">n</script> in the worst case(skewed tree).</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-queuebfs-accepted">Approach #3 Using queue(BFS) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The idea of traversal in the last approach is similar to Depth First Search. In that case, we need to traverse through all the nodes of the given tree in the order of branches. Firstly we explored one branch to as much depth as possible and then continued with the other ones. </p>\n<p>If, instead, we go for Breadth First Search, along with keeping track of the depth of the nodes being considered at any moment during the Breadth First Search, we can stop the search process as soon as all the nodes at the depth <script type="math/tex; mode=display">d - 1</script> have been considered once. </p>\n<p>To implement this BFS, we make use of a <script type="math/tex; mode=display">queue</script>. We start off by pushing the root node of the given tree at the back of the <script type="math/tex; mode=display">queue</script> and with the depth of the current level set as 1. Then, at every step, we do the following:</p>\n<ul>\n<li>\n<p>Remove an element from the front of the <script type="math/tex; mode=display">queue</script> and add all its children to the back of another temporary queue, <script type="math/tex; mode=display">temp</script>. </p>\n</li>\n<li>\n<p>Keep on adding the elements to the back of the <script type="math/tex; mode=display">temp</script> till <script type="math/tex; mode=display">queue</script> becomes empty. (Once <script type="math/tex; mode=display">queue</script> becomes empty, it indicates that all the nodes at the current level have been considered and now <script type="math/tex; mode=display">temp</script> contains all the nodes lying at the next level).</p>\n</li>\n<li>\n<p>Reinitialize <script type="math/tex; mode=display">queue</script>  with its value as <script type="math/tex; mode=display">temp</script>. Update the current value of the <script type="math/tex; mode=display">depth</script> to reflect the level of nodes currently being considered. </p>\n</li>\n<li>\n<p>Repeat the process till we reach the depth <script type="math/tex; mode=display">d - 1</script>. </p>\n</li>\n<li>\n<p>On hitting this depth level(<script type="math/tex; mode=display">d-1</script>), add the new nodes appropriately to all the nodes in the <script type="math/tex; mode=display">queue</script> currently, as done in the previous approaches.</p>\n</li>\n</ul>\n<p>The following animation illustrates the process.</p>\n<p>!?!../Documents/623_Add_One_Row_queue_new.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="EC8ne3QM" src="https://leetcode.com/playground/EC8ne3QM/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. A total of <script type="math/tex; mode=display">n</script> nodes of the given tree will be considered in the worst case.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(x)</script>. The size of the <script type="math/tex; mode=display">queue</script> or <script type="math/tex; mode=display">temp</script> queue can grow upto <script type="math/tex; mode=display">x</script> only. Here, <script type="math/tex; mode=display">x</script> refers to the number of maximum number of nodes at any level in the given tree.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Gilt Groupe'],
  },
  {
    id: '624',
    name: 'Maximum Distance in Arrays ',
    acceptance: '34.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven <code>m</code> arrays, and each array is sorted in ascending order. Now you can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers <code>a</code> and <code>b</code> to be their absolute difference <code>|a-b|</code>. Your task is to find the maximum distance.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \n[[1,2,3],\n [4,5],\n [1,2,3]]\n<b>Output:</b> 4\n<b>Explanation:</b> \nOne way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array.\n</pre>\n<p></p>\n\t\n<p><b>Note:</b><br>\n</p><ol>\n<li>Each given array will have at least 1 number. There will be at least two non-empty arrays.</li>\n<li>The total number of the integers in <b>all</b> the <code>m</code> arrays will be in the range of [2, 10000].</li>\n<li>The integers in the <code>m</code> arrays will be in the range of [-10000, 10000].</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-single-scan-accepted">Approach #3 Single Scan [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The simplest solution is to pick up every element of every array from the <script type="math/tex; mode=display">list</script> and find its distance from every element in all the other arrays except itself and find the largest distance from out of those.</p>\n<iframe frameborder="0" height="326" name="rge5K69S" src="https://leetcode.com/playground/rge5K69S/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O((n*x)^2)</script>. We traverse over all the arrays in <script type="math/tex; mode=display">list</script> for every element of every array considered. Here, <script type="math/tex; mode=display">n</script> refers to the number of arrays in the <script type="math/tex; mode=display">list</script> and <script type="math/tex; mode=display">x</script> refers to the average number of elements in each array in the <script type="math/tex; mode=display">list</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we didn\'t make use of the fact that every array in the <script type="math/tex; mode=display">list</script> is sorted. Thus, instead of considering the distances among all the elements of all the arrays(except intra-array elements), we can consider only the distances between the first(minimum element) element of an array and the last(maximum element) element of the other arrays and find out the maximum distance from among all such distances. </p>\n<iframe frameborder="0" height="275" name="QdXWERJK" src="https://leetcode.com/playground/QdXWERJK/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. We consider only max and min values directly for every array currenty considered. Here, <script type="math/tex; mode=display">n</script> refers to the number of arrays in the <script type="math/tex; mode=display">list</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-single-scan-accepted">Approach #3 Single Scan [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>As discussed already, in order to find out the maximum distance between any two arrays, we need not compare every element of the arrays, since the arrays are already sorted. Thus, we can consider only the extreme points in the arrays to do the distance calculations.</p>\n<p>Further, the two points being considered for the distance calculation should not both belong to the same array. Thus, for arrays <script type="math/tex; mode=display">a</script> and <script type="math/tex; mode=display">b</script> currently chosen, we can just find the maximum out of <script type="math/tex; mode=display">a[n-1]-b[0]</script> and <script type="math/tex; mode=display">b[m-1]-a[0]</script> to find the larger distance. Here, <script type="math/tex; mode=display">n</script> and <script type="math/tex; mode=display">m</script> refer to the lengths of arrays <script type="math/tex; mode=display">a</script> and <script type="math/tex; mode=display">b</script> respectively. </p>\n<p>But, we need not compare all the array pairs possible to find the maximum distance. Instead, we can keep on traversing over the arrays in the <script type="math/tex; mode=display">list</script> and keep a track of the maximum distance found so far. </p>\n<p>To do so, we keep a track of the element with minimum value(<script type="math/tex; mode=display">min\\_val</script>) and the one with maximum value(<script type="math/tex; mode=display">max\\_val</script>) found so far. Thus, now these extreme values can be treated as if they represent the extreme points of a cumulative array of all the arrays that have been considered till now. </p>\n<p>For every new array, <script type="math/tex; mode=display">a</script> considered, we find the distance <script type="math/tex; mode=display">a[n-1]-min\\_val</script> and <script type="math/tex; mode=display">max\\_val - a[0]</script> to compete with the maximum distance found so far. Here, <script type="math/tex; mode=display">n</script> refers to the number of elements in the current array, <script type="math/tex; mode=display">a</script>. Further, we need to note that the maximum distance found till now needs not always be contributed by the end points of the distance being <script type="math/tex; mode=display">max\\_val</script> and <script type="math/tex; mode=display">min\\_val</script>. </p>\n<p>But, such points could help in maximizing the distance in the future. Thus, we need to keep track of these maximum and minimum values along with the maximum distance found so far for future calculations. But, in general, the final maximum distance found will always be determined by one of these extreme values, <script type="math/tex; mode=display">max\\_val</script> and <script type="math/tex; mode=display">min\\_val</script>, or in some cases, by both of them.</p>\n<p>The following animation illustrates the process.</p>\n<p>!?!../Documents/624_Maximum_Distance.json:1000,563!?!</p>\n<p>From the above illustration, we can clearly see that although the <script type="math/tex; mode=display">max\\_val</script> or <script type="math/tex; mode=display">min\\_val</script> could not contribute to the local maximum distance values, they could later on contribute to the maximum distance.</p>\n<iframe frameborder="0" height="241" name="tiaZo26H" src="https://leetcode.com/playground/tiaZo26H/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We traverse over the <script type="math/tex; mode=display">list</script> of length <script type="math/tex; mode=display">n</script> once only.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Yahoo'],
  },
  {
    id: '625',
    name: 'Minimum Factorization ',
    acceptance: '30.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a positive integer <code>a</code>, find the smallest positive integer <code>b</code> whose multiplication of each digit equals to <code>a</code>. </p>\n\n<p>\nIf there is no answer or the answer is not fit in 32-bit signed integer, then return 0.</p>\n\n<p>\n<b>Example 1</b><br>\nInput:\n</p><pre>48 </pre>\nOutput:\n<pre>68</pre>\n<p></p>\n\n<p>\n<b>Example 2</b><br>\nInput: \n</p><pre>15</pre>\n\nOutput:\n<pre>35</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-using-factorizationaccepted">Approach #3  Using Factorization[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The simplest solution is to consider every possible 32-bit number starting from 1 which satisfies the given criteria. To check this, we obtain each individual digit of every such number and check if their product is equal to the given number <script type="math/tex; mode=display">a</script>. As soon as such a number is found, we return the same. If no such 32-bit number is found, we return a 0 value.</p>\n<iframe frameborder="0" height="309" name="W7M6JELz" src="https://leetcode.com/playground/W7M6JELz/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(9999999999)</script>. In case of prime numbers loop can go upto this large number.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of considering every possible number from the total search space, we can do the search in a smarter way. We can start putting the numbers from 9 to 2 at the ones position and keep on proceeding towards more significant places. For every number currently generated, we can check if the product of its digits exceeds the given number <script type="math/tex; mode=display">a</script>. If so, there is no point in appending more digitas to this number. Thus, we can change the composition of the number generated till now and continue the checking process. </p>\n<p>For doing this, we make use of a recursive function <code>search()</code>, which takes the number generated till now, <script type="math/tex; mode=display">res</script>(as a string) as one of its arguments along with the number to be appended next as the <script type="math/tex; mode=display">res</script> as a prefix as one of the other arguments. We can note that to obtain the smallest possible number, we need to try to put the largest number(which will be one of the factors for constituting the product <script type="math/tex; mode=display">a</script>) at the least significant position and the smallest one at the most significant position. Thus, we start from the least significant position by trying to place a 9 at this position and then continue by trying to place smaller numbers at this position if the numbers generated by the previous arrangements fail. If some arrangement leads to a product of digits not larger than <script type="math/tex; mode=display">a</script>, we continue with placing digits, equal to or smaller than the last digit placed, at the more significant positions.</p>\n<p>The following animation illustrates the recursive process:</p>\n<p>!?!../Documents/625_Minimum_Factorization.json:1000,563!?!</p>\n<iframe frameborder="0" height="411" name="mq3fEUtA" src="https://leetcode.com/playground/mq3fEUtA/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(l)</script>. Here <script type="math/tex; mode=display">l</script> refers to total number of combinations.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(log(a))</script>. In worst case, depth of recursion tree can go upto the <script type="math/tex; mode=display">O(log(a))</script>\n.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-factorizationaccepted">Approach #3  Using Factorization[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We know that the final number generated, <script type="math/tex; mode=display">res</script>,  should be such that its digits should have a product equal to the given number <script type="math/tex; mode=display">a</script>. In other words, the digits of <script type="math/tex; mode=display">res</script> will be the factors of the given number <script type="math/tex; mode=display">a</script>. Thus, our problem reduces to finding the factors(not necessarily prime) of <script type="math/tex; mode=display">a</script> and finding their smallest possible arrangement. Thus, we start with trying with the largest possible factor <script type="math/tex; mode=display">9</script>, obtain as many such counts of this factor as possible in <script type="math/tex; mode=display">res</script> and place such factors obtianed at its least significant positions. Then, we go on decrementing the number currently considered as the possible factor and if it is a factor, we keep on placing it at relatively more significant positions in <script type="math/tex; mode=display">res</script>. We go on getting such factors till we are done considering all the numbers from 9 to 2.  At the end, <script type="math/tex; mode=display">res</script> gives the required result.</p>\n<iframe frameborder="0" height="309" name="WHBgGGcX" src="https://leetcode.com/playground/WHBgGGcX/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(8loga)</script>. Outer loop will iterate only 8 times, while inner loop takes <script type="math/tex; mode=display">O(logi)</script> for particular <script type="math/tex; mode=display">i</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Tencent'],
  },
  {
    id: '626',
    name: 'Exchange Seats',
    acceptance: '47.7%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Mary is a teacher in a middle school and she has a table <code>seat</code> storing students' names and their corresponding seat ids.</p>\nThe column <b>id</b> is continuous increment.<p></p>\nMary wants to change seats for the adjacent students.<p></p>\nCan you write a SQL query to output the result for Mary?<p></p>\n<pre>+---------+---------+\n|    id   | student |\n+---------+---------+\n|    1    | Abbot   |\n|    2    | Doris   |\n|    3    | Emerson |\n|    4    | Green   |\n|    5    | Jeames  |\n+---------+---------+\n</pre>\nFor the sample input, the output is:<p></p>\n<pre>+---------+---------+\n|    id   | student |\n+---------+---------+\n|    1    | Doris   |\n|    2    | Abbot   |\n|    3    | Green   |\n|    4    | Emerson |\n|    5    | Jeames  |\n+---------+---------+\n</pre>\n<p>\n<b>Note:</b><br>\nIf the number of students is odd, there is no need to change the last one's seat.\n</p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-i-using-flow-control-statement-case-accepted">Approach I: Using flow control statement CASE [Accepted]</a></li>\n<li><a href="#approach-ii-using-bit-manipulation-and-coalesce-accepted">Approach II: Using bit manipulation and COALESCE() [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-i-using-flow-control-statement-case-accepted">Approach I: Using flow control statement <code>CASE</code> [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>For students with odd id, the new id is (id+1) after switch unless it is the last seat. And for students with even id, the new id is (id-1). In order to know how many seats in total, we can use a subquery:</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">counts</span>\n<span class="k">FROM</span>\n    <span class="n">seat</span>\n</pre></div>\n<p>Then, we can use the <code>CASE</code> statement and <code>MOD()</code> function to alter the seat id of each student.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="p">(</span><span class="k">CASE</span>\n        <span class="k">WHEN</span> <span class="k">MOD</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">AND</span> <span class="n">counts</span> <span class="o">!=</span> <span class="n">id</span> <span class="k">THEN</span> <span class="n">id</span> <span class="o">+</span> <span class="mi">1</span>\n        <span class="k">WHEN</span> <span class="k">MOD</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">AND</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">id</span> <span class="k">THEN</span> <span class="n">id</span>\n        <span class="k">ELSE</span> <span class="n">id</span> <span class="o">-</span> <span class="mi">1</span>\n    <span class="k">END</span><span class="p">)</span> <span class="k">AS</span> <span class="n">id</span><span class="p">,</span>\n    <span class="n">student</span>\n<span class="k">FROM</span>\n    <span class="n">seat</span><span class="p">,</span>\n    <span class="p">(</span><span class="k">SELECT</span>\n        <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">counts</span>\n    <span class="k">FROM</span>\n        <span class="n">seat</span><span class="p">)</span> <span class="k">AS</span> <span class="n">seat_counts</span>\n<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">id</span> <span class="k">ASC</span><span class="p">;</span>\n</pre></div>\n<h4 id="approach-ii-using-bit-manipulation-and-coalesce-accepted">Approach II: Using bit manipulation and <code>COALESCE()</code> [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Bit manipulation expression <code>(id+1)^1-1</code> can calculate the new id after switch.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="p">(</span><span class="n">id</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">student</span> <span class="k">FROM</span> <span class="n">seat</span><span class="p">;</span>\n</pre></div>\n<div class="codehilite"><pre><span></span>| id | (id+1)^1-1 | student |\n|----|------------|---------|\n| 1  | 2          | Abbot   |\n| 2  | 1          | Doris   |\n| 3  | 4          | Emerson |\n| 4  | 3          | Green   |\n| 5  | 6          | Jeames  |\n</pre></div>\n<p>Then, we can make a temp table and join seat with this table like below.</p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="o">*</span>\n<span class="k">FROM</span>\n    <span class="n">seat</span> <span class="n">s1</span>\n        <span class="k">LEFT</span> <span class="k">JOIN</span>\n    <span class="n">seat</span> <span class="n">s2</span> <span class="k">ON</span> <span class="p">(</span><span class="n">s1</span><span class="p">.</span><span class="n">id</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span> <span class="o">=</span> <span class="n">s2</span><span class="p">.</span><span class="n">id</span>\n<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">s1</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>\n</pre></div>\n<div class="codehilite"><pre><span></span>| id | student | id | student |\n|----|---------|----|---------|\n| 1  | Abbot   | 2  | Doris   |\n| 2  | Doris   | 1  | Abbot   |\n| 3  | Emerson | 4  | Green   |\n| 4  | Green   | 3  | Emerson |\n| 5  | Jeames  |    |         |\n</pre></div>\n<blockquote>\n<p>Note:The first two columns are from s1 and the last two are from s2.</p>\n</blockquote>\n<p>At last, we can output s1.id and s2.student. However, the s2.student is NULL for seat id \'5\' but s1.student is right. Thus, we we can use function <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#function_coalesce"><code>COALESCE()</code></a> to generate the correct output for the last record.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">SELECT</span>\n    <span class="n">s1</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">COALESCE</span><span class="p">(</span><span class="n">s2</span><span class="p">.</span><span class="n">student</span><span class="p">,</span> <span class="n">s1</span><span class="p">.</span><span class="n">student</span><span class="p">)</span> <span class="k">AS</span> <span class="n">student</span>\n<span class="k">FROM</span>\n    <span class="n">seat</span> <span class="n">s1</span>\n        <span class="k">LEFT</span> <span class="k">JOIN</span>\n    <span class="n">seat</span> <span class="n">s2</span> <span class="k">ON</span> <span class="p">((</span><span class="n">s1</span><span class="p">.</span><span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">=</span> <span class="n">s2</span><span class="p">.</span><span class="n">id</span>\n<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">s1</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>\n</pre></div>\n<blockquote>\n<p>Note: This solution comes from <a href="https://discuss.leetcode.com/user/fangxiaofang">@FANGXIAOFANG</a>.</p>\n</blockquote>\n</div>\n          ',
    tags: [],
  },
  {
    id: '627',
    name: 'Swap Salary',
    acceptance: '66.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            Given a table <code>salary</code>, such as the one below, that has m=male and  f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update query and no intermediate temp table.<p></p>\n \nFor example:<p></p>\n \n<pre>| id | name | sex | salary |\n|----|------|-----|--------|\n| 1  | A    | m   | 2500   |\n| 2  | B    | f   | 1500   |\n| 3  | C    | m   | 5500   |\n| 4  | D    | f   | 500    |\n</pre>\nAfter running your query, the above salary table should have the following rows:\n<pre>| id | name | sex | salary |\n|----|------|-----|--------|\n| 1  | A    | f   | 2500   |\n| 2  | B    | m   | 1500   |\n| 3  | C    | f   | 5500   |\n| 4  | D    | m   | 500    |\n</pre>\n\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-using-update-and-casewhen-accepted">Approach: Using UPDATE and CASE...WHEN [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-using-update-and-casewhen-accepted">Approach: Using <code>UPDATE</code> and <code>CASE...WHEN</code> [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>To dynamically set a value to a column, we can use <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html"><code>UPDATE</code></a> statement together when <a href="https://dev.mysql.com/doc/refman/5.7/en/case.html"><code>CASE...WHEN...</code></a> flow control statement.</p>\n<p><strong>MySQL</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">UPDATE</span> <span class="n">salary</span>\n<span class="k">SET</span>\n    <span class="n">sex</span> <span class="o">=</span> <span class="k">CASE</span> <span class="n">sex</span>\n        <span class="k">WHEN</span> <span class="s1">\'m\'</span> <span class="k">THEN</span> <span class="s1">\'f\'</span>\n        <span class="k">ELSE</span> <span class="s1">\'m\'</span>\n    <span class="k">END</span><span class="p">;</span>\n</pre></div>\n</div>\n          ',
    tags: [],
  },
  {
    id: '628',
    name: 'Maximum Product of Three Numbers',
    acceptance: '45.1%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,2,3]\n<b>Output:</b> 6\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [1,2,3,4]\n<b>Output:</b> 24\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The length of the given array will be in range [3,10<sup>4</sup>] and all elements are in the range [-1000, 1000].</li>\n<li>Multiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-sorting-accepted">Approach #2 Using Sorting [Accepted]</a></li>\n<li><a href="#approach-3-single-scan-accepted">Approach #3 Single Scan [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The simplest solution is to consider every triplet out of the given <script type="math/tex; mode=display">nums</script> array and check their product and find out the maximum product out of them.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. We need to consider every triplet from <script type="math/tex; mode=display">nums</script> array of length <script type="math/tex; mode=display">n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-sorting-accepted">Approach #2 Using Sorting [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Another solution could be to sort the given <script type="math/tex; mode=display">nums</script> array(in ascending order) and find out the product of the last three numbers. </p>\n<p>But, we can note that this product will be maximum only if all the numbers in <script type="math/tex; mode=display">nums</script> array are positive. But, in the given problem statement, negative elements could exist as well. </p>\n<p>Thus, it could also be possible that two negative numbers lying at the left extreme end could also contribute to lead to a larger product if the third number in the triplet being considered is the largest positive number in the <script type="math/tex; mode=display">nums</script> array. </p>\n<p>Thus, either the product <script type="math/tex; mode=display">nums[0]</script>x<script type="math/tex; mode=display">nums[1]</script>x<script type="math/tex; mode=display">nums[n-1]</script> or <script type="math/tex; mode=display">nums[n-3]</script>x<script type="math/tex; mode=display">nums[n-2]</script>x<script type="math/tex; mode=display">nums[n-1]</script> will give the required result. Thus, we need to find the larger one from out of these values.</p>\n<iframe frameborder="0" height="173" name="L7hasHZW" src="https://leetcode.com/playground/L7hasHZW/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script>. Sorting the <script type="math/tex; mode=display">nums</script> array takes <script type="math/tex; mode=display">nlog(n)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(log(n)))</script>. Sorting takes O(logn) space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-single-scan-accepted">Approach #3 Single Scan [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We need not necessarily sort the given <script type="math/tex; mode=display">nums</script> array to find the maximum product. Instead, we can only find the required 2 smallest values(<script type="math/tex; mode=display">min1</script> and <script type="math/tex; mode=display">min2</script>) and the three largest values(<script type="math/tex; mode=display">max1, max2, max3</script>) in the <script type="math/tex; mode=display">nums</script> array, by iterating over the <script type="math/tex; mode=display">nums</script> array only once. </p>\n<p>At the end, again we can find out the larger value out of <script type="math/tex; mode=display">min1</script>x<script type="math/tex; mode=display">min2</script>x<script type="math/tex; mode=display">max1</script> and <script type="math/tex; mode=display">max1</script>x<script type="math/tex; mode=display">max2</script>x<script type="math/tex; mode=display">max3</script> to find the required maximum product.</p>\n<iframe frameborder="0" height="479" name="bDifEipg" src="https://leetcode.com/playground/bDifEipg/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Only one iteration over the <script type="math/tex; mode=display">nums</script> array of length <script type="math/tex; mode=display">n</script> is required.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Intuit'],
  },
  {
    id: '629',
    name: 'K Inverse Pairs Array',
    acceptance: '26.8%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>\nGiven two integers <code>n</code> and <code>k</code>, find how many different arrays consist of numbers from <code>1</code> to <code>n</code> such that there are exactly <code>k</code> inverse pairs. \n</p>\n<p>\nWe define an inverse pair as following:\nFor <code>i<sub>th</sub></code> and <code>j<sub>th</sub></code> element in the array, if <code>i</code> &lt; <code>j</code> and <code>a[i]</code> &gt; <code>a[j]</code> then it's an inverse pair; Otherwise, it's not.\n</p>\n\n<p>\nSince the answer may be very large, the answer should be modulo 10<sup>9</sup> + 7.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> n = 3, k = 0\n<b>Output:</b> 1\n<b>Explanation:</b> \nOnly the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> n = 3, k = 1\n<b>Output:</b> 2\n<b>Explanation:</b> \nThe array [1,3,2] and [2,1,3] have exactly 1 inverse pair.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The integer <code>n</code> is in the range [1, 1000] and <code>k</code> is in the range [0, 1000].</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-recursion-with-memoization-time-limit-exceeded">Approach #2 Using Recursion with memoization [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-dynamic-programming-time-limit-exceeded">Approach #3 Dynamic Programming [Time Limit Exceeded]</a></li>\n<li><a href="#approach-4-dynamic-programming-with-cumulative-sumaccepted">Approach #4 Dynamic Programming with Cumulative Sum[Accepted]:</a></li>\n<li><a href="#approach-5-another-optimized-dynamic-programming-approachaccepted">Approach #5 Another Optimized Dynamic Programming Approach[Accepted]:</a></li>\n<li><a href="#approach-6-once-again-memoization-accepted">Approach #6 Once Again Memoization [Accepted]:</a></li>\n<li><a href="#approach-7-1-d-dynamic-programmming-accepted">Approach #7 1-D dynamic Programmming [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The most naive solution is to generate every permutation of the array consisting of numbers from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script>. Then, we can find out the number of inverse pairs in every array to determine if it is equal to 1. We can find out the count of permutations with the required number of inverse pairs. But, this solution is very terrible in terms of time complexity. Thus, we move on to the better approaches directly.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(n!*nlog(n)\\big)</script>. A total of <script type="math/tex; mode=display">n!</script> permutations will be generated. We need <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script> time to find the number of inverse pairs in every such permutation, by making use of merge sort. Here, <script type="math/tex; mode=display">n</script> refers to the given integer <script type="math/tex; mode=display">n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Each array generated during the permutations will require <script type="math/tex; mode=display">n</script> space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-recursion-with-memoization-time-limit-exceeded">Approach #2 Using Recursion with memoization [Time Limit Exceeded]</h4>\n<p>Before we discuss the solution, let\'s look at the idea behind it. Let\'s say, <script type="math/tex; mode=display">n</script> represents the given number defining the upper limit of the elements in the arrays being considered and <script type="math/tex; mode=display">k</script> represents the number of inverse pairs in the current array.</p>\n<p>Let\'s start with a simple example with <script type="math/tex; mode=display">n=4</script>, no <script type="math/tex; mode=display">k</script> is defined right now. Now, for <script type="math/tex; mode=display">k=0</script>, the only possible arrangement for the given array <script type="math/tex; mode=display">a_0</script> will be <code>[1,2,3,4]</code>, since all the greater elements lie after the smaller elements. Now, in order to generate an arrangement with any arbitrary <script type="math/tex; mode=display">k</script> value, we need to shift, an arbitrary number of elements(let\'s say <script type="math/tex; mode=display">x</script> elements) in the array <script type="math/tex; mode=display">a_0</script> towards the left, with each displacement(shift) being <script type="math/tex; mode=display">s_1, s_2, ...., s_x</script>, such that the sum of these shifts equals <script type="math/tex; mode=display">k</script>.</p>\n<p>To see what we mean by the above statement, let\'s look at the case for <code>[1,2,4,3]</code>. The number of inverse pairs in this array is 1. This array is obtained by shifting the number 4 by one position towards the left. </p>\n<p>Similarly, consider the case for <code>[2,4,1,3]</code>. This array can be obtained from <script type="math/tex; mode=display">a_0</script> by shifting 2 by one position towards the left first and then shifting 4 by 2 positions towards the left. Thus, the total number of displacements is 3, which is equal to the number of inverse pairs in the new array. </p>\n<p>This rule of displacements holds true because, whenever a number is shifted <script type="math/tex; mode=display">y</script> times towards the left starting from the array <script type="math/tex; mode=display">a_0</script>, after the shift, <script type="math/tex; mode=display">y</script> numbers smaller than it lie towards its right, giving a total of <script type="math/tex; mode=display">y</script> inverse pairs. </p>\n<p>Now, let\'s say, we start with the one of the arrangements <script type="math/tex; mode=display">a_3</script>\n<code>[2,4,1,3]</code>, with <script type="math/tex; mode=display">k=3</script>. Now, if we want to add a new number 5 to this array to consider an array with <script type="math/tex; mode=display">n=5</script>, let\'s say, initially, we append it to the end of <script type="math/tex; mode=display">a_3</script>. Now, the new array will be <code>[2,4,1,3,5]</code>. Since, the largest number is added at the end, the new number 5 doesn\'t add any new inverse pair to the total set of inverse pairs relative to the ones in <script type="math/tex; mode=display">a_3</script>(3). </p>\n<p>Now, all the numbers in <script type="math/tex; mode=display">a_3</script> are smaller than 5. Thus, if we add 5 at a position <script type="math/tex; mode=display">y</script> steps from the right, <script type="math/tex; mode=display">y</script> smaller numbers will lie towards its right. Thus, a total of <script type="math/tex; mode=display">y</script> inverse pairs will exist with 5 being one of the elements in these pairs. </p>\n<p>Thus, adding 5 at <script type="math/tex; mode=display">y</script> steps from the right adds a total of <script type="math/tex; mode=display">y</script> inverse pairs to the total set of inverse pairs in <script type="math/tex; mode=display">a_3</script> giving a total of <script type="math/tex; mode=display">3+y</script> inverse pairs now.</p>\n<p>Looking at the same statement from another point of view, we can say that, if we know the number of inverse pairs(say <script type="math/tex; mode=display">x</script>) in any arbitrary array <script type="math/tex; mode=display">b</script> with some <script type="math/tex; mode=display">n</script>, we can add a new element <script type="math/tex; mode=display">n+1</script> to this array <script type="math/tex; mode=display">b</script> at a position <script type="math/tex; mode=display">p</script> steps from the right, such that <script type="math/tex; mode=display">x+p=k</script> to generate an array with a total of <script type="math/tex; mode=display">k</script> inverse pairs. </p>\n<p>Extending this idea further, suppose we know the number of arrangements of an array with <script type="math/tex; mode=display">n-1</script> elements, with the number of inverse pairs being <script type="math/tex; mode=display">0, 1, 2,..., k</script>, let\'s say being equal to <script type="math/tex; mode=display">count_0, count_1, count_2,.., count_k</script>. Now, we can determine the number of arrangements of an array with <script type="math/tex; mode=display">n</script> elements with exactly <script type="math/tex; mode=display">k</script> inverse pairs easily. </p>\n<p>To generate the arrangements with exactly <script type="math/tex; mode=display">k</script> inverse pairs and <script type="math/tex; mode=display">n</script> elements, we can add the new number <script type="math/tex; mode=display">n</script> to all the arrangements with <script type="math/tex; mode=display">k</script> inverse pairs at the last position. For the arrangements with <script type="math/tex; mode=display">k-1</script> inverse pairs , we can add <script type="math/tex; mode=display">n</script> at a position 1 step from the right. </p>\n<p>Similarly, for an element with <script type="math/tex; mode=display">k-i</script> number of inverse pairs, we can add this new number <script type="math/tex; mode=display">n</script> at a position <script type="math/tex; mode=display">i</script> steps from the right. Each of these updations to the arrays leads to a new arrangement, each with the number of inverse pairs being equal to <script type="math/tex; mode=display">k</script>. </p>\n<p>The following image shows an example of how this is done for n=5 and k=4:</p>\n<p align="center"><img alt="Inversions" src="https://leetcode.com/articles/Figures/629/629_kinverse.PNG"></p>\n<p>Thus, to obtain the number of arrangements with exactly <script type="math/tex; mode=display">k</script> inverse pairs and <script type="math/tex; mode=display">n</script> numbers will be given by <script type="math/tex; mode=display">count_0 + count_1 + ... + count_k</script>.</p>\n<p>From the above discussion, we can obtain the recursive formula for finding the number of arrangements with exactly <script type="math/tex; mode=display">k</script> inverse pairs as follows. Let\'s say <script type="math/tex; mode=display">count(i,j)</script> represents the number of arrangements with <script type="math/tex; mode=display">i</script> elements and exactly <script type="math/tex; mode=display">j</script> inverse pairs.</p>\n<ol>\n<li>\n<p>If <script type="math/tex; mode=display">n=0</script>, no inverse pairs exist. Thus, <script type="math/tex; mode=display">count(0,k)=0</script>.</p>\n</li>\n<li>\n<p>If <script type="math/tex; mode=display">k=0</script>, only one arrangement is possible, which is all numbers sorted in ascending order. Thus, <script type="math/tex; mode=display">count(n,0)=1</script>.</p>\n</li>\n<li>\n<p>Otherwise, <script type="math/tex; mode=display">count(n,k) = \\sum_{i=0}^{min(k,n-1)} count(n-1, k-i)</script>. </p>\n</li>\n</ol>\n<p>Note that the upper limit on the summation is <script type="math/tex; mode=display">\\text{min}(k,n-1)</script>. This is because for <script type="math/tex; mode=display">i>k</script>, <script type="math/tex; mode=display">k-i<0</script>. No arrangement exists with negative number of inverse pairs. The reason for the other factor can be seen as follows. </p>\n<p>To generate a new arrangement adding <script type="math/tex; mode=display">k-i</script> new inverse pairs after adding the <script type="math/tex; mode=display">n^{th}</script> number, we need to add this number at the <script type="math/tex; mode=display">i^{th}</script> position from the right. For an array with size <script type="math/tex; mode=display">n</script>, only <script type="math/tex; mode=display">n-1</script> maximum shifts are possible.</p>\n<p>We need to take the modulus at every step to keep the answer within integral limits.</p>\n<p>We can see that a lot of duplicate function calls are made in the normal recursive solution. We can remove this redundancy by making use of a memoization array which stores the result for any function call <code>kInversePairs(i,j)</code> in <script type="math/tex; mode=display">memo[i][j]</script>. Thus, whenver a duplicate function call is made again, we can return the result directly from this memoization array. This prunes the search space to a great extent.</p>\n<iframe frameborder="0" height="343" name="HrBSsxBN" src="https://leetcode.com/playground/HrBSsxBN/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2*k)</script>. The function <code>kInversePairs</code> is called <script type="math/tex; mode=display">n^2</script> times to fill the <script type="math/tex; mode=display">memo</script> array of size <script type="math/tex; mode=display">n</script>x<script type="math/tex; mode=display">k</script>. Each function call itself takes <script type="math/tex; mode=display">O(n)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">memo</script> array of constant size <script type="math/tex; mode=display">1001</script>x<script type="math/tex; mode=display">1001</script> is used. The depth of recursion tree can go upto <script type="math/tex; mode=display">n</script>. </p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-dynamic-programming-time-limit-exceeded">Approach #3 Dynamic Programming [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>As we\'ve seen in the discussion above, the solution for if we know the solutions for <script type="math/tex; mode=display">count(n-1,0)</script>, <script type="math/tex; mode=display">count(n-1, 1)</script>..., <script type="math/tex; mode=display">count(n-1,k)</script>, we can directly obtain the solution for <script type="math/tex; mode=display">count(n,k)</script> as <script type="math/tex; mode=display">count(n,k)=\\sum_{0}^{min(k,n-1)} count(n-1, k-i)</script>.</p>\n<p>From this, we deduce that we can make use of Dynamic Programming to solve the given problem. To solve the given problem, we make use of a 2-D <script type="math/tex; mode=display">dp</script>, where <script type="math/tex; mode=display">dp[i][j]</script> is used to store the number of arrangements with <script type="math/tex; mode=display">i</script> elements and exactly <script type="math/tex; mode=display">j</script> inverse pairs. Based on the discussions above, the <script type="math/tex; mode=display">dp</script> updation equations become:</p>\n<ol>\n<li>\n<p>If <script type="math/tex; mode=display">n=0</script>, no inverse pairs exist. Thus, <script type="math/tex; mode=display">dp[0][k]=0</script>.</p>\n</li>\n<li>\n<p>If <script type="math/tex; mode=display">k=0</script>, only one arrangement is possible, which is all numbers sorted in ascending order. Thus, <script type="math/tex; mode=display">dp[n][0]=1</script>.</p>\n</li>\n<li>\n<p>Otherwise, <script type="math/tex; mode=display">dp[i,j] = \\sum_{p=0}^{min(j,i-1)} count(i-1, j-p)</script>.</p>\n</li>\n</ol>\n<p>Again, the limit <script type="math/tex; mode=display">\\text{min}(j, i-1)</script> is used to account for the cases where the number of inverse pairs needed becomes negative(<script type="math/tex; mode=display">p>j</script>) or the case where the new inverse pairs needed by adding the <script type="math/tex; mode=display">n^{th}</script> number is more than <script type="math/tex; mode=display">n-1</script> which isn\'t possible, since the new number can be added at <script type="math/tex; mode=display">(n-1)^{th}</script> position at most from the right.</p>\n<p>We start filling the <script type="math/tex; mode=display">dp</script> in a row-wise order starting from the first row. At the end, the value of <script type="math/tex; mode=display">dp[n][k]</script> gives the required result.</p>\n<p>The following animation shows how the <script type="math/tex; mode=display">dp</script> is filled for n=4 and k=5:</p>\n<p>!?!../Documents/629_dp4.json:1000,563!?!</p>\n<iframe frameborder="0" height="343" name="YaTc4PUF" src="https://leetcode.com/playground/YaTc4PUF/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2*k)</script>. <script type="math/tex; mode=display">dp</script> of size <script type="math/tex; mode=display">n</script>x<script type="math/tex; mode=display">k</script> is filled once. Filling each <script type="math/tex; mode=display">dp</script> entry takes <script type="math/tex; mode=display">O(n)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n*k)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n</script>x<script type="math/tex; mode=display">k</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-dynamic-programming-with-cumulative-sumaccepted">Approach #4 Dynamic Programming with Cumulative Sum[Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>From the last approach, we\'ve observed that we need to traverse back to some limit in the previous row of the <script type="math/tex; mode=display">dp</script> array to fill in the current <script type="math/tex; mode=display">dp</script> entry. Instead of doing this traversal to find the sum of the required elements, we can ease the process if we fill the cumulative sum upto the current element in a row in any <script type="math/tex; mode=display">dp</script> entry, instead of the actual value. </p>\n<p>Thus, now, <script type="math/tex; mode=display">dp[i][j]=count(i,j)+\\sum_{k=0}^{j-1} dp[i][k]</script>. Here, <script type="math/tex; mode=display">count(i,j)</script> refers to the number of arrangements with <script type="math/tex; mode=display">i</script> elements and exactly <script type="math/tex; mode=display">j</script> inverse pairs. Thus, each entry contains the sum of all the previous elements in the same row along with its own result.</p>\n<p>Now, we need to determine the value of <script type="math/tex; mode=display">count(i,j)</script> to be added to the sum of previous elements in a row, in order to update the <script type="math/tex; mode=display">dp[i][j]</script> entry. But, we need not traverse back in the previous row , since it contains entries representing the cumulative sums now.\nThus, to obtain the sum of elements from <script type="math/tex; mode=display">dp[i-1][j-i+1]</script>  to <script type="math/tex; mode=display">dp[i-1][j]</script>(including both), we can directly use <script type="math/tex; mode=display">dp[i-1][j] - dp[i-1][j-i]</script>. </p>\n<p>Now, to reflect the condition <script type="math/tex; mode=display">\\text{min}(j, i-1)</script> used in the previous approaches, we can note that, we need to take the sum of only <script type="math/tex; mode=display">i</script> elements in the previous row, if <script type="math/tex; mode=display">i</script> elements exist till we reach the end of the array while traversing backwards. Otherwise, we simply take the sum of all the elements. </p>\n<p>Only <script type="math/tex; mode=display">i</script> elements are considered because for generating <script type="math/tex; mode=display">j</script> new inverse pairs, by adding <script type="math/tex; mode=display">i</script> as the new number at the <script type="math/tex; mode=display">j^{th}</script> position, <script type="math/tex; mode=display">j</script> could reach only upto <script type="math/tex; mode=display">i-1</script>, as discussed in the last approaches as well. Thus, we need to consider the sum of elements from <script type="math/tex; mode=display">dp[i-1][j-(i-1)]</script> to  <script type="math/tex; mode=display">dp[i-1][j]</script>(including both) using <script type="math/tex; mode=display">dp[i-1][j] - dp[i-1][j-i]</script> if <script type="math/tex; mode=display">j-i &geq; 0</script>.</p>\n<p>Otherwise, we add all the elements of the previous row upto the current column <script type="math/tex; mode=display">j</script> being considered. In other words, we can use <script type="math/tex; mode=display">dp[i-1][j]</script> directly as the required sum.</p>\n<p>At the end, while returning the result, we need to return <script type="math/tex; mode=display">dp[n][k]-dp[n][k-1]</script> to obtain the required result from the cumulative sums. </p>\n<p>The following animation illustrates the process of filling the <script type="math/tex; mode=display">dp</script> array.</p>\n<p>!?!../Documents/629_dp5.json:1000,563!?!</p>\n<iframe frameborder="0" height="343" name="W8PNnR9j" src="https://leetcode.com/playground/W8PNnR9j/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n*k)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n</script>x<script type="math/tex; mode=display">k</script> is filled once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n*k)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n</script>x<script type="math/tex; mode=display">k</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-another-optimized-dynamic-programming-approachaccepted">Approach #5 Another Optimized Dynamic Programming Approach[Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>Another way to use the Dynamic Programming Approach could be if we can somehow directly store the required <script type="math/tex; mode=display">count(i,j)</script> in <script type="math/tex; mode=display">dp[i][j]</script> entry, but still we should not need to traverse back in the previous row to find the sum of the required elements. </p>\n<p>To do so, we can note that for the <script type="math/tex; mode=display">i^{th}</script> row, we need to add the elements from <script type="math/tex; mode=display">dp[i-1][j-i+1]</script> to <script type="math/tex; mode=display">dp[i-1][j]</script>(including both) if <script type="math/tex; mode=display">(j-1) > 0</script>. Otherwise, we need to add all the elements from <script type="math/tex; mode=display">dp[i-1][0]</script> to <script type="math/tex; mode=display">dp[i-1][j]</script>. This has already been discussed previously. </p>\n<p>Now, when we go for filling in <script type="math/tex; mode=display">dp[i][j+1]</script> after filling <script type="math/tex; mode=display">dp[i][j]</script>, we know <script type="math/tex; mode=display">dp[i][j]</script> already corresponds to the sum of the elements from <script type="math/tex; mode=display">dp[i-1][j-i+1]</script> to <script type="math/tex; mode=display">dp[i-1][j]</script>. But, for filling <script type="math/tex; mode=display">dp[i][j+1]</script>, we require the sum of the elements from <script type="math/tex; mode=display">dp[i-1][(j-i+1)+1]</script> to <script type="math/tex; mode=display">dp[i-1][j+1]</script>. </p>\n<p>We can observe that this sum only excludes <script type="math/tex; mode=display">dp[i-1][j-i+1]</script> from the previous sum(<script type="math/tex; mode=display">dp[i][j]</script>) and requires addition of only one new element(<script type="math/tex; mode=display">dp[i-1][j+1]</script>) to the to this sum. If the value <script type="math/tex; mode=display">j-i+1<0</script>, we need not remove any value.</p>\n<p>Thus, we can directly obtain <script type="math/tex; mode=display">dp[i][j]</script> value as <script type="math/tex; mode=display">dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j]</script>, if <script type="math/tex; mode=display">j-i &geq; 0</script>. Otherwise, we can use:  <script type="math/tex; mode=display">dp[i][j] = dp[i-1][j] + dp[i-1][j]</script>. </p>\n<p>We can also note that, since, here <script type="math/tex; mode=display">j</script> represents the number of inverse pairs that need to be currently considered, we can place another upper limit on <script type="math/tex; mode=display">j</script> as well. The maximum number of inverse pairs for any arbitrary <script type="math/tex; mode=display">n</script> occur only when the array is sorted in descending order leading to <code>[n,n-1,....,3,2,1]</code> as the arrangement. </p>\n<p>This arrangement has a total of <script type="math/tex; mode=display">n*(n-1)/2</script> inverse pairs. Thus, for an array with <script type="math/tex; mode=display">i</script> as the number of elements, the maximum number of inverse pairs possible is <script type="math/tex; mode=display">i*(i-1)/2</script> only. Thus, for fillling in the <script type="math/tex; mode=display">i^{th}</script> row of <script type="math/tex; mode=display">dp</script>, we can place this limit on <script type="math/tex; mode=display">j</script>\'s value.</p>\n<p>The following animation shows the <script type="math/tex; mode=display">dp</script> filling process.</p>\n<p>!?!../Documents/629_dp6.json:1000,563!?!</p>\n<iframe frameborder="0" height="394" name="8azxXjrN" src="https://leetcode.com/playground/8azxXjrN/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n*k)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">(n+1)</script>x<script type="math/tex; mode=display">(k+1)</script> is filled once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n*k)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">(n+1)</script>x<script type="math/tex; mode=display">(k+1)</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-6-once-again-memoization-accepted">Approach #6 Once Again Memoization [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>The Dynamic Programming solution discussed in Approach 5 can also be written down in the form of a recursive solution. But, again, that will include a lot of duplicate function calls. Thus, a better solution would be to use memoization to store the results of the previous function calls.</p>\n<iframe frameborder="0" height="360" name="KhoU86GW" src="https://leetcode.com/playground/KhoU86GW/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n*k)</script>. <script type="math/tex; mode=display">n</script>x<script type="math/tex; mode=display">k</script> entries in the <script type="math/tex; mode=display">memo</script> array are filled once.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. <script type="math/tex; mode=display">memo</script> array of constant size <script type="math/tex; mode=display">1001</script>x<script type="math/tex; mode=display">1001</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-7-1-d-dynamic-programmming-accepted">Approach #7 1-D dynamic Programmming [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>From the Dynamic Programming solution, we can also note that we only need the values of the previous row in the <script type="math/tex; mode=display">dp</script> array, and not any other row. Thus, instead of storing the whole 2-D <script type="math/tex; mode=display">dp</script> in memory, we can make use of a 1-D <script type="math/tex; mode=display">dp</script> to store the previous row\'s entries only. The updations can be done in a 1-D <script type="math/tex; mode=display">temp</script> array of the same size as <script type="math/tex; mode=display">dp</script> and <script type="math/tex; mode=display">dp</script> can be updated using this <script type="math/tex; mode=display">temp</script> everytime a row is finished.</p>\n<iframe frameborder="0" height="343" name="4BjBwzaY" src="https://leetcode.com/playground/4BjBwzaY/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n*k)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">k+1</script> is filled <script type="math/tex; mode=display">n+1</script> times.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(k)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">(k+1)</script> is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Works Applications'],
  },
  {
    id: '630',
    name: 'Course Schedule III',
    acceptance: '28.6%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>\nThere are <code>n</code> different online courses numbered from <code>1</code> to <code>n</code>. Each course has some duration(course length)  <code>t</code> and closed on <code>d<sub>th</sub></code> day. A course should be taken <b>continuously</b> for <code>t</code> days and must be finished before or on the <code>d<sub>th</sub></code> day. You will start at the <code>1<sub>st</sub></code> day.\n</p>\n\n<p>\nGiven <code>n</code> online courses represented by pairs <code>(t,d)</code>, your task is to find the maximal number of courses that can be taken.\n</p>\n\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]\n<b>Output:</b> 3\n<b>Explanation:</b> \nThere're totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\nSecond, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. \nThird, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. \nThe 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\n</pre>\n<p></p>\n\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The integer 1 &lt;= d, t, n &lt;= 10,000. </li>\n<li>You can't take two courses simultaneously.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-recursion-with-memoizationtime-limit-exceeded">Approach #2 Using Recursion with memoization[Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-iterative-solution-time-limit-exceeded">Approach #3  Iterative Solution [Time Limit Exceeded]</a></li>\n<li><a href="#approach-4-optimized-iterative-accepted">Approach #4  Optimized Iterative [Accepted]</a></li>\n<li><a href="#approach-5-using-extra-list-accepted">Approach #5 Using Extra List [Accepted]</a></li>\n<li><a href="#approach-6-using-priority-queue-accepted">Approach #6 Using Priority Queue [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The most naive solution will be to consider every possible permutation of the given courses and to try to take as much courses as possible by  taking the courses in a serial order in every permutation. We can find out the maximum number of courses that can be taken from out of values obtained from these permutations.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big((n+1)!\\big)</script>. A total of <script type="math/tex; mode=display">n!</script> permutations are possible for the <script type="math/tex; mode=display">courses</script> array of length <script type="math/tex; mode=display">n</script>. For every permutation, we scan over the <script type="math/tex; mode=display">n</script> elements of the permutation to find the number of courses that can be taken in each case.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Each permutation needs <script type="math/tex; mode=display">n</script> space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-recursion-with-memoizationtime-limit-exceeded">Approach #2 Using Recursion with memoization[Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Before we move on to the better approaches, let\'s discuss one basic idea to solve the given problem. Suppose, we are considering only two courses <script type="math/tex; mode=display">(a,x)</script> and <script type="math/tex; mode=display">(b,y)</script>. Let\'s assume <script type="math/tex; mode=display">y>x</script>. Now, we\'ll look at the various relative values which <script type="math/tex; mode=display">a</script> and <script type="math/tex; mode=display">b</script> can take, and which course should be taken first in each of these cases. In all the cases, we assume that the course\'s duration is always lesser than its end day i.e. <script type="math/tex; mode=display">a<x</script> and <script type="math/tex; mode=display">b<y</script>.</p>\n<ol>\n<li>\n<script type="math/tex; mode=display">(a+b) &le; x</script>: In this case, we can take the courses in any order. Both the courses can be taken irrespective of the order in which the courses are taken.</li>\n</ol>\n<p align="center"><img alt="Courses" src="https://leetcode.com/articles/Figures/630/630_Course_Schedule_III_1.PNG"></p>\n<ol>\n<li>\n<script type="math/tex; mode=display">(a+b)>x</script>, <script type="math/tex; mode=display">a>b</script>, <script type="math/tex; mode=display">(a+b) &leq; y</script>: In this case, as is evident from the figure, both the courses can be taken only by taking course <script type="math/tex; mode=display">a</script> before <script type="math/tex; mode=display">b</script>.</li>\n</ol>\n<p align="center"><img alt="Courses" src="https://leetcode.com/articles/Figures/630/630_Course_Schedule_III_2.PNG"></p>\n<ol>\n<li>\n<script type="math/tex; mode=display">(a+b)>x</script>, <script type="math/tex; mode=display">b>a</script>, <script type="math/tex; mode=display">(a+b) &leq; y</script>: In this case also, both the courses can be taken only by taking course <script type="math/tex; mode=display">a</script> before <script type="math/tex; mode=display">b</script>.</li>\n</ol>\n<p align="center"><img alt="Courses" src="https://leetcode.com/articles/Figures/630/630_Course_Schedule_III_3.PNG"></p>\n<ol>\n<li>\n<script type="math/tex; mode=display">(a+b)>y</script>: In this case, irrespective of the order in which we take the courses, only one course can be taken.</li>\n</ol>\n<p align="center"><img alt="Courses" src="https://leetcode.com/articles/Figures/630/630_Course_Schedule_III_4.PNG"></p>\n<p>From the above example, we can conclude that it is always profitable to take the course with a smaller end day prior to a course with a larger end day. This is because, the course with a smaller duration, if can be taken, can surely be taken only if it is taken prior to a course with a larger end day. </p>\n<p>Based on this idea, firstly, we sort the given <script type="math/tex; mode=display">courses</script> array based on their end days. Then, we try to take the courses in a serial order from this sorted <script type="math/tex; mode=display">courses</script> array. </p>\n<p>In order to solve the given problem, we make use of a recursive function <code>schedule(courses, i, time)</code> which returns the maximum number of courses that can be taken starting from the <script type="math/tex; mode=display">i^{th}</script> course(starting from 0), given the time aleady consumed by the other courses is <script type="math/tex; mode=display">time</script>, i.e. the current time is <script type="math/tex; mode=display">time</script>, given a <script type="math/tex; mode=display">courses</script> array as the schedule.</p>\n<p>Now, in each function call to <code>schedule(courses, i, time)</code>, we try to include the current course in the taken courses. But, this can be done only if <script type="math/tex; mode=display">time + duration_i < end\\_day_i</script>. Here, <script type="math/tex; mode=display">duration_i</script> refers to the duration of the <script type="math/tex; mode=display">i^{th}</script> course and <script type="math/tex; mode=display">end\\_day_i</script> refers to the end day of the <script type="math/tex; mode=display">i^{th}</script> course. </p>\n<p>If the course can be taken, we increment the number of courses taken and obtain the number of courses that can be taken by passing the updated time and courses\' index. i.e. we make the function call <code>schedule(courses, i + 1, time + duration_i)</code>. Let\'s say, we store the number of courses that can be taken by taking the current course in <script type="math/tex; mode=display">taken</script> variable.</p>\n<p>Further, for every current course, we also leave the current course, and find the number of courses that can be taken thereof. Now, we need not update the time, but we need to update the courses\' index. Thus, we make the function call, <code>schedule(courses, i + 1, time)</code>. Let\'s say, we store the count obtained in <script type="math/tex; mode=display">not\\_taken</script> variable. </p>\n<p>While returning the number of courses at the end of each function call, we return the maximum value out of <script type="math/tex; mode=display">taken</script> and <script type="math/tex; mode=display">not\\_taken</script>.</p>\n<p>Thus, the function call <code>schedule(courses, 0, 0)</code> gives the required result.</p>\n<p>In order to remove this redundancy, we make use of a memoization array <script type="math/tex; mode=display">memo</script>, such that <script type="math/tex; mode=display">memo[i][j]</script> is used to store the result of the function call <code>schedule(courses, i, time)</code>. Thus, whenever the same function call is made again, we can return the result directly from the <script type="math/tex; mode=display">memo</script> array. This helps to prune the search space to a great extent.</p>\n<iframe frameborder="0" height="377" name="JuEBXYU7" src="https://leetcode.com/playground/JuEBXYU7/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n*d)</script>. <script type="math/tex; mode=display">memo</script> array of size <script type="math/tex; mode=display">n</script>x<script type="math/tex; mode=display">d</script> is filled once. Here, <script type="math/tex; mode=display">n</script> refers to the number of courses in the given <script type="math/tex; mode=display">courses</script> array and <script type="math/tex; mode=display">d</script> refers to the maximum value of the end day from all the end days in the <script type="math/tex; mode=display">courses</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n*d)</script>. <script type="math/tex; mode=display">memo</script> array of size <script type="math/tex; mode=display">n</script>x<script type="math/tex; mode=display">d</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-iterative-solution-time-limit-exceeded">Approach #3  Iterative Solution [Time Limit Exceeded]</h4>\n<p>For the current approach, the idea goes as follows. As discussed in the previous approaches, we need to sort the given <script type="math/tex; mode=display">courses</script> array based on the end days. Thus, we consider the courses in the ascending order of their end days. We keep a track of the current time in a <script type="math/tex; mode=display">time</script> variable. Along with this, we also keep a track of the number of courses taken till now in <script type="math/tex; mode=display">count</script> variable.</p>\n<p>For each course being considered currently(let\'s say <script type="math/tex; mode=display">i^{th}</script> course), we try to take this course. But, to be able to do so, the current course should end before its corresponding end day i.e. <script type="math/tex; mode=display">time + duration_i &leq; end\\day_i</script>. Here, <script type="math/tex; mode=display">duration_i</script> refers to the duration of the <script type="math/tex; mode=display">i^{th}</script> course and <script type="math/tex; mode=display">end\\_day_i</script> refers to the end day of the <script type="math/tex; mode=display">i^{th}</script> course. </p>\n<p>If this course can be taken, we update the current time to <script type="math/tex; mode=display">time + duration_i</script> and also increment the current <script type="math/tex; mode=display">count</script> value to indicate that one more course has been taken. </p>\n<p>But, if we aren\'t able to take the current course i.e. <script type="math/tex; mode=display">time + duration_i > end\\_day_i</script>, we can try to take this course by removing some other course from amongst the courses that have already been taken. But, the current course can fit in by removing some other course, only if the duration of the course(<script type="math/tex; mode=display">j^{th}</script>) being removed <script type="math/tex; mode=display">duration_j</script> is larger than the current course\'s duration, <script type="math/tex; mode=display">duration_i</script> i.e. <script type="math/tex; mode=display">duration_j > duration_i</script>. </p>\n<p>We are sure of the fact that by removing the <script type="math/tex; mode=display">j^{th}</script> course, we can fit in the current course, because, <script type="math/tex; mode=display">course_j</script> was already fitting in the duration available till now. Since, <script type="math/tex; mode=display">duration_i < duration_j</script>, the current course can surely take its place. Thus, we look for a course from amongst the taken courses having a duration larger than the current course.</p>\n<p>But why are we doing this replacement? The answer to this question is as follows. By replacing the <script type="math/tex; mode=display">j^{th}</script> course, with the <script type="math/tex; mode=display">i^{th}</script> course of a relatively smaller duration, we can increase the time available for upcoming courses to be taken. An extra <script type="math/tex; mode=display">duration_j - duration_i</script> time can be made available by doing so. </p>\n<p>Now, for this saving in time to be maximum, the course taken for the replacement should be the one with the maximum duration. Thus, from amongst the courses that have been taken till now, we find the course having the maximum duration which should be more than the duration of the current course(which can\'t be taken). </p>\n<p>Let\'s say, this course be called as <script type="math/tex; mode=display">max\\_i</script>. Thus, now, a saving of <script type="math/tex; mode=display">duration_{max\\_i} - duration_i</script> can be achived, which could help later in fitting in more courses to be taken.</p>\n<p>If such a course, <script type="math/tex; mode=display">max\\_i</script>, is found, we remove this course from the taken courses and consider the current course as taekn. We also mark this course with <script type="math/tex; mode=display">\\text{-1}</script> to indicate that this course has not been taken and should not be considered in the future again for replacement. </p>\n<p>But, if such a course isn\'t found, we can\'t take the current course at any cost. Thus, we mark the current course with <script type="math/tex; mode=display">\\text{-1}</script> to indicate that the current course has not been taken.</p>\n<p>At the end, the value of <script type="math/tex; mode=display">count</script> gives the required result.</p>\n<p>The following animation illustrates the process.</p>\n<p>!?!../Documents/630_Course_Schedule_III.json:1000,563!?!</p>\n<iframe frameborder="0" height="462" name="HnKoFCWN" src="https://leetcode.com/playground/HnKoFCWN/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>.  We iterate over the <script type="math/tex; mode=display">count</script> array of size <script type="math/tex; mode=display">n</script> once. For every element currently considered, we could scan backwards till the first element, giving <script type="math/tex; mode=display">O(n^2)</script> complexity. Sorting the <script type="math/tex; mode=display">count</script> array takes <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script> time for <script type="math/tex; mode=display">count</script> array.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-optimized-iterative-accepted">Approach #4  Optimized Iterative [Accepted]</h4>\n<p>In the last approach, we\'ve seen that, in the case of current course which can\'t be taken direclty, i.e. for <script type="math/tex; mode=display">time + duration_i > end\\_day_i</script>, we need to traverse back in the <script type="math/tex; mode=display">courses</script> array till the beginning to find a course with the maximum duration which is larger than the current course\'s duration. This backward traversal also goes through the courses which aren\'t  taken and thus, can\'t be replaced, and have been marked as <script type="math/tex; mode=display">\\text{-1}</script>. </p>\n<p>We can bring in some optimization here. For this, we should search among only those courses which have been taken(and not the ones which haven\'t been taken). </p>\n<p>To do so, as we iterate over the <script type="math/tex; mode=display">courses</script> array, we also keep on updating it, such that the first <script type="math/tex; mode=display">count</script> number of elements in this array now correspond to only those <script type="math/tex; mode=display">count</script> number of courses which have been taken till now. </p>\n<p>Thus, whenever we update the <script type="math/tex; mode=display">count</script> to indicate that one more course has been taken, we also update the <script type="math/tex; mode=display">courses[count]</script> entry to \nreflect the current course that has just been taken. </p>\n<p>Whenever, we find a course for which <script type="math/tex; mode=display">time + duration_i > end\\_day_i</script>, we find a <script type="math/tex; mode=display">max_i</script> course from only amongst these first <script type="math/tex; mode=display">count</script> number of courses in the <script type="math/tex; mode=display">courses</script> array, which indicate the courses that have been taken till now. </p>\n<p>Also, instead of marking this <script type="math/tex; mode=display">max_i^{th}</script> course with a <script type="math/tex; mode=display">\\text{-1}</script>, we can simply replace this course with the current course. Thus, the first <script type="math/tex; mode=display">count</script> courses still reflect the courses that have been taken till now.</p>\n<iframe frameborder="0" height="479" name="v7EjYVQp" src="https://leetcode.com/playground/v7EjYVQp/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n*count)</script>. We iterate over a total of <script type="math/tex; mode=display">n</script> elements of the <script type="math/tex; mode=display">courses</script> array. For every element, we can traverse backwards upto atmost <script type="math/tex; mode=display">count</script>(final value) number of elements.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-using-extra-list-accepted">Approach #5 Using Extra List [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we updated the <script type="math/tex; mode=display">course</script> array itself so that the first <script type="math/tex; mode=display">count</script> elements indicate the <script type="math/tex; mode=display">count</script> number of courses that have been taken till now. If it is required to retain the <script type="math/tex; mode=display">courses</script> array as such, we can do the same job by maintaining a separate list <script type="math/tex; mode=display">valid\\_list</script> which is the list of those courses that have been taken till now. </p>\n<p>Thus, to find the <script type="math/tex; mode=display">max_i</script> course, we need to search in this list only. Further, when replacing this <script type="math/tex; mode=display">max_i^{th}</script> course with the current course, we can replace this <script type="math/tex; mode=display">max_i</script> course in the list with current course directly. The rest of the method remains the same as the last approach.</p>\n<iframe frameborder="0" height="479" name="esu9eSya" src="https://leetcode.com/playground/esu9eSya/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n*m)</script>. We iterate over a total of <script type="math/tex; mode=display">n</script> elements of the <script type="math/tex; mode=display">courses</script> array. For every element, we can traverse over atmost <script type="math/tex; mode=display">m</script> number of elements. Here, <script type="math/tex; mode=display">m</script> refers to the final length of the <script type="math/tex; mode=display">valid\\_list</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The <script type="math/tex; mode=display">valid\\_list</script> can contain atmost <script type="math/tex; mode=display">n</script> courses.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-6-using-priority-queue-accepted">Approach #6 Using Priority Queue [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>This approach is inspired by <a href="http://leetcode.com/stomach_ache">@stomach_ache</a></p>\n<p>In the last few approaches, we\'ve seen that we needed to traverse over the courses which have been taken to find the course(with the maximum duration) which can be replaced by the current course(if it can\'t be taken directly). These traversals can be saved, if we make use of a Priority Queue, <script type="math/tex; mode=display">queue</script>(which is implemented as a Max-Heap) which contains the durations of all the courses that have been taken till now. </p>\n<p>The iteration over the sorted <script type="math/tex; mode=display">courses</script> remains the same as in the last approaches. Whenver the current course(<script type="math/tex; mode=display">i^{th}</script> course) can be taken(<script type="math/tex; mode=display">time + duration_i &leq; end\\_day_i</script>), it is added to the <script type="math/tex; mode=display">queue</script> and the value of the current time is updated to <script type="math/tex; mode=display">time + duration_i</script>. </p>\n<p>If the current course can\'t be taken directly, as in the previous appraoches, we need to find a course whose duration <script type="math/tex; mode=display">duration_j</script> is maximum from amongst the courses taken till now. Now, since we are maintaing a Max-Heap, <script type="math/tex; mode=display">queue</script>, we can obtain this duration directly from this <script type="math/tex; mode=display">queue</script>. If the duration <script type="math/tex; mode=display">duration_j > duration_i</script>, we can replace the <script type="math/tex; mode=display">j^{th}</script> course, with the current one. </p>\n<p>Thus, we remove the <script type="math/tex; mode=display">duration_j</script> from the <script type="math/tex; mode=display">queue</script> and add the current course\'s duration <script type="math/tex; mode=display">duration_i</script> to the <script type="math/tex; mode=display">queue</script>. We also need to make proper adjustments to the <script type="math/tex; mode=display">time</script> to account for this replacement done.</p>\n<p>At the end, the number of elements in the <script type="math/tex; mode=display">queue</script> represent the number of courses that have been taken till now.</p>\n<iframe frameborder="0" height="343" name="AaRNrEU7" src="https://leetcode.com/playground/AaRNrEU7/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script>. At most <script type="math/tex; mode=display">n</script> elements are added to the <script type="math/tex; mode=display">queue</script>. Adding each element is followed by heapification, which takes <script type="math/tex; mode=display">O\\big(log(n)\\big)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The <script type="math/tex; mode=display">queue</script> containing the durations of the  courses taken can have atmost <script type="math/tex; mode=display">n</script> elements</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['WAP'],
  },
  {
    id: '631',
    name: 'Design Excel Sum Formula ',
    acceptance: '27.3%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Your task is to design the basic function of Excel and implement the function of sum formula.  Specifically, you need to implement the following functions:</p>\n\n\n\n<p><code>Excel(int H, char W):</code> This is the constructor. The inputs represents the height and width of the Excel form. <b>H</b> is a positive integer, range from 1 to 26. It represents the height. <b>W</b> is a character range from \'A\' to \'Z\'. It represents that the width is the number of characters from \'A\' to <b>W</b>. The Excel form content is represented by a height * width 2D integer array <code>C</code>, it should be initialized to zero. You should assume that the first row of <code>C</code> starts from 1, and the first column of <code>C</code> starts from \'A\'.</p>\n\n<br>\n\n<p><code>void Set(int row, char column, int val):</code> Change the value at <code>C(row, column)</code> to be val.</p>\n<br>\n<p><code>int Get(int row, char column):</code> Return the value at <code>C(row, column)</code>.</p>\n<br>\n<p><code>int Sum(int row, char column, List of Strings : numbers):</code> This function calculate and set the value at <code>C(row, column)</code>, where the value should be the sum of cells represented by <code>numbers</code>. This function return the sum result at <code>C(row, column)</code>. This sum formula should exist until this cell is overlapped by another value or another sum formula.</p>\n\n<p><code>numbers</code> is a list of strings that each string represent a cell or a range of cells. If the string represent a single cell, then it has the following format : <code>ColRow</code>. For example, "F7" represents the cell at (7, F). </p>\n\n<p>If the string represent a range of cells, then it has the following format : <code>ColRow1:ColRow2</code>. The range will always be a rectangle, and ColRow1 represent the position of the top-left cell, and ColRow2 represents the position of the bottom-right cell. </p>\n<br>\n<p><b>Example 1:</b><br>\n</p><pre>Excel(3,"C"); \n// construct a 3*3 2D array with all zero.\n//   A B C\n// 1 0 0 0\n// 2 0 0 0\n// 3 0 0 0\n\nSet(1, "A", 2);\n// set C(1,"A") to be 2.\n//   A B C\n// 1 2 0 0\n// 2 0 0 0\n// 3 0 0 0\n\nSum(3, "C", ["A1", "A1:B2"]);\n// set C(3,"C") to be the sum of value at C(1,"A") and the values sum of the rectangle range whose top-left cell is C(1,"A") and bottom-right cell is C(2,"B"). Return 4. \n//   A B C\n// 1 2 0 0\n// 2 0 0 0\n// 3 0 0 4\n\nSet(2, "B", 2);\n// set C(2,"B") to be 2. Note C(3, "C") should also be changed.\n//   A B C\n// 1 2 0 0\n// 2 0 2 0\n// 3 0 0 6\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>You could assume that there won\'t be any circular sum reference. For example, A1 = sum(B1) and B1 = sum(A1).</li>\n<li> The test cases are using double-quotes to represent a character.</li>\n<li>Please remember to <b>RESET</b> your class variables declared in class Excel, as static/class variables are <b>persisted across multiple test cases</b>. Please see <a href="https://leetcode.com/faq/#different-output">here</a> for more details.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-topological-sortaccepted">Approach #1 Using Topological Sort[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-topological-sortaccepted">Approach #1 Using Topological Sort[Accepted]</h4>\n<p>Before discussing the required design, we\'ll discuss some prerequisites to help ease the understanding of the solution. </p>\n<p>Firstly, we can note that once a formula is applied to any cell in excel, let\'s say <script type="math/tex; mode=display">C1 = C2 + C3</script>, if any change is made to <script type="math/tex; mode=display">C2</script> or <script type="math/tex; mode=display">C3</script>, the result to be put into <script type="math/tex; mode=display">C1</script> needs to be evaluated again based on the new values of <script type="math/tex; mode=display">C2</script> and <script type="math/tex; mode=display">C3</script>. Further, suppose some other cell, say <script type="math/tex; mode=display">D2</script> is also dependent on <script type="math/tex; mode=display">C1</script> due to some prior formula applied to <script type="math/tex; mode=display">D2</script>. Then, when any change is made to, say, <script type="math/tex; mode=display">C2</script>, we re-evaluate <script type="math/tex; mode=display">C1</script>\'s value. Furhter, since <script type="math/tex; mode=display">D2</script> is dependent on <script type="math/tex; mode=display">C1</script>, we need to re-evaluate <script type="math/tex; mode=display">D2</script>\'s value as well. </p>\n<p>Thus, whenever, we make any change to any cell, <script type="math/tex; mode=display">x</script>,  we need to determine the cells which are dependent on <script type="math/tex; mode=display">x</script>, and update these cells, and further determine the cells which are dependent on the changed cells and so on. We can assume that no cycles are present in the formulas, i.e. Any cell\'s value won\'t directly or indirectly be dependent on its own value. </p>\n<p>But, while doing these set of evaluations of the cells to determine their updated values, we need to update the cells in such an order that the cell on which some other cell is dependent is always evaluated prior to the cell which is dependent on the former cell.</p>\n<p>In order to do so, we can view the dependence between the cells in the form of a dependency graph, which can be a Directed Graph. Since, no cycles are allowed between the formulas, the graph reduces to a Directed Acyclic Graph. Now, to solve the problem of evaluating the cells in the required order, we can make use of a very well known method specifically used for such problems in Directed Acyclic Graphs, known as the Topological Sorting. </p>\n<p>Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge <script type="math/tex; mode=display">uv</script>, vertex <script type="math/tex; mode=display">u</script> comes before <script type="math/tex; mode=display">v</script> in the ordering. For example, a topological sorting of the following graph is <code>5 4 2 3 1 0</code>. </p>\n<p>There can be more than one topological sorting for a graph. For example, another topological sorting of the following graph is <code>4 5 2 3 1 0</code>. The first vertex in topological sorting is always a vertex with in-degree as 0 (a vertex with no in-coming edges).</p>\n<p align="center"><img alt="Topological_Sort_Graph" src="https://leetcode.com/articles/Figures/631/631_Design_Excel.PNG"></p>\n<p>Topological Sorting can be done if we modify the Depth First Search to some extent.  In Depth First Search, we start from a vertex, we first print it and then recursively call DFS for its adjacent vertices. Thus, the DFS obtained for the graph above, starting from node 5, will be <code>5 2 3 1 0 4</code>. But, in the case of a topological sort, we can\'t print a node until all the nodes on which it is dependent have already been printed. </p>\n<p>To solve this problem, we make use of a temporary stack. We do the traversals in the same manner as in DFS, but  we don’t print the current node immediately. Instead, for the current node we do as follows:</p>\n<ul>\n<li>\n<p>Recursively call topological sorting for all the nodes adjacent to the current node.</p>\n</li>\n<li>\n<p>Push the current node onto a stack. </p>\n</li>\n<li>\n<p>Repeat the above process till all the nodes have been considered atleast once. </p>\n</li>\n<li>\n<p>Print the contents of the stack. </p>\n</li>\n</ul>\n<p>Note that a vertex is pushed to stack only when all of its adjacent(dependent) vertices (and their adjacent(dependent) vertices and so on) are already in stack. Thus, we obtain the correct ordering of the vertices. </p>\n<p>The following animation shows an example of topological sorting for the graph above.</p>\n<p>!?!../Documents/631_Topological.json:1000,563!?!</p>\n<p>We can make use of the same concept while evaluating the cell values to determine the order in which they need to be evaluated. </p>\n<p>Now, let\'s discuss how we implement the various required functions. We make use of a simple structure(Class), <script type="math/tex; mode=display">Formula</script>, which contains two elements. First, the value of the cell which it represents, <script type="math/tex; mode=display">val</script>, and a HashMap, <script type="math/tex; mode=display">cells</script>. It is a list of cells on which the current cell\'s value is dependent. This <script type="math/tex; mode=display">cells</script> hashmap stores the data in the form <script type="math/tex; mode=display">(cellName, count)</script>.  <script type="math/tex; mode=display">cellName</script> has the format <script type="math/tex; mode=display">ColRow</script>. <script type="math/tex; mode=display">count</script> refers to the number of times the current cell directly or indirectly comes in the current cell\'s formulas. e.g. <script type="math/tex; mode=display">C1 = C2 + C3 + C2</script>. In this case, the frequency of <script type="math/tex; mode=display">C3</script> is 1 and that of <script type="math/tex; mode=display">C2</script> is 2.</p>\n<ul>\n<li>\n<p><code>Excel(int H, char W)</code> : We simply need to initialize an array of <script type="math/tex; mode=display">Formula</script> with <script type="math/tex; mode=display">H</script> rows and the required number of columns corresponding to <script type="math/tex; mode=display">W</script>.</p>\n</li>\n<li>\n<p><code>set(int row, char column, int val)</code> : For setting the value of the cell corresponding to the given <script type="math/tex; mode=display">row</script> and <script type="math/tex; mode=display">column</script>, we can simply change the value , <script type="math/tex; mode=display">val</script>, in the <script type="math/tex; mode=display">Formulas</script> array at the indices corresponding to the current cell. Further, if any new formula is applied to a particular cell, we need to remove  the previously applied formulas on the same cell. This is because two formulas can\'t be used to determine the value of a cell simultaneously. Now, setting a cell to a particular value can also be seen as a formula e.g. <script type="math/tex; mode=display">C1 = 2</script>. Thus, we remove all the <script type="math/tex; mode=display">cells</script> in the <script type="math/tex; mode=display">Formulas</script> for the current cell. Further, when the current cell\'s value is changed, all the other cells which are dependent on it also need to be evaluated in the correct order. Thus, we make use of Topological Sorting starting with the current cell. We make use of a function <code>topologicalSort(r, c)</code> for this purpose.</p>\n</li>\n</ul>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>topologicalSort(r, c)</code>: In every call to this function, we traverse over all the cells in the <script type="math/tex; mode=display">Formulas</script> array and further apply topological sorting to all the &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells which are dependent on the current cell(row=r, column=c). To find these cells, we can check the <script type="math/tex; mode=display">cells</script> in the <script type="math/tex; mode=display">Formulas</script> associated with each cell &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and check if the current cell lies in it. After applying Topological sorting to all these dependent cells, we put the current cell onto a <script type="math/tex; mode=display">stack</script>. </p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;After doing the topological sorting, the cells on the <script type="math/tex; mode=display">stack</script> lie in the order in which their values should be evaluated given the current dependency chain &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;based on the formulas applied. Thus, we pick up these cells one by one, and evaluate their values. To do the evaluation, we make use of &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>calculate_sum(r, c, cells)</code>. In this function, we traverse over all the <script type="math/tex; mode=display">cells</script> in the <script type="math/tex; mode=display">Formulas</script> of the current cell(row=r, column=c), and keep on adding &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;their values. When this summing has been done, we update the current cell\'s value, <script type="math/tex; mode=display">val</script>, to the sum just obtained. We keep on doing so till all the cells in &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the <script type="math/tex; mode=display">stack</script> have been evaluated.</p>\n<ul>\n<li>\n<p><code>get(int row, char column)</code> : We can simply obtain the value(<script type="math/tex; mode=display">val</script>) associated with the current cell\'s <script type="math/tex; mode=display">Formulas</script>. If the cell has never been initialized previously, we can return a 0 value.</p>\n</li>\n<li>\n<p><code>sum(int row, char column, List of Strings : numbers)</code> : To implement this function, firstly, we need to expand the given <script type="math/tex; mode=display">numbers</script> to obtain all the cells which need to be added in the current formula. We obtain them, by making use of a <code>convert</code> function, which extracts all these cells by doing appropriate expansions based on <code>:</code> values. We put all these cells in the <script type="math/tex; mode=display">cells</script> associated with the current cell\'s <script type="math/tex; mode=display">Formulas</script>. We also need to set the current cell\'s value to a new value based on the current formula added. For this, we make use of <code>calculate_sum</code> function as discussed above. We also need to do the topological sorting and evaluate all the cells dependent on the current cell. This is done in the same manner as in the <code>set</code> function discussed above. We also need to return the value to which the current cell has been set.</p>\n</li>\n</ul>\n<iframe frameborder="0" height="515" name="Bxcqy2c6" src="https://leetcode.com/playground/Bxcqy2c6/shared" width="100%"></iframe>\n<p><strong>Performance Analysis</strong></p>\n<ul>\n<li>\n<p><code>set</code> takes <script type="math/tex; mode=display">O\\big((r*c)^2\\big)</script> time. Here, <script type="math/tex; mode=display">r</script> and <script type="math/tex; mode=display">c</script> refer to the number of rows and columns in the current Excel Form. There can be a maximum of <script type="math/tex; mode=display">O(r*c)</script> formulas for an Excel Form with <script type="math/tex; mode=display">r</script> rows and <script type="math/tex; mode=display">c</script> columns. For each formula, <script type="math/tex; mode=display">r*c</script> time will be needed to find the dependent nodes. Thus, in the worst case, a total of <script type="math/tex; mode=display">O\\big((r*c)^2\\big)</script> will be needed.</p>\n</li>\n<li>\n<p><code>sum</code> takes <script type="math/tex; mode=display">O\\big((r*c)^2 + 2*r*c*l\\big)</script> time. Here, <script type="math/tex; mode=display">l</script> refers to the number of elements in the  the list of strings used for obtaining the cells required for the current sum. In the worst case, the expansion of each such element requires <script type="math/tex; mode=display">O(r*c)</script> time, leading to <script type="math/tex; mode=display">O(l*r*c)</script> time for expanding <script type="math/tex; mode=display">l</script> such elements. After doing the expansion, <code>calculate_sum</code> itself requires <script type="math/tex; mode=display">O(l*r*c)</script> time for traversing over the required elements for obtaining the sum. After this, we need to update all the dependent cells, which requires the use of <code>set</code> which itself requires <script type="math/tex; mode=display">O\\big((r*c)^2\\big)</script> time.</p>\n</li>\n<li>\n<p><code>get</code> takes <script type="math/tex; mode=display">O(1)</script> time. </p>\n</li>\n<li>\n<p>The space required will be <script type="math/tex; mode=display">O\\big((r*c)^2\\big)</script> in the worst case. <script type="math/tex; mode=display">O(r*c)</script> space will be required for the Excel Form itself. For each cell in this form, the <script type="math/tex; mode=display">cells</script> list can contain <script type="math/tex; mode=display">O(r*c)</script> cells.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Microsoft'],
  },
  {
    id: '632',
    name: 'Smallest Range',
    acceptance: '42.1%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>You have <code>k</code> lists of sorted integers in ascending order. Find the <b>smallest</b> range that includes at least one number from each of the <code>k</code> lists. </p>\n\n<p>We define the range [a,b] is smaller than range [c,d] if <code>b-a &lt; d-c</code> or <code>a &lt; c</code> if <code>b-a == d-c</code>.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]\n<b>Output:</b> [20,24]\n<b>Explanation:</b> \nList 1: [4, 10, 15, 24,26], 24 is in range [20,24].\nList 2: [0, 9, 12, 20], 20 is in range [20,24].\nList 3: [5, 18, 22, 30], 22 is in range [20,24].\n</pre>\n<p></p>\n\n<p>\n<b>Note:</b><br>\n</p><ol>\n<li>The given list may contain duplicates, so ascending order means &gt;= here.</li>\n<li>1 &lt;= <code>k</code> &lt;= 3500</li>\n<li> -10<sup>5</sup> &lt;= <code>value of elements</code> &lt;= 10<sup>5</sup>.</li>\n<li><b>For Java users, please note that the input type has been changed to List&lt;List&lt;Integer&gt;&gt;. And after you reset the code template, you'll see this point.</b></li>\n</ol>\n<br>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-using-pointers-time-limit-exceeded">Approach #3  Using Pointers [Time Limit Exceeded]</a></li>\n<li><a href="#approach-4-using-priority-queue-accepted">Approach #4 Using Priority Queue [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The naive approach is to consider every pair of elements, <script type="math/tex; mode=display">nums[i][j]</script> and <script type="math/tex; mode=display">nums[k][l]</script> from amongst the given \nlists and consider the range formed by these elements. For every range currently considered, we can traverse over all the \nlists to find if atleast one element from these lists can be included in the current range. If so, we store the end-points of the current range \nand compare it with the previous minimum range found, if any, satisfying the required criteria, to find the smaller range from among them.</p>\n<p>Once all the element pairs have been considered as the ranges, we can obtain the required minimum range.</p>\n<iframe frameborder="0" height="515" name="SMprvqVp" src="https://leetcode.com/playground/SMprvqVp/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^3)</script>. Considering every possible range(element pair) requires <script type="math/tex; mode=display">O(n^2)</script> time. For each range considered, \nwe need to traverse over all the elements of the given lists in the worst case requiring another <script type="math/tex; mode=display">O(n)</script> time. Here, <script type="math/tex; mode=display">n</script> refers to the \ntotal number of elements in the given lists.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we consider every possible range and then traverse over every list to check if atleast one of the \nelements from these lists lies in the required range. Instead of doing this traversal for every range, we can make use \nof Binary Search to find the index of the element just larger than(or equal to) the lower limit of the range currently \nconsidered. </p>\n<p>If all the elements in the current list are lesser than this lower limit, we\'ll get the index as <script type="math/tex; mode=display">nums[k].length</script>\n for the <script type="math/tex; mode=display">k^{th}</script> list being currently checked. In this case, none of the elements of the current list lies in the\ncurrent range.</p>\n<p>On the other hand, if all the elements in this list are larger than this lower limit, we\'ll get the index of the first element(minimum) in the current list. If this element happens to be larger than the upper limit  of the range currently considered, then also, none of the elements of the current list lies within the current range.</p>\n<p>Whenever a range is found which satisfies the required criteria, we can compare it with the minimum range found so far \n to determine the required minimum range.</p>\n<iframe frameborder="0" height="515" name="uXxKqhkz" src="https://leetcode.com/playground/uXxKqhkz/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(n^2log(k)\\big)</script>. The time required to consider every possible range is <script type="math/tex; mode=display">O(n^2)</script>. For every range currently considered, \na Binary Search requiring <script type="math/tex; mode=display">O\\big(log(k)\\big)</script> time is required. Here, <script type="math/tex; mode=display">n</script> refers to the total number of elements in the given \nlists and <script type="math/tex; mode=display">k</script> refers to the average length of each list.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-pointers-time-limit-exceeded">Approach #3  Using Pointers [Time Limit Exceeded]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We\'ll discuss about the implementation used in the current approach along with the idea behind it. </p>\n<p>This approach makes use of an array of pointers, <script type="math/tex; mode=display">next</script>, whose length is equal to the number of given lists. In this \narray, <script type="math/tex; mode=display">next[i]</script> refers to the element which needs to be considered next in the <script type="math/tex; mode=display">(i-1)^{th}</script> list. The meaning of this will become \nmore clearer when we look at the process.</p>\n<p>We start by initializing all the elements of <script type="math/tex; mode=display">next</script> to 0. Thus, currently, we are considering the first(minimum) element \namong all the lists. Now, we find out the index of the list containing the maximum(<script type="math/tex; mode=display">max_i</script>) and minimum(<script type="math/tex; mode=display">min_i</script>) \nelements from amongst the elements currently pointed by <script type="math/tex; mode=display">next</script>. The range formed by these maximum and minimum elements surely<br>\ncontains atleast one element from each list. </p>\n<p>But, now our objective is to minimize this range. To do so, there are two options: Either decrease the maximum value or increase the \nminimum value. </p>\n<p>Now, the maximum value can\'t be reduced any further, since it already corresponds to the minimum value in one of the lists. \nReducing it any further will lead to the exclusion of all the elements of this list(containing the last maximum value) \nfrom the new range. </p>\n<p>Thus, the only option left in our hand is to try to increase the minimum value. To do so, we now need to consider the\n next element in the list containing the last minimum value. Thus, we increment the entry at the corresponding index\n  in <script type="math/tex; mode=display">next</script>, to indicate that the next element in this list now needs to be considered. </p>\n<p>Thus, at every step, we find the maximum and minimum values being pointed currently, update the <script type="math/tex; mode=display">next</script> values \n  appropriately, and also find out the range formed by these maximum and minimum values to find out the smallest range \n satisfying the given criteria. </p>\n<p>While doing this process, if any of the lists gets completely exhausted, it means that the minimum value being increased for \n minimizing the range being considered can\'t be increased any further, without causing the exclusion of all the elements in atleast \n one of the lists. Thus, we can stop the search process whenever any list gets completely exhausted.</p>\n<p>We can also stop the process, when all the elements of the given lists have been exhausted.</p>\n<p>Summarizing the statements above, the process becomes:</p>\n<ol>\n<li>\n<p>Initialize <script type="math/tex; mode=display">next</script> array(pointers) with all 0\'s.</p>\n</li>\n<li>\n<p>Find the indices of the lists containing the minimum(<script type="math/tex; mode=display">min_i</script>) and the maximum(<script type="math/tex; mode=display">max_i</script>) elements amongst the elements pointed by the <script type="math/tex; mode=display">next</script> array.</p>\n</li>\n<li>\n<p>If the range formed by the maximum and minimum elements found above is larger than the previous maximum range, update the boundary values used for the maximum range.</p>\n</li>\n<li>\n<p>Increment the pointer <script type="math/tex; mode=display">nums[min_i]</script>.</p>\n</li>\n<li>\n<p>Repeat steps 2 to 4 till any of the lists gets exhausted.</p>\n</li>\n</ol>\n<p>The animation below illustrates the process for a visual understanding of the process.</p>\n<p>!?!../Documents/632_Smallest_Range.json:1000,563!?!</p>\n<iframe frameborder="0" height="513" name="rnPo3vGZ" src="https://leetcode.com/playground/rnPo3vGZ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n*m)</script>. In the worst case, we need to traverse over <script type="math/tex; mode=display">next</script> array(of length <script type="math/tex; mode=display">m</script>) for all the elements of the given lists.\nHere, <script type="math/tex; mode=display">n</script> refers to the total number of elements in all the lists. <script type="math/tex; mode=display">m</script> refers to the total number of lists.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m)</script>. <script type="math/tex; mode=display">next</script> array of size <script type="math/tex; mode=display">m</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-priority-queue-accepted">Approach #4 Using Priority Queue [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, at each step, we update the pointer corresponding to the current minimum element and traverse over the whole\n<script type="math/tex; mode=display">next</script> array to determine the new maximum and minimum values. We can do some optimization here, by making use of a simple observation.</p>\n<p>Whenever we update a single entry of <script type="math/tex; mode=display">next</script> to consider the new maximum and minimum values(if we already know the last maximum \nand minimum values), all the elements to be considered for finding the maximum and minimum values remain the same except the new element \nbeing pointed by a single updated entry in <script type="math/tex; mode=display">next</script>.  This new entry is certainly larger than the last minimum value(since that was the \nreasoning behind the updation). </p>\n<p>Thus, we can\'t be sure whether this is the new minimum element or not. But, since it is larger than the last \nvalue being considered, it could be a potential competitor for the new maximum value. Thus, we can directly compare it with the last \nmaximum value to determine the current maximum value.</p>\n<p>Now, we\'re left with finding the minimum value iteratively at every step. To avoid this iterative process, a better idea \nis to make use of a Min-Heap, which stores the values being pointed currently by the <script type="math/tex; mode=display">next</script> array. Thus, the minimum value always \nlies at the top of this heap, and we need not do the iterative search process. </p>\n<p>At every step, we remove the minimum element from this heap and find out the range formed by the current maximum and minimum values, and \ncompare it with the minimum range found so far to determine the required minimum range. We also update the increment the index in <script type="math/tex; mode=display">next</script> \ncorresponding to the list containing this minimum entry and add this element to the heap as well.</p>\n<p>The rest of the process remains the same as the last approach.</p>\n<iframe frameborder="0" height="515" name="kBqfu7ju" src="https://leetcode.com/playground/kBqfu7ju/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(n*log(m)\\big)</script>. Heapification of <script type="math/tex; mode=display">m</script> elements requires <script type="math/tex; mode=display">O\\big(log(m)\\big)</script> time. This step could be done \nfor all the elements of the given lists in the worst case. Here, <script type="math/tex; mode=display">n</script> refers to the total number of elements in \nall the lists. <script type="math/tex; mode=display">m</script> refers to the total number of lists.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m)</script>. <script type="math/tex; mode=display">next</script> array of size <script type="math/tex; mode=display">m</script> is used. A Min-Heap with <script type="math/tex; mode=display">m</script> elements is also used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Lyft'],
  },
  {
    id: '633',
    name: 'Sum of Square Numbers',
    acceptance: '32.3%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>\nGiven a non-negative integer <code>c</code>, your task is to decide whether there're two integers <code>a</code> and <code>b</code> such that a<sup>2</sup> + b<sup>2</sup> = c.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> 5\n<b>Output:</b> True\n<b>Explanation:</b> 1 * 1 + 2 * 2 = 5\n</pre>\n<p></p>\n\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> 3\n<b>Output:</b> False\n</pre>\n<p></p>\n\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-using-sqrt-function-accepted">Approach #3 Using sqrt function [Accepted]</a></li>\n<li><a href="#approach-4-using-binary-search-accepted">Approach #4 Using Binary Search [Accepted]</a></li>\n<li><a href="#approach-5-fermat-theorem-accepted">Approach #5 Fermat Theorem [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The simplest solution would be to consider every possible combination of integers <script type="math/tex; mode=display">a</script> and <script type="math/tex; mode=display">b</script> and check if the sum of their squares equals <script type="math/tex; mode=display">c</script>. Now, both <script type="math/tex; mode=display">a</script> and <script type="math/tex; mode=display">b</script> can lie within the range <script type="math/tex; mode=display">(0,\\sqrt{c})</script>. Thus, we need to check for the values of <script type="math/tex; mode=display">a</script> and <script type="math/tex; mode=display">b</script> in this range only.</p>\n<iframe frameborder="0" height="241" name="KJqxJTpS" src="https://leetcode.com/playground/KJqxJTpS/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(c)</script>. Two loops upto <script type="math/tex; mode=display">\\sqrt{c}</script>. Here, <script type="math/tex; mode=display">c</script> refers to the given integer(sum of squares).</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</h4>\n<p>We can improve the last solution, if we make the following observation. For any particular <script type="math/tex; mode=display">a</script> chosen, the value of <script type="math/tex; mode=display">b</script> required to satisfy the equation <script type="math/tex; mode=display">a^2 + b^2 = c</script> will be such that <script type="math/tex; mode=display">b^2 = c - a^2</script>. Thus, we need to traverse over the range <script type="math/tex; mode=display">(0, \\sqrt{c})</script> only for considering the various values of <script type="math/tex; mode=display">a</script>. For every current value of <script type="math/tex; mode=display">a</script> chosen, we can determine the corresponding <script type="math/tex; mode=display">b^2</script> value and check if it is a perfect square or not. If it happens to be a perfect square, <script type="math/tex; mode=display">c</script> is a sum of squares of two integers, otherwise not.</p>\n<p>Now, to determine, if the number <script type="math/tex; mode=display">c - a^2</script> is a perfect square or not, we can make use of the following theorem: "The square of <script type="math/tex; mode=display">n^{th}</script> positive integer can be represented as a sum of first <script type="math/tex; mode=display">n</script> odd positive integers." Or in mathematical terms:</p>\n<p>\n<script type="math/tex; mode=display">n^2 = 1 + 3 + 5 + ... + (2*n-1) = \\sum_{1}^{n} (2*i - 1)</script>.</p>\n<p>To look at the proof of this statement, look at the L.H.S. of the above statement.</p>\n<p>\n<script type="math/tex; mode=display">1 + 3 + 5 + ... + (2*n-1)=</script>\n</p>\n<p>\n<script type="math/tex; mode=display">(2*1-1) + (2*2-1) + (2*3-1) + ... + (2*n-1)=</script>\n</p>\n<p>\n<script type="math/tex; mode=display">2*(1+2+3+....+n) - (1+1+...n times)=</script>\n</p>\n<p>\n<script type="math/tex; mode=display">2*n*(n+1)/2 - n=</script>\n</p>\n<p>\n<script type="math/tex; mode=display">n*(n+1) - n=</script>\n</p>\n<p>\n<script type="math/tex; mode=display">n^2 + n - n = n^2</script>\n</p>\n<p>This completes the proof of the above statement.</p>\n<iframe frameborder="0" height="309" name="ToQxLr6g" src="https://leetcode.com/playground/ToQxLr6g/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(c)</script>. The total number of times the <script type="math/tex; mode=display">sum</script> is updated is: <script type="math/tex; mode=display">1+2+3+...(\\sqrt{c} times) = \\sqrt{c}(\\sqrt{c}+1)/2 = O(c)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-sqrt-function-accepted">Approach #3 Using sqrt function [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of finding if <script type="math/tex; mode=display">c - a^2</script> is a perfect square using sum of odd numbers, as done in the last approach, we can make use of the inbuilt <script type="math/tex; mode=display">sqrt</script> function and check if <script type="math/tex; mode=display">\\sqrt{c - a^2}</script> turns out to be an integer. If it happens for any value of <script type="math/tex; mode=display">a</script> in the range <script type="math/tex; mode=display">[0, \\sqrt{c}]</script>, we can return a True value immediately.</p>\n<iframe frameborder="0" height="241" name="PfDSwKKi" src="https://leetcode.com/playground/PfDSwKKi/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(\\sqrt{c}log(c)\\big)</script>. We iterate over <script type="math/tex; mode=display">\\sqrt{c}</script> values for choosing <script type="math/tex; mode=display">a</script>. For every <script type="math/tex; mode=display">a</script> chosen, finding square root of <script type="math/tex; mode=display">c - a^2</script> takes <script type="math/tex; mode=display">O\\big(log(c)\\big)</script> time in the worst case.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-binary-search-accepted">Approach #4 Using Binary Search [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Another method to check if <script type="math/tex; mode=display">c - a^2</script> is a perfect square, is by making use of Binary Search. The method remains same as that of a typical Binary Search to find a number.\nThe only difference lies in that we need to find an integer, <script type="math/tex; mode=display">mid</script> in the range <script type="math/tex; mode=display">[0, c - a^2]</script>, such that this number is the square root of <script type="math/tex; mode=display">c - a^2</script>.\nOr in other words, we need to find an integer, <script type="math/tex; mode=display">mid</script>, in the range <script type="math/tex; mode=display">[0, c - a^2]</script>, such that <script type="math/tex; mode=display">mid</script>x<script type="math/tex; mode=display">mid = c - a^2</script>.</p>\n<p>The following animation illustrates the search process for a particular value of <script type="math/tex; mode=display">c - a^2 = 36</script>.</p>\n<p>!?!../Documents/633_Sum_of_Squares.json:1000,563!?!</p>\n<iframe frameborder="0" height="394" name="Eo33FrYc" src="https://leetcode.com/playground/Eo33FrYc/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(\\sqrt{c}log(c)\\big)</script>. Binary search taking <script type="math/tex; mode=display">O\\big(log(c)\\big)</script> in the worst case is done for <script type="math/tex; mode=display">\\sqrt{c}</script> values of <script type="math/tex; mode=display">a</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(log(c))</script>. Binary Search will take <script type="math/tex; mode=display">O(log(c))</script> space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-fermat-theorem-accepted">Approach #5 Fermat Theorem [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>This approach is based on the following statement, which is based on Fermat\'s Theorem:</p>\n<p>"Any positive number <script type="math/tex; mode=display">n</script> is expressible as a sum of two squares if and only if the prime factorization of <script type="math/tex; mode=display">n</script>, every prime of the form <script type="math/tex; mode=display">(4k+3)</script> occurs an even number of times."</p>\n<p>By making use of the above theorem, we can directly find out if the given number <script type="math/tex; mode=display">c</script> can be expressed as a sum of two squares.</p>\n<p>To do so we simply find all the prime factors of the given number <script type="math/tex; mode=display">c</script>, which could range from <script type="math/tex; mode=display">[2,\\sqrt{c}]</script> along with the count of those factors, by repeated division. \nIf at any step, we find out that the number of occurences of any prime factor of the form <script type="math/tex; mode=display">(4k+3)</script> occurs an odd number of times, we can return a False value.</p>\n<p>In case, <script type="math/tex; mode=display">c</script> itself is a prime number, it won\'t be divisible by any of the primes in the <script type="math/tex; mode=display">[2,\\sqrt{c}]</script>. Thus, we need to check if <script type="math/tex; mode=display">c</script> can be expressed in the form of\n<script type="math/tex; mode=display">4k+3</script>. If so, we need to return a False value, indicating that this prime occurs an odd number(1) of times. </p>\n<p>Otherwise, we can return a True value.</p>\n<p>The proof of this theorem includes the knowledge of advanced mathematics and is beyond the scope of this article. However, interested reader can refer to <a href="http://wstein.org/edu/124/lectures/lecture21/lecture21/node2.html">this</a> documentation.</p>\n<iframe frameborder="0" height="326" name="f9Fgne3m" src="https://leetcode.com/playground/f9Fgne3m/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big(\\sqrt{c}log(c)\\big)</script>. We find the factors of <script type="math/tex; mode=display">c</script> and their count using repeated division. We check for the factors in the range <script type="math/tex; mode=display">[0, \\sqrt{c}]</script>.\nThe maximum number of times a factor can occur(repeated division can be done) is <script type="math/tex; mode=display">log(n)</script>(considering 2 as the only factor, <script type="math/tex; mode=display">c=2^x</script>. Thus, <script type="math/tex; mode=display">x=log(c)</script>).</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '634',
    name: 'Find the Derangement of An Array ',
    acceptance: '34.9%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nIn combinatorial mathematics, a derangement is a permutation of the elements of a set, such that no element appears in its original position.\n</p>\n\n<p>\nThere's originally an array consisting of <code>n</code> integers from 1 to <code>n</code> in ascending order, you need to find the number of derangement it can generate.\n</p>\n\n<p>\nAlso, since the answer may be very large, you should return the output mod 10<sup>9</sup> + 7.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> 3\n<b>Output:</b> 2\n<b>Explanation:</b> The original array is [1,2,3]. The two derangements are [2,3,1] and [3,1,2].\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n<code>n</code> is in the range of [1, 10<sup>6</sup>].\n</p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-recursion-stack-overflow">Approach #2 Using Recursion [Stack Overflow]</a></li>\n<li><a href="#approach-3-dynamic-programming-accepted">Approach #3 Dynamic Programming [Accepted]:</a></li>\n<li><a href="#approach-4-constant-space-dynamic-programming-accepted">Approach #4 Constant Space Dynamic Programming [Accepted]:</a></li>\n<li><a href="#approach-5-using-formula-accepted">Approach #5 Using Formula [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The simplest solution is to consider every possible permutation of the given numbers from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script> and count the number of permutations which are dereangements of the \noriginal arrangement. </p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O\\big((n+1)!\\big)</script>. <script type="math/tex; mode=display">n!</script> permutations are possible for <script type="math/tex; mode=display">n</script> numbers. For each permutation, we need to traverse over the whole arrangement to check if it \nis a derangement or not, which takes <script type="math/tex; mode=display">O(n)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. Each permutation would require <script type="math/tex; mode=display">n</script> space to be stored.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-recursion-stack-overflow">Approach #2 Using Recursion [Stack Overflow]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In order to find the number of derangements for <script type="math/tex; mode=display">n</script> numbers, firstly we can consider the the original array to be \n<code>[1,2,3,...,n]</code>. Now, in order to generate the derangements of this array, assume that firstly, we move the number 1 from \nits original position and place at the place of the number <script type="math/tex; mode=display">i</script>. But, now, this <script type="math/tex; mode=display">i^{th}</script> position can be chosen \nin <script type="math/tex; mode=display">n-1</script> ways. Now, for placing the number <script type="math/tex; mode=display">i</script> we have got two options:</p>\n<ol>\n<li>\n<p>We place <script type="math/tex; mode=display">i</script> at the place of <script type="math/tex; mode=display">1</script>: By doing this, the problem of finding the derangements reduces to finding the derangements of the \nremaining <script type="math/tex; mode=display">n-2</script> numbers, since we\'ve got <script type="math/tex; mode=display">n-2</script> numbers and <script type="math/tex; mode=display">n-2</script> places, such that every number can\'t be placed at exactly one position.</p>\n</li>\n<li>\n<p>We don\'t place <script type="math/tex; mode=display">i</script> at the place of <script type="math/tex; mode=display">1</script>: By doing this, the problem of finding the derangements reduces to finding the \nderangements for the <script type="math/tex; mode=display">n-1</script> elements(except 1). This is because, now we\'ve got <script type="math/tex; mode=display">n-1</script> elements and these <script type="math/tex; mode=display">n-1</script> elements can\'t be placed at \nexactly one location(with <script type="math/tex; mode=display">i</script> not being placed at the first position).</p>\n</li>\n</ol>\n<p align="center"><img alt="Derangement_Split" src="https://leetcode.com/articles/Figures/634/634_Find_Derangements_split.PNG"></p>\n<p>Based, on the above discussion, if <script type="math/tex; mode=display">d(n)</script> represents the number of derangements for <script type="math/tex; mode=display">n</script> elements, it can be obtained as:</p>\n<p>\n<script type="math/tex; mode=display">d(n) = (n-1)*[d(n-1) + d(n-2)]</script>\n</p>\n<p>This is a recursive equation and can thus, be solved easily by making use of a recursive function.</p>\n<p>But, if we go with the above method, a lot of duplicate function calls wiil be made, with the same parameters being passed. This is because the same state can be reached through various paths in the recursive tree. In order to avoid these duplicate calls, we can store the result of a function call, once its made, \ninto a memoization array. Thus, whenever the same function call is made again, we can directly return the result from this memoization array. \nThis helps to prune the search space to a great extent.</p>\n<iframe frameborder="0" height="326" name="6sZQMgm6" src="https://leetcode.com/playground/6sZQMgm6/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">memo</script> array of length <script type="math/tex; mode=display">n</script> is filled once only.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">memo</script> array of length <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-dynamic-programming-accepted">Approach #3 Dynamic Programming [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>As we\'ve discussed above, the recursive formula for finding the derangements for <script type="math/tex; mode=display">n</script> elements is given by:</p>\n<p>\n<script type="math/tex; mode=display">d(n) = (n-1)*[d(n-1) + d(n-2)]</script>\n</p>\n<p>From this expression, we can see that the result for derangements for <script type="math/tex; mode=display">i</script> numbers depends only on the result of the derangments \nof numbers lesser than <script type="math/tex; mode=display">i</script>. Thus, we can solve the given problem by making use of Dynamic Programming.</p>\n<p>The equation for Dynamic Programming remains identical to the recursive equation.</p>\n<p>\n<script type="math/tex; mode=display">dp[i] = (i - 1)*(dp[i-1]+dp[i-2])</script>\n</p>\n<p>Here, <script type="math/tex; mode=display">dp[i]</script> is used to store the number of derangements for <script type="math/tex; mode=display">i</script> elements. We start filling the <script type="math/tex; mode=display">dp</script> array from <script type="math/tex; mode=display">i=0</script> and move towards the larger values of <script type="math/tex; mode=display">i</script>. At the end, the value of \n<script type="math/tex; mode=display">dp[n]</script> gives the required result.</p>\n<p>The following animation illustrates the <script type="math/tex; mode=display">dp</script> filling process.</p>\n<p>!?!../Documents/634_Find_Derangements.json:1000,563!?!</p>\n<iframe frameborder="0" height="292" name="r4pe7vRB" src="https://leetcode.com/playground/r4pe7vRB/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Single loop upto <script type="math/tex; mode=display">n</script> is required to fill the <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-constant-space-dynamic-programming-accepted">Approach #4 Constant Space Dynamic Programming [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we can easily observe that the result for <script type="math/tex; mode=display">dp[i]</script> depends only on the previous two elements, <script type="math/tex; mode=display">dp[i-1]</script> and \n<script type="math/tex; mode=display">dp[i-2]</script>. Thus, instead of maintaining the entire 1-D array, we can just keep a track of the last two values required to calculate the \nvalue of the current element. By making use of this observation, we can save the space required by the <script type="math/tex; mode=display">dp</script> array in the last approach.</p>\n<iframe frameborder="0" height="326" name="Jg5QLdKy" src="https://leetcode.com/playground/Jg5QLdKy/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Single loop upto <script type="math/tex; mode=display">n</script> is required to find the required result.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-using-formula-accepted">Approach #5 Using Formula [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>Before discussing this approach, we need to look at some preliminaries.</p>\n<p>In combinatorics (combinatorial mathematics), the inclusion–exclusion principle is a counting \ntechnique which generalizes the familiar method of obtaining the number of elements in the union of two \nfinite sets; symbolically expressed as</p>\n<p>\n<script type="math/tex; mode=display">\\left|A\\cup B\\right|=\\left|A\\right|+\\left|B\\right|-\\left|A\\cap B\\right|</script>\n</p>\n<p>where <script type="math/tex; mode=display">A</script> and <script type="math/tex; mode=display">B</script> are two finite sets and <script type="math/tex; mode=display">\\left|S\\right|</script> indicates the cardinality of a set <script type="math/tex; mode=display">S</script> \n(which may be considered as the number of elements of the set, if the set is finite). </p>\n<p align="center"><img alt="AUB" src="https://leetcode.com/articles/Figures/634/634_AUB.PNG"></p>\n<p>The formula expresses the fact that the sum of the sizes of the two sets may be too large since\n some elements may be counted twice. The double-counted elements are those in the intersection of \n the two sets and the count is corrected by subtracting the size of the intersection.</p>\n<p>The principle is more clearly seen in the case of three sets, which for the sets <script type="math/tex; mode=display">A</script>, <script type="math/tex; mode=display">B</script> and <script type="math/tex; mode=display">C</script> is given by</p>\n<p>\n<script type="math/tex; mode=display">\\left|A\\cup B\\cup C\\right|=\\left|A\\right|+\\left|B\\right|+\\left|C\\right|-\\left|A\\cap B\\right|-\\left|A\\cap C\\right|-\\left|B\\cap C\\right|+\\left|A\\cap B\\cap C\\right|</script>.</p>\n<p>This formula can be verified by counting how many times each region in the \nVenn diagram figure shown below. </p>\n<p align="center"><img alt="AUBUC" src="https://leetcode.com/articles/Figures/634/634_AUBUC.png"></p>\n<p>In this case, \nwhen removing the contributions of over-counted elements, the number of elements in the mutual \nintersection of the three sets has been subtracted too often, so must be added back in to get the correct total.</p>\n<p>In its general form, the principle of inclusion–exclusion states that for finite sets <script type="math/tex; mode=display">A_1, ..., A_n</script>, one\n has the identity</p>\n<p>\n<script type="math/tex; mode=display">\\left|\\bigcup _{i=1}^{n}A_{i}\\right|=\\sum_{i=1}^{n}\\left|A_{i}\\right|-\\sum_{1 &leq; i < j &leq; n}\\left|A_{i}\\cap A_{j}\\right|+...</script>\n</p>\n<p>\n<script type="math/tex; mode=display">+...+\\sum_{1 &leq; i < j < k &leq; n}\\left|A_{i}\\cap A_{j}\\cap A_{k}\\right|-..... +(-1)^{n}\\left|A_{1}\\cap... \\cap A_{n}\\right|</script>\n</p>\n<p>By applying De-Morgan\'s law to the above equation, we can obtain</p>\n<p>\n<script type="math/tex; mode=display">\\left|\\bigcap _{i=1}^{n}\\bar{A_{i}}\\right|=\\left|S-\\bigcup _{i=1}^{n}A_{i}\\right|=\\left|S\\right|-</script>\n<script type="math/tex; mode=display">\\sum_{i=1}^{n}\\left|A_{i}\\right|+\\sum_{1 &leq; i < j &leq; n}\\left|A_{i}\\cap A_{j}\\right|-.... +(-1)^{n}\\left|A_{1}\\cap....\\cap A_{n}\\right|</script>\n</p>\n<p>Here, <script type="math/tex; mode=display">S</script> represents the universal set containing all of the <script type="math/tex; mode=display">A_i</script> and <script type="math/tex; mode=display">\\bar{A_{i}}</script> denotes the complement of <script type="math/tex; mode=display">A_i</script> in <script type="math/tex; mode=display">S</script>.</p>\n<p>Now, let <script type="math/tex; mode=display">A_i</script> denote the set of permutations  which leave <script type="math/tex; mode=display">A_i</script> in its natural position. Thus, the number of permutations in which \nthe <script type="math/tex; mode=display">i^{th}</script> element remains at its natural position is <script type="math/tex; mode=display">(n-1)!</script>. Thus, the component <script type="math/tex; mode=display">\\sum_{i=1}^{n}\\left|A_{i}\\right|</script> above \nbecomes <script type="math/tex; mode=display">{{n}\\choose{1}} (n-1)!</script>. Here, <script type="math/tex; mode=display">{{n}\\choose{1}}</script> represents the number of ways of choosing 1 element out of <script type="math/tex; mode=display">n</script> elements.</p>\n<p>Making use of this notation, the required number of derangements can be denoted by <script type="math/tex; mode=display">\\left|\\bigcap _{i=1}^{n}\\bar{A_{i}}\\right|</script> term. </p>\n<p>This is the same term which has been expanded in the last equation. Putting appropriate values of the elements, we can expand the above equation as:</p>\n<p>\n<script type="math/tex; mode=display">\\left|\\bigcap _{i=1}^{n}\\bar{A_{i}}\\right|=n! -{n \\choose 1}(n-1)! + {n\\choose 2}(n-2)! - {n \\choose 3}(n-3)! +...</script>\n<script type="math/tex; mode=display">...+(-1)^{p}{n \\choose p}(n-p)! +...+ (-1)^{n}{n \\choose n} (n-n)!</script>\n</p>\n<p>\n<script type="math/tex; mode=display"> = n! - \\frac{n!}{1!} + \\frac{n!}{2!} - \\frac{n!}{3!}+...+(-1)^n \\frac{n!}{n!}</script>\n</p>\n<p>We can make use of this formula to obtain the required number of derangements.</p>\n<iframe frameborder="0" height="224" name="e35fvm74" src="https://leetcode.com/playground/e35fvm74/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Single loop upto <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['IXL'],
  },
  {
    id: '635',
    name: 'Design Log Storage System ',
    acceptance: '48.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>You are given several logs that each log contains a unique id and timestamp. Timestamp is a string that has the following format: <code>Year:Month:Day:Hour:Minute:Second</code>, for example, <code>2017:01:01:23:59:59</code>. All domains are zero-padded decimal numbers. </p>\n\n<p>Design a log storage system to implement the following functions:</p>\n\n<p><code>void Put(int id, string timestamp)</code>: Given a log\'s unique id and timestamp, store the log in your storage system.</p>\n<br>\n<p><code>int[] Retrieve(String start, String end, String granularity)</code>: Return the id of logs whose timestamps are within the range from start to end. Start and end all have the same format as timestamp. However, granularity means the time level for consideration. For example, start = "2017:01:01:23:59:59", end = "2017:01:02:23:59:59", granularity = "Day", it means that we need to find the logs within the range from Jan. 1st 2017 to Jan. 2nd 2017.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre>put(1, "2017:01:01:23:59:59");\nput(2, "2017:01:01:22:59:59");\nput(3, "2016:01:01:00:00:00");\nretrieve("2016:01:01:01:01:01","2017:01:01:23:00:00","Year"); // return [1,2,3], because you need to return all logs within 2016 and 2017.\nretrieve("2016:01:01:01:01:01","2017:01:01:23:00:00","Hour"); // return [1,2], because you need to return all logs start from 2016:01:01:01 to 2017:01:01:23, where log 3 is left outside the range.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>There will be at most 300 operations of Put or Retrieve.</li>\n<li>Year ranges from [2000,2017]. Hour ranges from [00,23].</li>\n<li>Output for Retrieve has no order required.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-converting-timestamp-into-a-number-accepted">Approach #1 Converting timestamp into a number [Accepted]</a></li>\n<li><a href="#approach-2-better-retrieval-accepted">Approach #2 Better Retrieval [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-converting-timestamp-into-a-number-accepted">Approach #1 Converting timestamp into a number [Accepted]</h4>\n<p>This solution is based on converting the given timestap into a number. This can help because retrieval of Logs lying\nwithin a current range can be very easily done if the range to be used can be represented in the form of a single number.\nLet\'s look at the individual implementations directly.</p>\n<ol>\n<li>\n<p><code>put</code>: Firstly, we split the given timestamp based on <code>:</code> and store the individual components obtained into an <script type="math/tex; mode=display">st</script> array.\nNow, in order to put this log\'s entry into the storage, firstly, we convert this timestamp, now available as individual components \nin the <script type="math/tex; mode=display">st</script> array into a single number. To obtain a number which is unique for each timestamp, the number chosen is such that \nit represents the timestamp in terms of seconds. But, doing so for the Year values can lead to very large numbers, which could \nlead to a potential overflow. Since, we know that the Year\'s value can start from 2000 only, we subtract 1999 from the Year\'s value \nbefore doing the conversion of the given timestamp into seconds. We store this timestamp(in the form of a number now), along with the \nLog\'s id, in s <script type="math/tex; mode=display">list</script>, which stores data in the form <script type="math/tex; mode=display">[converted\\_timestamp, id]</script>. </p>\n</li>\n<li>\n<p><code>retrieve</code>: In order to retrieve the logs\' ids lying within the timestamp <script type="math/tex; mode=display">s</script> and <script type="math/tex; mode=display">e</script>, with a granularity <script type="math/tex; mode=display">gra</script>, firstly, we \nneed to convert the given timestamps into seconds. But, since, we need to take care of granularity, before doing the conversion, we \nneed to consider the effect of granularity. Granularity, in a way, depicts the precision of the results. Thus, for a granularity corresponding to \na Day, we need to consider the portion of the timestamp considering the precision upto Day only. The rest of the fields \ncan be assumed to be all 0\'s. After doing this for both the start and end timestamp, we do the conversion of the timestamp with the \nrequired precision into seconds. Once this has been done, we iterate over all the logs in the <script type="math/tex; mode=display">list</script> to obtain the ids of those \nlogs which lie within the required range. We keep on adding these ids to a <script type="math/tex; mode=display">res</script> list which is returned at the end of this function call.</p>\n</li>\n</ol>\n<iframe frameborder="0" height="515" name="zHbRZ2y6" src="https://leetcode.com/playground/zHbRZ2y6/shared" width="100%"></iframe>\n<p><strong>Performance Analysis</strong></p>\n<ul>\n<li>\n<p>The <code>put</code>method takes <script type="math/tex; mode=display">O(1)</script> time to insert a new entry into the given set of logs.</p>\n</li>\n<li>\n<p>The <code>retrieve</code> method takes <script type="math/tex; mode=display">O(n)</script> time to retrieve the logs in the required range. Determining the granularity takes <script type="math/tex; mode=display">O(1)</script> time. But, to find the logs lying in the required range, we need to iterate over the set of logs atleast once. Here, <script type="math/tex; mode=display">n</script> refers to the number of entries in the current set of logs.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-retrieval-accepted">Approach #2 Better Retrieval [Accepted]</h4>\n<p>This method remains almost the same as the last approach, except that, in order to store the timestamp data, we make use \nof a TreeMap instead of a list, with the key values being the timestamps converted in seconds form and the values being the \nids of the corresponding logs.</p>\n<p>Thus, the <code>put</code> method remains the same as the last approach. However, we can save some time in <code>retrieve</code> approach by making use \nof <code>tailMap</code> function of TreeMap, which stores the entries in the form of a sorted navigable binary tree. By making use of this function, instead of iterating over all the timestamps in \nthe storage to find the timestamps lying within the required range(after considering the granularity as in the last approach),\nwe can reduce the search space to only those elements whose timestamp is larger than(or equal to) the starting timestamp value.</p>\n<iframe frameborder="0" height="515" name="5bhZzaNE" src="https://leetcode.com/playground/5bhZzaNE/shared" width="100%"></iframe>\n<p><strong>Performance Analysis</strong></p>\n<ul>\n<li>\n<p>The TreeMap is maintained internally as a Red-Black(balanced) tree. Thus, the <code>put</code>method takes <script type="math/tex; mode=display">O\\big(log(n)\\big)</script> time to insert a new entry into the given set of logs. Here, <script type="math/tex; mode=display">n</script> refers to the number of entries currently present in the given set of logs.</p>\n</li>\n<li>\n<p>The <code>retrieve</code> method takes <script type="math/tex; mode=display">O(m_{start})</script> time to retrieve the logs in the required range. Determining the granularity takes <script type="math/tex; mode=display">O(1)</script> time. To find the logs in the required range, we only need to iterate over those elements which already lie in the required range. Here, <script type="math/tex; mode=display">m_{start}</script> refers to the number of entries in the current set of logs which have a timestamp greater than the current <script type="math/tex; mode=display">start</script> value.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Snapchat'],
  },
  {
    id: '636',
    name: 'Exclusive Time of Functions',
    acceptance: '44.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given the running logs of <b>n</b> functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions. </p>\n\n<p>Each function has a unique id, start from <b>0</b> to <b>n-1</b>. A function may be called recursively or by another function.</p>\n\n<p>A log is a string has this format : <code>function_id:start_or_end:timestamp</code>. For example, <code>"0:start:0"</code> means function 0 starts from the very beginning of time 0. <code>"0:end:0"</code> means function 0 ends to the very end of time 0. </p>\n\n<p>Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function\'s exclusive time. You should return the exclusive time of each function sorted by their function id.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>\nn = 2\nlogs = \n["0:start:0",\n "1:start:2",\n "1:end:5",\n "0:end:6"]\n<b>Output:</b>[3, 4]\n<b>Explanation:</b>\nFunction 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. \nNow function 0 <b>calls function 1</b>, function 1 starts at time 2, executes 4 units of time and end at time 5.\nFunction 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. \nSo function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>Input logs will be sorted by timestamp, NOT log id.</li>\n<li>Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0.</li>\n<li>Two functions won\'t start or end at the same time.</li>\n<li>Functions could be called recursively, and will always end.</li>\n<li>1 &lt;= n &lt;= 100</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-stack-time-limit-exceeded">Approach #1 Using Stack [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-approach-accepted">Approach #2 Better Approach [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-stack-time-limit-exceeded">Approach #1 Using Stack [Time Limit Exceeded]</h4>\n<p>Before starting off with the solution, let\'s discuss a simple idea. Suppose we have three functions <script type="math/tex; mode=display">func_1</script>, <script type="math/tex; mode=display">func_2</script> and <script type="math/tex; mode=display">func_3</script> such that <script type="math/tex; mode=display">func_1</script> calls <script type="math/tex; mode=display">func_2</script> and then <script type="math/tex; mode=display">func_2</script> calls <script type="math/tex; mode=display">func_3</script>. In this case, <script type="math/tex; mode=display">func_3</script> starts at the end and ends first, <script type="math/tex; mode=display">func_2</script> starts at 2nd position and ends at the 2nd last step. Similarly, <script type="math/tex; mode=display">func_1</script> starts first and ends at the last position. Thus, we can conclude that the function which is entered at the end finishes first and the one which is entered first ends at the last position. </p>\n<p>From the above discussion, we can conclude that we can make use of a <script type="math/tex; mode=display">stack</script> to solve the given problem. We can start by pushing the first function\'s id from the given <script type="math/tex; mode=display">logs</script> list onto the array. We also keep a track of the current <script type="math/tex; mode=display">time</script>. We also make use of a <script type="math/tex; mode=display">res</script> array, such that <script type="math/tex; mode=display">res[i]</script> is to keep a track of the exclusive time spent by the Fucntion with function id <script type="math/tex; mode=display">i</script> till the current time. </p>\n<p>Now, we can move on to the next function in <script type="math/tex; mode=display">logs</script>. The start/end time of the next function will obviously be larger than the start time of the function on the <script type="math/tex; mode=display">stack</script>. We keep on incrementing the current <script type="math/tex; mode=display">time</script> and the exclusive time for the function on the top of the <script type="math/tex; mode=display">stack</script> till the current time becomes equal to the start/end time of the next function in the <script type="math/tex; mode=display">logs</script> list. </p>\n<p>Thus, now, we\'ve reached a point, where the control shifts from the last function to a new function, due to a function call(indicated by a start label for the next function), or the last function could exit(indicated by the end label for the next function). Thus, we can no longer continue with the same old function. </p>\n<p>If the next function includes a start label, we push this function on the top of the <script type="math/tex; mode=display">stack</script>, since the last function would need to be revisited again in the future. On the other hand, if the next function includes an end label, it means the last function on the top of the <script type="math/tex; mode=display">stack</script> is terminating.</p>\n<p>We also know that an end label indicates that this function executes till the end of the given time. Thus, we need to increment the current <script type="math/tex; mode=display">time</script> and the exclusive time of the last function as well to account for this fact. Now, we can remove(pop) this function from the <script type="math/tex; mode=display">stack</script>.  We can continue this process for every function in the <script type="math/tex; mode=display">logs</script> list. </p>\n<p>At the end, the <script type="math/tex; mode=display">res</script> array gives the exclusive times for each function.</p>\n<p>Summarizing the above process, we need to do the following:</p>\n<ol>\n<li>\n<p>Push the function id of the first function in the <script type="math/tex; mode=display">logs</script> list on the <script type="math/tex; mode=display">stack</script>.</p>\n</li>\n<li>\n<p>Keep incrementing the exlusive time(along with the current time) corresponding to the function on the top of the <script type="math/tex; mode=display">stack</script>(in the <script type="math/tex; mode=display">res</script> array), till the current time equals the start/end time corresponding to the next function in the <script type="math/tex; mode=display">logs</script> list.</p>\n</li>\n<li>\n<p>If the next function has a \'start\' label, push this function\'s id onto the stack. Otherwise, increment the last function\'s exclusive time(along with the current time), and pop the function id from the top of the stack.</p>\n</li>\n<li>\n<p>Repeat steps 2 and 3 till all the functions in the <script type="math/tex; mode=display">logs</script> list have been considered.</p>\n</li>\n<li>\n<p>Return the resultant exlcusive time(<script type="math/tex; mode=display">res</script>).</p>\n</li>\n</ol>\n<iframe frameborder="0" height="496" name="RqRjdFmv" src="https://leetcode.com/playground/RqRjdFmv/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(t)</script>. We increment the time till all the functions are done with the execution. Here, <script type="math/tex; mode=display">t</script> refers to the end time of the last function in the <script type="math/tex; mode=display">logs</script> list.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The <script type="math/tex; mode=display">stack</script> can grow upto a depth of atmost <script type="math/tex; mode=display">n/2</script>. Here, <script type="math/tex; mode=display">n</script> refers to the number of elements in the given <script type="math/tex; mode=display">logs</script> list.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-approach-accepted">Approach #2 Better Approach [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, for every function on the top of the <script type="math/tex; mode=display">stack</script>, we incremented the current time and the exclusive time of this same function till the current time became equal to the start/end time of the next function. </p>\n<p>Instead of doing this incrementing step by step, we can directly use the difference between the next function\'s start/stop time and the current function\'s start/stop time. The rest of the process remains the same as in the last approach. </p>\n<p>The following animation illustrates the process.</p>\n<p>!?!../Documents/636_Exclusive_Time_of_Functions.json:1000,563!?!</p>\n<iframe frameborder="0" height="462" name="rZkuT7RU" src="https://leetcode.com/playground/rZkuT7RU/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We iterate over the entire <script type="math/tex; mode=display">logs</script> array just once. Here, <script type="math/tex; mode=display">n</script> refers to the number of elements in the <script type="math/tex; mode=display">logs</script> list.</p>\n</li>\n<li>\n<p>Space complexity : The <script type="math/tex; mode=display">stack</script> can grow upto a depth of atmost <script type="math/tex; mode=display">n/2</script>. Here, <script type="math/tex; mode=display">n</script> refers to the number of elements in the given <script type="math/tex; mode=display">logs</script> list.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Facebook', 'Uber'],
  },
  {
    id: '637',
    name: 'Average of Levels in Binary Tree',
    acceptance: '55.7%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n<b>Output:</b> [3, 14.5, 11]\n<b>Explanation:</b>\nThe average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The range of node's value is in the range of 32-bit signed integer.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-depth-first-search-accepted">Approach #1 Using Depth First Search [Accepted]</a></li>\n<li><a href="#approach-2-breadth-first-search-accepted">Approach #2 Breadth First Search [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-depth-first-search-accepted">Approach #1 Using Depth First Search [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>One of the methods to solve the given problem is to make use of Depth First Search. In DFS, we try to exhaust each branch of the given tree during the tree traversal before moving onto the next branch.</p>\n<p>To make use of DFS to solve the given problem, we make use of two lists <script type="math/tex; mode=display">count</script> and <script type="math/tex; mode=display">res</script>. Here, <script type="math/tex; mode=display">count[i]</script> refers to the total number of nodes found at the <script type="math/tex; mode=display">i^{th}</script> level(counting from root at level 0) till now, and <script type="math/tex; mode=display">res[i]</script> refers to the sum of the nodes at the <script type="math/tex; mode=display">i^{th}</script> level encountered till now during the Depth First Search.</p>\n<p>We make use of a function <code>average(t, i, res, count)</code>, which is used to fill the <script type="math/tex; mode=display">res</script> and <script type="math/tex; mode=display">count</script> array if we start the DFS from the node <script type="math/tex; mode=display">t</script> at the <script type="math/tex; mode=display">i^{th}</script> level in the given tree. We start by making the function call <code>average(root, 0, res, count)</code>. After this, we do the following at every step:</p>\n<ol>\n<li>\n<p>Add the value of the current node to the <script type="math/tex; mode=display">res</script>(or <script type="math/tex; mode=display">sum</script>) at the index corresponding to the current level. Also, increment the <script type="math/tex; mode=display">count</script> at the index corresponding to the current level. </p>\n</li>\n<li>\n<p>Call the same function, <code>average</code>, with the left and the right child of the current node. Also, update the current level used in making the function call.</p>\n</li>\n<li>\n<p>Repeat the above steps till all the nodes in the given tree have been considered once.</p>\n</li>\n<li>\n<p>Populate the averages in the resultant array to be returned.</p>\n</li>\n</ol>\n<p>The following animation illustrates the process.</p>\n<p>!?!../Documents/637_Avg_of_Levels_DFS.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="eyx7WogA" src="https://leetcode.com/playground/eyx7WogA/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The whole tree is traversed once only. Here, <script type="math/tex; mode=display">n</script> refers to the total number of nodes in the given binary tree.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(h)</script>. <script type="math/tex; mode=display">res</script> and <script type="math/tex; mode=display">count</script> array of size <script type="math/tex; mode=display">h</script> are used. Here, <script type="math/tex; mode=display">h</script> refers to the height(maximum number of levels) of the given binary tree. Further, the depth of the recursive tree could go upto <script type="math/tex; mode=display">h</script> only.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-breadth-first-search-accepted">Approach #2 Breadth First Search [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Another method to solve the given problem is to make use of a Breadth First Search. In BFS, we start by pushing the root node into a <script type="math/tex; mode=display">queue</script>. Then, we remove an element(node) from the front of the <script type="math/tex; mode=display">queue</script>. For every node removed from the <script type="math/tex; mode=display">queue</script>, we add all its children to the back of the same <script type="math/tex; mode=display">queue</script>. We keep on continuing this process till the <script type="math/tex; mode=display">queue</script> becomes empty. In this way, we can traverse the given tree on a level-by-level basis.</p>\n<p>But, in the current implementation, we need to do a slight modification, since we need to separate the nodes on one level from that of the other. </p>\n<p>The steps to be performed are listed below:</p>\n<ol>\n<li>\n<p>Put the root node into the <script type="math/tex; mode=display">queue</script>.</p>\n</li>\n<li>\n<p>Initialize <script type="math/tex; mode=display">sum</script> and <script type="math/tex; mode=display">count</script> as 0 and <script type="math/tex; mode=display">temp</script> as an empty queue.</p>\n</li>\n<li>\n<p>Pop a node from the front of the <script type="math/tex; mode=display">queue</script>. Add this node\'s value to the <script type="math/tex; mode=display">sum</script> corresponding to the current level. Also, update the <script type="math/tex; mode=display">count</script> corresponding to the current level.</p>\n</li>\n<li>\n<p>Put the children nodes of the node last popped into the a <script type="math/tex; mode=display">temp</script> queue(instead of <script type="math/tex; mode=display">queue</script>).</p>\n</li>\n<li>\n<p>Continue steps 3 and 4 till <script type="math/tex; mode=display">queue</script> becomes empty. (An empty <script type="math/tex; mode=display">queue</script> indicates that one level of the tree has been considered).</p>\n</li>\n<li>\n<p>Reinitialize <script type="math/tex; mode=display">queue</script> with its value as <script type="math/tex; mode=display">temp</script>.</p>\n</li>\n<li>\n<p>Populate the <script type="math/tex; mode=display">res</script> array with the average corresponding to the current level.</p>\n</li>\n<li>\n<p>Repeat steps 2 to 7 till the <script type="math/tex; mode=display">queue</script> and <script type="math/tex; mode=display">temp</script> become empty.</p>\n</li>\n</ol>\n<p>At the end, <script type="math/tex; mode=display">res</script> is the required result.</p>\n<p>The following animation illustrates the process.</p>\n<p>!?!../Documents/637_Average_Of_Levels.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="92XSTJqk" src="https://leetcode.com/playground/92XSTJqk/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The whole tree is traversed atmost once. Here, <script type="math/tex; mode=display">n</script> refers to the number of nodes in the given binary tree.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(m)</script>. The size of <script type="math/tex; mode=display">queue</script> or <script type="math/tex; mode=display">temp</script> can grow upto atmost the maximum number of nodes at any level in the given binary tree. Here, <script type="math/tex; mode=display">m</script> refers to the maximum mumber of nodes at any level in the input tree.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '638',
    name: 'Shopping Offers',
    acceptance: '43.6%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nIn LeetCode Store, there are some kinds of items to sell. Each item has a price.\n</p>\n\n<p>\nHowever, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.\n</p>\n\n<p>\nYou are given the each item's price, a set of special offers, and the number we need to buy for each item.\nThe job is to output the lowest price you have to pay for <b>exactly</b> certain items as given, where you could make optimal use of the special offers.\n</p>\n\n<p>\nEach special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.\n</p>\n\n<p>You could use any of special offers as many times as you want.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [2,5], [[3,0,5],[1,2,10]], [3,2]\n<b>Output:</b> 14\n<b>Explanation:</b> \nThere are two kinds of items, A and B. Their prices are $2 and $5 respectively. \nIn special offer 1, you can pay $5 for 3A and 0B\nIn special offer 2, you can pay $10 for 1A and 2B. \nYou need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]\n<b>Output:</b> 11\n<b>Explanation:</b> \nThe price of A is $2, and $3 for B, $4 for C. \nYou may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. \nYou need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. \nYou cannot add more items, though only $9 for 2A ,2B and 1C.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>There are at most 6 kinds of items, 100 special offers.</li>\n<li>For each item, you need to buy at most 6 of them.</li>\n<li>You are <b>not</b> allowed to buy more items than you want, even if that would lower the overall price.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</a></li>\n<li><a href="#approach-2-using-recursion-with-memoization-accepted">Approach #2 Using Recursion with memoization [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-recursion-accepted">Approach #1 Using Recursion [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Before discussing the steps involved in the process, we need to note a few points. Firstly, whenever an offer is used from amongst the ones available in the <script type="math/tex; mode=display">special</script> list, we need to update the <script type="math/tex; mode=display">needs</script> appropriately, such that the number of items in the current offer of each type are deducted from the ones in the corresponding entry in <script type="math/tex; mode=display">needs</script>.</p>\n<p>Further, an offer can be used only if the number of items, of each type, required for using the offer, is lesser than or equal to the ones available in the current <script type="math/tex; mode=display">needs</script>. </p>\n<p>Now, let\'s discuss the algorithm. We make use of a <code>shopping(price,special,needs)</code> function, which takes the <script type="math/tex; mode=display">price</script> and <script type="math/tex; mode=display">special</script> list along with the current(updated) <script type="math/tex; mode=display">needs</script> as the input and returns the minimum cost of buying these items as required by this <script type="math/tex; mode=display">needs</script> list. </p>\n<p>In every call of the function <code>shopping(price,special,needs)</code>, we do as follows:</p>\n<ol>\n<li>\n<p>Determine the cost of buying items as per the <script type="math/tex; mode=display">needs</script> array, without applying any offer. Store the result in <script type="math/tex; mode=display">res</script>.</p>\n</li>\n<li>\n<p>Iterate over every offer in the <script type="math/tex; mode=display">special</script> list. For every offer chosen, repeat steps 3 to 5.</p>\n</li>\n<li>\n<p>Create a copy of the current <script type="math/tex; mode=display">needs</script> in a <script type="math/tex; mode=display">clone</script> list(so that the original needs can be used again, while selecting the next offer).</p>\n</li>\n<li>\n<p>Try to apply the current offer. If possible, update the required number of items in <script type="math/tex; mode=display">clone</script>.</p>\n</li>\n<li>\n<p>If the current offer could be applied, find the minimum cost out of <script type="math/tex; mode=display">res</script> and <script type="math/tex; mode=display">offer_\\current</script> + <code>shopping(price,special,clone)</code>. Here, <script type="math/tex; mode=display">offer_\\current</script> refers to the price that needs to be paid for the current offer. Update the <script type="math/tex; mode=display">res</script> with the minimum value.</p>\n</li>\n<li>\n<p>Return the <script type="math/tex; mode=display">res</script> corresponding to the minimum cost.</p>\n</li>\n</ol>\n<p>We need to note that the <script type="math/tex; mode=display">clone</script> needs to be updated afresh from <script type="math/tex; mode=display">needs</script>(coming to the current function call) when we choose a new offer. This needs to be done, because solely applying the next offer could result in a lesser cost than the one resulting by using the previous offer first.</p>\n<iframe frameborder="0" height="515" name="b6RfW7x4" src="https://leetcode.com/playground/b6RfW7x4/shared" width="100%"></iframe>\n<hr>\n<h4 id="approach-2-using-recursion-with-memoization-accepted">Approach #2 Using Recursion with memoization [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we can observe that the same <script type="math/tex; mode=display">needs</script> can be reached by applying the offers in various orders. e.g. We can choose the first offer followed by the second offer or vice-versa. But, both lead to the same requirement of updated <script type="math/tex; mode=display">needs</script> and the cost as well. Thus, instead of repeating the whole process for the same <script type="math/tex; mode=display">needs</script> state through various recursive paths, we can create an entry corresponding to the current set of <script type="math/tex; mode=display">needs</script> in a HashMap, <script type="math/tex; mode=display">map</script>, which stores the minimum cost corresponding to this set of <script type="math/tex; mode=display">needs</script>. Thus, whenever the same call is made again in the future through a different path, we need not repeat the whole process over, and we can directly return the result stored in the <script type="math/tex; mode=display">map</script>.</p>\n<iframe frameborder="0" height="515" name="aPHtk8QK" src="https://leetcode.com/playground/aPHtk8QK/shared" width="100%"></iframe>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '639',
    name: 'Decode Ways II',
    acceptance: '24.4%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nA message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping way:\n</p>\n\n<pre>\'A\' -&gt; 1\n\'B\' -&gt; 2\n...\n\'Z\' -&gt; 26\n</pre>\n\n<p>\nBeyond that, now the encoded string can also contain the character \'*\', which can be treated as one of the numbers from 1 to 9.\n</p>\n\n\n<p>\nGiven the encoded message containing digits and the character \'*\', return the total number of ways to decode it.\n</p>\n\n<p>\nAlso, since the answer may be very large, you should return the output mod 10<sup>9</sup> + 7.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "*"\n<b>Output:</b> 9\n<b>Explanation:</b> The encoded message can be decoded to the string: "A", "B", "C", "D", "E", "F", "G", "H", "I".\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> "1*"\n<b>Output:</b> 9 + 9 = 18\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The length of the input string will fit in range [1, 10<sup>5</sup>].</li>\n<li>The input string will only contain the character \'*\' and digits \'0\' - \'9\'.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-recursion-with-memoization-stack-overflow">Approach #1 Using Recursion with memoization [Stack Overflow]</a></li>\n<li><a href="#approach-2-dynamic-programming-accepted">Approach #2 Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-3-constant-space-dynamic-programming-accepted">Approach #3 Constant Space Dynamic Programming [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-recursion-with-memoization-stack-overflow">Approach #1 Using Recursion with memoization [Stack Overflow]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In order to find the solution to the given problem, we need to consider every case possible(for the arrangement of the input digits/characters)\n and what value needs to be considered for each case. Let\'s look at each of the possibilites one by one.</p>\n<p>Firstly, let\'s assume, we have a function <code>ways(s,i)</code> which returns the number of ways to decode the input string <script type="math/tex; mode=display">s</script>, if only the characters upto the \n<script type="math/tex; mode=display">i^{th}</script> index in this string are considered. We start off by calling the function <code>ways(s, s.length()-1)</code> i.e. by considering the full length of this string <script type="math/tex; mode=display">s</script>.</p>\n<p>We started by using the last index of the string <script type="math/tex; mode=display">s</script>. Suppose, currently, we called the function as <code>ways(s,i)</code>. Let\'s look at how we proceed. At every step, we need \nto look at the current character at the last index (<script type="math/tex; mode=display">i</script>) and we need to determine the number of ways of decoding that using this <script type="math/tex; mode=display">i^{th}</script> character could \nadd to the total value. There are the following possiblities for the <script type="math/tex; mode=display">i^{th}</script> character.</p>\n<p>The <script type="math/tex; mode=display">i^{th}</script> character could be  a <code>*</code>. In this case, firstly, we can see that this <code>*</code> could be decoded into any of the digits from <code>1-9</code>. Thus, for every decoding possible \nupto the index <script type="math/tex; mode=display">i-1</script>, this <code>*</code> could be replaced by any of these digits(<code>1-9</code>). Thus, the total number of decodings is 9 times the number of decodings possible \nfor the same string upto the index <script type="math/tex; mode=display">i-1</script>. Thus, this <code>*</code> initially adds a factor of <code>9*ways(s,i-1)</code> to the total value. </p>\n<p align="center"><img alt="Decode_Ways" src="https://leetcode.com/articles/Figures/639/639_Decode_Ways2.png"></p>\n<p>Apart from this, this <code>*</code> at the <script type="math/tex; mode=display">i^{th}</script> index could also contribute further to the total number of ways depending upon the character/digit at its preceding\n index. If the preceding character happens to be a <code>1</code>, by combining this <code>1</code> with the current <code>*</code>, we could obtain any of the digits from <code>11-19</code> which could be decoded\n into any of the characters from <code>K-S</code>. We need to note that these decodings are in addition to the ones already obtained above by considering only a single current \n <code>*</code>(<code>1-9</code> decoding to <code>A-J</code>). Thus, this <code>1*</code> pair could be replaced by any of the numbers from <code>11-19</code> irrespective of the decodings done for the previous \n indices(before <script type="math/tex; mode=display">i-1</script>). Thus, this <code>1*</code> pair leads to 8 times the number of decodings possible with the string <script type="math/tex; mode=display">s</script> upto the index <script type="math/tex; mode=display">i-2</script>. Thus, this adds\n a factor of <code>9 * ways(s, i - 2)</code> to the total number of decodings. </p>\n<p>Similarly, a <code>2*</code> pair obtained by a <code>2</code> at the index <script type="math/tex; mode=display">i-1</script> could be considered of the numbers from <code>21-26</code>(decoding into <code>U-Z</code>), adding a total of 6 times the \n number of decodings possible upto the index <script type="math/tex; mode=display">i-2</script>. </p>\n<p align="center"><img alt="Decode_Ways" src="https://leetcode.com/articles/Figures/639/639_Decode_Ways3.PNG"></p>\n<p>On the same basis, if the character at the index <script type="math/tex; mode=display">i-1</script> happens to be another <code>*</code>, this <code>**</code> pairing could be considered as \n any of the numbers from <code>11-19</code>(9) and <code>21-26</code>(6). Thus, the total number of decodings will be 15(9+6) times  the number of decodings possible upto the index <script type="math/tex; mode=display">i-2</script>.</p>\n<p>Now, if the <script type="math/tex; mode=display">i^{th}</script> character could be a digit from <code>1-9</code> as well. In this case, the number of decodings that considering this single digit can \n contribute to the total number is equal to the number of decodings that can be contributed by the digits upto the index <script type="math/tex; mode=display">i-1</script>. But, if the <script type="math/tex; mode=display">i^{th}</script> character is<br>\n a <code>0</code>, this <code>0</code> alone can\'t contribute anything to the total number of decodings(but it can only contribute if the digit preceding it is a <code>1</code> or <code>2</code>. We\'ll consider this case below).<br></p>\n<p>Apart from the value obtained(just above) for the digit at the <script type="math/tex; mode=display">i^{th}</script> index being anyone from <code>0-9</code>, this digit could also pair with the digit at the \n preceding index, contributing a value dependent on the previous digit. If the previous digit happens to be a <code>1</code>, this <code>1</code> can combine with any of the current \ndigits forming a valid number in the range <code>10-19</code>. Thus, in this case, we can consider a pair formed by the current and the preceding digit, and, the number of \ndecodings possible by considering the decoded character to be a one formed using this pair, is equal to the total number of decodings possible by using the digits \nupto the index <script type="math/tex; mode=display">i-2</script> only. </p>\n<p>But, if the previous digit is a <code>2</code>, a valid number for decoding could only be a one from the range <code>20-26</code>. Thus, if the current digit is lesser than 7, again\nthis pairing could add decodings with count equal to the ones possible by using the digits upto the <script type="math/tex; mode=display">(i-2)^{th}</script> index only.</p>\n<p>Further, if the previous digit happens to be a <code>*</code>, the additional number of decodings depend on the current digit again i.e. If the current digit is greater than \n<code>6</code>, this <code>*</code> could lead to pairings only in the range <code>17-19</code>(<code>*</code> can\'t be replaced by <code>2</code> leading to <code>27-29</code>). Thus, additional decodings with count equal to the\ndecodings possible upto the index <script type="math/tex; mode=display">i-2</script>. </p>\n<p>On the other hand, if the current digit is lesser than 7, this <code>*</code> could be replaced by either a <code>1</code> or a <code>2</code> leading to the \ndecodings <code>10-16</code> and <code>20-26</code> respectively. Thus, the total number of decodings possible by considering this pair is equal to twice the number of decodings possible upto the \nindex <script type="math/tex; mode=display">i-2</script>(since <code>*</code> can now be replaced by two values).</p>\n<p>This way, by considering every possible case, we can obtain the required number of decodings by making use of the recursive function <code>ways</code> as and where necessary.</p>\n<p>By making use of memoization, we can reduce the time complexity owing to duplicate function calls.</p>\n<iframe frameborder="0" height="515" name="nVkrWZRc" src="https://leetcode.com/playground/nVkrWZRc/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Size of recursion tree can go upto <script type="math/tex; mode=display">n</script>, since <script type="math/tex; mode=display">memo</script> array is filled exactly once. Here, <script type="math/tex; mode=display">n</script> refers to the length of the input \nstring.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of recursion tree can go upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-dynamic-programming-accepted">Approach #2 Dynamic Programming [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>From the solutions discussed above, we can observe that the number of decodings possible upto any index, <script type="math/tex; mode=display">i</script>, is dependent only on the characters upto the \nindex <script type="math/tex; mode=display">i</script> and not on any of the characters following it. This leads us to the idea that this problem can be solved by making use of Dynamic Programming.</p>\n<p>We can also easily observe from the recursive solution that, the number of decodings possible upto the index <script type="math/tex; mode=display">i</script> can be determined easily if we know \nthe number of decodings possible upto the index <script type="math/tex; mode=display">i-1</script> and <script type="math/tex; mode=display">i-2</script>. Thus, we fill in the <script type="math/tex; mode=display">dp</script> array in a forward manner. <script type="math/tex; mode=display">dp[i]</script> is used to store the \nnumber of decodings possible by considering the characters in the given string <script type="math/tex; mode=display">s</script> upto the <script type="math/tex; mode=display">(i-1)^{th}</script> index only(including it).</p>\n<p>The equations for filling this <script type="math/tex; mode=display">dp</script> at any step again depend on the current character and the just preceding character. These equations are similar \nto the ones used in the recursive solution.</p>\n<p>The following animation illustrates the process of filling the <script type="math/tex; mode=display">dp</script> for a simple example.</p>\n<p>!?!../Documents/639_Decode_Ways_II.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="YDp8Hs74" src="https://leetcode.com/playground/YDp8Hs74/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n+1</script> is filled once only. Here, <script type="math/tex; mode=display">n</script> refers to the length of the input string.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">dp</script> array of size <script type="math/tex; mode=display">n+1</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-constant-space-dynamic-programming-accepted">Approach #3 Constant Space Dynamic Programming [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we can observe that only the last two values <script type="math/tex; mode=display">dp[i-2]</script> and <script type="math/tex; mode=display">dp[i-1]</script> are used to fill the entry at <script type="math/tex; mode=display">dp[i-1]</script>. We can save some \nspace in the last approach, if instead of maintaining a whole <script type="math/tex; mode=display">dp</script> array of length <script type="math/tex; mode=display">n</script>, we keep a track of only the required last two values. The rest of the \nprocess remains the same as in the last approach.</p>\n<iframe frameborder="0" height="515" name="5K3aiDQd" src="https://leetcode.com/playground/5K3aiDQd/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Single loop upto <script type="math/tex; mode=display">n</script> is required to find the required result. Here, <script type="math/tex; mode=display">n</script> refers to the length of the input string <script type="math/tex; mode=display">s</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '640',
    name: 'Solve the Equation',
    acceptance: '38.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nSolve a given equation and return the value of <code>x</code> in the form of string "x=#value". The equation contains only \'+\', \'-\' operation, the variable <code>x</code> and its coefficient.\n</p>\n\n<p>\nIf there is no solution for the equation, return "No solution".\n</p>\n<p>\nIf there are infinite solutions for the equation, return "Infinite solutions".\n</p>\n<p>\nIf there is exactly one solution for the equation, we ensure that the value of <code>x</code> is an integer.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "x+5-3+x=6+x-2"\n<b>Output:</b> "x=2"\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> "x=x"\n<b>Output:</b> "Infinite solutions"\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> "2x=x"\n<b>Output:</b> "x=0"\n</pre>\n<p></p>\n\n<p><b>Example 4:</b><br>\n</p><pre><b>Input:</b> "2x+3x-6x=x+2"\n<b>Output:</b> "x=-1"\n</pre>\n<p></p>\n\n<p><b>Example 5:</b><br>\n</p><pre><b>Input:</b> "x=x+2"\n<b>Output:</b> "No solution"\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-partioning-coefficients-accepted">Approach #1 Partioning Coefficients [Accepted]</a></li>\n<li><a href="#approach-2-using-regex-for-spliting-accepted">Approach #2 Using regex for spliting [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-partioning-coefficients-accepted">Approach #1 Partioning Coefficients [Accepted]</h4>\n<p>In the current approach, we start by splitting the given <script type="math/tex; mode=display">equation</script> based on <code>=</code> sign. This way, we\'ve separated the left and right hand side of this equation. Once this is done, we need to extract the individual elements(i.e. <code>x</code>\'s and the numbers) from both sides of the equation. To do so, we make use of <code>breakIt</code> function, in which we traverse over the given equation(either left hand side or right hand side), and put the separated parts into an array. </p>\n<p>Now, the idea is as follows. We treat the given equation as if we\'re bringing all the <code>x</code>\'s on the left hand side and all the rest of the numbers on the right hand side as done below for an example.</p>\n<p><code>x+5-3+x=6+x-2</code></p>\n<p><code>x+x-x=6-2-5+3</code></p>\n<p>Thus, every <code>x</code> in the left hand side of the given equation is treated as positive, while that on the right hand side is treated as negative, in the current implementation. </p>\n<p>Likewise, every number on the left hand side is treated as negative, while that on the right hand side is treated as positive. Thus, by doing so, we obtain all the <code>x</code>\'s in the new <script type="math/tex; mode=display">lhs</script> and all the numbers in the new <script type="math/tex; mode=display">rhs</script> of the original equation. </p>\n<p>Further, in case of an <code>x</code>, we also need to find its corresponding coefficients in order to evaluate the final effective coefficient of <code>x</code> on the left hand side. We also evaluate the final effective number on the right hand side as well.</p>\n<p>Now, in case of a unique solution, the ratio of the effective <script type="math/tex; mode=display">rhs</script> and <script type="math/tex; mode=display">lhs</script> gives the required result. In case of infinite solutions, both the effective <script type="math/tex; mode=display">lhs</script> and <script type="math/tex; mode=display">rhs</script> turns out to be zero e.g. <code>x+1=x+1</code>. In case of no solution, the coefficient of <code>x</code>(<script type="math/tex; mode=display">lhs</script>) turns out to be zero, but the effective number on the <script type="math/tex; mode=display">rhs</script> is non-zero.</p>\n<iframe frameborder="0" height="515" name="5qsPscf9" src="https://leetcode.com/playground/5qsPscf9/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Generating coefficients and findinn <script type="math/tex; mode=display">lhs</script> and <script type="math/tex; mode=display">rhs</script> will take <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. ArrayList <script type="math/tex; mode=display">res</script> size can grow upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-regex-for-spliting-accepted">Approach #2 Using regex for spliting [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we made use of a new function <code>breakIt</code> to obtain the individual components of either the left hand side or the right hand side. Instead of doing so, we can also make use of splitting based on <code>+</code> or <code>-</code> sign, to obtain the individual elements. The rest of the process remains the same as in the last approach. </p>\n<p>In order to do the splitting, we make use of an expression derived from regular expressions(regex). Simply speaking, regex is a functionality used to match a target string based on some given criteria. The ?=n quantifier, in regex, matches any string that is followed by a specific string <script type="math/tex; mode=display">n</script>. What it\'s saying is that the captured match must be followed by <script type="math/tex; mode=display">n</script> but the <script type="math/tex; mode=display">n</script> itself isn\'t captured.</p>\n<p>By making use of this kind of expression in the <code>split</code> functionality, we make sure that the partitions are obtained such that the <code>+</code> or <code>-</code> sign remains along with the parts(numbers or coefficients) even after the splitting.</p>\n<iframe frameborder="0" height="515" name="9JbHjYgz" src="https://leetcode.com/playground/9JbHjYgz/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Generating coefficients and finding <script type="math/tex; mode=display">lhs</script> and <script type="math/tex; mode=display">rhs</script> will take <script type="math/tex; mode=display">O(n)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. ArrayList <script type="math/tex; mode=display">res</script> size can grow upto <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '642',
    name: 'Design Search Autocomplete System ',
    acceptance: '31.0%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character <code>\'#\'</code>). For <b>each character</b> they type <b>except \'#\'</b>, you need to return the <b>top 3</b> historical hot sentences that have prefix the same as the part of sentence already typed. Here are the specific rules:</p>\n<ol>\n<li>The hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before. </li>\n<li>The returned top 3 hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same degree of hot, you need to use ASCII-code order (smaller one appears first). </li>\n<li>If less than 3 hot sentences exist, then just return as many as you can.</li>\n<li>When the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.</li>\n</ol>\n\n<p>Your job is to implement the following functions:</p>\n\n<p>The constructor function:</p>\n\n<p><code>AutocompleteSystem(String[] sentences, int[] times):</code> This is the constructor. The input is <b>historical data</b>. <code>Sentences</code> is a string array consists of previously typed sentences. <code>Times</code> is the corresponding times a sentence has been typed. Your system should record these historical data.</p>\n\n<p>Now, the user wants to input a new sentence. The following function will provide the next character the user types: </p>\n\n<p><code>List&lt;String&gt; input(char c):</code> The input <code>c</code> is the next character typed by the user. The character will only be lower-case letters (<code>\'a\'</code> to <code>\'z\'</code>), blank space (<code>\' \'</code>) or a special character (<code>\'#\'</code>). Also, the previously typed sentence should be recorded in your system. The output will be the <b>top 3</b> historical hot sentences that have prefix the same as the part of sentence already typed.</p>\n\n<br>\n<p><b>Example:</b><br>\n\n<b>Operation:</b> AutocompleteSystem(["i love you", "island","ironman", "i love leetcode"], [5,3,2,2])\n<br>\nThe system have already tracked down the following sentences and their corresponding times:\n<br>\n<code>"i love you"</code> : <code>5</code> times\n<br>\n<code>"island"</code> : <code>3</code> times\n<br>\n<code>"ironman"</code> : <code>2</code> times\n<br>\n<code>"i love leetcode"</code> : <code>2</code> times\n<br>\nNow, the user begins another search:\n<br><br>\n<b>Operation:</b> input(\'i\')\n<br>\n<b>Output:</b> ["i love you", "island","i love leetcode"]\n<br>\n<b>Explanation:</b> \n<br>\nThere are four sentences that have prefix <code>"i"</code>. Among them, "ironman" and "i love leetcode" have same hot degree. Since <code>\' \'</code> has ASCII code 32 and <code>\'r\'</code> has ASCII code 114, "i love leetcode" should be in front of "ironman". Also we only need to output top 3 hot sentences, so "ironman" will be ignored.\n<br><br>\n<b>Operation:</b> input(\' \')\n<br>\n<b>Output:</b> ["i love you","i love leetcode"]\n<br>\n<b>Explanation:</b> \n<br>\nThere are only two sentences that have prefix <code>"i "</code>.\n<br><br>\n<b>Operation:</b> input(\'a\')\n<br>\n<b>Output:</b> []\n<br>\n<b>Explanation:</b> \n<br>\nThere are no sentences that have prefix <code>"i a"</code>.\n<br><br>\n<b>Operation:</b> input(\'#\')\n<br>\n<b>Output:</b> []\n<br>\n<b>Explanation:</b> \n<br>\nThe user finished the input, the sentence <code>"i a"</code> should be saved as a historical sentence in system. And the following input will be counted as a new search.\n<br>\n\n</p>\n<br>\n<p><b>Note:</b><br>\n\n</p><ol>\n\n<li>The input sentence will always start with a letter and end with \'#\', and only one blank space will exist between two words. </li>\n<li>The number of <b>complete sentences</b> that to be searched won\'t exceed 100. The length of each sentence including those in the historical data won\'t exceed 100. </li>\n<li>Please use double-quote instead of single-quote when you write test cases even for a character input.</li>\n<li>Please remember to <b>RESET</b> your class variables declared in class AutocompleteSystem, as static/class variables are <b>persisted across multiple test cases</b>. Please see <a href="https://leetcode.com/faq/#different-output">here</a> for more details.</li>\n</ol>\n\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-one-level-indexingaccepted">Approach #2 Using One level Indexing[Accepted]</a></li>\n<li><a href="#approach-3-using-trieaccepted">Approach #3 Using Trie[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>In this solution, we make use of a HashMap <script type="math/tex; mode=display">map</script> which stores entries in the form <script type="math/tex; mode=display">(sentence_i, times_i)</script>. Here, <script type="math/tex; mode=display">times_i</script> refers to the number of times the <script type="math/tex; mode=display">sentence_i</script> has been typed earlier.</p>\n<p><code>AutocompleteSystem</code>: We pick up each sentence from <script type="math/tex; mode=display">sentences</script> and their corresponding times from the <script type="math/tex; mode=display">times</script>, and make their entries in the <script type="math/tex; mode=display">map</script> appropriately.</p>\n<p><code>input(c)</code>: We make use of a current sentence tracker variable, <script type="math/tex; mode=display">cur_sen</script>, which is used to store the sentence entered till now as the input. For <script type="math/tex; mode=display">c</script> as the current input, firstly, we append this <script type="math/tex; mode=display">c</script> to <script type="math/tex; mode=display">cur_sen</script> and then iterate over all the keys of <script type="math/tex; mode=display">map</script> to check if a key exists whose initial characters match with <script type="math/tex; mode=display">cur_sen</script>. We add all such keys to a <script type="math/tex; mode=display">list</script>. Then, we sort this <script type="math/tex; mode=display">list</script> as per our requirements, and obtain the first three values from this <script type="math/tex; mode=display">list</script>.</p>\n<iframe frameborder="0" height="515" name="aHjFCN7k" src="https://leetcode.com/playground/aHjFCN7k/shared" width="100%"></iframe>\n<p><strong>Performance Analysis</strong></p>\n<ul>\n<li>\n<p><code>AutocompleteSystem()</code> takes <script type="math/tex; mode=display">O(k*l)</script> time. This is because, putting an entry in a hashMap takes <script type="math/tex; mode=display">O(1)</script> time. But, to create a hash value for a sentence of average length <script type="math/tex; mode=display">k</script>, it will be scanned atleast once. We need to put <script type="math/tex; mode=display">l</script> such entries in the <script type="math/tex; mode=display">map</script>.</p>\n</li>\n<li>\n<p><code>input()</code> takes <script type="math/tex; mode=display">O\\big(n+mlog(m)\\big)</script> time. We need to iterate over the list of sentences, in <script type="math/tex; mode=display">map</script>, entered till now(say with a count <script type="math/tex; mode=display">n</script>), taking <script type="math/tex; mode=display">O(n)</script> time, to populate the <script type="math/tex; mode=display">list</script> used for finding the hot sentences. Then, we need to sort the <script type="math/tex; mode=display">list</script> of length <script type="math/tex; mode=display">m</script>, taking <script type="math/tex; mode=display">O\\big(mlog(m)\\big)</script> time.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-one-level-indexingaccepted">Approach #2 Using One level Indexing[Accepted]</h4>\n<p>This method is almost the same as that of the last approach except that instead of making use of simply a HashMap to store the sentences along with their number of occurences, we make use of a Two level HashMap. </p>\n<p>Thus, we make use of an array <script type="math/tex; mode=display">arr</script> of HashMapsEach element of this array, <script type="math/tex; mode=display">arr</script>, is used to refer to one of the alphabets possible. Each element is a HashMap itself, which stores the sentences and their number of occurences similar to the last approach. e.g. <script type="math/tex; mode=display">arr[0]</script> is used to refer to a HashMap which stores the sentences starting with an \'a\'. </p>\n<p>The process of adding the data in <code>AutocompleteSystem</code> and retrieving the data remains the same as in the last approach, except the one level indexing using <script type="math/tex; mode=display">arr</script> which needs to be done prior to accessing the required HashMap.</p>\n<iframe frameborder="0" height="515" name="PWdCczhB" src="https://leetcode.com/playground/PWdCczhB/shared" width="100%"></iframe>\n<p><strong>Performance Analysis</strong></p>\n<ul>\n<li>\n<p><code>AutocompleteSystem()</code> takes <script type="math/tex; mode=display">O(k*l+26)</script> time. Putting an entry in a hashMap takes <script type="math/tex; mode=display">O(1)</script> time. But, to create a hash value for a sentence of average length <script type="math/tex; mode=display">k</script>, it will be scanned atleast once. We need to put <script type="math/tex; mode=display">l</script> such entries in the <script type="math/tex; mode=display">map</script>.</p>\n</li>\n<li>\n<p><code>input()</code> takes <script type="math/tex; mode=display">O\\big(s+mlog(m)\\big)</script> time. We need to iterate only over one hashmap corresponding to the sentences starting with the first character of the current sentence, to populate the <script type="math/tex; mode=display">list</script> for finding the hot sentences. Here, <script type="math/tex; mode=display">s</script> refers to the size of this corresponding hashmap. Then, we need to sort the <script type="math/tex; mode=display">list</script> of length <script type="math/tex; mode=display">m</script>, taking <script type="math/tex; mode=display">O\\big(mlog(m)\\big)</script> time.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-trieaccepted">Approach #3 Using Trie[Accepted]</h4>\n<p>A Trie is a special data structure used to store strings that can be visualized like a tree. It consists of nodes and edges. Each node consists of at max 26 children and edges connect each parent node to its children. These 26 pointers are nothing but pointers for each of the 26 letters of the English alphabet A separate edge is maintained for every edge.</p>\n<p>Strings are stored in a top to bottom manner on the basis of their prefix in a trie. All prefixes of length 1 are stored at until level 1, all prefixes of length 2 are sorted at until level 2 and so on. </p>\n<p>A Trie data structure is very commonly used for representing the words stored in a dictionary. Each level represents one character of the word being formed. A word available in the dictionary can be read off from the Trie by starting from the root and going till the leaf. </p>\n<p>By doing a small modification to this structure, we can also include an entry, <script type="math/tex; mode=display">times</script>, for the number of times the current word has been previously typed. This entry can be stored in the leaf node corresponding to the particular word.</p>\n<p>Now, for implementing the <code>AutoComplete</code> function, we need to consider each character of the every word given in <script type="math/tex; mode=display">sentences</script> array, and add an entry corresponding to each such character at one level of the trie. At the leaf node of every word, we can update the <script type="math/tex; mode=display">times</script> section of the node with the corresponding number of times this word has been typed. </p>\n<p>The following figure shows a trie structure for the words  "A","to", "tea", "ted", "ten", "i", "in", and "inn", occuring 15, 7, 3, 4, 12, 11, 5 and 9 times respectively.</p>\n<p><img alt="Trie" src="https://leetcode.com/articles/Figures/642/642_Trie.PNG"></p>\n<p>Similarly, to implement the <code>input(c)</code> function, for every input character <script type="math/tex; mode=display">c</script>, we need to add this character to the word being formed currently, i.e. to <script type="math/tex; mode=display">cur_sent</script>. Then, we need to traverse in the current trie till all the characters in the current word, <script type="math/tex; mode=display">cur_sent</script>, have been exhausted. </p>\n<p>From this point onwards, we traverse all the branches possible in the Trie, put the sentences/words formed by these branches to a <script type="math/tex; mode=display">list</script> along with their corresponding number of occurences, and find the best 3 out of them similar to the last approach. The following animation shows a typical illustration.</p>\n<p>!?!../Documents/642_Design_Autocomplete.json:1000,563!?!</p>\n<iframe frameborder="0" height="515" name="AEzkJpCD" src="https://leetcode.com/playground/AEzkJpCD/shared" width="100%"></iframe>\n<p><strong>Performance Analysis</strong></p>\n<ul>\n<li>\n<p><code>AutocompleteSystem()</code> takes <script type="math/tex; mode=display">O(k*l)</script> time. We need to iterate over <script type="math/tex; mode=display">l</script> sentences each of average length <script type="math/tex; mode=display">k</script>, to create the trie for the given set of <script type="math/tex; mode=display">sentences</script>.</p>\n</li>\n<li>\n<p><code>input()</code> takes <script type="math/tex; mode=display">O\\big(p+q+mlog(m)\\big)</script> time. Here, <script type="math/tex; mode=display">p</script> refers to the length of the sentence formed till now, <script type="math/tex; mode=display">cur_sen</script>. <script type="math/tex; mode=display">q</script> refers to the number of nodes in the trie considering the sentence formed till now as the root node. Again, we need to sort the <script type="math/tex; mode=display">list</script> of length <script type="math/tex; mode=display">m</script> indicating the options available for the hot sentences, which takes <script type="math/tex; mode=display">O\\big(mlog(m)\\big)</script> time.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Facebook', 'Microsoft'],
  },
  {
    id: '643',
    name: 'Maximum Average Subarray I',
    acceptance: '37.8%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array consisting of <code>n</code> integers, find the contiguous subarray of given length <code>k</code> that has the maximum average value. And you need to output the maximum average value.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,12,-5,-6,50,3], k = 4\n<b>Output:</b> 12.75\n<b>Explanation:</b> Maximum average is (12-5-6+50)/4 = 51/4 = 12.75\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>1 &lt;= <code>k</code> &lt;= <code>n</code> &lt;= 30,000.</li>\n<li>Elements of the given array will be in the range [-10,000, 10,000].</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-cumulative-sum-accepted">Approach #1 Cumulative Sum [Accepted]</a></li>\n<li><a href="#approach-2-sliding-window-accepted">Approach #2 Sliding Window [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-cumulative-sum-accepted">Approach #1 Cumulative Sum [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We know that in order to obtain the averages of subarrays with length <script type="math/tex; mode=display">k</script>, we need to obtain the sum of these <script type="math/tex; mode=display">k</script> length subarrays. One of the methods of obtaining this sum is to make use of a cumulative sum array, <script type="math/tex; mode=display">sum</script>, which is populated only once. Here, <script type="math/tex; mode=display">sum[i]</script> is used to store the sum of the elements of the given <script type="math/tex; mode=display">nums</script> array from the first element upto the element at the <script type="math/tex; mode=display">i^{th}</script> index.</p>\n<p>Once the <script type="math/tex; mode=display">sum</script> array has been filled up, in order to find the sum of elements from the index <script type="math/tex; mode=display">i</script> to <script type="math/tex; mode=display">i+k</script>, all we need to do is to use: <script type="math/tex; mode=display">sum[i] - sum[i-k]</script>. Thus, now, by doing one more iteration over the <script type="math/tex; mode=display">sum</script> array, we can determine the maximum average possible from the subarrays of length <script type="math/tex; mode=display">k</script>.</p>\n<p>The following animation illustrates the process for a simple example.</p>\n<p>!?!../Documents/643_Maximum_Average.json:1000,563!?!</p>\n<iframe frameborder="0" height="275" name="dJyoFWQo" src="https://leetcode.com/playground/dJyoFWQo/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We iterate over the <script type="math/tex; mode=display">nums</script> array of length <script type="math/tex; mode=display">n</script> once to fill the <script type="math/tex; mode=display">sum</script> array. Then, we iterate over <script type="math/tex; mode=display">n-k</script> elements of <script type="math/tex; mode=display">sum</script> to determine the required result.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. We make use of a <script type="math/tex; mode=display">sum</script> array of length <script type="math/tex; mode=display">n</script> to store the cumulative sum.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-sliding-window-accepted">Approach #2 Sliding Window [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Instead of creating a cumulative sum array first, and then traversing over it to determine the required sum, we can simply traverse over <script type="math/tex; mode=display">nums</script> just once, and on the go keep on determining the sums possible for the subarrays of length <script type="math/tex; mode=display">k</script>. To understand the idea, assume that we already know the sum of elements from index <script type="math/tex; mode=display">i</script> to index <script type="math/tex; mode=display">i+k</script>, say it is <script type="math/tex; mode=display">x</script>.</p>\n<p>Now, to determine the sum of elements from the index <script type="math/tex; mode=display">i+1</script> to the index <script type="math/tex; mode=display">i+k+1</script>, all we need to do is to subtract the element <script type="math/tex; mode=display">nums[i]</script> from <script type="math/tex; mode=display">x</script> and to add the element <script type="math/tex; mode=display">nums[i+k+1]</script> to <script type="math/tex; mode=display">x</script>. We can carry out our process based on this idea and determine the maximum possible average.</p>\n<iframe frameborder="0" height="292" name="uABxt2Z8" src="https://leetcode.com/playground/uABxt2Z8/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We iterate over the given <script type="math/tex; mode=display">nums</script> array of length <script type="math/tex; mode=display">n</script> once only.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '644',
    name: 'Maximum Average Subarray II ',
    acceptance: '23.4%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an array consisting of <code>n</code> integers, find the contiguous subarray whose <b>length is greater than or equal to</b> <code>k</code> that has the maximum average value. And you need to output the maximum average value.\n</p>\n\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,12,-5,-6,50,3], k = 4\n<b>Output:</b> 12.75\n<b>Explanation:</b>\nwhen length is 5, maximum average value is 10.8,\nwhen length is 6, maximum average value is 9.16667.\nThus return 12.75.\n</pre>\n<p></p>\n\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>1 &lt;= <code>k</code> &lt;= <code>n</code> &lt;= 10,000.</li>\n<li>Elements of the given array will be in range [-10,000, 10,000].</li>\n<li>The answer with the calculation error less than 10<sup>-5</sup> will be accepted.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-iterative-method-time-limit-exceeded">Approach #1 Iterative method [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-binary-search-accepted">Approach #2 Using Binary Search [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-iterative-method-time-limit-exceeded">Approach #1 Iterative method [Time Limit Exceeded]</h4>\n<p>One of the simplest solutions is to consider the sum of every possible subarray with length greater than or equal to <script type="math/tex; mode=display">k</script> and to determine the maximum average from out of those. But, instead of finding out this sum in a naive manner for every subarray with length greater than or equal to <script type="math/tex; mode=display">k</script> separately, we can do as follows. </p>\n<p>For every starting point, <script type="math/tex; mode=display">s</script>, considered, we can iterate over the elements of <script type="math/tex; mode=display">nums</script> starting from <script type="math/tex; mode=display">nums</script>, and keep a track of the <script type="math/tex; mode=display">sum</script> found till the current index(<script type="math/tex; mode=display">i</script>). Whenever the index reached is such that the number of elements lying between <script type="math/tex; mode=display">s</script> and <script type="math/tex; mode=display">i</script> is greater than or equal to <script type="math/tex; mode=display">k</script>, we can check if the average of the elements between <script type="math/tex; mode=display">s</script> and <script type="math/tex; mode=display">i</script> is greater than the average found till now or not.</p>\n<iframe frameborder="0" height="309" name="uX3gpV7T" src="https://leetcode.com/playground/uX3gpV7T/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. Two for loops iterating over the whole length of <script type="math/tex; mode=display">nums</script> with <script type="math/tex; mode=display">n</script> elements.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-binary-search-accepted">Approach #2 Using Binary Search [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>To understand the idea behind this method, let\'s look at the following points. </p>\n<p>Firstly, we know that the value of the average could lie between the range <script type="math/tex; mode=display">(min, max)</script>. Here, <script type="math/tex; mode=display">min</script> and <script type="math/tex; mode=display">max</script> refer to the minimum and the maximum values out of the given <script type="math/tex; mode=display">nums</script> array. This is because, the average can\'t be lesser than the minimum value and can\'t be larger than the maximum value. </p>\n<p>But, in this case, we need to find the maximum average of a subarray with atleast <script type="math/tex; mode=display">k</script> elements. The idea in this method is to try to approximate(guess) the solution and to try to find if this solution really exists. </p>\n<p>If it exists, we can continue trying to approximate the solution even to a further precise value, but choosing a larger number as the next approximation. But, if the initial guess is wrong, and the initial maximum average value(guessed) isn\'t possible, we need to try with a smaller number as the next approximate.</p>\n<p>Now, instead of doing the guesses randomly, we can make use of Binary Search. With <script type="math/tex; mode=display">min</script> and <script type="math/tex; mode=display">max</script> as the initial numbers to begin with, we can find out the <script type="math/tex; mode=display">mid</script> of these two numbers given by <script type="math/tex; mode=display">(min+max)/2</script>. Now, we need to find if a subarray with length greater than or equal to <script type="math/tex; mode=display">k</script> is possible with an average sum greater than this <script type="math/tex; mode=display">mid</script> value.</p>\n<p>To determine if this is possible in a single scan, let\'s look at an observation. Suppose, there exist <script type="math/tex; mode=display">j</script> elements, <script type="math/tex; mode=display">a_1, a_2, a_3..., a_j</script> in a subarray within <script type="math/tex; mode=display">nums</script> such that their average is greater than <script type="math/tex; mode=display">mid</script>. In this case, we can say that </p>\n<p>\n<script type="math/tex; mode=display">(a_1+a_2+ a_3...+a_j)/j &geq; mid</script> or</p>\n<p>\n<script type="math/tex; mode=display">(a_1+a_2+ a_3...+a_j) &geq; j*mid</script> or</p>\n<p>\n<script type="math/tex; mode=display">(a_1-mid) +(a_2-mid)+ (a_3-mid) ...+(a_j-mid) &geq; 0</script>\n</p>\n<p>Thus, we can see that if after subtracting the <script type="math/tex; mode=display">mid</script> number from the elements of a subarray with more than <script type="math/tex; mode=display">k-1</script> elements, within <script type="math/tex; mode=display">nums</script>, if the sum of elements of this reduced subarray is greater than 0, we can achieve an average value greater than <script type="math/tex; mode=display">mid</script>. Thus, in this case, we need to set the <script type="math/tex; mode=display">mid</script> as the new minimum element and continue the process. </p>\n<p>Otherwise, if this reduced sum is lesser than 0 for all subarrays with greater than or equal to <script type="math/tex; mode=display">k</script> elements, we can\'t achieve <script type="math/tex; mode=display">mid</script> as the average. Thus, we need to set <script type="math/tex; mode=display">mid</script> as the new maximum element and continue the process.</p>\n<p>In order to determine if such a subarray exists in a linear manner, we keep on adding <script type="math/tex; mode=display">nums[i]-mid</script> to the <script type="math/tex; mode=display">sum</script> obtained till the <script type="math/tex; mode=display">i^{th}</script> element while traversing over the <script type="math/tex; mode=display">nums</script> array. If on traversing the first <script type="math/tex; mode=display">k</script> elements, the <script type="math/tex; mode=display">sum</script> becomes greater than or equal to 0, we can directly determine that we can increase the average beyond <script type="math/tex; mode=display">mid</script>. Otherwise, we continue making additions to <script type="math/tex; mode=display">sum</script> for elements beyond the <script type="math/tex; mode=display">k^{th}</script> element, making use of the following idea.</p>\n<p>If we know the cumulative sum upto indices <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script>, say <script type="math/tex; mode=display">sum_i</script> and <script type="math/tex; mode=display">sum_j</script> respectively, we can determine the sum of the subarray between these indices(including <script type="math/tex; mode=display">j</script>) as <script type="math/tex; mode=display">sum_j - sum_i</script>. In our case, we want this difference between the cumulative sums to be greater than or equal to 0 as discusssed above. </p>\n<p>Further, for <script type="math/tex; mode=display">sum_i</script> as the cumulative sum upto the current(<script type="math/tex; mode=display">i^{th}</script>) index, all we need is <script type="math/tex; mode=display">sum_j - sum_i &geq; 0</script> such that <script type="math/tex; mode=display">j - i &geq; k</script>. </p>\n<p>To achive this, instead of checking with all possible values of <script type="math/tex; mode=display">sum_i</script>, we can just consider the minimum cumulative sum upto the index <script type="math/tex; mode=display">j - k</script>. This is because if the required condition can\'t be sastisfied with the minimum <script type="math/tex; mode=display">sum_i</script>, it can never be satisfied with a larger value.</p>\n<p>To fulfil this, we make use of a <script type="math/tex; mode=display">prev</script> variable which again stores the cumulative sums but, its current index(for cumulative sum) lies behind the current index for <script type="math/tex; mode=display">sum</script> at an offset of <script type="math/tex; mode=display">k</script> units. Thus, by finding the minimum out of <script type="math/tex; mode=display">prev</script> and the last minimum value, we can easily find out the required minimum sum value.</p>\n<p>Every time after checking the possiblility with a new <script type="math/tex; mode=display">mid</script> value, at the end, we need to settle at some value as the average. But, we can observe that eventually, we\'ll reach a point, where we\'ll keep moving near some same value with very small changes. In order to keep our precision in control, we limit this process to <script type="math/tex; mode=display">10^-5</script> precision, by making use of <script type="math/tex; mode=display">error</script> and continuing the process till <script type="math/tex; mode=display">error</script> becomes lesser than 0.00001 .</p>\n<iframe frameborder="0" height="515" name="9co4Jxkv" src="https://leetcode.com/playground/9co4Jxkv/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nlog(max\\_val-min\\_val))</script>. <script type="math/tex; mode=display">check</script> takes <script type="math/tex; mode=display">O(n)</script> time and it is executed <script type="math/tex; mode=display">O(log(max\\_val-min\\_val))</script> times.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant Space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '645',
    name: 'Set Mismatch',
    acceptance: '39.9%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>\nThe set <code>S</code> originally contains numbers from 1 to <code>n</code>. But unfortunately, due to the data error, one of the numbers in the set got duplicated to <b>another</b> number in the set, which results in repetition of one number and loss of another number. \n</p>\n\n<p>\nGiven an array <code>nums</code> representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.\n</p>\n\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> nums = [1,2,2,4]\n<b>Output:</b> [2,3]\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The given array size will in the range [2, 10000].</li>\n<li>The given array's numbers won't have any order.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-using-sorting-accepted">Approach #3 Using Sorting [Accepted]</a></li>\n<li><a href="#approach-4-using-map-accepted">Approach #4 Using map [Accepted]</a></li>\n<li><a href="#approach-5-using-extra-arrayaccepted">Approach #5 Using Extra Array[Accepted]:</a></li>\n<li><a href="#approach-6-using-constant-spaceaccepted">Approach #6 Using Constant Space[Accepted]:</a></li>\n<li><a href="#approach-7-using-xor-accepted">Approach #7 Using XOR [Accepted]:</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1 Brute Force [Time Limit Exceeded]</h4>\n<p>The most naive solution is to consider each number from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script>, and traverse over the whole <script type="math/tex; mode=display">nums</script> array to check if the current number occurs twice in <script type="math/tex; mode=display">nums</script>\nor doesn\'t occur at all. We need to set the duplicate number, <script type="math/tex; mode=display">dup</script> and the missing number, <script type="math/tex; mode=display">missing</script>, appropriately in such cases respectively.</p>\n<iframe frameborder="0" height="343" name="XmJ9Tdi2" src="https://leetcode.com/playground/XmJ9Tdi2/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. We traverse over the <script type="math/tex; mode=display">nums</script> array of size <script type="math/tex; mode=display">n</script> for each of the numbers from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-better-brute-force-time-limit-exceeded">Approach #2 Better Brute Force [Time Limit Exceeded]</h4>\n<p>In the last approach, we continued the search process, even when we\'ve already found the duplicate and the missing number. But, as per the problem statement, \nwe know that only one number will be repeated and only one number will be missing. Thus, we can optimize the last approach to some extent, by stopping \nthe search process as soon as we find these two required numbers.</p>\n<iframe frameborder="0" height="394" name="XQ5or7QV" src="https://leetcode.com/playground/XQ5or7QV/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. We traverse over the <script type="math/tex; mode=display">nums</script> array of size <script type="math/tex; mode=display">n</script> for each of the numbers from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script>, in the worst case.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-sorting-accepted">Approach #3 Using Sorting [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>One way to further optimize the last approach is to sort the given <script type="math/tex; mode=display">nums</script> array. This way, the numbers which are equal will always lie together. \nFurther, we can easily identify the missing number by checking if every two consecutive elements in the sorted <script type="math/tex; mode=display">nums</script> array are just one count apart or not.</p>\n<iframe frameborder="0" height="292" name="5WFPjrzW" src="https://leetcode.com/playground/5WFPjrzW/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nlogn)</script>. Sorting takes <script type="math/tex; mode=display">O(nlogn)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(logn)</script>. Sorting takes <script type="math/tex; mode=display">O(logn)</script> space. </p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-using-map-accepted">Approach #4 Using map [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The given problem can also be solved easily if we can somehow keep a track of the number of times each element of the <script type="math/tex; mode=display">nums</script> array occurs. One way to \ndo so is to make an entry for each element of <script type="math/tex; mode=display">nums</script> in a HashMap <script type="math/tex; mode=display">map</script>. This <script type="math/tex; mode=display">map</script> stores the entries in the form <script type="math/tex; mode=display">(num_i, count_i)</script>. Here, <script type="math/tex; mode=display">num</script> refers to\nthe <script type="math/tex; mode=display">i^{th}</script> element in <script type="math/tex; mode=display">nums</script> and <script type="math/tex; mode=display">count_i</script> refers to the number of times this element occurs in <script type="math/tex; mode=display">nums</script>.\n  Whenever, the same element occurs again, we can increment the count corresponding to the \nsame. </p>\n<p>After this, we can consider every number from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script>, and check for its presence in <script type="math/tex; mode=display">map</script>. If it isn\'t present, we can update the <script type="math/tex; mode=display">missing</script> variable \nappropriately. But, if the <script type="math/tex; mode=display">count</script> corresponding to the current number is <script type="math/tex; mode=display">2</script>, we can update the <script type="math/tex; mode=display">dup</script> variable with the current number.</p>\n<iframe frameborder="0" height="343" name="NdSWUKGM" src="https://leetcode.com/playground/NdSWUKGM/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Traversing over <script type="math/tex; mode=display">nums</script> of size <script type="math/tex; mode=display">n</script> takes <script type="math/tex; mode=display">O(n)</script> time. Considering each number from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script> also takes <script type="math/tex; mode=display">O(n)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">map</script> can contain atmost <script type="math/tex; mode=display">n</script> entries for each of the numbers from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-5-using-extra-arrayaccepted">Approach #5 Using Extra Array[Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the last approach, we make use of a <script type="math/tex; mode=display">map</script> to store the elements of <script type="math/tex; mode=display">nums</script> along with their corresponding counts. But, we can note, that each entry in <script type="math/tex; mode=display">map</script> \nrequires two entries. Thus, putting up <script type="math/tex; mode=display">n</script> entries requires <script type="math/tex; mode=display">2n</script> space actually. We can reduce this space required to <script type="math/tex; mode=display">n</script> by making use of an array, <script type="math/tex; mode=display">arr</script> instead.\nNow, the indices of <script type="math/tex; mode=display">arr</script> can be used instead of storing the elements again. Thus, we make use of <script type="math/tex; mode=display">arr</script> in such a way that, <script type="math/tex; mode=display">arr[i]</script> is used to store \nthe number of occurences of the element <script type="math/tex; mode=display">i+1</script>. The rest of the process remains the same as in the last approach.</p>\n<iframe frameborder="0" height="326" name="362FM5TH" src="https://leetcode.com/playground/362FM5TH/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Traversing over <script type="math/tex; mode=display">nums</script> of size <script type="math/tex; mode=display">n</script> takes <script type="math/tex; mode=display">O(n)</script> time. Considering each number from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script> also takes <script type="math/tex; mode=display">O(n)</script> time.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">arr</script> can contain atmost <script type="math/tex; mode=display">n</script> elements for each of the numbers from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-6-using-constant-spaceaccepted">Approach #6 Using Constant Space[Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can save the space used in the last approach, if we can somehow, include the information regarding the duplicacy of an element or absence of an element\n in the <script type="math/tex; mode=display">nums</script> array. Let\'s see how this can be done.</p>\n<p>We know that all the elements in the given <script type="math/tex; mode=display">nums</script> array are positive, and lie in the range <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script> only. Thus, we can pick up each element <script type="math/tex; mode=display">i</script> \n from <script type="math/tex; mode=display">nums</script>. For every number <script type="math/tex; mode=display">i</script> picked up, we can invert the element at the index <script type="math/tex; mode=display">\\left|i\\right|</script>. By doing so,  if one of the elements <script type="math/tex; mode=display">j</script> occurs twice, \nwhen this number is encountered the second time,  the element <script type="math/tex; mode=display">nums[\\left|i\\right|]</script> will be found to be negative. \nThus, while doing the inversions, we can check if a number found is already negative, to find the duplicate number.</p>\n<p>After the inversions have been done, if all the elements in <script type="math/tex; mode=display">nums</script> are present correctly, the resultant <script type="math/tex; mode=display">nums</script> array will have all the elements as \n negative now. But, if one of the numbers, <script type="math/tex; mode=display">j</script> is missing, the element at the <script type="math/tex; mode=display">j^{th}</script> index will be positive. This  can be used to determine the missing number.</p>\n<iframe frameborder="0" height="326" name="jNt2byCg" src="https://leetcode.com/playground/jNt2byCg/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. Two traversals over the <script type="math/tex; mode=display">nums</script> array of size <script type="math/tex; mode=display">n</script> are done.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-7-using-xor-accepted">Approach #7 Using XOR [Accepted]:</h4>\n<p><strong>Algorithm</strong></p>\n<p>Before we dive into the solution to this problem, let\'s consider a simple problem. Consider an array with <script type="math/tex; mode=display">n-1</script> elements containing numbers from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script> with one number missing out of them. Now, how to we find out this missing element. One of the solutions is to take the XOR of all the elements of this array with all the numbers from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script>. By doing so, we get the required missing number. This works because XORing a number with itself results in a 0 result. Thus, only the number which is missing can\'t get cancelled with this XORing.</p>\n<p>Now, using this idea as the base, let\'s take it a step forward and use it for the current problem. By taking the XOR of all the elements of the given <script type="math/tex; mode=display">nums</script> array with all the numbers from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script>, we will get a result, <script type="math/tex; mode=display">xor</script>, as <script type="math/tex; mode=display">x^y</script>. Here, <script type="math/tex; mode=display">x</script> and <script type="math/tex; mode=display">y</script> refer to the repeated and the missing term in the given <script type="math/tex; mode=display">nums</script> array. This happens on the same grounds as in the first problem discussed above.</p>\n<p>Now, in the resultant <script type="math/tex; mode=display">xor</script>, we\'ll get a 1 in the binary representation only at those bit positions which have a 1 in one out of the numbers <script type="math/tex; mode=display">x</script> and <script type="math/tex; mode=display">y</script>, and a 0 at the same bit position in the other one. In the current solution, we consider the rightmost bit which is 1 in the <script type="math/tex; mode=display">xor</script>, although any bit would work. Let\'s say, this position is called the <script type="math/tex; mode=display">rightmostbit</script>. </p>\n<p>If we divide the elements of the given <script type="math/tex; mode=display">nums</script> array into two parts such that the first set contains the elements which have a 1 at the <script type="math/tex; mode=display">rightmostbit</script> position and the second set contains the elements having a 0 at the same position, we\'ll get one out of <script type="math/tex; mode=display">x</script> or <script type="math/tex; mode=display">y</script> in one set and the other one in the second set. Now, our problem has reduced somewhat to the simple problem discussed above.</p>\n<p>To solve this reduced problem, we can find out the elements from <script type="math/tex; mode=display">1</script> to <script type="math/tex; mode=display">n</script> and consider them as a part of the previous sets only, with the allocation of the set depending on a 1 or 0 at the <script type="math/tex; mode=display">righmostbit</script> position. </p>\n<p>Now, if we do the XOR of all the elements of the first set, all the elements will result in an XOR of 0, due to cancellation of the similar terms in both <script type="math/tex; mode=display">nums</script> and the numbers <script type="math/tex; mode=display">(1:n)</script>, except one term, which is either <script type="math/tex; mode=display">x</script> or <script type="math/tex; mode=display">y</script>. </p>\n<p>For the other term, we can do the XOR of all the elements in the second set as well.</p>\n<p>Consider the example <code>[1 2 4 4 5 6]</code></p>\n<p><img alt="XOR" src="https://leetcode.com/articles/Figures/645_Set_Mismatch.PNG"></p>\n<p>One more traversal over the <script type="math/tex; mode=display">nums</script> can be used to identify the missing and the repeated number out of the two numbers found.</p>\n<iframe frameborder="0" height="515" name="WhhZovFh" src="https://leetcode.com/playground/WhhZovFh/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We iterate over <script type="math/tex; mode=display">n</script> elements five times.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(1)</script>. Constant extra space is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '646',
    name: 'Maximum Length of Pair Chain',
    acceptance: '47.6%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nYou are given <code>n</code> pairs of numbers. In every pair, the first number is always smaller than the second number.\n</p>\n\n<p>\nNow, we define a pair <code>(c, d)</code> can follow another pair <code>(a, b)</code> if and only if <code>b &lt; c</code>. Chain of pairs can be formed in this fashion. \n</p>\n\n<p>\nGiven a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.\n</p>\n\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [[1,2], [2,3], [3,4]]\n<b>Output:</b> 2\n<b>Explanation:</b> The longest chain is [1,2] -&gt; [3,4]\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The number of given pairs will be in the range [1, 1000].</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-2-greedy-accepted">Approach #2: Greedy [Accepted]</a></li>\n</ul>\n</div>\n<hr>\n<h4 id="approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If a chain of length <code>k</code> ends at some <code>pairs[i]</code>, and <code>pairs[i][1] &lt; pairs[j][0]</code>, we can extend this chain to a chain of length <code>k+1</code>.</p>\n<p><strong>Algorithm</strong></p>\n<p>Sort the pairs by first coordinate, and let <code>dp[i]</code> be the length of the longest chain ending at <code>pairs[i]</code>.  When <code>i &lt; j</code> and <code>pairs[i][1] &lt; pairs[j][0]</code>, we can extend the chain, and so we have the candidate answer <code>dp[j] = max(dp[j], dp[i] + 1)</code>.</p>\n<iframe frameborder="0" height="378" name="5RAj49MD" src="https://leetcode.com/playground/5RAj49MD/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script> where <script type="math/tex; mode=display">N</script> is the length of <code>pairs</code>.  There are two for loops, and <script type="math/tex; mode=display">N^2</script> dominates the sorting step.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script> for sorting and to store <code>dp</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-greedy-accepted">Approach #2: Greedy [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can greedily add to our chain.  Choosing the next addition to be the one with the lowest second coordinate is at least better than a choice with a larger second coordinate.</p>\n<p><strong>Algorithm</strong></p>\n<p>Consider the pairs in increasing order of their <em>second</em> coordinate.  We\'ll try to add them to our chain.  If we can, by the above argument we know that it is correct to do so.</p>\n<iframe frameborder="0" height="242" name="imd3oEYD" src="https://leetcode.com/playground/imd3oEYD/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N \\log N)</script> where <script type="math/tex; mode=display">N</script> is the length of <code>S</code>.  The complexity comes from the sorting step, but the rest of the solution does linear work.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>.  The additional space complexity of storing <code>cur</code> and <code>ans</code>, but sorting uses <script type="math/tex; mode=display">O(N)</script> space.  Depending on the implementation of the language used, sorting can sometimes use less space.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '647',
    name: 'Palindromic Substrings',
    acceptance: '55.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a string, your task is to count how many palindromic substrings in this string.\n</p>\n\n<p>\nThe substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. \n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "abc"\n<b>Output:</b> 3\n<b>Explanation:</b> Three palindromic strings: "a", "b", "c".\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> "aaa"\n<b>Output:</b> 6\n<b>Explanation:</b> Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The input string length won\'t exceed 1000.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-expand-around-center-accepted">Approach #1: Expand Around Center [Accepted]</a></li>\n<li><a href="#approach-2-manachers-algorithm-accepted">Approach #2: Manacher\'s Algorithm [Accepted]</a></li>\n</ul>\n</div>\n<hr>\n<h4 id="approach-1-expand-around-center-accepted">Approach #1: Expand Around Center [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Let <code>N</code> be the length of the string.  The middle of the palindrome could be in one of <code>2N - 1</code> positions: either at letter or between two letters.</p>\n<p>For each center, let\'s count all the palindromes that have this center.  Notice that if <code>[a, b]</code> is a palindromic interval (meaning <code>S[a], S[a+1], ..., S[b]</code> is a palindrome), then <code>[a+1, b-1]</code> is one too.</p>\n<p><strong>Algorithm</strong></p>\n<p>For each possible palindrome center, let\'s expand our candidate palindrome on the interval <code>[left, right]</code> as long as we can.  The condition for expanding is <code>left &gt;= 0 and right &lt; N and S[left] == S[right]</code>.  That means we want to count a new palindrome <code>S[left], S[left+1], ..., S[right]</code>.</p>\n<iframe frameborder="0" height="310" name="EEGE8AYR" src="https://leetcode.com/playground/EEGE8AYR/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script> where <script type="math/tex; mode=display">N</script> is the length of <code>S</code>.  Each expansion might do <script type="math/tex; mode=display">O(N)</script> work.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-manachers-algorithm-accepted">Approach #2: Manacher\'s Algorithm [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Manacher\'s algorithm is a textbook algorithm that finds in linear time, the maximum size palindrome for any possible palindrome center.  If we had such an algorithm, finding the answer is straightforward.</p>\n<p>What follows is a discussion of why this algorithm works.</p>\n<p><strong>Algorithm</strong></p>\n<p>Our loop invariants will be that <code>center, right</code> is our knowledge of the palindrome with the largest right-most boundary with <code>center &lt; i</code>, centered at <code>center</code> with right-boundary <code>right</code>.  Also, <code>i &gt; center</code>, and we\'ve already computed all <code>Z[j]</code>\'s for <code>j &lt; i</code>.</p>\n<p>When <code>i &lt; right</code>, we reflect <code>i</code> about <code>center</code> to be at some coordinate <code>j = 2 * center - i</code>.  Then, limited to the interval with radius <code>right - i</code> and center <code>i</code>, the situation for <code>Z[i]</code> is the same as for <code>Z[j]</code>.</p>\n<p>For example, if at some time <code>center = 7, right = 13, i = 10</code>, then for a string like <code>A = \'@#A#B#A#A#B#A#$\'</code>, the <code>center</code> is at the <code>\'#\'</code> between the two middle <code>\'A\'</code>\'s, the right boundary is at the last <code>\'#\'</code>, <code>i</code> is at the last <code>\'B\'</code>, and <code>j</code> is at the first <code>\'B\'</code>.</p>\n<p>Notice that limited to the interval <code>[center - (right - center), right]</code> (the interval with center <code>center</code> and right-boundary <code>right</code>), the situation for <code>i</code> and <code>j</code> is a reflection of something we have already computed.  Since we already know <code>Z[j] = 3</code>, we can quickly find <code>Z[i] = min(right - i, Z[j]) = 3</code>.</p>\n<p>Now, why is this algorithm linear?  The while loop only checks the condition more than once when <code>Z[i] = right - i</code>.  In that case, for each time <code>Z[i] += 1</code>, it increments <code>right</code>, and <code>right</code> can only be incremented up to <code>2*N+2</code> times.</p>\n<p>Finally, we sum up <code>(v+1) / 2</code> for each <code>v in Z</code>.  Say the longest palindrome with some given center C has radius R.  Then, the substring with center C and radius R-1, R-2, R-3, ..., 0 are also palindromes.  Example:  <code>abcdedcba</code> is a palindrome with center <code>e</code>, radius 4:  but <code>e</code>, <code>ded</code>, <code>cdedc</code>, <code>bcdedcb</code>, and <code>abcdedcba</code> are all palindromes.</p>\n<p>We are dividing by 2 because we were using half-lengths instead of lengths.  For example we actually had the palindrome <code>a#b#c#d#e#d#c#b#a</code>, so our length is twice as big.</p>\n<iframe frameborder="0" height="500" name="ttFoRCjg" src="https://leetcode.com/playground/ttFoRCjg/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script> where <script type="math/tex; mode=display">N</script> is the length of <code>S</code>.  As discussed above, the complexity is linear.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of <code>A</code> and <code>Z</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Facebook', 'LinkedIn'],
  },
  {
    id: '648',
    name: 'Replace Words',
    acceptance: '47.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nIn English, we have a concept called <code>root</code>, which can be followed by some other words to form another longer word - let\'s call this word <code>successor</code>. For example, the root <code>an</code>, followed by <code>other</code>, which can form another word <code>another</code>.\n</p>\n\n\n<p>\nNow, given a dictionary consisting of many roots and a sentence. You need to replace all the <code>successor</code> in the sentence with the <code>root</code> forming it. If a <code>successor</code> has many <code>roots</code> can form it, replace it with the root with the shortest length.\n</p>\n\n<p>\nYou need to output the sentence after the replacement.\n</p>\n\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> dict = ["cat", "bat", "rat"]\nsentence = "the cattle was rattled by the battery"\n<b>Output:</b> "the cat was rat by the bat"\n</pre>\n<p></p>\n\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The input will only have lower-case letters.</li>\n<li> 1 &lt;= dict words number &lt;= 1000 </li>\n<li> 1 &lt;= sentence words number &lt;= 1000  </li>\n<li> 1 &lt;= root length &lt;= 100 </li>\n<li> 1 &lt;= sentence words length &lt;= 1000 </li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-prefix-hash-accepted">Approach #1: Prefix Hash [Accepted]</a></li>\n<li><a href="#approach-2-trie-accepted">Approach #2: Trie [Accepted]</a></li>\n</ul>\n</div>\n<hr>\n<h4 id="approach-1-prefix-hash-accepted">Approach #1: Prefix Hash [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>For each word in the sentence, we\'ll look at successive prefixes and see if we saw them before.</p>\n<p><strong>Algorithm</strong></p>\n<p>Store all the <code>roots</code> in a <em>Set</em> structure.  Then for each word, look at successive prefixes of that word.  If you find a prefix that is a root, replace the word with that prefix.  Otherwise, the prefix will just be the word itself, and we should add that to the final sentence answer.</p>\n<iframe frameborder="0" height="361" name="tvjGGLzd" src="https://leetcode.com/playground/tvjGGLzd/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(\\sum w_i^2)</script> where <script type="math/tex; mode=display">w_i</script> is the length of the <script type="math/tex; mode=display">i</script>-th word.  We might check every prefix, the <script type="math/tex; mode=display">i</script>-th of which is <script type="math/tex; mode=display">O(w_i^2)</script> work.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script> where <script type="math/tex; mode=display">N</script> is the length of our sentence; the space used by <code>rootset</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-trie-accepted">Approach #2: Trie [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Put all the roots in a trie (prefix tree).  Then for any query word, we can find the smallest root that was a prefix in linear time.</p>\n<iframe frameborder="0" height="500" name="5Dt2dcFU" src="https://leetcode.com/playground/5Dt2dcFU/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script> where <script type="math/tex; mode=display">N</script> is the length of the <code>sentence</code>.  Every query of a word is in linear time.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of our trie.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Uber'],
  },
  {
    id: '649',
    name: 'Dota2 Senate',
    acceptance: '36.0%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nIn the world of Dota2, there are two parties: the <code>Radiant</code> and the <code>Dire</code>.\n</p>\n\n<p>\nThe Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise <code>one</code> of the two rights:\n</p><ol>\n<li><code>Ban one senator's right</code>: <br>A senator can make another senator lose <b>all his rights</b> in this and all the following rounds.</li>\n<li><code>Announce the victory</code>: <br>If this senator found the senators who still have rights to vote are all from <b>the same party</b>, he can announce the victory and make the decision about the change in the game.</li>\n</ol>\n<p></p>\n\n<p>\nGiven a string representing each senator's party belonging. The character 'R' and 'D' represent the <code>Radiant</code> party and the <code>Dire</code> party respectively. Then if there are <code>n</code> senators, the size of the given string will be <code>n</code>.\n</p>\n\n<p>\nThe round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\n</p>\n\n<p>\nSuppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be <code>Radiant</code> or <code>Dire</code>.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \"RD\"\n<b>Output:</b> \"Radiant\"\n<b>Explanation:</b> The first senator comes from Radiant and he can just ban the next senator's right in the round 1. <br>And the second senator can't exercise any rights any more since his right has been banned. <br>And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\n</pre>\n<p></p>\n\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \"RDD\"\n<b>Output:</b> \"Dire\"\n<b>Explanation:</b> \nThe first senator comes from Radiant and he can just ban the next senator's right in the round 1. <br>And the second senator can't exercise any rights anymore since his right has been banned. <br>And the third senator comes from Dire and he can ban the first senator's right in the round 1. <br>And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The length of the given string will in the range [1, 10,000].</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-simulation-accepted">Approach #1: Simulation [Accepted]</a></li>\n</ul>\n</div>\n<hr>\n<h4 id="approach-1-simulation-accepted">Approach #1: Simulation [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>A senator performing a ban doesn\'t need to use it on another senator immediately.  We can wait to see when another team\'s senator will vote, then use that ban retroactively.</p>\n<p><strong>Algorithm</strong></p>\n<p>Put the senators in an integer queue: <code>1</code> for <code>\'Radiant\'</code> and <code>0</code> for <code>\'Dire\'</code>.</p>\n<p>Now process the queue: if there is a floating ban for that senator, exercise it and continue.  Otherwise, add a floating ban against the other team, and enqueue this senator again.</p>\n<iframe frameborder="0" height="497" name="zdvGbwLN" src="https://leetcode.com/playground/zdvGbwLN/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script> where <script type="math/tex; mode=display">N</script> is the size of the senate.  Every vote removes one senator from the other team.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the space used by our queue.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Valve'],
  },
  {
    id: '650',
    name: '2 Keys Keyboard',
    acceptance: '44.9%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nInitially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step: \n</p><ol>\n<li><code>Copy All</code>: You can copy all the characters present on the notepad (partial copy is not allowed).</li>\n<li><code>Paste</code>: You can paste the characters which are copied <b>last time</b>.</li>\n</ol>\n<p></p>\n\n<p>\nGiven a number <code>n</code>. You have to get <b>exactly</b> <code>n</code> 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get <code>n</code> 'A'. \n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> 3\n<b>Output:</b> 3\n<b>Explanation:</b>\nIntitally, we have one character 'A'.\nIn step 1, we use <b>Copy All</b> operation.\nIn step 2, we use <b>Paste</b> operation to get 'AA'.\nIn step 3, we use <b>Paste</b> operation to get 'AAA'.\n</pre>\n<p></p>\n\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The <code>n</code> will be in the range [1, 1000].</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-prime-factorization-accepted">Approach #1: Prime Factorization [Accepted]</a></li>\n</ul>\n</div>\n<hr>\n<h4 id="approach-1-prime-factorization-accepted">Approach #1: Prime Factorization [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can break our moves into groups of <code>(copy, paste, ..., paste)</code>.  Let <code>C</code> denote copying and <code>P</code> denote pasting.  Then for example, in the sequence of moves <code>CPPCPPPPCP</code>, the groups would be <code>[CPP][CPPPP][CP]</code>.</p>\n<p>Say these groups have lengths <code>g_1, g_2, ...</code>.  After parsing the first group, there are <code>g_1</code> <code>\'A\'</code>s.  After parsing the second group, there are <code>g_1 * g_2</code> <code>\'A\'</code>s, and so on.  At the end, there are <code>g_1 * g_2 * ... * g_n</code> <code>\'A\'</code>s.</p>\n<p>We want exactly <code>N = g_1 * g_2 * ... * g_n</code>.  If any of the <code>g_i</code> are composite, say <code>g_i = p * q</code>, then we can split this group into two groups (the first of which has one copy followed by <code>p-1</code> pastes, while the second group having one copy and <code>q-1</code> pastes).</p>\n<p>Such a split never uses more moves: we use <code>p+q</code> moves when splitting, and <code>pq</code> moves previously.  As <code>p+q &lt;= pq</code> is equivalent to <code>1 &lt;= (p-1)(q-1)</code>, which is true as long as <code>p &gt;= 2</code> and <code>q &gt;= 2</code>.</p>\n<p><strong>Algorithm</strong>\nBy the above argument, we can suppose <code>g_1, g_2, ...</code> is the prime factorization of <code>N</code>, and the answer is therefore the sum of these prime factors.</p>\n<iframe frameborder="0" height="276" name="U88jzmPG" src="https://leetcode.com/playground/U88jzmPG/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(\\sqrt{N})</script>.  When <code>N</code> is the square of a prime, our loop does <script type="math/tex; mode=display">O(\\sqrt{N})</script> steps.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>, the space used by <code>ans</code> and <code>d</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Microsoft'],
  },
  {
    id: '651',
    name: '4 Keys Keyboard ',
    acceptance: '49.1%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Imagine you have a special keyboard with the following keys: </p>\n<p><code>Key 1: (A)</code>:  Print one 'A' on screen.</p>\n<p><code>Key 2: (Ctrl-A)</code>: Select the whole screen.</p>\n<p><code>Key 3: (Ctrl-C)</code>: Copy selection to buffer.</p>\n<p><code>Key 4: (Ctrl-V)</code>: Print buffer on screen appending it after what has already been printed. </p>\n\n\n\n<p>Now, you can only press the keyboard for <b>N</b> times (with the above four keys), find out the maximum numbers of 'A' you can print on screen.</p>\n\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> N = 3\n<b>Output:</b> 3\n<b>Explanation:</b> \nWe can at most get 3 A's on screen by pressing following key sequence:\nA, A, A\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> N = 7\n<b>Output:</b> 9\n<b>Explanation:</b> \nWe can at most get 9 A's on screen by pressing following key sequence:\nA, A, A, Ctrl A, Ctrl C, Ctrl V, Ctrl V\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>1 &lt;= N &lt;= 50 </li>\n<li>Answers will be in the range of 32-bit signed integer.</li>\n</ol>\n<p></p>\n\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-framework">Approach Framework</a></li>\n<li><a href="#approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-2-optimized-dynamic-programming-accepted">Approach #2: Optimized Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-3-mathematical-accepted">Approach #3: Mathematical [Accepted]</a></li>\n</ul>\n</div>\n<hr>\n<h4 id="approach-framework">Approach Framework</h4>\n<p><strong>Explanation</strong></p>\n<p>We either press \'A\', or press \'CTRL+A\', \'CTRL+C\', and some number of \'CTRL+V\'s.  Thus, there are only two types of moves:</p>\n<ul>\n<li>Add (Cost <code>1</code>):  Add <code>1</code></li>\n<li>Multiply (Cost <code>k+1</code>):  Multiply by <code>k</code>, where <code>k &gt;= 2</code>.</li>\n</ul>\n<p>In the following explanations, we will reference these as moves.</p>\n<hr>\n<h4 id="approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Say <code>best[k]</code> is the most number of <code>\'A\'</code>\'s possible after <code>k</code> moves.  If the last move was adding, then <code>best[k] = best[k-1] + 1</code>.  If the last move was multiplying, then <code>best[k-(x+1)] = best[k-(x+1)] * x</code> for some <code>x &lt; k-1</code>.</p>\n<p>Taking the best of these candidates lets us find <code>best[k]</code> in terms of previous <code>best[j], j &lt; k</code>.</p>\n<iframe frameborder="0" height="242" name="rRc3PEi7" src="https://leetcode.com/playground/rRc3PEi7/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script>.  We have two nested for-loops, each of which do <script type="math/tex; mode=display">O(N)</script> work.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of <code>best</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-optimized-dynamic-programming-accepted">Approach #2: Optimized Dynamic Programming [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we multiply by <code>2N</code>, paying a cost of <code>2N+1</code>, we could instead multiply by <code>N</code> then <code>2</code>, paying <code>N+4</code>.  When <code>N &gt;= 3</code>, we don\'t pay more by doing it the second way.</p>\n<p>Similarly, if we are to multiply by <code>2N+1</code> paying <code>2N+2</code>, we could instead multiply by <code>N+1</code> then <code>2</code>, paying <code>N+5</code>.  Again, when <code>N &gt;= 3</code>, we don\'t pay more doing it the second way.</p>\n<p>Thus, we never multiply by more than <code>5</code>.</p>\n<p><strong>Algorithm</strong></p>\n<p>Our approach is the same as <em>Approach #1</em>, except we do not consider <code>k-x-1 &gt; 5</code> in our inner loop.  For brevity, we have omitted this solution.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>.  We have two nested for-loops, but the inner loop does <script type="math/tex; mode=display">O(1)</script> work.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of <code>best</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-mathematical-accepted">Approach #3: Mathematical [Accepted]</h4>\n<p><strong>Explanation</strong></p>\n<p>As in <em>Approach #2</em>, we never multiply by more than 5.</p>\n<p>When <code>N</code> is arbitrarily large, the long run behavior of multiplying by <code>k</code> repeatedly is to get to the value <script type="math/tex; mode=display">k^{\\frac{N}{k+1}}</script>.  Analyzing the function <script type="math/tex; mode=display">k^{\\frac{1}{k+1}}</script> at values <script type="math/tex; mode=display">k = 2, 3, 4, 5</script>, it attains a peak at <script type="math/tex; mode=display">k = 4</script>.  Thus, we should expect that <em>eventually</em>, <code>best[K] = best[K-5] * 4</code>.</p>\n<p>Now, we need to make a few more deductions.</p>\n<ul>\n<li>\n<p>We never add after multiplying: if we add <code>c</code> after multiplying by <code>k</code>, we should instead multiply by <code>k+c</code>.</p>\n</li>\n<li>\n<p>We never add after 5: If we add <code>1</code> then multiply by <code>k</code> to get to <code>(x+1) * k = xk + k</code>, we could instead multiply by <code>k+1</code> to get to <code>xk + x</code>.  Since <code>k &lt;= 5</code>, we must have <code>x &lt;= 5</code> for our additions to not be dominated.</p>\n</li>\n<li>\n<p>The number of multiplications by 2, 3, or 5 is bounded.</p>\n</li>\n<li>\n<p>Every time we\'ve multiplied by 2 two times, we prefer to multiply by 4 once for less cost. (4^1 for a cost of 5, vs 2^2 for a cost of 6.)</p>\n</li>\n<li>Every time we\'ve multiplied by 3 five times, we prefer to multiply by 4 four times for the same cost but a larger result. (4^4 &gt; 3^5, and cost is 20.)</li>\n<li>Every time we\'ve multiplied by 5 five times, we prefer to multiply by 4 six times for the same cost but a larger result. (4^6 &gt; 5^5, and cost is 30.)</li>\n</ul>\n<p>Together, this shows there are at most 5 additions and 9 multiplications by a number that isn\'t 4.</p>\n<p>We can find the first 14 operations on 1 by hand: <code>1, 2, 3, 4, 5, 6, 9, 12, 16, 20, 27, 36, 48, 64, 81</code>. After that, every subsequent number is achieved by multiplying by 4: ie., <code>best[K] = best[K-5] * 4</code>.</p>\n<iframe frameborder="0" height="191" name="Qwo3hc2x" src="https://leetcode.com/playground/Qwo3hc2x/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time and Space Complexity: <script type="math/tex; mode=display">O(1)</script>.</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Google', 'Microsoft'],
  },
  {
    id: '652',
    name: 'Find Duplicate Subtrees',
    acceptance: '36.3%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nGiven a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any <b>one</b> of them. </p>\n\n<p>\nTwo trees are duplicate if they have the same structure with same node values.\n</p>\n\n<p><b>Example 1: </b><br>\n</p><pre>        1\n       / \\\n      2   3\n     /   / \\\n    4   2   4\n       /\n      4\n</pre>\nThe following are two duplicate subtrees:\n<pre>      2\n     /\n    4\n</pre>\nand\n<pre>    4\n</pre>\nTherefore, you need to return above trees' root in the form of a list.\n<p></p>\n\n\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</a></li>\n<li><a href="#approach-2-unique-identifier-accepted">Approach #2: Unique Identifier [Accepted]</a></li>\n</ul>\n</div>\n<hr>\n<h4 id="approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can serialize each subtree.  For example, the tree</p>\n<div class="codehilite"><pre><span></span>   <span class="mi">1</span>\n  <span class="o">/</span> \\\n <span class="mi">2</span>   <span class="mi">3</span>\n    <span class="o">/</span> \\\n   <span class="mi">4</span>   <span class="mi">5</span>\n</pre></div>\n<p>can be represented as the serialization <code>1,2,#,#,3,4,#,#,5,#,#</code>, which is a unique representation of the tree.</p>\n<p><strong>Algorithm</strong></p>\n<p>Perform a depth-first search, where the recursive function returns the serialization of the tree.  At each node, record the result in a map, and analyze the map after to determine duplicate subtrees.</p>\n<iframe frameborder="0" height="378" name="4UyWd7Zu" src="https://leetcode.com/playground/4UyWd7Zu/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script>, where <script type="math/tex; mode=display">N</script> is the number of nodes in the tree.  We visit each node once, but each creation of <code>serial</code> may take <script type="math/tex; mode=display">O(N)</script> work.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N^2)</script>, the size of <code>count</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-unique-identifier-accepted">Approach #2: Unique Identifier [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Suppose we have a unique identifier for subtrees: two subtrees are the same if and only if they have the same id.</p>\n<p>Then, for a node with left child id of <code>x</code> and right child id of <code>y</code>, <code>(node.val, x, y)</code> uniquely determines the tree.</p>\n<p><strong>Algorithm</strong></p>\n<p>If we have seen the triple <code>(node.val, x, y)</code> before, we can use the identifier we\'ve remembered.  Otherwise, we\'ll create a new one.</p>\n<iframe frameborder="0" height="480" name="sgdon7Zu" src="https://leetcode.com/playground/sgdon7Zu/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the number of nodes in the tree.  We visit each node once.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>.  Every structure we use is using <script type="math/tex; mode=display">O(1)</script> storage per node.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.  Approach #2 inspired by <a href="https://discuss.leetcode.com/topic/97625/o-n-time-and-space-lots-of-analysis">@StefanPochmann</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '653',
    name: 'Two Sum IV - Input is a BST',
    acceptance: '50.2%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\nTarget = 9\n\n<b>Output:</b> True\n</pre>\n<p></p>\n\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\nTarget = 28\n\n<b>Output:</b> False\n</pre>\n<p></p>\n\n\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-hashsetaccepted">Approach #1 Using HashSet[Accepted]</a></li>\n<li><a href="#approach-2-using-bfs-and-hashset-accepted">Approach #2 Using BFS and HashSet [Accepted]</a></li>\n<li><a href="#approach-3-using-bst-accepted">Approach #3 Using BST [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-hashsetaccepted">Approach #1 Using HashSet[Accepted]</h4>\n<p>The simplest solution will be to traverse over the whole tree and consider every possible pair of nodes to determine if they can form the required sum <script type="math/tex; mode=display">k</script>. But, we can improve the process if we look at a little catch here.</p>\n<p>If the sum of two elements <script type="math/tex; mode=display">x + y</script> equals <script type="math/tex; mode=display">k</script>, and we already know that <script type="math/tex; mode=display">x</script> exists in the given tree, we only need to check if an element <script type="math/tex; mode=display">y</script> exists in the given tree, such that <script type="math/tex; mode=display">y = k - x</script>. Based on this simple catch, we can traverse the tree in both the directions(left child and right child) at every step. We keep a track of the elements which have been found so far during the tree traversal, by putting them into a <script type="math/tex; mode=display">set</script>. </p>\n<p>For every current node with a value of <script type="math/tex; mode=display">p</script>, we check if <script type="math/tex; mode=display">k-p</script> already exists in the array. If so, we can conclude that the sum <script type="math/tex; mode=display">k</script> can be formed by using the two elements from the given tree. Otherwise, we put this value <script type="math/tex; mode=display">p</script> into the <script type="math/tex; mode=display">set</script>.</p>\n<p>If even after the whole tree\'s traversal, no such element <script type="math/tex; mode=display">p</script> can be found, the sum <script type="math/tex; mode=display">k</script> can\'t be formed by using any two elements.</p>\n<iframe frameborder="0" height="309" name="NwhifNbv" src="https://leetcode.com/playground/NwhifNbv/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. The entire tree is traversed only once in the worst case. Here, <script type="math/tex; mode=display">n</script> refers to the number of nodes in the given tree.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The size of the <script type="math/tex; mode=display">set</script> can grow upto <script type="math/tex; mode=display">n</script> in the worst case.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-bfs-and-hashset-accepted">Approach #2 Using BFS and HashSet [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, the idea of using the <script type="math/tex; mode=display">set</script> is the same as in the last approach. But, we can carry on the traversal in a Breadth First Search manner, which is a very common traversal method used in Trees. The way BFS is used can be summarized as given below. We start by putting the root node into a <script type="math/tex; mode=display">queue</script>. We also maintain a <script type="math/tex; mode=display">set</script> similar to the last approach. Then, at every step, we do as follows:</p>\n<ol>\n<li>\n<p>Remove an element, <script type="math/tex; mode=display">p</script>,  from the front of the <script type="math/tex; mode=display">queue</script>. </p>\n</li>\n<li>\n<p>Check if the element <script type="math/tex; mode=display">k-p</script> already exists in the <script type="math/tex; mode=display">set</script>. If so, return True.</p>\n</li>\n<li>\n<p>Otherwise, add this element, <script type="math/tex; mode=display">p</script> to the <script type="math/tex; mode=display">set</script>. Further, add the right and the left child nodes of the current node to the back of the <script type="math/tex; mode=display">queue</script>.</p>\n</li>\n<li>\n<p>Continue steps 1. to 3. till the <script type="math/tex; mode=display">queue</script> becomes empty. </p>\n</li>\n<li>\n<p>Return false if the <script type="math/tex; mode=display">queue</script> becomes empty.</p>\n</li>\n</ol>\n<p>By following this process, we traverse the tree on a level by level basis. </p>\n<iframe frameborder="0" height="377" name="7SgfKz2F" src="https://leetcode.com/playground/7SgfKz2F/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We need to traverse over the whole tree once in the worst case.  Here, <script type="math/tex; mode=display">n</script> refers to the number of nodes in the given tree.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The size of the <script type="math/tex; mode=display">set</script> can grow atmost upto <script type="math/tex; mode=display">n</script>. </p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-bst-accepted">Approach #3 Using BST [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In this approach, we make use of the fact that the given tree is a Binary  Search Tree. Now, we know that the inorder traversal of a BST gives the nodes in ascending order. Thus, we do the inorder traversal of the given tree and put the results in a <script type="math/tex; mode=display">list</script> which contains the nodes sorted in ascending order.</p>\n<p>Once this is done, we make use of two pointers <script type="math/tex; mode=display">l</script> and <script type="math/tex; mode=display">r</script> pointing to the beginning and the end of the sorted <script type="math/tex; mode=display">list</script>. Then, we do as follows:</p>\n<ol>\n<li>\n<p>Check if the sum of the elements pointed by <script type="math/tex; mode=display">l</script> and <script type="math/tex; mode=display">r</script> is equal to the required sum <script type="math/tex; mode=display">k</script>. If so, return a True immediately.</p>\n</li>\n<li>\n<p>Otherwise, if the sum of the current two elements is lesser than the required sum <script type="math/tex; mode=display">k</script>, update <script type="math/tex; mode=display">l</script> to point to the next element. This is done, because, we need to increase the sum of the current elements, which can only be done by increasing the smaller number.</p>\n</li>\n<li>\n<p>Otherwise, if the sum of the current two elements is larger than the required sum <script type="math/tex; mode=display">k</script>, update <script type="math/tex; mode=display">r</script> to point to the previous element. This is done, because, we need to decrease the sum of the current elements, which can only be done by reducing the larger number. </p>\n</li>\n<li>\n<p>Continue steps 1. to 3. till the left pointer <script type="math/tex; mode=display">l</script> crosses the right pointer <script type="math/tex; mode=display">r</script>.</p>\n</li>\n<li>\n<p>If the two pointers cross each other, return a False value.</p>\n</li>\n</ol>\n<p>Note that we need not increase the larger number or reduce the smaller number in any case. This happens because, in case, a number larger than the current <script type="math/tex; mode=display">list[r]</script> is needed to form the required sum <script type="math/tex; mode=display">k</script>, the right pointer could not have been reduced in the first place. The similar argument holds true for not reducing the smaller number as well.</p>\n<iframe frameborder="0" height="462" name="chZDDTAy" src="https://leetcode.com/playground/chZDDTAy/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n)</script>. We need to traverse over the whole tree once to do the inorder traversal.  Here, <script type="math/tex; mode=display">n</script> refers to the number of nodes in the given tree.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The sorted <script type="math/tex; mode=display">list</script> will contain <script type="math/tex; mode=display">n</script> elements.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Facebook', 'Samsung'],
  },
  {
    id: '654',
    name: 'Maximum Binary Tree',
    acceptance: '70.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven an integer array with no duplicates. A maximum tree building on this array is defined as follow:\n</p><ol>\n<li>The root is the maximum number in the array. </li>\n<li>The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.</li>\n<li>The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.</li> \n</ol>\n<p></p>\n\n<p>\nConstruct the maximum tree by the given array and output the root node of this tree.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [3,2,1,6,0,5]\n<b>Output:</b> return the tree root node representing the following tree:\n\n      6\n    /   \\\n   3     5\n    \\    / \n     2  0   \n       \\\n        1\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The size of the given array will be in the range [1,1000].</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-recursive-solutionaccepted">Approach #1 Recursive Solution[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-recursive-solutionaccepted">Approach #1 Recursive Solution[Accepted]</h4>\n<p>The current solution is very simple. We make use of a function <code>construct(nums, l, r)</code>, which returns the maximum binary tree consisting of numbers within the indices <script type="math/tex; mode=display">l</script> and <script type="math/tex; mode=display">r</script> in the given <script type="math/tex; mode=display">nums</script> array(excluding the <script type="math/tex; mode=display">r^{th}</script> element).</p>\n<p>The algorithm consists of the following steps:</p>\n<ol>\n<li>\n<p>Start with the function call <code>construct(nums, 0, n)</code>. Here, <script type="math/tex; mode=display">n</script> refers to the number of elements in the given <script type="math/tex; mode=display">nums</script> array.</p>\n</li>\n<li>\n<p>Find the index, <script type="math/tex; mode=display">max_i</script>, of the largest element in the current range of indices <script type="math/tex; mode=display">(l:r-1)</script>. Make this largest element, $<script type="math/tex; mode=display">nums[max_i]</script> as the local root node.</p>\n</li>\n<li>\n<p>Determine the left child using <code>construct(nums, l, max_i)</code>. Doing this recursively finds the largest element in the subarray left to the current largest element.</p>\n</li>\n<li>\n<p>Similarly, determine the right child using <code>construct(nums, max_i + 1, r)</code>.</p>\n</li>\n<li>\n<p>Return the root node to the calling function.</p>\n</li>\n</ol>\n<iframe frameborder="0" height="428" name="j4QpdWko" src="https://leetcode.com/playground/j4QpdWko/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n^2)</script>. The function <code>construct</code> is called <script type="math/tex; mode=display">n</script> times. At each level of the recursive tree, we traverse over all the <script type="math/tex; mode=display">n</script> elements to find the maximum element.  In the average case, there will be a <script type="math/tex; mode=display">log(n)</script> levels leading to a complexity of <script type="math/tex; mode=display">O\\big(nlog(n)\\big)</script>. In the worst case, the depth of the recursive tree can grow upto <script type="math/tex; mode=display">n</script>, which happens in the case of a sorted <script type="math/tex; mode=display">nums</script> array, giving a complexity of <script type="math/tex; mode=display">O(n^2)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The size of the <script type="math/tex; mode=display">set</script> can grow upto <script type="math/tex; mode=display">n</script> in the worst case. In the average case, the size will be <script type="math/tex; mode=display">log(n)</script> for <script type="math/tex; mode=display">n</script> elements in <script type="math/tex; mode=display">nums</script>, giving an average case complexity of <script type="math/tex; mode=display">O(log(n))</script>\n</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Microsoft'],
  },
  {
    id: '655',
    name: 'Print Binary Tree',
    acceptance: '49.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Print a binary tree in an m*n 2D string array following these rules: </p>\n\n<ol>\n<li>The row number <code>m</code> should be equal to the height of the given binary tree.</li>\n<li>The column number <code>n</code> should always be an odd number.</li>\n<li>The root node\'s value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (<b>left-bottom part and right-bottom part</b>). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don\'t need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don\'t need to leave space for both of them. </li>\n<li>Each unused space should contain an empty string <code>""</code>.</li>\n<li>Print the subtrees following the same rules.</li>\n</ol>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>\n     1\n    /\n   2\n<b>Output:</b>\n[["", "1", ""],\n ["2", "", ""]]\n</pre>\n<p></p>\n\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b>\n     1\n    / \\\n   2   3\n    \\\n     4\n<b>Output:</b>\n[["", "", "", "1", "", "", ""],\n ["", "2", "", "", "", "3", ""],\n ["", "", "4", "", "", "", ""]]\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b>\n      1\n     / \\\n    2   5\n   / \n  3 \n / \n4 \n<b>Output:</b>\n\n[["",  "",  "", "",  "", "", "", "1", "",  "",  "",  "",  "", "", ""]\n ["",  "",  "", "2", "", "", "", "",  "",  "",  "",  "5", "", "", ""]\n ["",  "3", "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]\n ["4", "",  "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]]\n</pre>\n<p></p>\n\n<p><b>Note:</b>\nThe height of binary tree is in the range of [1, 10].\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-recursive-solutionaccepted">Approach #1 Recursive Solution[Accepted]</a></li>\n<li><a href="#approach-2-using-queuebfsaccepted">Approach #2 Using queue(BFS)[Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-recursive-solutionaccepted">Approach #1 Recursive Solution[Accepted]</h4>\n<p>We start by initializing a <script type="math/tex; mode=display">res</script> array with the dimensions being <script type="math/tex; mode=display">height</script>x<script type="math/tex; mode=display">2^{height}-1</script>. Here, <script type="math/tex; mode=display">height</script> refers to the number of levels in the given tree. In order to fill this <script type="math/tex; mode=display">res</script> array with the required elements, initially, we fill the complete array with <code>""</code> .  After this we make use of a recursive function <code>fill(res, root, i, l, r)</code> which fills the <script type="math/tex; mode=display">res</script> array such that the current element has to be filled in <script type="math/tex; mode=display">i^{th}</script> row, and the column being the middle of the indices <script type="math/tex; mode=display">l</script> and <script type="math/tex; mode=display">r</script>, where <script type="math/tex; mode=display">l</script> and <script type="math/tex; mode=display">r</script> refer to the left and the right boundaries of the columns in which the current element can be filled.</p>\n<p>In every recursive call, we do as follows:</p>\n<ol>\n<li>\n<p>If we\'ve reached the end of the tree, i.e. if root==null, return.</p>\n</li>\n<li>\n<p>Determine the column in which the current element(<script type="math/tex; mode=display">root</script>) needs to be filled, which is the middle of <script type="math/tex; mode=display">l</script> and <script type="math/tex; mode=display">r</script>, given by say, <script type="math/tex; mode=display">j</script>. The row number is same as <script type="math/tex; mode=display">i</script>. Put the current element at <script type="math/tex; mode=display">res[i][j]</script>.</p>\n</li>\n<li>\n<p>Make the recursive call for the left child of the <script type="math/tex; mode=display">root</script> using <code>fill(res, root.left, i + 1, l, (l + r) / 2)</code>.</p>\n</li>\n<li>\n<p>Make the recursive call for the right child of the <script type="math/tex; mode=display">root</script> using <code>fill(res, root.right, i + 1, (l + r + 1) / 2, r)</code>.</p>\n</li>\n</ol>\n<p>Note, that in the last two recursive calls, we update the row number(level of the tree). This ensures that the child nodes fit into the correct row. We also update the column boundaries appropriately based on the <script type="math/tex; mode=display">l</script> and <script type="math/tex; mode=display">r</script> values.</p>\n<p>Further, to determine the <script type="math/tex; mode=display">height</script> also, we make use of recursive funtion <code>getHeight(root)</code>, which returns the height of the tree starting from the <script type="math/tex; mode=display">root</script> node. We traverse into all the branches possible in the tree recursively and find the depth of the longest branch.</p>\n<p>At the end, we convert the <script type="math/tex; mode=display">res</script> array into the required list format, before returning the results.</p>\n<iframe frameborder="0" height="479" name="ncTFx4nd" src="https://leetcode.com/playground/ncTFx4nd/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(h*2^h)</script>. We need to fill the <script type="math/tex; mode=display">res</script> array of size <script type="math/tex; mode=display">h</script>x<script type="math/tex; mode=display">2^h - 1</script>. Here, <script type="math/tex; mode=display">h</script> refers to the height of the given tree.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(h*2^h)</script>.  <script type="math/tex; mode=display">res</script> array of size <script type="math/tex; mode=display">h</script>x<script type="math/tex; mode=display">2^h - 1</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-queuebfsaccepted">Approach #2 Using queue(BFS)[Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>We can also solve the problem by making use of Breadth First Search\'s idea. For this, we make use of a class <script type="math/tex; mode=display">Params</script> which stores the parameters of a <script type="math/tex; mode=display">node</script> of  the tree, including its value, its level in the tree(<script type="math/tex; mode=display">i</script>), and the left(<script type="math/tex; mode=display">l</script>) and right(<script type="math/tex; mode=display">r</script>) boundaries of the columns in which this element can be filled in the result to be returned.</p>\n<p>We start by initializing a <script type="math/tex; mode=display">res</script> array as in the previous approach. After this, we add the parametrized <script type="math/tex; mode=display">root</script> of the tree into a <script type="math/tex; mode=display">queue</script>. After this, we do the following at every step.</p>\n<ol>\n<li>\n<p>Remove an element, $$p$,  from the front of the <script type="math/tex; mode=display">queue</script>. </p>\n</li>\n<li>\n<p>Add this element at its correct position in the <script type="math/tex; mode=display">res</script> array given by <script type="math/tex; mode=display">res[p.i][(p.l + p.r) / 2]</script>. Here, the values <script type="math/tex; mode=display">i</script>, <script type="math/tex; mode=display">l</script> and <script type="math/tex; mode=display">r</script> refer to the column/level number, and the left and right boundaries permissible for putting the current node into <script type="math/tex; mode=display">res</script>. These are obtained from the node\'s parameters, which have been associated with it before putting it into the <script type="math/tex; mode=display">queue</script>.</p>\n</li>\n<li>\n<p>If the left child of <script type="math/tex; mode=display">p</script> exists, put it at the back of the <script type="math/tex; mode=display">queue</script>, in a parametized form, by appropriately updating the level as the next level and the boundaries permissible as well.</p>\n</li>\n<li>\n<p>If the right child of <script type="math/tex; mode=display">p</script> exists, put it at the back of the <script type="math/tex; mode=display">queue</script>, in a parametized form, by appropriately updating the level as the next level and the boundaries permissible as well.</p>\n</li>\n<li>\n<p>Continue steps 1. to 4. till the <script type="math/tex; mode=display">queue</script> becomes empty. </p>\n</li>\n</ol>\n<p>At the end, we again convert the <script type="math/tex; mode=display">res</script> array into the required list format, before returning the results.</p>\n<iframe frameborder="0" height="515" name="jb3EALV4" src="https://leetcode.com/playground/jb3EALV4/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(h*2^h)</script>. We need to fill the <script type="math/tex; mode=display">res</script> array of size <script type="math/tex; mode=display">h</script>x<script type="math/tex; mode=display">2^h - 1</script>. Here, <script type="math/tex; mode=display">h</script> refers to the height of the given tree.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(h*2^h)</script>.  <script type="math/tex; mode=display">res</script> array of size <script type="math/tex; mode=display">h</script>x<script type="math/tex; mode=display">2^h - 1</script> is used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Poynt'],
  },
  {
    id: '656',
    name: 'Coin Path ',
    acceptance: '25.5%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>\nGiven an array <code>A</code> (index starts at <code>1</code>) consisting of N integers: A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>&nbsp;and an integer <code>B</code>. The integer <code>B</code> denotes that from any place (suppose the index is <code>i</code>) in the array <code>A</code>, you can jump to any one of the place in the array <code>A</code> indexed <code>i+1</code>, <code>i+2</code>, …, <code>i+B</code> if this place can be jumped to. Also, if you step on the index <code>i</code>, you have to pay A<sub>i</sub>&nbsp;coins. If A<sub>i</sub>&nbsp;is -1, it means you can’t jump to the place indexed <code>i</code> in the array.\n</p>\n\n<p>\nNow, you start from the place indexed <code>1</code> in the array <code>A</code>, and your aim is to reach the place indexed <code>N</code> using the minimum coins. You need to return the path of indexes (starting from 1 to N) in the array you should take to get to the place indexed <code>N</code> using minimum coins.\n</p>\n\n<p>\nIf there are multiple paths with the same cost, return the lexicographically smallest such path.\n</p>\n<p>\nIf it's not possible to reach the place indexed N then you need to return an empty array.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,2,4,-1,2], 2\n<b>Output:</b> [1,3,5]\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [1,2,4,-1,2], 1\n<b>Output:</b> []\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>Path Pa<sub>1</sub>, Pa<sub>2</sub>, ..., Pa<sub>n</sub>&nbsp;is lexicographically smaller than Pb<sub>1</sub>, Pb<sub>2</sub>, ..., Pb<sub>m</sub>, if and only if at the first <code>i</code> where Pa<sub>i</sub>&nbsp;and Pb<sub>i</sub>&nbsp;differ, Pa<sub>i</sub>&nbsp;&lt; Pb<sub>i</sub>; when no such&nbsp;<code>i</code>&nbsp;exists, then&nbsp;<code>n</code> &lt; <code>m</code>.</li>\n<li>A<sub>1</sub> &gt;= 0. A<sub>2</sub>, ..., A<sub>N</sub> (if exist) will in the range of [-1, 100]. </li>\n<li>Length of A is in the range of [1, 1000].</li>\n<li>B is in the range of [1, 100].</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-forcetime-limit-exceeded">Approach #1 Brute Force[Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-using-memoization-accepted">Approach #2 Using Memoization [Accepted]</a></li>\n<li><a href="#approach-3-using-dynamic-programming-accepted">Approach #3 Using Dynamic Programming [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-forcetime-limit-exceeded">Approach #1 Brute Force[Time Limit Exceeded]</h4>\n<p>In this approach, we make use of a <script type="math/tex; mode=display">next</script> array of size <script type="math/tex; mode=display">n</script>. Here, <script type="math/tex; mode=display">n</script> refers to the size of the given <script type="math/tex; mode=display">A</script> array. The array <script type="math/tex; mode=display">nums</script> is used such that <script type="math/tex; mode=display">nums[i]</script> is used to store the minimum number of coins needed to jump till the end of the array <script type="math/tex; mode=display">A</script>, starting from the index <script type="math/tex; mode=display">i</script>. </p>\n<p>We start by filling the <script type="math/tex; mode=display">next</script> array with all -1\'s. Then, in order to fill this <script type="math/tex; mode=display">next</script> array, we make use of a recursive function <code>jump(A, B, i, next)</code> which fills the <script type="math/tex; mode=display">next</script> array starting from the index <script type="math/tex; mode=display">i</script> onwards, given <script type="math/tex; mode=display">A</script> as the coins array and <script type="math/tex; mode=display">B</script> as the largest jump value.</p>\n<p>With <script type="math/tex; mode=display">i</script> as the current index, we can consider every possible index from <script type="math/tex; mode=display">i+1</script> to <script type="math/tex; mode=display">i+B</script> as the next place to be jumped to. For every such next index, <script type="math/tex; mode=display">j</script>, if this place can be jumped to, we determine the cost of reaching the end of the array starting from the index <script type="math/tex; mode=display">i</script>, and with <script type="math/tex; mode=display">j</script> as the next index jumped from <script type="math/tex; mode=display">i</script>, as  <script type="math/tex; mode=display">A[i] + jump(A, B, j, next)</script>. If this cost is lesser than the minimum cost required till now, for the same starting index, we can update the minimum cost and the value of <script type="math/tex; mode=display">next[i]</script> as well. </p>\n<p>For every such function call, we also need to return this minimum cost.</p>\n<p>At the end, we traverse over the <script type="math/tex; mode=display">next</script> array starting from the index 1. At every step, we add the current index to the <script type="math/tex; mode=display">res</script> list to be returned and also jump/move to the index pointed by <script type="math/tex; mode=display">next[i]</script>, since this refers to the next index for the minimum cost. We continue in the same manner till we reach the end of the array <script type="math/tex; mode=display">A</script>.</p>\n<iframe frameborder="0" height="515" name="9tcSoGzo" src="https://leetcode.com/playground/9tcSoGzo/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(B^n)</script>. The size of the recursive tree can grow upto <script type="math/tex; mode=display">O(b^n)</script> in the worst case. This is because, we have <script type="math/tex; mode=display">B</script> possible branches at every step. Here, <script type="math/tex; mode=display">B</script> refers to the limit of the largest jump and <script type="math/tex; mode=display">n</script> refers to the size of the given <script type="math/tex; mode=display">A</script> array. </p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of the recursive tree can grow upto <script type="math/tex; mode=display">n</script>. <script type="math/tex; mode=display">next</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-memoization-accepted">Approach #2 Using Memoization [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>In the recursive solution just discussed, a lot of duplicate function calls are made, since we are considering the same index through multiple paths. To remove this redundancy, we can make use of memoization.</p>\n<p>We keep a <script type="math/tex; mode=display">memo</script> array, such that <script type="math/tex; mode=display">memo[i]</script> is used to store the minimum cost of jumps to reach the end of the array <script type="math/tex; mode=display">A</script>. Whenever the value for any index is calculated once, it is stored in its appropriate location. Thus, next time whenever the same function call is made, we can return the result directly from this <script type="math/tex; mode=display">memo</script> array, pruning the search space to a great extent.</p>\n<iframe frameborder="0" height="515" name="mAVq4r5H" src="https://leetcode.com/playground/mAVq4r5H/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nB)</script>. <script type="math/tex; mode=display">memo</script> array of size <script type="math/tex; mode=display">n</script> is filled only once. We also do a traversal over the <script type="math/tex; mode=display">next</script> array, which will go upto <script type="math/tex; mode=display">B</script> steps.  Here, <script type="math/tex; mode=display">n</script> refers to the number of nodes in the given tree.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. The depth of the recursive tree can grow upto <script type="math/tex; mode=display">n</script>. <script type="math/tex; mode=display">next</script> array of size <script type="math/tex; mode=display">n</script> is used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-using-dynamic-programming-accepted">Approach #3 Using Dynamic Programming [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>From the solutions discussed above, we can observe that the cost of jumping till the end of the array <script type="math/tex; mode=display">A</script> starting from the index <script type="math/tex; mode=display">i</script> is only dependent on the elements following the index <script type="math/tex; mode=display">i</script> and not the ones before it. This inspires us to make use of Dynamic Programming to solve the current problem.</p>\n<p>We again make use of a <script type="math/tex; mode=display">next</script> array to store the next jump locations. We also make use of a <script type="math/tex; mode=display">dp</script> with the same size as that of the given <script type="math/tex; mode=display">A</script> array. <script type="math/tex; mode=display">dp[i]</script> is used to store the minimum cost of jumping till the end of the array <script type="math/tex; mode=display">A</script>, starting from the index <script type="math/tex; mode=display">i</script>. We start with the last index as the current index and proceed backwards for filling the <script type="math/tex; mode=display">next</script> and <script type="math/tex; mode=display">dp</script> array.</p>\n<p>With <script type="math/tex; mode=display">i</script> as the current index, we consider all the next possible positions from <script type="math/tex; mode=display">i+1</script>, <script type="math/tex; mode=display">i+2</script>,..., <script type="math/tex; mode=display">i+B</script>, and determine the position, <script type="math/tex; mode=display">j</script>,  which leads to a minimum cost of reaching the end of <script type="math/tex; mode=display">A</script>, which is given by <script type="math/tex; mode=display">A[i]+dp[j]</script>. We update <script type="math/tex; mode=display">next[i]</script> with this corresponding index. We also update <script type="math/tex; mode=display">dp[i]</script> with the minimum cost, to be used by the previous indices\' cost calculations.</p>\n<p>At the end, we again jump over the indices as per the <script type="math/tex; mode=display">next</script> array and put these indices in the <script type="math/tex; mode=display">res</script> array to be returned.</p>\n<iframe frameborder="0" height="515" name="BMCVq3jo" src="https://leetcode.com/playground/BMCVq3jo/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(nB)</script>. We need to consider all the possible <script type="math/tex; mode=display">B</script> positions for every current index considered in the <script type="math/tex; mode=display">A</script> array. Here, <script type="math/tex; mode=display">A</script> refers to the number of elements in <script type="math/tex; mode=display">A</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(n)</script>. <script type="math/tex; mode=display">dp</script> and <script type="math/tex; mode=display">next</script> array of size <script type="math/tex; mode=display">n</script> are used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/vinod23">@vinod23</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '657',
    name: 'Judge Route Circle',
    acceptance: '68.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nInitially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to <b>the original place</b>. \n</p>\n\n<p>\nThe move sequence is represented by a string. And each move is represent by a character. The valid robot moves are <code>R</code> (Right), <code>L</code> (Left), <code>U</code> (Up) and <code>D</code> (down). The output should be true or false representing whether the robot makes a circle.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "UD"\n<b>Output:</b> true\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> "LL"\n<b>Output:</b> false\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-simulation-accepted">Approach #1: Simulation [Accepted]</a></li>\n</ul>\n</div>\n<hr>\n<h4 id="approach-1-simulation-accepted">Approach #1: Simulation [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can simulate the position of the robot after each command.</p>\n<p><strong>Algorithm</strong></p>\n<p>Initially, the robot is at <code>(x, y) = (0, 0)</code>.  If the move is <code>\'U\'</code>, the robot goes to <code>(x, y-1)</code>; if the move is <code>\'R\'</code>, the robot goes to <code>(x, y) = (x+1, y)</code>, and so on.</p>\n<iframe frameborder="0" height="259" name="9w36FnNS" src="https://leetcode.com/playground/9w36FnNS/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>moves</code>.  We iterate through the string.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>.  In Java, our character array is <script type="math/tex; mode=display">O(N)</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '658',
    name: 'Find K Closest Elements',
    acceptance: '35.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a sorted array, two integers <code>k</code> and <code>x</code>, find the <code>k</code> closest elements to <code>x</code> in the array.  The result should also be sorted in ascending order.\nIf there is a tie,  the smaller elements are always preferred.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,2,3,4,5], k=4, x=3\n<b>Output:</b> [1,2,3,4]\n</pre>\n<p></p>\n\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [1,2,3,4,5], k=4, x=-1\n<b>Output:</b> [1,2,3,4]\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The value k is positive and will always be smaller than the length of the sorted array.</li>\n<li> Length of the given array is positive and will not exceed 10<sup>4</sup></li>\n<li> Absolute value of elements in the array and x will not exceed 10<sup>4</sup></li>\n</ol>\n<p></p>\n\n<hr>\n\n<p>\n<b><font color="red">UPDATE (2017/9/19):</font></b><br>\nThe <i>arr</i> parameter had been changed to an <b>array of integers</b> (instead of a list of integers). <b><i>Please reload the code definition to get the latest changes</i></b>.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-using-collectionsort-accepted">Approach #1 Using Collection.sort( ) [Accepted]</a></li>\n<li><a href="#approach-2-using-binary-search-and-two-pointers-accepted">Approach #2 Using Binary Search and Two Pointers [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-using-collectionsort-accepted">Approach #1 Using Collection.sort( ) [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>Intuitively, we can sort the elements in list <code>arr</code> by their absolute difference values to the target <code>x</code>. Then the sublist of the first k elements is the result after sorting the elements by the natural order.</p>\n<iframe frameborder="0" height="156" name="5B68PpKj" src="https://leetcode.com/playground/5B68PpKj/shared" width="100%"></iframe>\n<p>Note: This solution is inspired by <a href="https://discuss.leetcode.com/user/compton_scatter">@compton_scatter</a>.</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(n*log(n))</script>. Collections.sort() uses binary sort so it has a <script type="math/tex; mode=display">O(n*log(n))</script> complexity.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(k)</script>. The in-place sorting does not consume any extra space. However, generating a k length sublist will take some space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-using-binary-search-and-two-pointers-accepted">Approach #2 Using Binary Search and Two Pointers [Accepted]</h4>\n<p><strong>Algorithm</strong></p>\n<p>The original array has been sorted so we can take this advantage by the following steps.\n1. If the target <code>x</code> is less or equal than the first element in the sorted array, the first <code>k</code> elements are the result.\n2. Similarly, if the target <code>x</code> is more or equal than the last element in the sorted array, the last <code>k</code> elements are the result.\n3. Otherwise, we can use binary search to find the <code>index</code> of the element, which is equal (when this list has <code>x</code>) or a little bit larger than <code>x</code> (when this list does not have it). Then set <code>low</code> to its left <code>k-1</code> position, and <code>high</code> to the right <code>k-1</code> position of this <code>index</code> as a start. The desired k numbers must in this rang [index-k-1, index+k-1]. So we can shrink this range to get the result using the following rules.\n    * If <code>low</code> reaches the lowest index <code>0</code> or the <code>low</code> element is closer to <code>x</code> than the <code>high</code> element, decrease the <code>high</code> index.\n    * If <code>high</code> reaches to the highest index <code>arr.size()-1</code> or it is nearer to <code>x</code> than the <code>low</code> element, increase the <code>low</code> index.\n    * The looping ends when there are exactly k elements in [low, high], the subList of which is the result.</p>\n<iframe frameborder="0" height="479" name="sqToH7AR" src="https://leetcode.com/playground/sqToH7AR/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(log(n)+k)</script>. <script type="math/tex; mode=display">O(log(n))</script> is for the time of binary search, while <script type="math/tex; mode=display">O(k)</script> is for shrinking the index range to k elements.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(k)</script>. It is to generate the required sublist.</p>\n</li>\n</ul>\n<p>Analysis written by: <a href="https://discuss.leetcode.com/user/mr-bin">@Mr.Bin</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '659',
    name: 'Split Array into Consecutive Subsequences',
    acceptance: '36.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>You are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers. Return whether you can make such a split.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,2,3,3,4,5]\n<b>Output:</b> True\n<b>Explanation:</b>\nYou can split them into two consecutive subsequences : \n1, 2, 3\n3, 4, 5\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [1,2,3,3,4,4,5,5]\n<b>Output:</b> True\n<b>Explanation:</b>\nYou can split them into two consecutive subsequences : \n1, 2, 3, 4, 5\n3, 4, 5\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> [1,2,3,4,4,5]\n<b>Output:</b> False\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The length of the input is in range of [1, 10000]</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-opening-and-closing-events-accepted">Approach #1: Opening and Closing Events [Accepted]</a></li>\n<li><a href="#approach-2-greedy-accepted">Approach #2: Greedy [Accepted]</a></li>\n</ul>\n</div>\n<hr>\n<h4 id="approach-1-opening-and-closing-events-accepted">Approach #1: Opening and Closing Events [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can think of the problem as drawing intervals on a number line.  This gives us the idea of opening and closing events.</p>\n<p>To illustrate this concept, say we have <code>nums = [10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13]</code>, with no <code>9</code>s and no <code>14</code>s.  We must have two sequences start at 10, two sequences start at 11, and 3 sequences end at 12.</p>\n<p>In general, when considering a chain of consecutive integers <code>x</code>, we must have <code>C = count[x+1] - count[x]</code> sequences start at <code>x+1</code> when <code>C &gt; 0</code>, and <code>-C</code> sequences end at <code>x</code> if <code>C &lt; 0</code>.  Even if there are more endpoints on the intervals we draw, there must be at least this many endpoints.</p>\n<p>Also, if for example we know some sequences must start at time <code>1</code> and <code>4</code> and some sequences end at <code>5</code> and <code>7</code>, to maximize the smallest length sequence, we should pair the events together in the order they occur: ie., <code>1</code> with <code>5</code> and <code>4</code> with <code>7</code>.</p>\n<p><strong>Algorithm</strong></p>\n<p>For each group of numbers, say the number is <code>x</code> and there are <code>count</code> of them.  Furthermore, say <code>prev, prev_count</code> is the previous integer encountered and it\'s count.</p>\n<p>Then, in general there are <code>abs(count - prev_count)</code> events that will happen: if <code>count &gt; prev_count</code> then we will add this many <code>t</code>\'s to <code>starts</code>; and if <code>count &lt; prev_count</code> then we will attempt to pair <code>starts.popleft()</code> with <code>t-1</code>.</p>\n<p>More specifically, when we have finished a consecutive group, we will have <code>prev_count</code> endings; and when we are in a consecutive group, we may have <code>count - prev_count</code> starts or <code>prev_count - count</code> endings.</p>\n<p>For example, when <code>nums = [1,2,3,3,4,5]</code>, then the starts are at <code>[1, 3]</code> and the endings are at <code>[3, 5]</code>.  As our algorithm progresses:</p>\n<ul>\n<li>When <code>t = 1, count = 1</code>: <code>starts = [1]</code></li>\n<li>When <code>t = 2, count = 1</code>: <code>starts = [1]</code></li>\n<li>When <code>t = 3, count = 2</code>: <code>starts = [1, 3]</code></li>\n<li>When <code>t = 4, count = 1</code>: <code>starts = [3]</code>, since <code>prev_count - count = 1</code> we process one closing event, which is accepted as <code>t-1 &gt;= starts.popleft() + 2</code>.</li>\n<li>When <code>t = 5, count = 1</code>: <code>starts = [3]</code></li>\n</ul>\n<p>And at the end, we process <code>prev_count</code> more closing events <code>nums[-1]</code>.</p>\n<iframe frameborder="0" height="500" name="f738FxSm" src="https://leetcode.com/playground/f738FxSm/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>.  We iterate over the array and every event is added or popped to <code>starts</code> at most once.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of <code>starts</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-greedy-accepted">Approach #2: Greedy [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Call a <em>chain</em> a sequence of 3 or more consecutive numbers.</p>\n<p>Considering numbers <code>x</code> from left to right, if <code>x</code> can be added to a current chain, it\'s at least as good to add <code>x</code> to that chain first, rather than to start a new chain.</p>\n<p>Why?  If we started with numbers <code>x</code> and greater from the beginning, the shorter chains starting from <code>x</code> could be concatenated with the chains ending before <code>x</code>, possibly helping us if there was a "chain" from <code>x</code> that was only length 1 or 2.</p>\n<p><strong>Algorithm</strong></p>\n<p>Say we have a count of each number, and let <code>tails[x]</code> be the number of chains ending right before <code>x</code>.</p>\n<p>Now let\'s process each number.  If there\'s a chain ending before <code>x</code>, then add it to that chain.  Otherwise, if we can start a new chain, do so.</p>\n<p>It\'s worth noting that our solution can be amended to take only <script type="math/tex; mode=display">O(1)</script> additional space, since we could do our counts similar to <em>Approach #1</em>, and we only need to know the last 3 counts at a time.</p>\n<iframe frameborder="0" height="500" name="J6zXVCne" src="https://leetcode.com/playground/J6zXVCne/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>.  We iterate over the array.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of <code>count</code> and <code>tails</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.  Approach #2 inspired by <a href="https://discuss.leetcode.com/topic/99187/java-o-n-time-o-n-space">@compton_scatter</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '660',
    name: 'Remove 9 ',
    acceptance: '48.1%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Start from integer 1, remove any integer that contains 9 such as 9, 19, 29... </p>\n\n<p>So now, you will have a new integer sequence: 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, ...</p>\n\n<p>Given a positive integer <code>n</code>, you need to return the n-th integer after removing. Note that 1 will be the first integer.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> 9\n<b>Output:</b> 10\n</pre>\n<p></p>\n\n<p>\n<b> Hint</b>: n will not exceed <code>9 x 10^8</code>.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-mathematical">Approach #1: Mathematical</a></li>\n</ul>\n</div>\n<hr>\n<h4 id="approach-1-mathematical">Approach #1: Mathematical</h4>\n<p><strong>Intuition</strong></p>\n<p>Let\'s write the first numbers and try to notice a pattern.  Those numbers are:</p>\n<div class="codehilite"><pre><span></span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>\n<span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span>\n<span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span>\n<span class="o">...</span>\n<span class="mi">80</span><span class="p">,</span> <span class="mi">81</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">84</span><span class="p">,</span> <span class="mi">85</span><span class="p">,</span> <span class="mi">86</span><span class="p">,</span> <span class="mi">87</span><span class="p">,</span> <span class="mi">88</span><span class="p">,</span>\n<span class="mi">100</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">102</span><span class="p">,</span> <span class="o">...</span>\n</pre></div>\n<p>These numbers look exactly like all base-9 numbers!</p>\n<p>Indeed, every base-9 number is a number in this sequence, and every number in this sequence is a base-9 number.  Both this sequence and the sequence of all base-9 numbers are in increasing order.  The answer is therefore just the n-th base-9 number.</p>\n<iframe frameborder="0" height="174" name="tGRiLEQb" src="https://leetcode.com/playground/tGRiLEQb/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(1)</script>, since <script type="math/tex; mode=display">N</script> has at most 9 digits.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Houzz'],
  },
  {
    id: '661',
    name: 'Image Smoother',
    acceptance: '45.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself.  If a cell has less than 8 surrounding cells, then use as many as you can.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>\n[[1,1,1],\n [1,0,1],\n [1,1,1]]\n<b>Output:</b>\n[[0, 0, 0],\n [0, 0, 0],\n [0, 0, 0]]\n<b>Explanation:</b>\nFor the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0\nFor the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0\nFor the point (1,1): floor(8/9) = floor(0.88888889) = 0\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The value in the given matrix is in the range of [0, 255].</li>\n<li>The length and width of the given matrix are in the range of [1, 150].</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-iterate-through-grid">Approach #1: Iterate Through Grid</a></li>\n</ul>\n</div>\n<hr>\n<h4 id="approach-1-iterate-through-grid">Approach #1: Iterate Through Grid</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>For each cell in the grid, look at the immediate neighbors - up to 9 of them, including the original cell.</p>\n<p>Then, we will add the sum of the neighbors into <code>ans[r][c]</code> while recording <code>count</code>, the number of such neighbors.  The final answer is the sum divided by the count.</p>\n<iframe frameborder="0" height="395" name="i8A5ppzu" src="https://leetcode.com/playground/i8A5ppzu/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the number of pixels in our image.  We iterate over every pixel.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of our answer.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '662',
    name: 'Maximum Width of Binary Tree',
    acceptance: '37.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a <b>full binary tree</b>, but some nodes are null. </p>\n\n<p>The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the <code>null</code> nodes between the end-nodes are also counted into the length calculation.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \n\n           1\n         /   \\\n        3     2\n       / \\     \\  \n      5   3     9 \n\n<b>Output:</b> 4\n<b>Explanation:</b> The maximum width existing in the third level with the length 4 (5,3,null,9).\n</pre>\n\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \n\n          1\n         /  \n        3    \n       / \\       \n      5   3     \n\n<b>Output:</b> 2\n<b>Explanation:</b> The maximum width existing in the third level with the length 2 (5,3).\n</pre>\n\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> \n\n          1\n         / \\\n        3   2 \n       /        \n      5      \n\n<b>Output:</b> 2\n<b>Explanation:</b> The maximum width existing in the second level with the length 2 (3,2).\n</pre>\n\n<p><b>Example 4:</b><br>\n</p><pre><b>Input:</b> \n\n          1\n         / \\\n        3   2\n       /     \\  \n      5       9 \n     /         \\\n    6           7\n<b>Output:</b> 8\n<b>Explanation:</b>The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).\n\n\n</pre>\n\n<p><b>Note:</b>\nAnswer will in the range of 32-bit signed integer.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-framework">Approach Framework</a></li>\n<li><a href="#approach-1-breadth-first-search-accepted">Approach #1: Breadth-First Search [Accepted]</a></li>\n<li><a href="#approach-2-depth-first-search-accepted">Approach #2: Depth-First Search [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-framework">Approach Framework</h4>\n<p><strong>Explanation</strong></p>\n<p>As we need to reach every node in the given tree, we will have to traverse the tree, either with a depth-first search, or with a breadth-first search.</p>\n<p>The main idea in this question is to give each node a <code>position</code> value. If we go down the left neighbor, then <code>position -&gt; position * 2</code>; and if we go down the right neighbor, then <code>position -&gt; position * 2 + 1</code>. This makes it so that when we look at the position values <code>L</code> and <code>R</code> of two nodes with the same depth, the width will be <code>R - L + 1</code>.</p>\n<hr>\n<h4 id="approach-1-breadth-first-search-accepted">Approach #1: Breadth-First Search [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Traverse each node in breadth-first order, keeping track of that node\'s position.  For each depth, the first node reached is the left-most, while the last node reached is the right-most.</p>\n<iframe frameborder="0" height="500" name="GsZid6zn" src="https://leetcode.com/playground/GsZid6zn/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script> where <script type="math/tex; mode=display">N</script> is the number of nodes in the input tree.  We traverse every node.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of our <code>queue</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-depth-first-search-accepted">Approach #2: Depth-First Search [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Traverse each node in depth-first order, keeping track of that node\'s position.  For each depth, the position of the first node reached of that depth will be kept in <code>left[depth]</code>.</p>\n<p>Then, for each node, a candidate width is <code>pos - left[depth] + 1</code>.  We take the maximum of the candidate answers.</p>\n<iframe frameborder="0" height="344" name="A9iKAcsQ" src="https://leetcode.com/playground/A9iKAcsQ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script> where <script type="math/tex; mode=display">N</script> is the number of nodes in the input tree.  We traverse every node.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of the implicit call stack in our DFS.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '663',
    name: 'Equal Tree Partition ',
    acceptance: '36.5%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nGiven a binary tree with <code>n</code> nodes, your task is to check if it's possible to partition the tree to two trees which have the equal sum of values after removing <b>exactly</b> one edge on the original tree.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>     \n    5\n   / \\\n  10 10\n    /  \\\n   2   3\n\n<b>Output:</b> True\n<b>Explanation:</b> \n    5\n   / \n  10\n      \nSum: 15\n\n   10\n  /  \\\n 2    3\n\nSum: 15\n</pre>\n<p></p>\n\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b>     \n    1\n   / \\\n  2  10\n    /  \\\n   2   20\n\n<b>Output:</b> False\n<b>Explanation:</b> You can't split the tree into two trees with equal sum after removing exactly one edge on the tree.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The range of tree node value is in the range of [-100000, 100000].</li>\n<li>1 &lt;= n &lt;= 10000</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>After removing some edge from <code>parent</code> to <code>child</code>, (where the <code>child</code> cannot be the original <code>root</code>) the subtree rooted at <code>child</code> must be half the sum of the entire tree.</p>\n<p>Let\'s record the sum of every subtree.  We can do this recursively using depth-first search.  After, we should check that half the sum of the entire tree occurs somewhere in our recording (and not from the total of the entire tree.)</p>\n<p>Our careful treatment and analysis above prevented errors in the case of these trees:</p>\n<div class="codehilite"><pre><span></span>  <span class="mi">0</span>\n <span class="o">/</span> \\\n<span class="o">-</span><span class="mi">1</span>  <span class="mi">1</span>\n\n <span class="mi">0</span>\n  \\\n   <span class="mi">0</span>\n</pre></div>\n<iframe frameborder="0" height="378" name="PfHZumnG" src="https://leetcode.com/playground/PfHZumnG/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script> where <script type="math/tex; mode=display">N</script> is the number of nodes in the input tree.  We traverse every node.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of <code>seen</code> and the implicit call stack in our DFS.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '664',
    name: 'Strange Printer',
    acceptance: '33.0%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nThere is a strange printer with the following two special requirements:\n\n</p><ol>\n<li>The printer can only print a sequence of the same character each time.</li>\n<li>At each turn, the printer can print new characters starting from and ending at any places, and will cover the original existing characters.</li>\n</ol>\n\n<p></p>\n\n<p>\nGiven a string consists of lower English letters only, your job is to count the minimum number of turns the printer needed in order to print it.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "aaabbb"\n<b>Output:</b> 2\n<b>Explanation:</b> Print "aaa" first and then print "bbb".\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> "aba"\n<b>Output:</b> 2\n<b>Explanation:</b> Print "aaa" first and then print "b" from the second place of the string, which will cover the existing character \'a\'.\n</pre>\n<p></p>\n\n<p><b>Hint</b>: Length of the given string will not exceed 100.</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>It is natural to consider letting <code>dp(i, j)</code> be the answer for printing <code>S[i], S[i+1], ..., S[j]</code>, but proceeding from here is difficult.  We need the following sequence of deductions:</p>\n<ul>\n<li>\n<p>Whatever turn creates the final print of <code>S[i]</code> might as well be the first turn, and also there might as well only be one print, since any later prints on interval <code>[i, k]</code> could just be on <code>[i+1, k]</code>.</p>\n</li>\n<li>\n<p>Say the first print is on <code>[i, k]</code>.  We can assume <code>S[i] == S[k]</code>, because if it wasn\'t, we could print up to the last occurrence of <code>S[i]</code> in <code>[i, k]</code> for the same result.</p>\n</li>\n<li>\n<p>When correctly printing everything in <code>[i, k]</code> (with <code>S[i] == S[k]</code>), it will take the same amount of steps as correctly printing everything in <code>[i, k-1]</code>.  This is because if <code>S[i]</code> and <code>S[k]</code> get completed in separate steps, we might as well print them first in one step instead.</p>\n</li>\n</ul>\n<p><strong>Algorithm</strong></p>\n<p>With the above deductions, the algorithm is straightforward.</p>\n<p>To compute a recursion for <code>dp(i, j)</code>, for every <code>i &lt;= k &lt;= j</code> with <code>S[i] == S[k]</code>, we have some candidate answer <code>dp(i, k-1) + dp(k+1, j)</code>, and we take the minimum of these candidates.  Of course, when <code>k = i</code>, the candidate is just <code>1 + dp(i+1, j)</code>.</p>\n<p>To avoid repeating work, we memoize our intermediate answers <code>dp(i, j)</code>.</p>\n<iframe frameborder="0" height="378" name="L3mAUr9w" src="https://leetcode.com/playground/L3mAUr9w/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^3)</script> where <script type="math/tex; mode=display">N</script> is the length of <code>s</code>.  For each of <script type="math/tex; mode=display">O(N^2)</script> possible states representing a subarray of <code>s</code>, we perform <script type="math/tex; mode=display">O(N)</script> work iterating through <code>k</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N^2)</script>, the size of our <code>memo</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['NetEase'],
  },
  {
    id: '665',
    name: 'Non-decreasing Array',
    acceptance: '20.9%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>\nGiven an array with <code>n</code> integers, your task is to check if it could become non-decreasing by modifying <b>at most</b> <code>1</code> element.\n</p>\n\n<p>\nWe define an array is non-decreasing if <code>array[i] &lt;= array[i + 1]</code> holds for every <code>i</code> (1 &lt;= i &lt; n).\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [4,2,3]\n<b>Output:</b> True\n<b>Explanation:</b> You could modify the first <code>4</code> to <code>1</code> to get a non-decreasing array.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [4,2,1]\n<b>Output:</b> False\n<b>Explanation:</b> You can't get a non-decreasing array by modify at most one element.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\nThe <code>n</code> belongs to [1, 10,000].\n</p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1: Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-reduce-to-smaller-problem-accepted">Approach #2: Reduce to Smaller Problem [Accepted]</a></li>\n<li><a href="#approach-3-locate-and-analyze-problem-index-accepted">Approach #3: Locate and Analyze Problem Index [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1: Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>For the given array <script type="math/tex; mode=display">\\text{A}</script>, if we are changing at most one element <script type="math/tex; mode=display">\\text{A[i]}</script>, we should change <script type="math/tex; mode=display">\\text{A[i]}</script> to <script type="math/tex; mode=display">\\text{A[i-1]}</script>, as it would be guaranteed that <script type="math/tex; mode=display">\\text{A[i-1]} &leq; \\text{A[i]}</script>, and <script type="math/tex; mode=display">\\text{A[i]}</script> would be the smallest possible to try and achieve <script type="math/tex; mode=display">\\text{A[i]} &leq; \\text{A[i+1]}</script>.</p>\n<p><strong>Algorithm</strong></p>\n<p>For each possible change <script type="math/tex; mode=display">\\text{A[i]}</script>, check if the sequence is monotone increasing.  We\'ll modify <script type="math/tex; mode=display">\\text{new}</script>, a copy of the array <script type="math/tex; mode=display">\\text{A}</script>.</p>\n<iframe frameborder="0" height="343" name="FK7JPfxR" src="https://leetcode.com/playground/FK7JPfxR/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: Let <script type="math/tex; mode=display">N</script> be the length of the given array.  For each element <script type="math/tex; mode=display">\\text{A[i]}</script>, we check if some sequence is monotone increasing, which takes <script type="math/tex; mode=display">O(N)</script> steps.  In total, this is a complexity of <script type="math/tex; mode=display">O(N^2)</script>.</p>\n</li>\n<li>\n<p>Space Complexity: To hold our array <script type="math/tex; mode=display">\\text{new}</script>, we need <script type="math/tex; mode=display">O(N)</script> space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-reduce-to-smaller-problem-accepted">Approach #2: Reduce to Smaller Problem [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If <script type="math/tex; mode=display">\\text{A[0]} &leq; \\text{A[1]} &leq; \\text{A[2]}</script>, then we may remove <script type="math/tex; mode=display">\\text{A[0]}</script> without changing the answer.  Similarly, if <script type="math/tex; mode=display">\\text{A}\\big[\\text{len(A)-3}\\big] &leq; \\text{A}\\big[\\text{len(A)-2}\\big] &leq; \\text{A}\\big[\\text{len(A)-1}\\big]</script>, we may remove <script type="math/tex; mode=display">\\text{A[len(A)-1]}</script> without changing the answer.</p>\n<p>If the problem is solvable, then after these removals, very few numbers will remain.</p>\n<p><strong>Algorithm</strong></p>\n<p>Consider the interval <script type="math/tex; mode=display">\\text{[i, j]}</script> corresponding to the subarray <script type="math/tex; mode=display">\\big[\\text{A[i], A[i+1], ..., A[j]}\\big]</script>.  When <script type="math/tex; mode=display">\\text{A[i]} &leq; \\text{A[i+1]} &leq; \\text{A[i+2]}</script>, we know we do not need to modify <script type="math/tex; mode=display">\\text{A[i]}</script>, and we can consider solving the problem on the interval <script type="math/tex; mode=display">\\text{[i+1, j]}</script> instead.  We use a similar approach for <script type="math/tex; mode=display">j</script>.</p>\n<p>Afterwards, with the length of the interval under consideration being <script type="math/tex; mode=display">\\text{j - i + 1}</script>, if the interval has size 2 or less, then we did not find any problem.  </p>\n<p>If our interval under consideration has 5 or more elements, then there are two disjoint problems that cannot be fixed with one replacement.  </p>\n<p>Otherwise, our problem size is now at most 4 elements, which we can easily brute force.</p>\n<iframe frameborder="0" height="343" name="4ypTHUiy" src="https://leetcode.com/playground/4ypTHUiy/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: Let <script type="math/tex; mode=display">N</script> be the length of the given array.  Our pointers <script type="math/tex; mode=display">i</script> and <script type="math/tex; mode=display">j</script> move at most <script type="math/tex; mode=display">O(N)</script> times.  Our brute force is constant time as there are at most 4 elements in the array.  Hence, the complexity is <script type="math/tex; mode=display">O(N)</script>.</p>\n</li>\n<li>\n<p>Space Complexity:  The extra array <script type="math/tex; mode=display">\\text{A[i: j+1]}</script> only has at most 4 elements, so it is constant space, and so is the space used by our auxillary brute force algorithm.  In total, the space complexity is <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-locate-and-analyze-problem-index-accepted">Approach #3: Locate and Analyze Problem Index [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Consider all indices <script type="math/tex; mode=display">p</script> for which <script type="math/tex; mode=display">\\text{A[p]} > \\text{A[p+1]}</script>.  If there are zero, the answer is <code>True</code>.  If there are 2 or more, the answer is <code>False</code>, as more than one element of the array must be changed for <script type="math/tex; mode=display">\\text{A}</script> to be monotone increasing.</p>\n<p>At the problem index <script type="math/tex; mode=display">p</script>, we only care about the surrounding elements.  Thus, immediately the problem is reduced to a very small size that can be analyzed by casework.</p>\n<p><strong>Algorithm</strong></p>\n<p>As before, let <script type="math/tex; mode=display">p</script> be the unique problem index for which <script type="math/tex; mode=display">\\text{A[p]} > \\text{A[p+1]}</script>.  If this is not unique or doesn\'t exist, the answer is <code>False</code> or <code>True</code> respectively.  We analyze the following cases:</p>\n<ul>\n<li>If <script type="math/tex; mode=display">\\text{p = 0}</script>, then we could make the array good by setting <script type="math/tex; mode=display">\\text{A[p] = A[p+1]}</script>.</li>\n<li>If <script type="math/tex; mode=display">\\text{p = len(A) - 2}</script>, then we could make the array good by setting <script type="math/tex; mode=display">\\text{A[p+1] = A[p]}</script>.</li>\n<li>Otherwise, <script type="math/tex; mode=display">\\text{A[p-1], A[p], A[p+1], A[p+2]}</script> all exist, and:<ul>\n<li>We could change <script type="math/tex; mode=display">\\text{A[p]}</script> to be between <script type="math/tex; mode=display">\\text{A[p-1]}</script> and <script type="math/tex; mode=display">\\text{A[p+1]}</script> if possible, or;</li>\n<li>We could change <script type="math/tex; mode=display">\\text{A[p+1]}</script> to be between <script type="math/tex; mode=display">\\text{A[p]}</script> and <script type="math/tex; mode=display">\\text{A[p+2]}</script> if possible.</li>\n</ul>\n</li>\n</ul>\n<iframe frameborder="0" height="241" name="NGHYqESJ" src="https://leetcode.com/playground/NGHYqESJ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: Let <script type="math/tex; mode=display">N</script> be the length of the given array.  We loop through the array once, so our time complexity is <script type="math/tex; mode=display">O(N)</script>.</p>\n</li>\n<li>\n<p>Space Complexity:  We only use <script type="math/tex; mode=display">p</script> and <script type="math/tex; mode=display">i</script>, and the answer itself as the additional space.  The additional space complexity is <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '666',
    name: 'Path Sum IV ',
    acceptance: '49.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nIf the depth of a tree is smaller than <code>5</code>, then this tree can be represented by a list of three-digits integers.\n</p>\n\n<p>\nFor each integer in this list:<br>\n</p><ol>\n<li>The hundreds digit represents the depth <code>D</code> of this node, <code>1 &lt;= D &lt;= 4.</code></li>\n<li>The tens digit represents the position <code>P</code> of this node in the level it belongs to, <code>1 &lt;= P &lt;= 8</code>. The position is the same as that in a full binary tree. </li>\n<li>The units digit represents the value <code>V</code> of this node, <code>0 &lt;= V &lt;= 9.</code></li>\n</ol>\n<p></p>\n\n<p>\nGiven a list of <code>ascending</code> three-digits integers representing a binary with the depth smaller than 5. You need to return the sum of all paths from the root towards the leaves.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [113, 215, 221]\n<b>Output:</b> 12\n<b>Explanation:</b> \nThe tree that the list represents is:\n    3\n   / \\\n  5   1\n\nThe path sum is (3 + 5) + (3 + 1) = 12.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [113, 221]\n<b>Output:</b> 4\n<b>Explanation:</b> \nThe tree that the list represents is: \n    3\n     \\\n      1\n\nThe path sum is (3 + 1) = 4.\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-convert-to-tree-accepted">Approach #1: Convert to Tree [Accepted]</a></li>\n<li><a href="#approach-2-direct-traversal-accepted">Approach #2: Direct Traversal [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-convert-to-tree-accepted">Approach #1: Convert to Tree [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Convert the given array into a tree using Node objects.  Afterwards, for each path from root to leaf, we can add the sum of that path to our answer.</p>\n<p><strong>Algorithm</strong></p>\n<p>There are two steps, the tree construction, and the traversal.</p>\n<p>In the tree construction, we have some depth, position, and value, and we want to know where the new node goes.  With some effort, we can see the relevant condition for whether a node should be left or right is <code>pos - 1 &lt; 2**(depth - 2)</code>.  For example, when <code>depth = 4</code>, the positions are <code>1, 2, 3, 4, 5, 6, 7, 8</code>, and it\'s left when <code>pos &lt;= 4</code>.</p>\n<p>In the traversal, we perform a depth-first search from root to leaf, keeping track of the current sum along the path we have travelled.  Every time we reach a leaf <code>(node.left == null &amp;&amp; node.right == null)</code>, we have to add that running sum to our answer.</p>\n<iframe frameborder="0" height="500" name="9DugWkyp" src="https://leetcode.com/playground/9DugWkyp/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script> where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>.  We construct the graph and traverse it in this time.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of the implicit call stack in our depth-first search.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-direct-traversal-accepted">Approach #2: Direct Traversal [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>As in <em>Approach #1</em>, we will depth-first search on the tree.  One time-saving idea is that we can use <code>num / 10 = 10 * depth + pos</code> as a unique identifier for that node.  The left child of such a node would have identifier <code>10 * (depth + 1) + 2 * pos - 1</code>, and the right child would be one greater.</p>\n<iframe frameborder="0" height="500" name="JG3jC7pT" src="https://leetcode.com/playground/JG3jC7pT/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time and Space Complexity: <script type="math/tex; mode=display">O(N)</script>.  The analysis is the same as in <em>Approach #1</em>.</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Alibaba'],
  },
  {
    id: '667',
    name: 'Beautiful Arrangement II',
    acceptance: '51.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven two integers <code>n</code> and <code>k</code>, you need to construct a list which contains <code>n</code> different positive integers ranging from <code>1</code> to <code>n</code> and obeys the following requirement: <br>\n\nSuppose this list is [a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ... , a<sub>n</sub>], then the list [|a<sub>1</sub> - a<sub>2</sub>|, |a<sub>2</sub> - a<sub>3</sub>|, |a<sub>3</sub> - a<sub>4</sub>|, ... , |a<sub>n-1</sub> - a<sub>n</sub>|] has exactly <code>k</code> distinct integers.\n</p>\n\n<p>\nIf there are multiple answers, print any of them.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> n = 3, k = 1\n<b>Output:</b> [1, 2, 3]\n<b>Explanation:</b> The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> n = 3, k = 2\n<b>Output:</b> [1, 3, 2]\n<b>Explanation:</b> The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The <code>n</code> and <code>k</code> are in the range 1 &lt;= k &lt; n &lt;= 10<sup>4</sup>.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1: Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-construction-accepted">Approach #2: Construction [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1: Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>For each permutation of <script type="math/tex; mode=display">\\text{[1, 2, ..., n]}</script>, let\'s look at the set of differences of the adjacent elements.</p>\n<p><strong>Algorithm</strong></p>\n<p>For each permutation, we find the number of unique differences of adjacent elements.  If it is the desired number, we\'ll return that permutation.</p>\n<p>To enumerate each permutation without using library functions, we use a recursive algorithm, where <code>permute</code> is responsible for permuting the indexes of <script type="math/tex; mode=display">\\text{nums}</script> in the interval <script type="math/tex; mode=display">\\text{[start, nums.length)}</script>.</p>\n<iframe frameborder="0" height="515" name="JvKeuMXb" src="https://leetcode.com/playground/JvKeuMXb/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(n!)</script> to generate every permutation in the outer loop, then <script type="math/tex; mode=display">O(n)</script> work to check differences.  In total taking <script type="math/tex; mode=display">O(n* n!)</script> time.</p>\n</li>\n<li>\n<p>Space Complexity:  <script type="math/tex; mode=display">O(n)</script>.  We use <script type="math/tex; mode=display">\\text{seen}</script> to store whether we\'ve seen the differences, and each generated permutation has a length equal to <script type="math/tex; mode=display">\\text{n}</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-construction-accepted">Approach #2: Construction [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>When <script type="math/tex; mode=display">\\text{k = n-1}</script>, a valid construction is <script type="math/tex; mode=display">\\text{[1, n, 2, n-1, 3, n-2, ....]}</script>. One way to see this is, we need to have a difference of <script type="math/tex; mode=display">\\text{n-1}</script>, which means we need <script type="math/tex; mode=display">\\text{1}</script> and <script type="math/tex; mode=display">\\text{n}</script> adjacent; then, we need a difference of <script type="math/tex; mode=display">\\text{n-2}</script>, etc.</p>\n<p>Also, when <script type="math/tex; mode=display">\\text{k = 1}</script>, a valid construction is <script type="math/tex; mode=display">\\text{[1, 2, 3, ..., n]}</script>. So we have a construction when <script type="math/tex; mode=display">\\text{n-k}</script> is tiny, and when it is large.  This leads to the idea that we can stitch together these two constructions:  we can put <script type="math/tex; mode=display">\\text{[1, 2, ..., n-k-1]}</script> first so that <script type="math/tex; mode=display">\\text{n}</script> is effectively <script type="math/tex; mode=display">\\text{k+1}</script>, and then finish the construction with the first <script type="math/tex; mode=display">\\text{"k = n-1"}</script> method.</p>\n<p>For example, when <script type="math/tex; mode=display">\\text{n = 6}</script> and <script type="math/tex; mode=display">\\text{k = 3}</script>, we will construct the array as <script type="math/tex; mode=display">\\text{[1, 2, 3, 6, 4, 5]}</script>.  This consists of two parts: a construction of <script type="math/tex; mode=display">\\text{[1, 2]}</script> and a construction of <script type="math/tex; mode=display">\\text{[1, 4, 2, 3]}</script> where every element had <script type="math/tex; mode=display">\\text{2}</script> added to it (i.e. <script type="math/tex; mode=display">\\text{[3, 6, 4, 5]}</script>).</p>\n<p><strong>Algorithm</strong></p>\n<p>As before, write <script type="math/tex; mode=display">\\text{[1, 2, ..., n-k-1]}</script> first.  The remaining <script type="math/tex; mode=display">\\text{k+1}</script> elements to be written are <script type="math/tex; mode=display">\\text{[n-k, n-k+1, ..., n]}</script>, and we\'ll write them in alternating head and tail order.</p>\n<p>When we are writing the <script type="math/tex; mode=display">i^{th}</script> element from the remaining <script type="math/tex; mode=display">\\text{k+1}</script>, every even <script type="math/tex; mode=display">i</script> is going to be chosen from the head, and will have value <script type="math/tex; mode=display">\\text{n-k + i//2}</script>.  Every odd <script type="math/tex; mode=display">i</script> is going to be chosen from the tail, and will have value <script type="math/tex; mode=display">\\text{n - i//2}</script>.</p>\n<iframe frameborder="0" height="275" name="knXdznYV" src="https://leetcode.com/playground/knXdznYV/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(n)</script>.  We are making a list of size <script type="math/tex; mode=display">\\text{n}</script>.</p>\n</li>\n<li>\n<p>Space Complexity:  <script type="math/tex; mode=display">O(n)</script>.  Our answer has a length equal to <script type="math/tex; mode=display">\\text{n}</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '668',
    name: 'Kth Smallest Number in Multiplication Table',
    acceptance: '38.1%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nNearly every one have used the <a href="https://en.wikipedia.org/wiki/Multiplication_table">Multiplication Table</a>. But could you find out the <code>k-th</code> smallest number quickly from the multiplication table?\n</p>\n\n<p>\nGiven the height <code>m</code> and the length <code>n</code> of a <code>m * n</code> Multiplication Table, and a positive integer <code>k</code>, you need to return the <code>k-th</code> smallest number in this table.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> m = 3, n = 3, k = 5\n<b>Output:</b> \n<b>Explanation:</b> \nThe Multiplication Table:\n1\t2\t3\n2\t4\t6\n3\t6\t9\n\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\n</pre>\n<p></p>\n\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> m = 2, n = 3, k = 6\n<b>Output:</b> \n<b>Explanation:</b> \nThe Multiplication Table:\n1\t2\t3\n2\t4\t6\n\nThe 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).\n</pre>\n<p></p>\n\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The <code>m</code> and <code>n</code> will be in the range [1, 30000].</li>\n<li>The <code>k</code> will be in the range [1, m * n]</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-memory-limit-exceeded">Approach #1: Brute Force [Memory Limit Exceeded]</a></li>\n<li><a href="#approach-2-next-heap-time-limit-exceeded">Approach #2: Next Heap [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-binary-search-accepted">Approach #3: Binary Search [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-memory-limit-exceeded">Approach #1: Brute Force [Memory Limit Exceeded]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Create the multiplication table and sort it, then take the <script type="math/tex; mode=display">k^{th}</script> element.</p>\n<iframe frameborder="0" height="258" name="JNTnTCLa" src="https://leetcode.com/playground/JNTnTCLa/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(m*n)</script> to create the table, and <script type="math/tex; mode=display">O(m*n\\log(m*n))</script> to sort it.</p>\n</li>\n<li>\n<p>Space Complexity:  <script type="math/tex; mode=display">O(m*n)</script> to store the table.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-next-heap-time-limit-exceeded">Approach #2: Next Heap [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>Maintain a heap of the smallest unused element of each row.  Then, finding the next element is a pop operation on the heap.</p>\n<p><strong>Algorithm</strong></p>\n<p>Our <code>heap</code> is going to consist of elements <script type="math/tex; mode=display">\\text{(val, root)}</script>, where <script type="math/tex; mode=display">\\text{val}</script> is the next unused value of that row, and <script type="math/tex; mode=display">\\text{root}</script> was the starting value of that row.</p>\n<p>We will repeatedly find the next lowest element in the table.  To do this, we pop from the heap.  Then, if there\'s a next lowest element in that row, we\'ll put that element back on the heap.</p>\n<iframe frameborder="0" height="515" name="Evrh9ssK" src="https://leetcode.com/playground/Evrh9ssK/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(k * m \\log m) = O(m^2 n \\log m)</script>.  Our initial heapify operation is <script type="math/tex; mode=display">O(m)</script>.  Afterwards, each pop and push is <script type="math/tex; mode=display">O(m \\log m)</script>, and our outer loop is <script type="math/tex; mode=display">O(k) = O(m*n)</script>\n</p>\n</li>\n<li>\n<p>Space Complexity:  <script type="math/tex; mode=display">O(m)</script>.  Our heap is implemented as an array with <script type="math/tex; mode=display">m</script> elements.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-binary-search-accepted">Approach #3: Binary Search [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>As <script type="math/tex; mode=display">\\text{k}</script> and <script type="math/tex; mode=display">\\text{m*n}</script> are up to <script type="math/tex; mode=display">9 * 10^8</script>, linear solutions will not work.  This motivates solutions with <script type="math/tex; mode=display">\\log</script> complexity, such as binary search.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let\'s do the binary search for the answer <script type="math/tex; mode=display">\\text{A}</script>.</p>\n<p>Say <code>enough(x)</code> is true if and only if there are <script type="math/tex; mode=display">\\text{k}</script> or more values in the multiplication table that are less than or equal to <script type="math/tex; mode=display">\\text{x}</script>.  Colloquially, <code>enough</code> describes whether <script type="math/tex; mode=display">\\text{x}</script> is large enough to be the <script type="math/tex; mode=display">k^{th}</script> value in the multiplication table.</p>\n<p>Then (for our answer <script type="math/tex; mode=display">\\text{A}</script>), whenever <script type="math/tex; mode=display">\\text{x &geq; A}</script>, <code>enough(x)</code> is <code>True</code>; and whenever <script type="math/tex; mode=display">\\text{x < A}</script>, <code>enough(x)</code> is <code>False</code>.</p>\n<p>In our binary search, our loop invariant is <code>enough(hi) = True</code>.  At the beginning, <code>enough(m*n) = True</code>, and whenever <code>hi</code> is set, it is set to a value that is "enough" (<code>enough(mi) = True</code>).  That means <code>hi</code> will be the lowest such value at the end of our binary search.</p>\n<p>This leaves us with the task of counting how many values are less than or equal to <script type="math/tex; mode=display">\\text{x}</script>.  For each of <script type="math/tex; mode=display">\\text{m}</script> rows, the <script type="math/tex; mode=display">i^{th}</script> row looks like <script type="math/tex; mode=display">\\text{[i, 2*i, 3*i, ..., n*i]}</script>.  The largest possible <script type="math/tex; mode=display">\\text{k*i &leq; x}</script> that could appear is <script type="math/tex; mode=display">\\text{k = x // i}</script>. However, if <script type="math/tex; mode=display">\\text{x}</script> is really big, then perhaps <script type="math/tex; mode=display">\\text{k > n}</script>, so in total there are <script type="math/tex; mode=display">\\text{min(k, n) = min(x // i, n)}</script> values in that row that are less than or equal to <script type="math/tex; mode=display">\\text{x}</script>.</p>\n<p>After we have the count of how many values in the table are less than or equal to <script type="math/tex; mode=display">\\text{x}</script>, by the definition of <code>enough(x)</code>, we want to know if that count is greater than or equal to <script type="math/tex; mode=display">\\text{k}</script>.</p>\n<iframe frameborder="0" height="377" name="4ankdsg9" src="https://leetcode.com/playground/4ankdsg9/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(m * \\log (m*n))</script>.  Our binary search divides the interval <script type="math/tex; mode=display">\\text{[lo, hi]}</script> into half at each step.  At each step, we call <code>enough</code> which requires <script type="math/tex; mode=display">O(m)</script> time.</p>\n</li>\n<li>\n<p>Space Complexity:  <script type="math/tex; mode=display">O(1)</script>.  We only keep integers in memory during our intermediate calculations.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '669',
    name: 'Trim a Binary Search Tree',
    acceptance: '58.3%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a binary search tree and the lowest and highest boundaries as <code>L</code> and <code>R</code>, trim the tree so that all its elements lies in <code>[L, R]</code> (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \n    1\n   / \\\n  0   2\n\n  L = 1\n  R = 2\n\n<b>Output:</b> \n    1\n      \\\n       2\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \n    3\n   / \\\n  0   4\n   \\\n    2\n   /\n  1\n\n  L = 1\n  R = 3\n\n<b>Output:</b> \n      3\n     / \n   2   \n  /\n 1\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-recursion-accepted">Approach #1: Recursion [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-recursion-accepted">Approach #1: Recursion [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Let <code>trim(node)</code> be the desired answer for the subtree at that node.  We can construct the answer recursively.</p>\n<p><strong>Algorithm</strong></p>\n<p>When <script type="math/tex; mode=display">\\text{node.val > R}</script>, we know that the trimmed binary tree must occur to the left of the node. Similarly, when <script type="math/tex; mode=display">\\text{node.val < L}</script>, the trimmed binary tree occurs to the right of the node. Otherwise, we will trim both sides of the tree.</p>\n<iframe frameborder="0" height="309" name="8eWsgDRM" src="https://leetcode.com/playground/8eWsgDRM/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity:  <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the total number of nodes in the given tree.  We visit each node at most once.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>.  Even though we don\'t explicitly use any additional memory, the call stack of our recursion could be as large as the number of nodes in the worst case.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '670',
    name: 'Maximum Swap',
    acceptance: '38.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a non-negative integer, you could swap two digits <b>at most</b> once to get the maximum valued number. Return the maximum valued number you could get.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> 2736\n<b>Output:</b> 7236\n<b>Explanation:</b> Swap the number 2 and the number 7.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> 9973\n<b>Output:</b> 9973\n<b>Explanation:</b> No swap.\n</pre>\n<p></p>\n\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The given number is in the range [0, 10<sup>8</sup>]</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-greedy-accepted">Approach #2: Greedy [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>The number only has at most 8 digits, so there are only <script type="math/tex; mode=display">{}^{8}\\text{C}_{2}</script> = 28 available swaps.  We can easily brute force them all.</p>\n<p><strong>Algorithm</strong></p>\n<p>We will store the candidates as lists of length <script type="math/tex; mode=display">\\text{len(num)}</script>.  For each candidate swap with positions <script type="math/tex; mode=display">\\text{(i, j)}</script>, we swap the number and record if the candidate is larger than the current answer, then swap back to restore the original number.</p>\n<p>The only detail is possibly to check that we didn\'t introduce a leading zero.  We don\'t actually need to check it, because our original number doesn\'t have one.</p>\n<iframe frameborder="0" height="462" name="9BbnzEUC" src="https://leetcode.com/playground/9BbnzEUC/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity:  <script type="math/tex; mode=display">O(N^3)</script>, where <script type="math/tex; mode=display">N</script> is the total number of digits in the input number.  For each pair of digits, we spend up to <script type="math/tex; mode=display">O(N)</script> time to compare the final sequences.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the information stored in <script type="math/tex; mode=display">\\text{A}</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-greedy-accepted">Approach #2: Greedy [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>At each digit of the input number in order, if there is a larger digit that occurs later, we know that the best swap must occur with the digit we are currently considering.</p>\n<p><strong>Algorithm</strong></p>\n<p>We will compute <script type="math/tex; mode=display">\\text{last[d] = i}</script>, the index <script type="math/tex; mode=display">\\text{i}</script> of the last occurrence of digit <script type="math/tex; mode=display">\\text{d}</script> (if it exists).</p>\n<p>Afterwards, when scanning the number from left to right, if there is a larger digit in the future, we will swap it with the largest such digit; if there are multiple such digits, we will swap it with the one that occurs the latest.</p>\n<iframe frameborder="0" height="411" name="c2u3L78L" src="https://leetcode.com/playground/c2u3L78L/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity:  <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the total number of digits in the input number.  Every digit is considered at most once.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>.  The additional space used by <script type="math/tex; mode=display">\\text{last}</script> only has up to 10 values.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '671',
    name: 'Second Minimum Node In a Binary Tree',
    acceptance: '41.9%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>\nGiven a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly <code>two</code> or <code>zero</code> sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. \n</p>\n\n<p>\nGiven such a binary tree, you need to output the <b>second minimum</b> value in the set made of all the nodes' value in the whole tree. \n</p>\n\n<p>\nIf no such second minimum value exists, output -1 instead.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \n    2\n   / \\\n  2   5\n     / \\\n    5   7\n\n<b>Output:</b> 5\n<b>Explanation:</b> The smallest value is 2, the second smallest value is 5.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \n    2\n   / \\\n  2   2\n\n<b>Output:</b> -1\n<b>Explanation:</b> The smallest value is 2, but there isn't any second smallest value.\n</pre>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#solution">Solution</a><ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-ad-hoc-accepted">Approach #2: Ad-Hoc [Accepted]</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id="solution">Solution</h2>\n<hr>\n<h4 id="approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Traverse the tree with a depth-first search, and record every unique value in the tree using a Set structure <code>uniques</code>.</p>\n<p>Then, we\'ll look through the recorded values for the second minimum.  The first minimum must be <script type="math/tex; mode=display">\\text{root.val}</script>.</p>\n<iframe frameborder="0" height="394" name="rVYM4qCQ" src="https://leetcode.com/playground/rVYM4qCQ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity:  <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the total number of nodes in the given tree.  We visit each node exactly once, and scan through the <script type="math/tex; mode=display">O(N)</script> values in <code>unique</code> once.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the information stored in <code>uniques</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-ad-hoc-accepted">Approach #2: Ad-Hoc [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Let <script type="math/tex; mode=display">\\text{min1 = root.val}</script>.  When traversing the tree at some node, <script type="math/tex; mode=display">\\text{node}</script>, if <script type="math/tex; mode=display">\\text{node.val > min1}</script>, we know all values in the subtree at <script type="math/tex; mode=display">\\text{node}</script> are at least <script type="math/tex; mode=display">\\text{node.val}</script>, so there cannot be a better candidate for the second minimum in this subtree.  Thus, we do not need to search this subtree.</p>\n<p>Also, as we only care about the second minimum <script type="math/tex; mode=display">\\text{ans}</script>, we do not need to record any values that are larger than our current candidate for the second minimum, so unlike Approach #1 we can skip maintaining a Set of values(<code>uniques</code>) entirely.</p>\n<iframe frameborder="0" height="394" name="btTLPkjK" src="https://leetcode.com/playground/btTLPkjK/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity:  <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the total number of nodes in the given tree.  We visit each node at most once.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>.  The information stored in <script type="math/tex; mode=display">\\text{ans}</script> and <script type="math/tex; mode=display">\\text{min1}</script> is <script type="math/tex; mode=display">O(1)</script>, but our depth-first search may store up to <script type="math/tex; mode=display">O(h) = O(N)</script> information in the call stack, where <script type="math/tex; mode=display">h</script> is the height of the tree.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '672',
    name: 'Bulb Switcher II',
    acceptance: '48.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nThere is a room with <code>n</code> lights which are turned on initially and 4 buttons on the wall. After performing exactly <code>m</code> unknown operations towards buttons, you need to return how many different kinds of status of the <code>n</code> lights could be.\n</p>\n\n<p>\nSuppose <code>n</code> lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:\n\n</p><ol>\n<li>Flip all the lights.</li>\n<li>Flip lights with even numbers.</li>\n<li>Flip lights with odd numbers.</li>\n<li>Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...</li>\n</ol>\n<p></p>\n\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> n = 1, m = 1.\n<b>Output:</b> 2\n<b>Explanation:</b> Status can be: [on], [off]\n</pre>\n<p></p>\n\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> n = 2, m = 1.\n<b>Output:</b> 3\n<b>Explanation:</b> Status can be: [on, off], [off, on], [off, off]\n</pre>\n<p></p>\n\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> n = 3, m = 1.\n<b>Output:</b> 4\n<b>Explanation:</b> Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n<code>n</code> and <code>m</code> both fit in range [0, 1000].\n</p>\n\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-reduce-search-space-accepted">Approach #1: Reduce Search Space [Accepted]</a></li>\n<li><a href="#approach-2-mathematical-accepted">Approach #2: Mathematical [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-reduce-search-space-accepted">Approach #1: Reduce Search Space [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>As the search space is very large (<script type="math/tex; mode=display">2^N</script> states of lights, naively <script type="math/tex; mode=display">4^M</script> operation sequences), let us try to reduce it.</p>\n<p>The first 6 lights uniquely determine the rest of the lights.  This is because every operation that modifies the <script type="math/tex; mode=display">x</script>-th light also modifies the <script type="math/tex; mode=display">(x+6)</script>-th light.</p>\n<p>Also, operations commute: doing operation A followed by B is the same as doing operation B followed by A.  So we can assume we do all the operations in order.</p>\n<p>Finally, doing the same operation twice in a row is the same as doing nothing.  So we only need to consider whether each operation was done 0 or 1 times.</p>\n<p><strong>Algorithm</strong></p>\n<p>Say we do the <script type="math/tex; mode=display">i</script>-th operation <script type="math/tex; mode=display">f_i</script> times.  Let\'s first figure out what sets of residues are possible: that is, what sets <script type="math/tex; mode=display">c_i = f_i</script> (<script type="math/tex; mode=display">\\mod 2</script> ) are possible.</p>\n<p>Because <script type="math/tex; mode=display">c_i \\equiv f_i</script> and <script type="math/tex; mode=display">c_i \\leq f_i</script>, if <script type="math/tex; mode=display">\\sum f_i \\not\\equiv \\sum c_i</script>, or if <script type="math/tex; mode=display">\\sum f_i < \\sum c_i</script>, it isn\'t possible.  Otherwise, it is possible by a simple construction: do the operations specified by <script type="math/tex; mode=display">c_i</script>, then do operation number 1 with the even number of operations you have left.</p>\n<p>For each possible set of residues, let\'s simulate and remember what the first 6 lights will look like, storing it in a <em>Set</em> structure <code>seen</code>.  At the end, we\'ll return the size of this set.</p>\n<p>In Java, we make use of bit manipulations to manage the state of lights, where in Python we simulate it directly.</p>\n<iframe frameborder="0" height="378" name="pHeNoQ3Q" src="https://leetcode.com/playground/pHeNoQ3Q/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(1)</script>.  Our checks are bounded by a constant.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>, the size of the data structures used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-mathematical-accepted">Approach #2: Mathematical [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>As before, the first 6 lights uniquely determine the rest of the lights.  This is because every operation that modifies the <script type="math/tex; mode=display">x</script>-th light also modifies the <script type="math/tex; mode=display">(x+6)</script>-th light, so the <script type="math/tex; mode=display">x</script>-th light is always equal to the <script type="math/tex; mode=display">(x+6)</script>-th light.</p>\n<p>Actually, the first 3 lights uniquely determine the rest of the sequence, as shown by the table below for performing the operations a, b, c, d:</p>\n<ul>\n<li>Light 1 = 1 + a + c + d</li>\n<li>Light 2 = 1 + a + b</li>\n<li>Light 3 = 1 + a + c</li>\n<li>Light 4 = 1 + a + b + d</li>\n<li>Light 5 = 1 + a + c</li>\n<li>Light 6 = 1 + a + b</li>\n</ul>\n<p>So that (modulo 2):</p>\n<ul>\n<li>Light 4 = (Light 1) + (Light 2) + (Light 3)</li>\n<li>Light 5 = Light 3</li>\n<li>Light 6 = Light 2</li>\n</ul>\n<p>The above justifies taking <script type="math/tex; mode=display">n = min(n, 3)</script> without loss of generality.  The rest is now casework.</p>\n<p>Let\'s denote the state of lights by the tuple <script type="math/tex; mode=display">(a, b, c)</script>.  The transitions are to XOR by <script type="math/tex; mode=display">(1, 1, 1), (0, 1, 0), (1, 0, 1),</script> or <script type="math/tex; mode=display">(1, 0, 0)</script>.</p>\n<p>When <script type="math/tex; mode=display">m = 0</script>, all the lights are on, and there is only one state <script type="math/tex; mode=display">(1, 1, 1)</script>.  The answer in this case is always 1.</p>\n<p>When <script type="math/tex; mode=display">m = 1</script>, we could get states <script type="math/tex; mode=display">(0, 0, 0)</script>, <script type="math/tex; mode=display">(1, 0, 1)</script>, <script type="math/tex; mode=display">(0, 1, 0)</script>, or <script type="math/tex; mode=display">(0, 1, 1)</script>.  The answer in this case is either <script type="math/tex; mode=display">2, 3, 4</script> for <script type="math/tex; mode=display">n = 1, 2, 3</script> respectively.</p>\n<p>When <script type="math/tex; mode=display">m = 2</script>, we can manually check that we can get 7 states: all of them except for <script type="math/tex; mode=display">(0, 1, 1)</script>.  The answer in this case is either <script type="math/tex; mode=display">2, 4, 7</script> for <script type="math/tex; mode=display">n = 1, 2, 3</script> respectively.</p>\n<p>When <script type="math/tex; mode=display">m = 3</script>, we can get all 8 states.  The answer in this case is either <script type="math/tex; mode=display">2, 4, 8</script> for <script type="math/tex; mode=display">n = 1, 2, 3</script> respectively.</p>\n<iframe frameborder="0" height="208" name="yn2rvFzw" src="https://leetcode.com/playground/yn2rvFzw/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time and Space Complexity: <script type="math/tex; mode=display">O(1)</script>.  The entire program uses constants.</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Microsoft'],
  },
  {
    id: '673',
    name: 'Number of Longest Increasing Subsequence',
    acceptance: '31.2%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nGiven an unsorted array of integers, find the number of longest increasing subsequence.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,3,5,4,7]\n<b>Output:</b> 2\n<b>Explanation:</b> The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [2,2,2,2,2]\n<b>Output:</b> 5\n<b>Explanation:</b> The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\nLength of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.\n</p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-2-segment-tree-accepted">Approach #2: Segment Tree [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Suppose for sequences ending at <code>nums[i]</code>, we knew the length <code>length[i]</code> of the longest sequence, and the number <code>count[i]</code> of such sequences with that length.</p>\n<p>For every <code>i &lt; j</code> with <code>A[i] &lt; A[j]</code>, we might append <code>A[j]</code> to a longest subsequence ending at <code>A[i]</code>.  It means that we have demonstrated <code>count[i]</code> subsequences of length <code>length[i] + 1</code>.  </p>\n<p>Now, if those sequences are longer than <code>length[j]</code>, then we know we have <code>count[i]</code> sequences of this length.  If these sequences are equal in length to <code>length[j]</code>, then we know that there are now <code>count[i]</code> additional sequences to be counted of that length (ie. <code>count[j] += count[i]</code>).</p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">findNumberOfLIS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>\n        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>\n        <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">N</span>\n        <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span> <span class="c1">#lengths[i] = longest ending in nums[i]</span>\n        <span class="n">counts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span> <span class="c1">#count[i] = number of longest ending in nums[i]</span>\n\n        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>\n            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>\n                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>\n                    <span class="k">if</span> <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>\n                        <span class="n">lengths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>\n                        <span class="n">counts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>\n                    <span class="k">elif</span> <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">lengths</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>\n                        <span class="n">counts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>\n\n        <span class="n">longest</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span>\n        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="k">if</span> <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">longest</span><span class="p">)</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findNumberOfLIS</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">N</span><span class="o">;</span>\n        <span class="kt">int</span><span class="o">[]</span> <span class="n">lengths</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">N</span><span class="o">];</span> <span class="c1">//lengths[i] = length of longest ending in nums[i]</span>\n        <span class="kt">int</span><span class="o">[]</span> <span class="n">counts</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">N</span><span class="o">];</span> <span class="c1">//count[i] = number of longest ending in nums[i]</span>\n        <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">counts</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>\n\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">lengths</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>\n                    <span class="n">lengths</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n                    <span class="n">counts</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">counts</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">lengths</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>\n                    <span class="n">counts</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">counts</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n                <span class="o">}</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n\n        <span class="kt">int</span> <span class="n">longest</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">length</span><span class="o">:</span> <span class="n">lengths</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">longest</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">longest</span><span class="o">,</span> <span class="n">length</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">longest</span><span class="o">)</span> <span class="o">{</span>\n                <span class="n">ans</span> <span class="o">+=</span> <span class="n">counts</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script> where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>.  There are two for-loops and the work inside is <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the space used by <code>lengths</code> and <code>counts</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-segment-tree-accepted">Approach #2: Segment Tree [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Suppose we knew for each length <code>L</code>, the number of sequences with length <code>L</code> ending in <code>x</code>.  Then when considering the next element of <code>nums</code>, updating our knowledge hinges on knowing the number of sequences with length <code>L-1</code> ending in <code>y &lt; x</code>.  This type of query over an interval is a natural fit for using some sort of tree.</p>\n<p>We could try using Fenwick trees, but we would have to store <script type="math/tex; mode=display">N</script> of them, which naively might be <script type="math/tex; mode=display">O(N^2)</script> space.  Here, we focus on an implementation of a Segment Tree.</p>\n<p><strong>Algorithm</strong></p>\n<p>Implementing Segment Trees is discussed in more detail <a href="https://leetcode.com/articles/recursive-approach-segment-trees-range-sum-queries-lazy-propagation/">here</a>.  In this approach, we will attempt a variant of segment tree that doesn\'t use lazy propagation.</p>\n<p>First, let us call the "value" of an interval, the longest length of an increasing subsequence, and the number of such subsequences in that interval.</p>\n<p>Each node knows about the interval of <code>nums</code> values it is considering <code>[node.range_left, node.range_right]</code>, and it knows about <code>node.val</code>, which contains information on the value of interval.  Nodes also have <code>node.left</code> and <code>node.right</code> children that represents the left and right half of the interval <code>node</code> considers.  These child nodes are created on demand as appropriate.</p>\n<p>Now, <code>query(node, key)</code> will tell us the value of the interval specified by <code>node</code>, except we\'ll exclude anything above <code>key</code>.  When key is outside the interval specified by <code>node</code>, we return the answer.  Otherwise, we\'ll divide the interval into two and query both intervals, then <code>merge</code> the result.</p>\n<p>What does <code>merge(v1, v2)</code> do?  Suppose two nodes specify adjacent intervals, and have corresponding values <code>v1 = node1.val, v2 = node2.val</code>.  What should the aggregate value, <code>v = merge(v1, v2)</code> be?  If there are longer subsequences in one node, then <code>v</code> will just be that.  If both nodes have longest subsequences of equal length, then we should count subsequences in both nodes.  Note that we did not have to consider cases where larger subsequences were made, since these were handled by <code>insert</code>.</p>\n<p>What does <code>insert(node, key, val)</code> do?  We repeatedly insert the <code>key</code> into the correct half of the interval that <code>node</code> specifies (possibly a point), and after such insertion this node\'s value could change, so we merge the values together again.</p>\n<p>Finally, in our main algorithm, for each <code>num in nums</code> we <code>query</code> for the value <code>length, count</code> of the interval below <code>num</code>, and we know it will lead to <code>count</code> additional sequences of length <code>length + 1</code>.  We then update our tree with that knowledge.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="n">Value</span> <span class="nf">merge</span><span class="o">(</span><span class="n">Value</span> <span class="n">v1</span><span class="o">,</span> <span class="n">Value</span> <span class="n">v2</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">v1</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">v2</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">v1</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Value</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>\n            <span class="k">return</span> <span class="k">new</span> <span class="n">Value</span><span class="o">(</span><span class="n">v1</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">v1</span><span class="o">.</span><span class="na">count</span> <span class="o">+</span> <span class="n">v2</span><span class="o">.</span><span class="na">count</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">v1</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="n">v2</span><span class="o">.</span><span class="na">length</span> <span class="o">?</span> <span class="n">v1</span> <span class="o">:</span> <span class="n">v2</span><span class="o">;</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">key</span><span class="o">,</span> <span class="n">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">range_left</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="na">range_right</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">merge</span><span class="o">(</span><span class="n">val</span><span class="o">,</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>\n            <span class="k">return</span><span class="o">;</span>\n        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">&lt;=</span> <span class="n">node</span><span class="o">.</span><span class="na">getRangeMid</span><span class="o">())</span> <span class="o">{</span>\n            <span class="n">insert</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getLeft</span><span class="o">(),</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>\n        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>\n            <span class="n">insert</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getRight</span><span class="o">(),</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">merge</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getLeft</span><span class="o">().</span><span class="na">val</span><span class="o">,</span> <span class="n">node</span><span class="o">.</span><span class="na">getRight</span><span class="o">().</span><span class="na">val</span><span class="o">);</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="n">Value</span> <span class="nf">query</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">range_right</span> <span class="o">&lt;=</span> <span class="n">key</span><span class="o">)</span> <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>\n        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">range_left</span> <span class="o">&gt;</span> <span class="n">key</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Value</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>\n        <span class="k">else</span> <span class="k">return</span> <span class="n">merge</span><span class="o">(</span><span class="n">query</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getLeft</span><span class="o">(),</span> <span class="n">key</span><span class="o">),</span> <span class="n">query</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getRight</span><span class="o">(),</span> <span class="n">key</span><span class="o">));</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findNumberOfLIS</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">min</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>\n            <span class="n">max</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="n">Node</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">Value</span> <span class="n">v</span> <span class="o">=</span> <span class="n">query</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>\n            <span class="n">insert</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">num</span><span class="o">,</span> <span class="k">new</span> <span class="n">Value</span><span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">v</span><span class="o">.</span><span class="na">count</span><span class="o">));</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="na">val</span><span class="o">.</span><span class="na">count</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n\n<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">range_left</span><span class="o">,</span> <span class="n">range_right</span><span class="o">;</span>\n    <span class="n">Node</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span>\n    <span class="n">Value</span> <span class="n">val</span><span class="o">;</span>\n    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">range_left</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>\n        <span class="n">range_right</span> <span class="o">=</span> <span class="n">end</span><span class="o">;</span>\n        <span class="n">left</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>\n        <span class="n">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>\n        <span class="n">val</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Value</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>\n    <span class="o">}</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getRangeMid</span><span class="o">()</span> <span class="o">{</span>\n        <span class="k">return</span> <span class="n">range_left</span> <span class="o">+</span> <span class="o">(</span><span class="n">range_right</span> <span class="o">-</span> <span class="n">range_left</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="kd">public</span> <span class="n">Node</span> <span class="nf">getLeft</span><span class="o">()</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">range_left</span><span class="o">,</span> <span class="n">getRangeMid</span><span class="o">());</span>\n        <span class="k">return</span> <span class="n">left</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="kd">public</span> <span class="n">Node</span> <span class="nf">getRight</span><span class="o">()</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">getRangeMid</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">range_right</span><span class="o">);</span>\n        <span class="k">return</span> <span class="n">right</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n\n<span class="kd">class</span> <span class="nc">Value</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">length</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>\n    <span class="kd">public</span> <span class="nf">Value</span><span class="o">(</span><span class="kt">int</span> <span class="n">len</span><span class="o">,</span> <span class="kt">int</span> <span class="n">ct</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">length</span> <span class="o">=</span> <span class="n">len</span><span class="o">;</span>\n        <span class="n">count</span> <span class="o">=</span> <span class="n">ct</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">range_left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_right</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right</span> <span class="o">=</span> <span class="bp">None</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="c1">#length, count</span>\n    <span class="nd">@property</span>\n    <span class="k">def</span> <span class="nf">range_mid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>\n        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range_left</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>\n    <span class="nd">@property</span>\n    <span class="k">def</span> <span class="nf">left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left</span> <span class="ow">or</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range_left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_mid</span><span class="p">)</span>\n        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left</span>\n    <span class="nd">@property</span>\n    <span class="k">def</span> <span class="nf">right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right</span> <span class="ow">or</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range_mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_right</span><span class="p">)</span>\n        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right</span>\n\n<span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>\n    <span class="k">if</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>\n        <span class="k">if</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>\n        <span class="k">return</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>\n    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>\n\n<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>\n    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">range_left</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">range_right</span><span class="p">:</span>\n        <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>\n        <span class="k">return</span>\n    <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;=</span> <span class="n">node</span><span class="o">.</span><span class="n">range_mid</span><span class="p">:</span>\n        <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>\n    <span class="k">else</span><span class="p">:</span>\n        <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>\n    <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>\n\n<span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>\n    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">range_right</span> <span class="o">&lt;=</span> <span class="n">key</span><span class="p">:</span>\n        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>\n    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">range_left</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">:</span>\n        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>\n    <span class="k">else</span><span class="p">:</span>\n        <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">query</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">query</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>\n\n<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">findNumberOfLIS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>\n        <span class="k">if</span> <span class="ow">not</span> <span class="n">nums</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>\n        <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">nums</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>\n        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>\n            <span class="n">length</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">query</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">num</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>\n            <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="p">(</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>\n        <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N\\log {N})</script> where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>.  In our main for loop, we do <code>$$O(\\log{N})$$</code> work to <code>query</code> and <code>insert</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the space used by the segment tree.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.  Approach #2 inspired by <a href="https://discuss.leetcode.com/topic/103992/python-dp-segment_tree-o-nlogn">@dut200901102</a>.</p>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '674',
    name: 'Longest Continuous Increasing Subsequence',
    acceptance: '42.7%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>\nGiven an unsorted array of integers, find the length of longest <code>continuous</code> increasing subsequence (subarray).\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,3,5,4,7]\n<b>Output:</b> 3\n<b>Explanation:</b> The longest continuous increasing subsequence is [1,3,5], its length is 3. \nEven though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4. \n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [2,2,2,2,2]\n<b>Output:</b> 1\n<b>Explanation:</b> The longest continuous increasing subsequence is [2], its length is 1. \n</pre>\n<p></p>\n\n<p><b>Note:</b>\nLength of the array will not exceed 10,000.\n</p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-sliding-window-accepted">Approach #1: Sliding Window [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-sliding-window-accepted">Approach #1: Sliding Window [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Every (continuous) increasing subsequence is disjoint, and the boundary of each such subsequence occurs whenever <code>nums[i-1] &gt;= nums[i]</code>.  When it does, it marks the start of a new increasing subsequence at <code>nums[i]</code>, and we store such <code>i</code> in the variable <code>anchor</code>.</p>\n<p>For example, if <code>nums = [7, 8, 9, 1, 2, 3]</code>, then <code>anchor</code> starts at <code>0</code> (<code>nums[anchor] = 7</code>) and gets set again to <code>anchor = 3</code> (<code>nums[anchor] = 1</code>).  Regardless of the value of <code>anchor</code>, we record a candidate answer of <code>i - anchor + 1</code>, the length of the subarray <code>nums[anchor], nums[anchor+1], ..., nums[i]</code>; and our answer gets updated appropriately.</p>\n<iframe frameborder="0" height="225" name="AvR7oHwg" src="https://leetcode.com/playground/AvR7oHwg/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>.  We perform one loop through <code>nums</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>, the space used by <code>anchor</code> and <code>ans</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '675',
    name: 'Cut Off Trees for Golf Event',
    acceptance: '26.7%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>\nYou are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:\n</p><ol>\n<li><code>0</code> represents the <code>obstacle</code> can't be reached.</li>\n<li><code>1</code> represents the <code>ground</code> can be walked through.</li>\n<li><code>The place with number bigger than 1</code> represents a <code>tree</code> can be walked through, and this positive number represents the tree's height.</li>\n</ol>\n<p></p>\n\n<p>\nYou are asked to cut off <b>all</b> the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). \n</p>\n\n<p>\nYou will start from the point (0, 0) and you should output the minimum steps <b>you need to walk</b> to cut off all the trees. If you can't cut off all the trees, output -1 in that situation.\n</p>\n\n<p>\nYou are guaranteed that no two <code>trees</code> have the same height and there is at least one tree needs to be cut off.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \n[\n [1,2,3],\n [0,0,4],\n [7,6,5]\n]\n<b>Output:</b> 6\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \n[\n [1,2,3],\n [0,0,0],\n [7,6,5]\n]\n<b>Output:</b> -1\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> \n[\n [2,3,4],\n [0,0,5],\n [8,7,6]\n]\n<b>Output:</b> 6\n<b>Explanation:</b> You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.\n</pre>\n<p></p>\n\n<p>\n<b>Hint</b>: size of the given matrix will not exceed 50x50.\n</p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-framework">Approach Framework</a></li>\n<li><a href="#approach-1-bfs-accepted">Approach #1: BFS [Accepted]</a></li>\n<li><a href="#approach-2-a-search-accepted">Approach #2: A* Search [Accepted]</a></li>\n<li><a href="#approach-3-hadlocks-algorithm-accepted">Approach #3: Hadlock\'s Algorithm [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-framework">Approach Framework</h4>\n<p><strong>Explanation</strong></p>\n<p>Starting from <code>(0, 0)</code>, for each tree in height order, we will calculate the distance from where we are to the next tree (and move there), adding that distance to the answer.</p>\n<p>We frame the problem as providing some distance function <code>dist(forest, sr, sc, tr, tc)</code> that calculates the path distance from source <code>(sr, sc)</code> to target <code>(tr, tc)</code> through obstacles <code>dist[i][j] == 0</code>.  (This distance function will return <code>-1</code> if the path is impossible.)</p>\n<p>What follows is code and complexity analysis that is common to all three approaches.  After, the algorithms presented in our approaches will focus on only providing our <code>dist</code> function.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">cutOffTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forest</span><span class="p">):</span>\n        <span class="n">trees</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">forest</span><span class="p">)</span>\n                       <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>\n        <span class="n">sr</span> <span class="o">=</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>\n        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">tc</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>\n            <span class="n">d</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">forest</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">)</span>\n            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>\n            <span class="n">ans</span> <span class="o">+=</span> <span class="n">d</span>\n            <span class="n">sr</span><span class="p">,</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">tr</span><span class="p">,</span> <span class="n">tc</span>\n        <span class="k">return</span> <span class="n">ans</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kt">int</span><span class="o">[]</span> <span class="n">dr</span> <span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>\n    <span class="kt">int</span><span class="o">[]</span> <span class="n">dc</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>\n\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">cutOffTree</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">forest</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">trees</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">forest</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">r</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">forest</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">c</span><span class="o">)</span> <span class="o">{</span>\n                <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">forest</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">r</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="n">trees</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">v</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">c</span><span class="o">});</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n\n        <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">trees</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>\n\n        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">sc</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">tree</span><span class="o">:</span> <span class="n">trees</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">dist</span><span class="o">(</span><span class="n">forest</span><span class="o">,</span> <span class="n">sr</span><span class="o">,</span> <span class="n">sc</span><span class="o">,</span> <span class="n">tree</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">tree</span><span class="o">[</span><span class="mi">2</span><span class="o">]);</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>\n            <span class="n">ans</span> <span class="o">+=</span> <span class="n">d</span><span class="o">;</span>\n            <span class="n">sr</span> <span class="o">=</span> <span class="n">tree</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">tree</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<p>All three algorithms have similar worst case complexities, but in practice each successive algorithm presented performs faster on random data.</p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O((RC)^2)</script> where there are <script type="math/tex; mode=display">R</script> rows and <script type="math/tex; mode=display">C</script> columns in the given <code>forest</code>.  We walk to <script type="math/tex; mode=display">R*C</script> trees, and each walk could spend <script type="math/tex; mode=display">O(R*C)</script> time searching for the tree.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(R*C)</script>, the maximum size of the data structures used.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-1-bfs-accepted">Approach #1: BFS [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>We perform a breadth-first-search, processing nodes (grid positions) in a queue.  <code>seen</code> keeps track of nodes that have already been added to the queue at some point - those nodes will be already processed or are in the queue awaiting processing.</p>\n<p>For each node that is next to be processed, we look at it\'s neighbors.  If they are in the forest (grid), they haven\'t been enqueued, and they aren\'t an obstacle, we will enqueue that neighbor.</p>\n<p>We also keep a side count of the distance travelled for each node.  If the node we are processing is our destination \'target\' <code>(tr, tc)</code>, we\'ll return the answer.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">forest</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">):</span>\n    <span class="n">R</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">forest</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">forest</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>\n    <span class="n">queue</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">([(</span><span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>\n    <span class="n">seen</span> <span class="o">=</span> <span class="p">{(</span><span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">)}</span>\n    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>\n        <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>\n        <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="n">tr</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="n">tc</span><span class="p">:</span>\n            <span class="k">return</span> <span class="n">d</span>\n        <span class="k">for</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="ow">in</span> <span class="p">((</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>\n            <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nr</span> <span class="o">&lt;</span> <span class="n">R</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nc</span> <span class="o">&lt;</span> <span class="n">C</span> <span class="ow">and</span>\n                    <span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span> <span class="ow">and</span> <span class="n">forest</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="n">nc</span><span class="p">]):</span>\n                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>\n                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>\n    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">bfs</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">forest</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sc</span><span class="o">,</span> <span class="kt">int</span> <span class="n">tr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">tc</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="n">forest</span><span class="o">.</span><span class="na">size</span><span class="o">(),</span> <span class="n">C</span> <span class="o">=</span> <span class="n">forest</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">size</span><span class="o">();</span>\n    <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">();</span>\n    <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">sr</span><span class="o">,</span> <span class="n">sc</span><span class="o">,</span> <span class="mi">0</span><span class="o">});</span>\n    <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">seen</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">R</span><span class="o">][</span><span class="n">C</span><span class="o">];</span>\n    <span class="n">seen</span><span class="o">[</span><span class="n">sr</span><span class="o">][</span><span class="n">sc</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>\n    <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>\n        <span class="kt">int</span><span class="o">[]</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">tr</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">tc</span><span class="o">)</span> <span class="k">return</span> <span class="n">cur</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">di</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">di</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="o">++</span><span class="n">di</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">dr</span><span class="o">[</span><span class="n">di</span><span class="o">];</span>\n            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">dc</span><span class="o">[</span><span class="n">di</span><span class="o">];</span>\n            <span class="k">if</span> <span class="o">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">R</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">C</span> <span class="o">&amp;&amp;</span>\n                    <span class="o">!</span><span class="n">seen</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">forest</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">r</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n                <span class="n">seen</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>\n                <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">r</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">cur</span><span class="o">[</span><span class="mi">2</span><span class="o">]+</span><span class="mi">1</span><span class="o">});</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<hr>\n<h4 id="approach-2-a-search-accepted">Approach #2: A* Search [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>The A<em> star algorithm is another path-finding algorithm.  For every node at position <code>(r, c)</code>, we have some estimated cost <code>node.f = node.g + node.h</code>, where <code>node.g</code> is the actual distance from <code>(sr, sc)</code> to <code>(r, c)</code>, and <code>node.h</code> is our </em>heuristic* (guess) of the distance from <code>(r, c)</code> to <code>(tr, tc)</code>.  In this case, our guess will be the taxicab distance, <code>node.h = abs(r-tr) + abs(c-tc)</code>.</p>\n<p>We keep a priority queue to decide what node to search in (<em>expand</em>) next.  We can prove that if we find the target node, we must have travelled the lowest possible distance <code>node.g</code>.  By considering the last time where two backwards paths are the same, without loss of generality we could suppose the the penultimate square of the two paths are different, and then in this case <code>node.f = node.g + 1</code>, showing the path with less actual distance travelled is expanded first as desired.</p>\n<p>It might be useful for solvers familiar with <em>Dijkstra\'s Algorithm</em> to know that <em>A* Search</em> is a special case of <em>Dijkstra\'s</em> with <code>node.h = 0</code> always.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">astar</span><span class="p">(</span><span class="n">forest</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">):</span>\n    <span class="n">R</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">forest</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">forest</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>\n    <span class="n">heap</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">)]</span>\n    <span class="n">cost</span> <span class="o">=</span> <span class="p">{(</span><span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">):</span> <span class="mi">0</span><span class="p">}</span>\n    <span class="k">while</span> <span class="n">heap</span><span class="p">:</span>\n        <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>\n        <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="n">tr</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="n">tc</span><span class="p">:</span> <span class="k">return</span> <span class="n">g</span>\n        <span class="k">for</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="ow">in</span> <span class="p">((</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span>\n            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nr</span> <span class="o">&lt;</span> <span class="n">R</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nc</span> <span class="o">&lt;</span> <span class="n">C</span> <span class="ow">and</span> <span class="n">forest</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="n">nc</span><span class="p">]:</span>\n                <span class="n">ncost</span> <span class="o">=</span> <span class="n">g</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">nr</span> <span class="o">-</span> <span class="n">tr</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">nc</span> <span class="o">-</span> <span class="n">tc</span><span class="p">)</span>\n                <span class="k">if</span> <span class="n">ncost</span> <span class="o">&lt;</span> <span class="n">cost</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">),</span> <span class="mi">9999</span><span class="p">):</span>\n                    <span class="n">cost</span><span class="p">[</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncost</span>\n                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">ncost</span><span class="p">,</span> <span class="n">g</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>\n    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">cutOffTree</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">forest</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sc</span><span class="o">,</span> <span class="kt">int</span> <span class="n">tr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">tc</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="n">forest</span><span class="o">.</span><span class="na">size</span><span class="o">(),</span> <span class="n">C</span> <span class="o">=</span> <span class="n">forest</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">size</span><span class="o">();</span>\n    <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">heap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;(</span>\n        <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">Integer</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>\n    <span class="n">heap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">sr</span><span class="o">,</span> <span class="n">sc</span><span class="o">});</span>\n\n    <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">cost</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>\n    <span class="n">cost</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">sr</span> <span class="o">*</span> <span class="n">C</span> <span class="o">+</span> <span class="n">sc</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>\n\n    <span class="k">while</span> <span class="o">(!</span><span class="n">heap</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>\n        <span class="kt">int</span><span class="o">[]</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">heap</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>\n        <span class="kt">int</span> <span class="n">g</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">tr</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">==</span> <span class="n">tc</span><span class="o">)</span> <span class="k">return</span> <span class="n">g</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">di</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">di</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="o">++</span><span class="n">di</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">dr</span><span class="o">[</span><span class="n">di</span><span class="o">],</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">dc</span><span class="o">[</span><span class="n">di</span><span class="o">];</span>\n            <span class="k">if</span> <span class="o">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nr</span> <span class="o">&amp;&amp;</span> <span class="n">nr</span> <span class="o">&lt;</span> <span class="n">R</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nc</span> <span class="o">&amp;&amp;</span> <span class="n">nc</span> <span class="o">&lt;</span> <span class="n">C</span> <span class="o">&amp;&amp;</span> <span class="n">forest</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nr</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">nc</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n                <span class="kt">int</span> <span class="n">ncost</span> <span class="o">=</span> <span class="n">g</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">nr</span><span class="o">-</span><span class="n">tr</span><span class="o">)</span> <span class="o">+</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">nc</span><span class="o">-</span><span class="n">tr</span><span class="o">);</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">ncost</span> <span class="o">&lt;</span> <span class="n">cost</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">nr</span> <span class="o">*</span> <span class="n">C</span> <span class="o">+</span> <span class="n">nc</span><span class="o">,</span> <span class="mi">9999</span><span class="o">))</span> <span class="o">{</span>\n                    <span class="n">cost</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nr</span> <span class="o">*</span> <span class="n">C</span> <span class="o">+</span> <span class="n">nc</span><span class="o">,</span> <span class="n">ncost</span><span class="o">);</span>\n                    <span class="n">heap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">ncost</span><span class="o">,</span> <span class="n">g</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">nr</span><span class="o">,</span> <span class="n">nc</span><span class="o">});</span>\n                <span class="o">}</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<hr>\n<h4 id="approach-3-hadlocks-algorithm-accepted">Approach #3: Hadlock\'s Algorithm [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Without any obstacles, the distance from <code>source = (sr, sc)</code> to <code>target = (tr, tc)</code> is simply <code>taxi(source, target) = abs(sr-tr) + abs(sc-tc)</code>.  This represents a sort of minimum distance that must be travelled.  Whenever we walk "away" from the target, we increase this minimum by 2, as we stepped 1 move, plus the taxicab distance from our new location has increased by one.</p>\n<p>Let\'s call such a move that walks away from the target a <em>detour</em>.  It can be proven that the distance from source to target is simply <code>taxi(source, target) + 2 * detours</code>, where <code>detours</code> is the smallest number of detours in any path from <code>source</code> to <code>target</code>.</p>\n<p><strong>Algorithm</strong></p>\n<p>With respect to a <code>source</code> and <code>target</code>, call the <em>detour number</em> of a square to be the lowest number of detours possible in any path from <code>source</code> to that square.  (Here, detours are defined with respect to <code>target</code> - the number of away steps from that target.)</p>\n<p>We will perform a priority-first-search in order of detour number.  If the target is found, it was found with the lowest detour number and therefore the lowest corresponding distance.  This motivates using <code>processed</code>, keeping track of when nodes are expanded, not visited - nodes could potentially be visited twice.</p>\n<p>As each neighboring node can only have the same detour number or a detour number one higher, we will only consider at most 2 priority classes at a time.  Thus, we can use a deque (double ended queue) to perform this implementation.  We will place nodes with the same detour number to be expanded first, and nodes with a detour number one higher to be expanded after all nodes with the current number are done.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">hadlocks</span><span class="p">(</span><span class="n">forest</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">):</span>\n    <span class="n">R</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">forest</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">forest</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>\n    <span class="n">processed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>\n    <span class="n">deque</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">)])</span>\n    <span class="k">while</span> <span class="n">deque</span><span class="p">:</span>\n        <span class="n">detours</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>\n        <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed</span><span class="p">:</span>\n            <span class="n">processed</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>\n            <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="n">tr</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="n">tc</span><span class="p">:</span>\n                <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sr</span><span class="o">-</span><span class="n">tr</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sc</span><span class="o">-</span><span class="n">tc</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">detours</span>\n            <span class="k">for</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">closer</span> <span class="ow">in</span> <span class="p">((</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="n">tr</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">tr</span><span class="p">),</span>\n                                   <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="n">tc</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">tc</span><span class="p">)):</span>\n                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nr</span> <span class="o">&lt;</span> <span class="n">R</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nc</span> <span class="o">&lt;</span> <span class="n">C</span> <span class="ow">and</span> <span class="n">forest</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="n">nc</span><span class="p">]:</span>\n                    <span class="k">if</span> <span class="n">closer</span><span class="p">:</span>\n                        <span class="n">deque</span><span class="o">.</span><span class="n">appendleft</span><span class="p">((</span><span class="n">detours</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>\n                    <span class="k">else</span><span class="p">:</span>\n                        <span class="n">deque</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">detours</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>\n    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="nf">hadlocks</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">forest</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sc</span><span class="o">,</span> <span class="kt">int</span> <span class="n">tr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">tc</span><span class="o">)</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="n">forest</span><span class="o">.</span><span class="na">size</span><span class="o">(),</span> <span class="n">C</span> <span class="o">=</span> <span class="n">forest</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">size</span><span class="o">();</span>\n    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">processed</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">();</span>\n    <span class="n">Deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">deque</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">();</span>\n    <span class="n">deque</span><span class="o">.</span><span class="na">offerFirst</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="n">sr</span><span class="o">,</span> <span class="n">sc</span><span class="o">});</span>\n    <span class="k">while</span> <span class="o">(!</span><span class="n">deque</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>\n        <span class="kt">int</span><span class="o">[]</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>\n        <span class="kt">int</span> <span class="n">detours</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cur</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>\n        <span class="k">if</span> <span class="o">(!</span><span class="n">processed</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">r</span><span class="o">*</span><span class="n">C</span> <span class="o">+</span> <span class="n">c</span><span class="o">))</span> <span class="o">{</span>\n            <span class="n">processed</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">r</span><span class="o">*</span><span class="n">C</span> <span class="o">+</span> <span class="n">c</span><span class="o">);</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">tr</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">==</span> <span class="n">tc</span><span class="o">)</span> <span class="o">{</span>\n                <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">sr</span><span class="o">-</span><span class="n">tr</span><span class="o">)</span> <span class="o">+</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">sc</span><span class="o">-</span><span class="n">tc</span><span class="o">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">detours</span><span class="o">;</span>\n            <span class="o">}</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">di</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">di</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="o">++</span><span class="n">di</span><span class="o">)</span> <span class="o">{</span>\n                <span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">dr</span><span class="o">[</span><span class="n">di</span><span class="o">];</span>\n                <span class="kt">int</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">dc</span><span class="o">[</span><span class="n">di</span><span class="o">];</span>\n                <span class="kt">boolean</span> <span class="n">closer</span><span class="o">;</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">di</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="n">closer</span> <span class="o">=</span> <span class="n">di</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="n">tr</span> <span class="o">:</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">tr</span><span class="o">;</span>\n                <span class="k">else</span> <span class="n">closer</span> <span class="o">=</span> <span class="n">di</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">?</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="n">tc</span> <span class="o">:</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">tc</span><span class="o">;</span>\n                <span class="k">if</span> <span class="o">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nr</span> <span class="o">&amp;&amp;</span> <span class="n">nr</span> <span class="o">&lt;</span> <span class="n">R</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nc</span> <span class="o">&amp;&amp;</span> <span class="n">nc</span> <span class="o">&lt;</span> <span class="n">C</span> <span class="o">&amp;&amp;</span> <span class="n">forest</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nr</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">nc</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n                    <span class="k">if</span> <span class="o">(</span><span class="n">closer</span><span class="o">)</span> <span class="n">deque</span><span class="o">.</span><span class="na">offerFirst</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">detours</span><span class="o">,</span> <span class="n">nr</span><span class="o">,</span> <span class="n">nc</span><span class="o">});</span>\n                    <span class="k">else</span> <span class="n">deque</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">detours</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">nr</span><span class="o">,</span> <span class="n">nc</span><span class="o">});</span>\n                <span class="o">}</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>\n<span class="o">}</span>\n</pre></div>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '676',
    name: 'Implement Magic Dictionary',
    acceptance: '49.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nImplement a magic directory with <code>buildDict</code>, and <code>search</code> methods.\n</p>\n\n<p>\nFor the method <code>buildDict</code>, you\'ll be given a list of non-repetitive words to build a dictionary.\n</p>\n\n<p>\nFor the method <code>search</code>, you\'ll be given a word, and judge whether if you modify <b>exactly</b> one character into <b>another</b> character in this word, the modified word is in the dictionary you just built.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre>Input: buildDict(["hello", "leetcode"]), Output: Null\nInput: search("hello"), Output: False\nInput: search("hhllo"), Output: True\nInput: search("hell"), Output: False\nInput: search("leetcoded"), Output: False\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>You may assume that all the inputs are consist of lowercase letters <code>a-z</code>.</li>\n<li>For contest purpose, the test data is rather small by now. You could think about highly efficient algorithm after the contest.</li>\n<li>Please remember to <b>RESET</b> your class variables declared in class MagicDictionary, as static/class variables are <b>persisted across multiple test cases</b>. Please see <a href="https://leetcode.com/faq/#different-output">here</a> for more details.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-brute-force-with-bucket-by-length-accepted">Approach #1: Brute Force with Bucket-By-Length [Accepted]</a></li>\n<li><a href="#approach-2-generalized-neighbors-accepted">Approach #2: Generalized Neighbors [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-brute-force-with-bucket-by-length-accepted">Approach #1: Brute Force with Bucket-By-Length [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Call two strings neighbors if exactly one character can be changed in one to make the strings equal (ie. their hamming distance is 1.)</p>\n<p>Strings can only be neighbors if their lengths are equal.  When <code>search</code>ing a new word, let\'s check only the words that are the same length.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">MagicDictionary</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">buckets</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>\n\n    <span class="k">def</span> <span class="nf">buildDict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>\n        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>\n            <span class="bp">self</span><span class="o">.</span><span class="n">buckets</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>\n\n    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>\n        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="o">!=</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">candidate</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span>\n                   <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">buckets</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)])</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">MagicDictionary</span> <span class="o">{</span>\n    <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">buckets</span><span class="o">;</span>\n    <span class="kd">public</span> <span class="nf">MagicDictionary</span><span class="o">()</span> <span class="o">{</span>\n        <span class="n">buckets</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildDict</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">:</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">buckets</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">()).</span><span class="na">add</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(!</span><span class="n">buckets</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">candidate</span><span class="o">:</span> <span class="n">buckets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()))</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">mismatch</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">candidate</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>\n                    <span class="k">if</span> <span class="o">(++</span><span class="n">mismatch</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>\n                <span class="o">}</span>\n            <span class="o">}</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">mismatch</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(S)</script> to build and <script type="math/tex; mode=display">O(NK)</script> to search, where <script type="math/tex; mode=display">N</script> is the number of <code>words</code> in our magic dictionary, <script type="math/tex; mode=display">S</script> is the total number of letters in it, and <script type="math/tex; mode=display">K</script> is the length of the search word.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(S)</script>, the space used by <code>buckets</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-generalized-neighbors-accepted">Approach #2: Generalized Neighbors [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Recall in <em>Approach #1</em> that two words are <em>neighbors</em> if exactly one character can be changed in one word to make the strings equal.</p>\n<p>Let\'s say a word \'apple\' has <em>generalized neighbors</em> \'*pple\', \'a*ple\', \'ap*le\', \'app*e\', and \'appl*\'. When searching for whether a word like \'apply\' has a neighbor like \'apple\', we only need to know whether they have a common <em>generalized neighbor</em>.</p>\n<p><strong>Algorithm</strong></p>\n<p>Continuing the above thinking, one issue is that \'apply\' is not a neighbor with itself, yet it has the same generalized neighbor \'*pply\'.  To remedy this, we\'ll count how many sources generated \'*pply\'.  If there are 2 or more, then one of them won\'t be \'apply\'.  If there is exactly one, we should check that it wasn\'t \'apply\'.  In either case, we can be sure that there was some magic word generating \'*pply\' that <em>wasn\'t</em> \'apply\'.</p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">MagicDictionary</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">_genneighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>\n        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>\n            <span class="k">yield</span> <span class="n">word</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">\'*\'</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>\n\n    <span class="k">def</span> <span class="nf">buildDict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">nei</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span>\n                                        <span class="k">for</span> <span class="n">nei</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_genneighbors</span><span class="p">(</span><span class="n">word</span><span class="p">))</span>\n\n    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>\n        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span>\n                   <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">word</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">words</span>\n                   <span class="k">for</span> <span class="n">nei</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_genneighbors</span><span class="p">(</span><span class="n">word</span><span class="p">))</span>\n</pre></div>\n<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MagicDictionary</span> <span class="o">{</span>\n    <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span><span class="o">;</span>\n    <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">count</span><span class="o">;</span>\n\n    <span class="kd">public</span> <span class="nf">MagicDictionary</span><span class="o">()</span> <span class="o">{</span>\n        <span class="n">words</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">();</span>\n        <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>\n    <span class="o">}</span>\n\n    <span class="kd">private</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">generalizedNeighbors</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>\n        <span class="kt">char</span><span class="o">[]</span> <span class="n">ca</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">char</span> <span class="n">letter</span> <span class="o">=</span> <span class="n">ca</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n            <span class="n">ca</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="sc">\'*\'</span><span class="o">;</span>\n            <span class="n">String</span> <span class="n">magic</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">ca</span><span class="o">);</span>\n            <span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">magic</span><span class="o">);</span>\n            <span class="n">ca</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">letter</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">buildDict</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">:</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">this</span><span class="o">.</span><span class="na">words</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>\n            <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">nei</span><span class="o">:</span> <span class="n">generalizedNeighbors</span><span class="o">(</span><span class="n">word</span><span class="o">))</span> <span class="o">{</span>\n                <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nei</span><span class="o">,</span> <span class="n">count</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">nei</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">nei</span><span class="o">:</span> <span class="n">generalizedNeighbors</span><span class="o">(</span><span class="n">word</span><span class="o">))</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">nei</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">words</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">word</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(\\sum w_i^2)</script> to build and <script type="math/tex; mode=display">O(K^2)</script> to search, where <script type="math/tex; mode=display">w_i</script> is the length of <code>words[i]</code>, and <script type="math/tex; mode=display">K</script> is the length of our search word.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(\\sum w_i^2)</script>, the space used by <code>count</code>.  We also use <script type="math/tex; mode=display">O(K^2)</script> space when generating neighbors to search.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '677',
    name: 'Map Sum Pairs',
    acceptance: '52.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nImplement a MapSum class with <code>insert</code>, and <code>sum</code> methods.\n</p>\n\n<p>\nFor the method <code>insert</code>, you\'ll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.\n</p>\n\n<p>\nFor the method <code>sum</code>, you\'ll be given a string representing the prefix, and you need to return the sum of all the pairs\' value whose key starts with the prefix.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre>Input: insert("apple", 3), Output: Null\nInput: sum("ap"), Output: 3\nInput: insert("app", 2), Output: Null\nInput: sum("ap"), Output: 5\n</pre>\n<p></p>\n\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-prefix-hashmap-accepted">Approach #2: Prefix Hashmap [Accepted]</a></li>\n<li><a href="#approach-3-trie-accepted">Approach #3: Trie [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>For each key in the map, if that key starts with the given prefix, then add it to the answer.</p>\n<iframe frameborder="0" height="360" name="jNhyy639" src="https://leetcode.com/playground/jNhyy639/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: Every insert operation is <script type="math/tex; mode=display">O(1)</script>.  Every sum operation is <script type="math/tex; mode=display">O(N * P)</script> where <script type="math/tex; mode=display">N</script> is the number of items in the map, and <script type="math/tex; mode=display">P</script> is the length of the input prefix.</p>\n</li>\n<li>\n<p>Space Complexity: The space used by <code>map</code> is linear in the size of all input <code>key</code> and <code>val</code> values combined.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-prefix-hashmap-accepted">Approach #2: Prefix Hashmap [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>We can remember the answer for all possible prefixes in a HashMap <code>score</code>.  When we get a new <code>(key, val)</code> pair, we update every prefix of <code>key</code> appropriately: each prefix will be changed by <code>delta = val - map[key]</code>, where <code>map</code> is the previous associated value of <code>key</code> (zero if undefined.)</p>\n<iframe frameborder="0" height="394" name="QYzALHGM" src="https://leetcode.com/playground/QYzALHGM/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: Every insert operation is <script type="math/tex; mode=display">O(K^2)</script>, where <script type="math/tex; mode=display">K</script> is the length of the key, as <script type="math/tex; mode=display">K</script> strings are made of an average length of <script type="math/tex; mode=display">K</script>.  Every sum operation is <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n<li>\n<p>Space Complexity: The space used by <code>map</code> and <code>score</code> is linear in the size of all input <code>key</code> and <code>val</code> values combined.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-trie-accepted">Approach #3: Trie [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Since we are dealing with prefixes, a Trie (prefix tree) is a natural data structure to approach this problem.  For every node of the trie corresponding to some prefix, we will remember the desired answer (score) and store it at this node.  As in <em>Approach #2</em>, this involves modifying each node by <code>delta = val - map[key]</code>.</p>\n<iframe frameborder="0" height="513" name="FbmbbgFJ" src="https://leetcode.com/playground/FbmbbgFJ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: Every insert operation is <script type="math/tex; mode=display">O(K)</script>, where <script type="math/tex; mode=display">K</script> is the length of the key.  Every sum operation is <script type="math/tex; mode=display">O(K)</script>.</p>\n</li>\n<li>\n<p>Space Complexity: The space used is linear in the size of the total input.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Akuna Capital'],
  },
  {
    id: '678',
    name: 'Valid Parenthesis String',
    acceptance: '29.1%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nGiven a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:\n</p><ol>\n<li>Any left parenthesis <code>'('</code> must have a corresponding right parenthesis <code>')'</code>.</li>\n<li>Any right parenthesis <code>')'</code> must have a corresponding left parenthesis <code>'('</code>.</li>\n<li>Left parenthesis <code>'('</code> must go before the corresponding right parenthesis <code>')'</code>.</li>\n<li><code>'*'</code> could be treated as a single right parenthesis <code>')'</code> or a single left parenthesis <code>'('</code> or an empty string.</li>\n<li>An empty string is also valid.</li>\n</ol>\n<p></p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \"()\"\n<b>Output:</b> True\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \"(*)\"\n<b>Output:</b> True\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> \"(*))\"\n<b>Output:</b> True\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The string size will be in the range [1, 100].</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1: Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-dynamic-programming-accepted">Approach #2: Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-3-greedy-accepted">Approach #3: Greedy [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1: Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>For each asterisk, let\'s try both possibilities.</p>\n<iframe frameborder="0" height="515" name="HHVFGh2C" src="https://leetcode.com/playground/HHVFGh2C/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N * 3^{N})</script>, where <script type="math/tex; mode=display">N</script> is the length of the string.  For each asterisk we try 3 different values.  Thus, we could be checking the validity of up to <script type="math/tex; mode=display">3^N</script> strings.  Then, each check of validity is <script type="math/tex; mode=display">O(N)</script>.</p>\n</li>\n<li>\n<p>Space Complexity:  <script type="math/tex; mode=display">O(N)</script>, the space used by our character array.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-dynamic-programming-accepted">Approach #2: Dynamic Programming [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Let <code>dp[i][j]</code> be <code>true</code> if and only if the interval <code>s[i], s[i+1], ..., s[j]</code> can be made valid.  Then <code>dp[i][j]</code> is true only if:</p>\n<ul>\n<li>\n<p><code>s[i]</code> is <code>\'*\'</code>, and the interval <code>s[i+1], s[i+2], ..., s[j]</code> can be made valid;</p>\n</li>\n<li>\n<p>or, <code>s[i]</code> can be made to be <code>\'(\'</code>, and there is some <code>k</code> in <code>[i+1, j]</code> such that <code>s[k]</code> can be made to be <code>\')\'</code>, plus the two intervals cut by <code>s[k]</code> (<code>s[i+1: k]</code> and <code>s[k+1: j+1]</code>) can be made valid;</p>\n</li>\n</ul>\n<iframe frameborder="0" height="515" name="c2qhBzko" src="https://leetcode.com/playground/c2qhBzko/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^3)</script>, where <script type="math/tex; mode=display">N</script> is the length of the string.  There are <script type="math/tex; mode=display">O(N^2)</script> states corresponding to entries of <code>dp</code>, and we do an average of <script type="math/tex; mode=display">O(N)</script> work on each state.</p>\n</li>\n<li>\n<p>Space Complexity:  <script type="math/tex; mode=display">O(N^2)</script>, the space used to store intermediate results in <code>dp</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-greedy-accepted">Approach #3: Greedy [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>When checking whether the string is valid, we only cared about the "<code>balance</code>": the number of extra, open left brackets as we parsed through the string.  For example, when checking whether \'(()())\' is valid, we had a balance of <code>1, 2, 1, 2, 1, 0</code> as we parse through the string: <code>\'(\'</code> has 1 left bracket, <code>\'((\'</code> has 2, <code>\'(()\'</code> has 1, and so on.  This means that after parsing the first <code>i</code> symbols, (which may include asterisks,) we only need to keep track of what the <code>balance</code> could be.</p>\n<p>For example, if we have string <code>\'(***)\'</code>, then as we parse each symbol, the set of possible values for the <code>balance</code> is <code>[1]</code> for <code>\'(\'</code>; <code>[0, 1, 2]</code> for <code>\'(*\'</code>; <code>[0, 1, 2, 3]</code> for <code>\'(**\'</code>; <code>[0, 1, 2, 3, 4]</code> for <code>\'(***\'</code>, and <code>[0, 1, 2, 3]</code> for <code>\'(***)\'</code>.</p>\n<p>Furthermore, we can prove these states always form a contiguous interval.  Thus, we only need to know the left and right bounds of this interval.  That is, we would keep those intermediate states described above as <code>[lo, hi] = [1, 1], [0, 2], [0, 3], [0, 4], [0, 3]</code>.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let <code>lo, hi</code> respectively be the smallest and largest possible number of open left brackets after processing the current character in the string.</p>\n<p>If we encounter a left bracket (<code>c == \'(\'</code>), then <code>lo++</code>, otherwise we could write a right bracket, so <code>lo--</code>.  If we encounter what can be a left bracket (<code>c != \')\'</code>), then <code>hi++</code>, otherwise we must write a right bracket, so <code>hi--</code>.  If <code>hi &lt; 0</code>, then the current prefix can\'t be made valid no matter what our choices are.  Also, we can never have less than <code>0</code> open left brackets.  At the end, we should check that we can have exactly 0 open left brackets.</p>\n<iframe frameborder="0" height="258" name="AP7MmhXJ" src="https://leetcode.com/playground/AP7MmhXJ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of the string.  We iterate through the string once.</p>\n</li>\n<li>\n<p>Space Complexity:  <script type="math/tex; mode=display">O(1)</script>, the space used by our <code>lo</code> and <code>hi</code> pointers.  However, creating a new character array will take <script type="math/tex; mode=display">O(N)</script> space.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Alibaba'],
  },
  {
    id: '679',
    name: '24 Game',
    acceptance: '38.9%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nYou have 4 cards each containing a number from 1 to 9.  You need to judge whether they could operated through <code>*</code>, <code>/</code>, <code>+</code>, <code>-</code>, <code>(</code>, <code>)</code> to get the value of 24.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [4, 1, 8, 7]\n<b>Output:</b> True\n<b>Explanation:</b> (8-4) * (7-1) = 24\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [1, 2, 1, 2]\n<b>Output:</b> False\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The division operator <code>/</code> represents real division, not integer division.  For example, 4 / (1 - 2/3) = 12.</li>\n<li>Every operation done is between two numbers.  In particular, we cannot use <code>-</code> as a unary operator.  For example, with <code>[1, 1, 1, 1]</code> as input, the expression <code>-1 - 1 - 1 - 1</code> is not allowed.</li>\n<li>You cannot concatenate numbers together.  For example, if the input is <code>[1, 2, 1, 2]</code>, we cannot write this as 12 + 12.</li>\n</ol>\n<p></p>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-backtracking-accepted">Approach #1: Backtracking [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-backtracking-accepted">Approach #1: Backtracking [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>There are only 4 cards and only 4 operations that can be performed.  Even when all operations do not commute, that gives us an upper bound of <script type="math/tex; mode=display">12 * 6 * 2 * 4 * 4 * 4 = 9216</script> possibilities, which makes it feasible to just try them all.  Specifically, we choose two numbers (with order) in 12 ways and perform one of 4 operations (12 * 4). Then, with 3 remaining numbers, we choose 2 of them and perform one of 4 operations (6 * 4).  Finally we have two numbers left and make a final choice of 2 * 4 possibilities.</p>\n<p>We will perform 3 binary operations (<code>+, -, *, /</code> are the operations) on either our numbers or resulting numbers.  Because <code>-</code> and <code>/</code> do not commute, we must be careful to consider both <code>a / b</code> and <code>b / a</code>.</p>\n<p>For every way to remove two numbers <code>a, b</code> in our list, and for each possible result they can make, like <code>a+b</code>, <code>a/b</code>, etc., we will recursively solve the problem on this smaller list of numbers.</p>\n<iframe frameborder="0" height="515" name="vSR6aMjS" src="https://leetcode.com/playground/vSR6aMjS/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(1)</script>.  There is a hard limit of 9216 possibilities, and we do <script type="math/tex; mode=display">O(1)</script> work for each of them.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>.  Our intermediate arrays are at most 4 elements, and the number made is bounded by an <script type="math/tex; mode=display">O(1)</script> factor.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '680',
    name: 'Valid Palindrome II',
    acceptance: '32.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a non-empty string <code>s</code>, you may delete <b>at most</b> one character.  Judge whether you can make it a palindrome.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "aba"\n<b>Output:</b> True\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> "abca"\n<b>Output:</b> True\n<b>Explanation:</b> You could delete the character \'c\'.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The string will only contain lowercase characters a-z.\nThe maximum length of the string is 50000.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1: Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-greedy-accepted">Approach #2: Greedy [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1: Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>For each index <code>i</code> in the given string, let\'s remove that character, then check if the resulting string is a palindrome.  If it is, (or if the original string was a palindrome), then we\'ll return <code>true</code></p>\n<iframe frameborder="0" height="394" name="F8rXiMNb" src="https://leetcode.com/playground/F8rXiMNb/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script> where <script type="math/tex; mode=display">N</script> is the length of the string.  We do the following <script type="math/tex; mode=display">N</script> times: create a string of length <script type="math/tex; mode=display">N</script> and iterate over it.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the space used by our candidate answer.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-greedy-accepted">Approach #2: Greedy [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If the beginning and end characters of a string are the same (ie. <code>s[0] == s[s.length - 1]</code>), then whether the inner characters are a palindrome (<code>s[1], s[2], ..., s[s.length - 2]</code>) uniquely determines whether the entire string is a palindrome.</p>\n<p><strong>Algorithm</strong></p>\n<p>Suppose we want to know whether <code>s[i], s[i+1], ..., s[j]</code> form a palindrome.  If <code>i &gt;= j</code> then we are done.  If <code>s[i] == s[j]</code> then we may take <code>i++; j--</code>.  Otherwise, the palindrome must be either <code>s[i+1], s[i+2],  ..., s[j]</code> or <code>s[i], s[i+1], ..., s[j-1]</code>, and we should check both cases.</p>\n<iframe frameborder="0" height="360" name="46SiEhrv" src="https://leetcode.com/playground/46SiEhrv/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script> where <script type="math/tex; mode=display">N</script> is the length of the string.  Each of two checks of whether some substring is a palindrome is <script type="math/tex; mode=display">O(N)</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script> additional complexity.  Only pointers were stored in memory.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '681',
    name: 'Next Closest Time ',
    acceptance: '43.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a time represented in the format "HH:MM", form the next closest time by reusing the current digits. There is no limit on how many times a digit can be reused.</p>\n\n<p>You may assume the given input string is always valid. For example, "01:34", "12:09" are all valid. "1:34", "12:9" are all invalid.</p>\n\n<p><b>Example 1:</b>\n</p><pre><b>Input:</b> "19:34"\n<b>Output:</b> "19:39"\n<b>Explanation:</b> The next closest time choosing from digits <b>1</b>, <b>9</b>, <b>3</b>, <b>4</b>, is <b>19:39</b>, which occurs 5 minutes later.  It is not <b>19:33</b>, because this occurs 23 hours and 59 minutes later.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b>\n</p><pre><b>Input:</b> "23:59"\n<b>Output:</b> "22:22"\n<b>Explanation:</b> The next closest time choosing from digits <b>2</b>, <b>3</b>, <b>5</b>, <b>9</b>, is <b>22:22</b>. It may be assumed that the returned time is next day\'s time since it is smaller than the input time numerically.\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<h4 id="approach-1-simulation-accepted">Approach #1: Simulation [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Simulate the clock going forward by one minute.  Each time it moves forward, if all the digits are allowed, then return the current time.</p>\n<p>The natural way to represent the time is as an integer <code>t</code> in the range <code>0 &lt;= t &lt; 24 * 60</code>.  Then the hours are <code>t / 60</code>, the minutes are <code>t % 60</code>, and each digit of the hours and minutes can be found by <code>hours / 10, hours % 10</code> etc.</p>\n<iframe frameborder="0" height="377" name="vBGi23jY" src="https://leetcode.com/playground/vBGi23jY/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(1)</script>.  We try up to <script type="math/tex; mode=display">24 * 60</script> possible times until we find the correct time.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-build-from-allowed-digits-accepted">Approach #2: Build From Allowed Digits [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>We have up to 4 different allowed digits, which naively gives us <code>4 * 4 * 4 * 4</code> possible times.  For each possible time, let\'s check that it can be displayed on a clock: ie., <code>hours &lt; 24 and mins &lt; 60</code>.  The best possible <code>time != start</code> is the one with the smallest <code>cand_elapsed = (time - start) % (24 * 60)</code>, as this represents the time that has elapsed since <code>start</code>, and where the modulo operation is taken to be always non-negative.</p>\n<p>For example, if we have <code>start = 720</code> (ie. noon), then times like <code>12:05 = 725</code> means that <code>(725 - 720) % (24 * 60) = 5</code> seconds have elapsed; while times like <code>00:10 = 10</code> means that <code>(10 - 720) % (24 * 60) = -710 % (24 * 60) = 730</code> seconds have elapsed.</p>\n<p>Also, we should make sure to handle <code>cand_elapsed</code> carefully.  When our current candidate time <code>cur</code> is equal to the given starting time, then <code>cand_elapsed</code> will be <code>0</code> and we should handle this case appropriately.</p>\n<iframe frameborder="0" height="479" name="Yr63hFuh" src="https://leetcode.com/playground/Yr63hFuh/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(1)</script>.  We all <script type="math/tex; mode=display">4^4</script> possible times and take the best one.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '682',
    name: 'Baseball Game',
    acceptance: '58.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nYou\'re now a baseball game point recorder.\n</p>\n\n<p>\nGiven a list of strings, each string can be one of the 4 following types:\n</p><ol>\n<li><code>Integer</code> (one round\'s score): Directly represents the number of points you get in this round.</li>\n<li><code>"+"</code> (one round\'s score): Represents that the points you get in this round are the sum of the last two <code>valid</code> round\'s points.</li>\n<li><code>"D"</code> (one round\'s score): Represents that the points you get in this round are the doubled data of the last <code>valid</code> round\'s points.</li>\n<li><code>"C"</code> (an operation, which isn\'t a round\'s score): Represents the last <code>valid</code> round\'s points you get were invalid and should be removed.</li>\n</ol>\n<p></p>\n\n<p>\nEach round\'s operation is permanent and could have an impact on the round before and the round after.\n</p>\n\n<p>\nYou need to return the sum of the points you could get in all the rounds.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> ["5","2","C","D","+"]\n<b>Output:</b> 30\n<b>Explanation:</b> \nRound 1: You could get 5 points. The sum is: 5.\nRound 2: You could get 2 points. The sum is: 7.\nOperation 1: The round 2\'s data was invalid. The sum is: 5.  \nRound 3: You could get 10 points (the round 2\'s data has been removed). The sum is: 15.\nRound 4: You could get 5 + 10 = 15 points. The sum is: 30.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> ["5","-2","4","C","D","9","+","+"]\n<b>Output:</b> 27\n<b>Explanation:</b> \nRound 1: You could get 5 points. The sum is: 5.\nRound 2: You could get -2 points. The sum is: 3.\nRound 3: You could get 4 points. The sum is: 7.\nOperation 1: The round 3\'s data is invalid. The sum is: 3.  \nRound 4: You could get -4 points (the round 3\'s data has been removed). The sum is: -1.\nRound 5: You could get 9 points. The sum is: 8.\nRound 6: You could get -4 + 9 = 5 points. The sum is 13.\nRound 7: You could get 9 + 5 = 14 points. The sum is 27.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><li>The size of the input list will be between 1 and 1000.</li>\n<li>Every integer represented in the list will be between -30000 and 30000.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<h4 id="approach-1-stack-accepted">Approach #1: Stack [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Let\'s maintain the value of each valid round on a stack as we process the data.  A stack is ideal since we only deal with operations involving the last or second-last valid round.</p>\n<iframe frameborder="0" height="462" name="FRAbgcgJ" src="https://leetcode.com/playground/FRAbgcgJ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>ops</code>.  We parse through every element in the given array once, and do <script type="math/tex; mode=display">O(1)</script> work for each element.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the space used to store our <code>stack</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '683',
    name: 'K Empty Slots ',
    acceptance: '36.4%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>\nThere is a garden with <code>N</code> slots. In each slot, there is a flower. The <code>N</code> flowers will bloom one by one in <code>N</code> days. In each day, there will be <code>exactly</code> one flower blooming and it will be in the status of blooming since then.\n</p>\n\n<p>\nGiven an array <code>flowers</code> consists of number from <code>1</code> to <code>N</code>. Each number in the array represents the place where the flower will open in that day.\n</p>\n\n<p>\nFor example, <code>flowers[i] = x</code> means that the unique flower that blooms at day <code>i</code> will be at position <code>x</code>, where <code>i</code> and <code>x</code> will be in the range from <code>1</code> to <code>N</code>.\n</p>\n\n<p>\nAlso given an integer <code>k</code>, you need to output in which day there exists two flowers in the status of blooming, and also the number of flowers between them is <code>k</code> and these flowers are not blooming.\n</p>\n\n<p>\nIf there isn't such day, output -1.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \nflowers: [1,3,2]\nk: 1\n<b>Output:</b> 2\n<b>Explanation:</b> In the second day, the first and the third flower have become blooming.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \nflowers: [1,2,3]\nk: 1\n<b>Output:</b> -1\n</pre>\n<p></p>\n\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The given array will be in the range [1, 20000].</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<h4 id="approach-1-insert-into-sorted-structure-accepted">Approach #1: Insert Into Sorted Structure [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Let\'s add flowers in the order they bloom.  When each flower blooms, we check it\'s neighbors to see if they can satisfy the condition with the current flower.</p>\n<p><strong>Algorithm</strong></p>\n<p>We\'ll maintain <code>active</code>, a sorted data structure containing every flower that has currently bloomed.  When we add a flower to <code>active</code>, we should check it\'s lower and higher neighbors.  If some neighbor satisfies the condition, we know the condition occurred first on this day.</p>\n<iframe frameborder="0" height="326" name="cYMSzwUd" src="https://leetcode.com/playground/cYMSzwUd/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity (Java): <script type="math/tex; mode=display">O(N \\log N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>flowers</code>.  Every insertion and search is <script type="math/tex; mode=display">O(\\log N)</script>.</p>\n</li>\n<li>\n<p>Time Complexity (Python): <script type="math/tex; mode=display">O(N^2)</script>.  As above, except <code>list.insert</code> is <script type="math/tex; mode=display">O(N)</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of <code>active</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-min-queue-accepted">Approach #2: Min Queue [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>For each contiguous block ("window") of <code>k</code> positions in the flower bed, we know it satisfies the condition in the problem statement if the minimum blooming date of this window is larger than the blooming date of the left and right neighbors.</p>\n<p>Because these windows overlap, we can calculate these minimum queries more efficiently using a sliding window structure.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let <code>days[x] = i</code> be the time that the flower at position <code>x</code> blooms.  For each window of <code>k</code> days, let\'s query the minimum of this window in (amortized) constant time using a <code>MinQueue</code>, a data structure built just for this task.  If this minimum is larger than it\'s two neighbors, then we know this is a place where "<code>k</code> empty slots" occurs, and we record this candidate answer.</p>\n<p>To operate a <code>MinQueue</code>, the key invariant is that <code>mins</code> will be an increasing list of candidate answers to the query <code>MinQueue.min</code>.  </p>\n<p>For example, if our queue is <code>[1, 3, 6, 2, 4, 8]</code>, then <code>mins</code> will be <code>[1, 2, 4, 8]</code>.  As we <code>MinQueue.popleft</code>, <code>mins</code> will become <code>[2, 4, 8]</code>, then after 3 more <code>popleft</code>\'s will become <code>[4, 8]</code>, then after 1 more <code>popleft</code> will become <code>[8]</code>.  </p>\n<p>As we <code>MinQueue.append</code>, we should maintain this invariant.  We do it by popping any elements larger than the one we are inserting.  For example, if we appended <code>5</code> to <code>[1, 3, 6, 2, 4, 8]</code>, then <code>mins</code> which was <code>[1, 2, 4, 8]</code> becomes <code>[1, 2, 4, 5]</code>.</p>\n<p>Note that we used a simpler variant of <code>MinQueue</code> that requires every inserted element to be unique to ensure correctness.  Also, the operations are amortized constant time because every element will be inserted and removed exactly once from each queue.</p>\n<iframe frameborder="0" height="515" name="kJxmutAX" src="https://leetcode.com/playground/kJxmutAX/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>flowers</code>.  In enumerating through the <script type="math/tex; mode=display">O(N)</script> outer loop, we do constant work as <code>MinQueue.popleft</code> and <code>MinQueue.min</code> operations are (amortized) constant time.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of our <code>window</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-sliding-window-accepted">Approach #3: Sliding Window [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>As in <em>Approach #2</em>, we have <code>days[x] = i</code> for the time that the flower at position <code>x</code> blooms.  We wanted to find <em>candidate</em> intervals <code>[left, right]</code> where <code>days[left], days[right]</code> are the two smallest values in <code>[days[left], days[left+1], ..., days[right]]</code>, and <code>right - left = k + 1</code>.</p>\n<p>Notice that these candidate intervals cannot intersect: for example, if the candidate intervals are <code>[left1, right1]</code> and <code>[left2, right2]</code> with <code>left1 &lt; left2 &lt; right1 &lt; right2</code>, then for the first interval to be a candidate, <code>days[left2] &gt; days[right1]</code>; and for the second interval to be a candidate, <code>days[right1] &gt; days[left2]</code>, a contradiction.</p>\n<p>That means whenever whether some interval can be a candidate and it fails first at <code>i</code>, indices <code>j &lt; i</code> can\'t be the start of a candidate interval.  This motivates a sliding window approach.</p>\n<p><strong>Algorithm</strong></p>\n<p>As in <em>Approach #2</em>, we construct <code>days</code>.</p>\n<p>Then, for each interval <code>[left, right]</code> (starting with the first available one), we\'ll check whether it is a candidate: whether <code>days[i] &gt; days[left]</code> and <code>days[i] &gt; days[right]</code> for <code>left &lt; i &lt; right</code>.</p>\n<p>If we fail, then we\'ve found some new minimum <code>days[i]</code> and we should check the new interval <code>[i, i+k+1]</code>.  If we succeed, then it\'s a candidate answer, and we\'ll check the new interval <code>[right, right+k+1]</code>.</p>\n<iframe frameborder="0" height="497" name="YBwfZARy" src="https://leetcode.com/playground/YBwfZARy/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time and Space Complexity: <script type="math/tex; mode=display">O(N)</script>.  The analysis is the same as in Approach #2.</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.  Approach #1 inspired by <a href="https://leetcode.com/stefanpochmann">@StefanPochmann</a>.  Approach #3 inspired by <a href="https://discuss.leetcode.com/topic/104771/java-c-simple-o-n-solution">@Vincent Cai</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '684',
    name: 'Redundant Connection',
    acceptance: '40.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nIn this problem, a tree is an <b>undirected</b> graph that is connected and has no cycles.\n</p><p>\nThe given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.\n</p><p>\nThe resulting graph is given as a 2D-array of <code>edges</code>.  Each element of <code>edges</code> is a pair <code>[u, v]</code> with <code>u &lt; v</code>, that represents an <b>undirected</b> edge connecting nodes <code>u</code> and <code>v</code>.\n</p><p>\nReturn an edge that can be removed so that the resulting graph is a tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.  The answer edge <code>[u, v]</code> should be in the same format, with <code>u &lt; v</code>.\n</p><p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [[1,2], [1,3], [2,3]]\n<b>Output:</b> [2,3]\n<b>Explanation:</b> The given undirected graph will be like this:\n  1\n / \\\n2 - 3\n</pre>\n<p></p>\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [[1,2], [2,3], [3,4], [1,4], [1,5]]\n<b>Output:</b> [1,4]\n<b>Explanation:</b> The given undirected graph will be like this:\n5 - 1 - 2\n    |   |\n    4 - 3\n</pre>\n<p></p>\n<p><b>Note:</b><br>\n</p><li>The size of the input 2D-array will be between 3 and 1000.</li>\n<li>Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.</li>\n<p></p>\n\n<br>\n\n<p>\n<b><font color="red">Update (2017-09-26):</font></b><br>\nWe have overhauled the problem description + test cases and specified clearly the graph is an <b><i>undirected</i></b> graph. For the <b><i>directed</i></b> graph follow up please see <b><a href="https://leetcode.com/problems/redundant-connection-ii/description/">Redundant Connection II</a></b>). We apologize for any inconvenience caused.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-dfs-accepted">Approach #1: DFS [Accepted]</a></li>\n<li><a href="#approach-2-union-find-accepted">Approach #2: Union-Find [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-dfs-accepted">Approach #1: DFS [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>For each edge <code>(u, v)</code>, traverse the graph with a depth-first search to see if we can connect <code>u</code> to <code>v</code>.  If we can, then it must be the duplicate edge.</p>\n<iframe frameborder="0" height="515" name="W7EXu5ND" src="https://leetcode.com/playground/W7EXu5ND/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity:  <script type="math/tex; mode=display">O(N^2)</script> where <script type="math/tex; mode=display">N</script> is the number of vertices (and also the number of edges) in the graph.  In the worst case, for every edge we include, we have to search every previously-occurring edge of the graph.</p>\n</li>\n<li>\n<p>Space Complexity:  <script type="math/tex; mode=display">O(N)</script>.  The current construction of the graph has at most <script type="math/tex; mode=display">N</script> nodes.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-union-find-accepted">Approach #2: Union-Find [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>If we are familiar with a Disjoint Set Union (DSU) data structure, we can use this in a straightforward manner to solve the problem: we simply find the first edge occurring in the graph that is already connected.  The rest of this explanation will focus on the details of implementing DSU.</p>\n<p>A DSU data structure can be used to maintain knowledge of the connected components of a graph, and query for them quickly.  In particular, we would like to support two operations:</p>\n<ul>\n<li>\n<p><code>dsu.find(node x)</code>, which outputs a unique id so that two nodes have the same id if and only if they are in the same connected component, and:</p>\n</li>\n<li>\n<p><code>dsu.union(node x, node y)</code>, which draws an edge <code>(x, y)</code> in the graph, connecting the components with id <code>find(x)</code> and <code>find(y)</code> together.</p>\n</li>\n</ul>\n<p>To achieve this, we keep track of <code>parent</code>, which remembers the <code>id</code> of a smaller node in the same connected component.  If the node is it\'s own parent, we call this the <em>leader</em> of that connected component.</p>\n<p>A naive implementation of a DSU structure would look something like this:</p>\n<p><em>Psuedocode</em></p>\n<iframe frameborder="0" height="190" name="sCjT3wyq" src="https://leetcode.com/playground/sCjT3wyq/shared" width="100%"></iframe>\n<p>We use two techniques to improve the run-time complexity: <em>path compression</em>, and <em>union-by-rank</em>.</p>\n<ul>\n<li>\n<p>Path compression involves changing the <code>x = parent[x]</code> in the <code>find</code> function to <code>parent[x] = find(parent[x])</code>.  Basically, as we compute the correct leader for x, we should remember our calculation.</p>\n</li>\n<li>\n<p>Union-by-rank involves distributing the workload of <code>find</code> across leaders evenly.  Whenever we <code>dsu.union(x, y)</code>, we have two leaders <code>xr, yr</code> and we have to choose whether we want <code>parent[x] = yr</code> or <code>parent[y] = xr</code>.  We choose the leader that has a higher following to pick up a new follower.<br>\nSpecifically, the meaning of <code>rank</code> is that there are less than <code>2 ^ rank[x]</code> followers of <code>x</code>.  This strategy can be shown to give us better bounds for how long the recursive loop in <code>dsu.find</code> could run for.<br></p>\n</li>\n</ul>\n<iframe frameborder="0" height="515" name="tFfjEuXo" src="https://leetcode.com/playground/tFfjEuXo/shared" width="100%"></iframe>\n<p><em>Alternate Implementation of DSU without Union-By-Rank</em>\n<iframe frameborder="0" height="207" name="DzMVxYRc" src="https://leetcode.com/playground/DzMVxYRc/shared" width="100%"></iframe></p>\n<iframe frameborder="0" height="515" name="YgdvM9bJ" src="https://leetcode.com/playground/YgdvM9bJ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity:  <script type="math/tex; mode=display">O(N\\alpha(N)) \\approx O(N)</script>, where <script type="math/tex; mode=display">N</script> is the number of vertices (and also the number of edges) in the graph, and <script type="math/tex; mode=display">\\alpha</script> is the <em>Inverse-Ackermann</em> function.  We make up to <script type="math/tex; mode=display">N</script> queries of <code>dsu.union</code>, which takes (amortized) <script type="math/tex; mode=display">O(\\alpha(N))</script> time.  Outside the scope of this article, it can be shown why <code>dsu.union</code> has <script type="math/tex; mode=display">O(\\alpha(N))</script> complexity, what the Inverse-Ackermann function is, and why <script type="math/tex; mode=display">O(\\alpha(N))</script> is approximately <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n<li>\n<p>Space Complexity:  <script type="math/tex; mode=display">O(N)</script>.  The current construction of the graph (embedded in our <code>dsu</code> structure) has at most <script type="math/tex; mode=display">N</script> nodes.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '685',
    name: 'Redundant Connection II',
    acceptance: '28.6%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nIn this problem, a rooted tree is a <b>directed</b> graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.\n</p><p>\nThe given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, ..., N), with one additional directed edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.\n</p><p>\nThe resulting graph is given as a 2D-array of <code>edges</code>.  Each element of <code>edges</code> is a pair <code>[u, v]</code> that represents a <b>directed</b> edge connecting nodes <code>u</code> and <code>v</code>, where <code>u</code> is a parent of child <code>v</code>.\n</p><p>\nReturn an edge that can be removed so that the resulting graph is a rooted tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.\n</p><p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [[1,2], [1,3], [2,3]]\n<b>Output:</b> [2,3]\n<b>Explanation:</b> The given directed graph will be like this:\n  1\n / \\\nv   v\n2--&gt;3\n</pre>\n<p></p>\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [[1,2], [2,3], [3,4], [4,1], [1,5]]\n<b>Output:</b> [4,1]\n<b>Explanation:</b> The given directed graph will be like this:\n5 &lt;- 1 -&gt; 2\n     ^    |\n     |    v\n     4 &lt;- 3\n</pre>\n<p></p>\n<p><b>Note:</b><br>\n</p><li>The size of the input 2D-array will be between 3 and 1000.</li>\n<li>Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Starting from a rooted tree with <code>N-1</code> edges and <code>N</code> vertices, let\'s enumerate the possibilities for the added "redundant" edge.  If there is no loop, then either one vertex must have two parents (or no edge is redundant.)  If there is a loop, then either one vertex has two parents, or every vertex has one parent.</p>\n<p>In the first two cases, there are only two candidates for deleting an edge, and we can try removing the last one and seeing if that works.  In the last case, the last edge of the cycle can be removed: for example, when <code>1-&gt;2-&gt;3-&gt;4-&gt;1-&gt;5</code>, we want the last edge (by order of occurrence) in the cycle <code>1-&gt;2-&gt;3-&gt;4-&gt;1</code> (but not necessarily <code>1-&gt;5</code>).</p>\n<p><strong>Algorithm</strong></p>\n<p>We\'ll first construct the underlying graph, keeping track of edges coming from nodes with multiple parents.  After, we either have 2 or 0 <code>candidates</code>.</p>\n<p>If there are no candidates, then every vertex has one parent, such as in the case <code>1-&gt;2-&gt;3-&gt;4-&gt;1-&gt;5</code>.  From any node, we walk towards it\'s parent until we revisit a node - then we must be inside the cycle, and any future seen nodes are part of that cycle.  Now we take the last edge that occurs in the cycle.</p>\n<p>Otherwise, we\'ll see if the graph induced by <code>parent</code> is a rooted tree.  We again take the <code>root</code> by walking from any node towards the parent until we can\'t, then we perform a depth-first search on this <code>root</code>.  If we visit every node, then removing the last of the two edge candidates is acceptable, and we should.  Otherwise, we should remove the first of the two edge candidates.</p>\n<p>In our solution, we use <code>orbit</code> to find the result upon walking from a node <code>x</code> towards it\'s parent repeatedly until you revisit a node or can\'t walk anymore.  <code>orbit(x).node</code> (or <code>orbit(x)[0]</code> in Python) will be the resulting node, while <code>orbit(x).seen</code> (or <code>orbit(x)[1]</code>) will be all the nodes visited.</p>\n<iframe frameborder="0" height="500" name="sHSf6pyj" src="https://leetcode.com/playground/sHSf6pyj/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity:  <script type="math/tex; mode=display">O(N)</script> where <script type="math/tex; mode=display">N</script> is the number of vertices (and also the number of edges) in the graph.  We perform a depth-first search.</p>\n</li>\n<li>\n<p>Space Complexity:  <script type="math/tex; mode=display">O(N)</script>, the size of the graph.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '686',
    name: 'Repeated String Match',
    acceptance: '34.3%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1.</p>\n\n<p>\nFor example, with A = "abcd" and B = "cdabcdab". </p>\n\n<p>\nReturn 3, because by repeating A three times (“abcdabcdabcd”), B is a substring of it; and B is not a substring of A repeated two times ("abcdabcd").\n</p>\n\n<p><b>Note:</b><br>\nThe length of <code>A</code> and <code>B</code> will be between 1 and 10000.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-ad-hoc-accepted">Approach #1: Ad-Hoc [Accepted]</a></li>\n<li><a href="#approach-2-rabin-karp-rolling-hash-accepted">Approach #2: Rabin-Karp (Rolling Hash) [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-ad-hoc-accepted">Approach #1: Ad-Hoc [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>The question can be summarized as "What is the smallest <code>k</code> for which <code>B</code> is a substring of <code>A * k</code>?"  We can just try every <code>k</code>.</p>\n<p><strong>Algorithm</strong></p>\n<p>Imagine we wrote <code>S = A+A+A+...</code>.  If <code>B</code> is to be a substring of <code>S</code>, we only need to check whether some <code>S[0:], S[1:], ..., S[len(A) - 1:]</code> starts with <code>B</code>, as <code>S</code> is long enough to contain <code>B</code>, and <code>S</code> has period at most <code>len(A)</code>.</p>\n<p>Now, suppose <code>q</code> is the least number for which <code>len(B) &lt;= len(A * q)</code>.  We only need to check whether <code>B</code> is a substring of <code>A * q</code> or <code>A * (q+1)</code>.  If we try <code>k &lt; q</code>, then <code>B</code> has larger length than <code>A * q</code> and therefore can\'t be a substring.  When <code>k = q+1</code>, <code>A * k</code> is already big enough to try all positions for <code>B</code>; namely, <code>A[i:i+len(B)] == B</code> for <code>i = 0, 1, ..., len(A) - 1</code>.</p>\n<iframe frameborder="0" height="224" name="gTtmgvev" src="https://leetcode.com/playground/gTtmgvev/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N*(N+M))</script>, where <script type="math/tex; mode=display">M, N</script> are the lengths of strings <code>A, B</code>.  We create two strings <code>A * q</code>, <code>A * (q+1)</code> which have length at most <code>O(M+N)</code>.  When checking whether <code>B</code> is a substring of <code>A</code>, this check takes naively the product of their lengths.</p>\n</li>\n<li>\n<p>Space complexity: As justified above, we created strings that used <script type="math/tex; mode=display">O(M+N)</script> space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-rabin-karp-rolling-hash-accepted">Approach #2: Rabin-Karp (Rolling Hash) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>As in <em>Approach #1</em>, we\'ve reduced the problem to deciding whether B is a substring of some <code>A * k</code>.  Using the following technique, we can decide whether <code>B</code> is a substring in <script type="math/tex; mode=display">O(len(A) * k)</script> time.</p>\n<p><strong>Algorithm</strong></p>\n<p>For strings <script type="math/tex; mode=display">S</script>, consider each <script type="math/tex; mode=display">S[i]</script> as some integer ASCII code.  Then for some prime <script type="math/tex; mode=display">p</script>, consider the following function modulo some prime modulus <script type="math/tex; mode=display">\\mathcal{M}</script>:</p>\n<p>\n<script type="math/tex; mode=display">\\text{hash}(S) = \\sum_{0 \\leq i < len(S)} p^i * S[i]</script>\n</p>\n<p>Notably, <script type="math/tex; mode=display">\\text{hash}(S[1:] + x) = \\frac{(\\text{hash}(S) - S[0])}{p} + p^{n-1} x</script>.  This shows we can get the hash of every substring of <code>A * q</code> in time complexity linear to it\'s size.  (We will also use the fact that <script type="math/tex; mode=display">p^{-1} = p^{\\mathcal{M}-2} \\mod \\mathcal{M}</script>.)</p>\n<p>However, hashes may collide haphazardly.  To be absolutely sure in theory, we should check the answer in the usual way.  The expected number of checks we make is in the order of <script type="math/tex; mode=display">1 + \\frac{s}{\\mathcal{M}}</script> where <script type="math/tex; mode=display">s</script> is the number of substrings we computed hashes for (assuming the hashes are equally distributed), which is effectively 1.</p>\n<iframe frameborder="0" height="515" name="DKSFgXSr" src="https://leetcode.com/playground/DKSFgXSr/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(M+N)</script> (at these sizes), where <script type="math/tex; mode=display">M, N</script> are the lengths of strings <code>A, B</code>.  As in <em>Approach #1</em>, we justify that <code>A * (q+1)</code> will be of length <script type="math/tex; mode=display">O(M + N)</script>, and computing the rolling hashes was linear work.  We will also do a linear <script type="math/tex; mode=display">O(N)</script> final check of our answer <script type="math/tex; mode=display">1 + O(M) / \\mathcal{M}</script> times.  In total, this is <script type="math/tex; mode=display">O(M+N + N(1 + \\frac{M}{\\mathcal{M}}))</script> work.  Since <script type="math/tex; mode=display">M \\leq 10000 < \\mathcal{M} = 10^9 + 7</script>, we can consider this to be linear behavior.</p>\n</li>\n<li>\n<p>Space complexity:  <script type="math/tex; mode=display">O(1)</script>.  Only integers were stored with additional memory.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '687',
    name: 'Longest Univalue Path',
    acceptance: '34.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.</p>\n\n<p><b>Note:</b> The length of path between two nodes is represented by the number of edges between them.</p>\n\n<p>\n<b>Example 1:</b>\n</p>\n\n\n<p>\nInput:\n</p><pre>              5\n             / \\\n            4   5\n           / \\   \\\n          1   1   5\n</pre>\n<p></p>\n\n<p>\nOutput:\n</p><pre>2\n</pre>\n<p></p>\n\n<p>\n<b>Example 2:</b>\n</p>\n\n\n<p>\nInput:\n</p><pre>              1\n             / \\\n            4   5\n           / \\   \\\n          4   4   5\n</pre>\n<p></p>\n\n<p>\nOutput:\n</p><pre>2\n</pre>\n<p></p>\n\n<p><b>Note:</b>\nThe given binary tree has not more than 10000 nodes.  The height of the tree is not more than 1000.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-recursion-accepted">Approach #1: Recursion [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-recursion-accepted">Approach #1: Recursion [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can think of any path (of nodes with the same values) as up to two arrows extending from it\'s root.</p>\n<p>Specifically, the <em>root</em> of a path will be the unique node such that the parent of that node does not appear in the path, and an <em>arrow</em> will be a path where the root only has one child node in the path.</p>\n<p>Then, for each node, we want to know what is the longest possible arrow extending left, and the longest possible arrow extending right?  We can solve this using recursion.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let <code>arrow_length(node)</code> be the length of the longest arrow that extends from the <code>node</code>.  That will be <code>1 + arrow_length(node.left)</code> if <code>node.left</code> exists and has the same value as <code>node</code>.  Similarly for the <code>node.right</code> case.</p>\n<p>While we are computing arrow lengths, each candidate answer will be the sum of the arrows in both directions from that node.  We record these candidate answers and return the best one.</p>\n<iframe frameborder="0" height="428" name="DjHbgZUi" src="https://leetcode.com/playground/DjHbgZUi/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the number of nodes in the tree.  We process every node once.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(H)</script>, where <script type="math/tex; mode=display">H</script> is the height of the tree.  Our recursive call stack could be up to <script type="math/tex; mode=display">H</script> layers deep.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '688',
    name: 'Knight Probability in Chessboard',
    acceptance: '39.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nOn an <code>N</code>x<code>N</code> chessboard, a knight starts at the <code>r</code>-th row and <code>c</code>-th column and attempts to make exactly <code>K</code> moves.  The rows and columns are 0 indexed, so the top-left square is <code>(0, 0)</code>, and the bottom-right square is <code>(N-1, N-1)</code>.\n</p>\n\n<p>\nA chess knight has 8 possible moves it can make, as illustrated below.  Each move is two squares in a cardinal direction, then one square in an orthogonal direction.\n</p>\n\n<img src="https://leetcode.com/static/images/problemset/knight.png" style="width:200px; height:200px">\n\n<p>\nEach time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\n</p>\n\n<p>\nThe knight continues moving until it has made exactly <code>K</code> moves or has moved off the chessboard.  Return the probability that the knight remains on the board after it has stopped moving.\n</p>\n\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> 3, 2, 0, 0\n<b>Output:</b> 0.0625\n<b>Explanation:</b> There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\nFrom each of those positions, there are also two moves that will keep the knight on the board.\nThe total probability the knight stays on the board is 0.0625.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><li><code>N</code> will be between 1 and 25.</li>\n<li><code>K</code> will be between 0 and 100.</li>\n<li>The knight always initially starts on the board.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-2-matrix-exponentiation-accepted">Approach #2: Matrix Exponentiation [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Let <code>f[r][c][steps]</code> be the probability of being on square <code>(r, c)</code> after <code>steps</code> steps.  Based on how a knight moves, we have the following recursion:</p>\n<p>\n<script type="math/tex; mode=display">f[r][c][steps] = \\sum_{dr, dc} f[r+dr][c+dc][steps-1] / 8.0</script>\n</p>\n<p>where the sum is taken over the eight <script type="math/tex; mode=display">(dr, dc)</script> pairs <script type="math/tex; mode=display">(2, 1),</script>\n<script type="math/tex; mode=display">(2, -1),</script>\n<script type="math/tex; mode=display">(-2, 1),</script>\n<script type="math/tex; mode=display">(-2, -1),</script>\n<script type="math/tex; mode=display">(1, 2),</script>\n<script type="math/tex; mode=display">(1, -2),</script>\n<script type="math/tex; mode=display">(-1, 2),</script>\n<script type="math/tex; mode=display">(-1, -2)</script>.</p>\n<p>Instead of using a three-dimensional array <code>f</code>, we will use two two-dimensional ones <code>dp</code> and <code>dp2</code>, storing the result of the two most recent layers we are working on.  <code>dp2</code> will represent <code>f[][][steps]</code>, and <code>dp</code> will represent <code>f[][][steps-1]</code>.</p>\n<iframe frameborder="0" height="515" name="VTNPLt6H" src="https://leetcode.com/playground/VTNPLt6H/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2 K)</script> where <script type="math/tex; mode=display">N, K</script> are defined as in the problem.  We do <script type="math/tex; mode=display">O(1)</script> work on each layer <code>dp</code> of <script type="math/tex; mode=display">N^2</script> elements, and there are <script type="math/tex; mode=display">K</script> layers considered.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N^2)</script>, the size of <code>dp</code> and <code>dp2</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-matrix-exponentiation-accepted">Approach #2: Matrix Exponentiation [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>The recurrence expressed in <em>Approach #1</em> expressed states that transitioned to a linear combination of other states.  Any time this happens, we can represent the entire transition as a matrix of those linear combinations.  Then, the <script type="math/tex; mode=display">n</script>-th power of this matrix represents the transition of <script type="math/tex; mode=display">n</script> moves, and thus we can reduce the problem to a problem of matrix exponentiation.</p>\n<p><strong>Algorithm</strong></p>\n<p>First, there is a lot of symmetry on the board that we can exploit.  Naively, there are <script type="math/tex; mode=display">N^2</script> possible states the knight can be in (assuming it is on the board).  Because of symmetry through the horizontal, vertical, and diagonal axes, we can assume that the knight is in the top-left quadrant of the board, and that the column number is equal to or larger than the row number.  For any square, the square that is found by reflecting about these axes to satisfy these conditions will be the <em>canonical index</em> of that square.</p>\n<p>This will reduce the number of states from <script type="math/tex; mode=display">N^2</script> to approximately <script type="math/tex; mode=display">\\frac{N^2}{8}</script>, which makes the following (cubic) matrix exponentiation on this <script type="math/tex; mode=display">O(\\frac{N^2}{8}) \\times O(\\frac{N^2}{8})</script> matrix approximately <script type="math/tex; mode=display">8^3</script> times faster.</p>\n<p>Now, if we know that every state becomes some linear combination of states after one move, then let\'s write a transition matrix <script type="math/tex; mode=display">\\mathcal{T}</script> of them, where the <script type="math/tex; mode=display">i</script>-th row of <script type="math/tex; mode=display">\\mathcal{T}</script> represents the linear combination of states that the <script type="math/tex; mode=display">i</script>-th state goes to.  Then, <script type="math/tex; mode=display">\\mathcal{T}^n</script> represents a transition of <script type="math/tex; mode=display">n</script> moves, for which we want the sum of the <script type="math/tex; mode=display">i</script>-th row, where <script type="math/tex; mode=display">i</script> is the index of the starting square.</p>\n<iframe frameborder="0" height="515" name="ARu5yUUd" src="https://leetcode.com/playground/ARu5yUUd/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^6 \\log(K))</script> where <script type="math/tex; mode=display">N, K</script> are defined as in the problem.  There are approximately <script type="math/tex; mode=display">\\frac{N^2}{8}</script> canonical states, which makes our matrix multiplication <script type="math/tex; mode=display">O(N^6)</script>.  To find the <script type="math/tex; mode=display">K</script>-th power of this matrix, we make <script type="math/tex; mode=display">O(\\log(K))</script> matrix multiplications.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N^4)</script>.  The matrix has approximately <script type="math/tex; mode=display">\\frac{N^4}{64}</script> elements.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Goldman Sachs'],
  },
  {
    id: '689',
    name: 'Maximum Sum of 3 Non-Overlapping Subarrays',
    acceptance: '41.3%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nIn a given array <code>nums</code> of positive integers, find three non-overlapping subarrays with maximum sum.\n</p>\n<p>\nEach subarray will be of size <code>k</code>, and we want to maximize the sum of all <code>3*k</code> entries.\n</p>\n<p>\nReturn the result as a list of indices representing the starting position of each interval (0-indexed).  If there are multiple answers, return the lexicographically smallest one.\n</p>\n<p><b>Example:</b><br>\n</p><pre><b>Input:</b> [1,2,1,2,6,7,5,1], 2\n<b>Output:</b> [0, 3, 5]\n<b>Explanation:</b> Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].\nWe could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><li><code>nums.length</code> will be between 1 and 20000.</li>\n<li><code>nums[i]</code> will be between 1 and 65535.</li>\n<li><code>k</code> will be between 1 and floor(nums.length / 3).</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-ad-hoc-accepted">Approach #1: Ad-Hoc [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-ad-hoc-accepted">Approach #1: Ad-Hoc [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>It is natural to consider an array <code>W</code> of each interval\'s sum, where each interval is the given length <code>K</code>.  To create <code>W</code>, we can either use prefix sums, or manage the sum of the interval as a window slides along the array.</p>\n<p>From there, we approach the reduced problem: Given some array <code>W</code> and an integer <code>K</code>, what is the lexicographically smallest tuple of indices <code>(i, j, k)</code> with <code>i + K &lt;= j</code> and <code>j + K &lt;= k</code> that maximizes <code>W[i] + W[j] + W[k]</code>?</p>\n<p><strong>Algorithm</strong></p>\n<p>Suppose we fixed <code>j</code>.  We would like to know on the intervals <script type="math/tex; mode=display">i \\in [0, j-K]</script> and <script type="math/tex; mode=display">k \\in [j+K, \\text{len}(W)-1]</script>, where the largest value of <script type="math/tex; mode=display">W[i]</script> (and respectively <script type="math/tex; mode=display">W[k]</script>) occurs first.  (Here, first means the smaller index.)</p>\n<p>We can solve these problems with dynamic programming.  For example, if we know that <script type="math/tex; mode=display">i</script> is where the largest value of <script type="math/tex; mode=display">W[i]</script> occurs first on <script type="math/tex; mode=display">[0, 5]</script>, then on <script type="math/tex; mode=display">[0, 6]</script> the first occurrence of the largest <script type="math/tex; mode=display">W[i]</script> must be either <script type="math/tex; mode=display">i</script> or <script type="math/tex; mode=display">6</script>.  If say, <script type="math/tex; mode=display">6</script> is better, then we set <code>best = 6</code>.</p>\n<p>At the end, <code>left[z]</code> will be the first occurrence of the largest value of <code>W[i]</code> on the interval <script type="math/tex; mode=display">i \\in [0, z]</script>, and <code>right[z]</code> will be the same but on the interval <script type="math/tex; mode=display">i \\in [z, \\text{len}(W) - 1]</script>.  This means that for some choice <code>j</code>, the candidate answer must be <code>(left[j-K], j, right[j+K])</code>.  We take the candidate that produces the maximum <code>W[i] + W[j] + W[k]</code>.</p>\n<iframe frameborder="0" height="515" name="rcX96JEv" src="https://leetcode.com/playground/rcX96JEv/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of the array.  Every loop is bounded in the number of steps by <script type="math/tex; mode=display">N</script>, and does <script type="math/tex; mode=display">O(1)</script> work.</p>\n</li>\n<li>\n<p>Space complexity:  <script type="math/tex; mode=display">O(N)</script>.  <code>W</code>, <code>left</code>, and <code>right</code> all take <script type="math/tex; mode=display">O(N)</script> memory.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Google', 'Facebook'],
  },
  {
    id: '690',
    name: 'Employee Importance',
    acceptance: '52.5%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>You are given a data structure of employee information, which includes the employee's <b>unique id</b>, his <b>importance value</b> and his <b>direct</b> subordinates' id. </p>\n\n<p>For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is <b>not direct</b>.</p>\n\n<p>Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1\n<b>Output:</b> 11\n<b>Explanation:</b>\nEmployee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>One employee has at most one <b>direct</b> leader and may have several subordinates.</li>\n<li>The maximum number of employees won't exceed 2000.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Let\'s use a hashmap <code>emap = {employee.id -&gt; employee}</code> to query employees quickly.</p>\n<p>Now to find the total importance of an employee, it will be the importance of that employee, plus the total importance of each of that employee\'s subordinates.  This is a straightforward depth-first search.</p>\n<iframe frameborder="0" height="310" name="NX7sm9qW" src="https://leetcode.com/playground/NX7sm9qW/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the number of employees.  We might query each employee in <code>dfs</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of the implicit call stack when evaluating <code>dfs</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Uber'],
  },
  {
    id: '691',
    name: 'Stickers to Spell Word',
    acceptance: '33.9%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nWe are given N different types of stickers.  Each sticker has a lowercase English word on it.\n</p><p>\nYou would like to spell out the given <code>target</code> string by cutting individual letters from your collection of stickers and rearranging them.\n</p><p>\nYou can use each sticker more than once if you want, and you have infinite quantities of each sticker.\n</p><p>\nWhat is the minimum number of stickers that you need to spell out the <code>target</code>?  If the task is impossible, return -1.\n</p>\n\n<p><b>Example 1:</b></p>\n<p>Input:</p><pre>["with", "example", "science"], "thehat"\n</pre><p></p>\n\n<p>Output:</p><pre>3\n</pre><p></p>\n\n<p>Explanation:</p><pre>We can use 2 "with" stickers, and 1 "example" sticker.\nAfter cutting and rearrange the letters of those stickers, we can form the target "thehat".\nAlso, this is the minimum number of stickers necessary to form the target string.\n</pre><p></p>\n\n<p><b>Example 2:</b></p>\n<p>Input:</p><pre>["notice", "possible"], "basicbasic"\n</pre><p></p>\n\n<p>Output:</p><pre>-1\n</pre><p></p>\n\n<p>Explanation:</p><pre>We can\'t form the target "basicbasic" from cutting letters from the given stickers.\n</pre><p></p>\n\n<p><b>Note:</b>\n</p><li><code>stickers</code> has length in the range <code>[1, 50]</code>.</li>\n<li><code>stickers</code> consists of lowercase English words (without apostrophes).</li>\n<li><code>target</code> has length in the range <code>[1, 15]</code>, and consists of lowercase English letters.</li>\n<li>In all test cases, all words were chosen <u>randomly</u> from the 1000 most common US English words, and the target was chosen as a concatenation of two random words.</li>\n<li>The time limit may be more challenging than usual.  It is expected that a 50 sticker test case can be solved within 35ms on average.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-optimized-exhaustive-search">Approach 1: Optimized Exhaustive Search</a></li>\n<li><a href="#approach-2-dynamic-programming">Approach 2: Dynamic Programming</a></li>\n</ul>\n</div>\n<h4 id="approach-1-optimized-exhaustive-search">Approach 1: Optimized Exhaustive Search</h4>\n<p><br></p>\n<p><strong>Intuition</strong></p>\n<p>A natural answer is to exhaustively search combinations of stickers.  Because the data is randomized, there are many heuristics available to us that will make this faster.</p>\n<ul>\n<li>\n<p>For all stickers, we can ignore any letters that are not in the target word.</p>\n</li>\n<li>\n<p>When our candidate answer won\'t be smaller than an answer we have already found, we can stop searching this path.</p>\n</li>\n<li>\n<p>We should try to have our exhaustive search bound the answer as soon as possible, so the effect described in the above point happens more often.</p>\n</li>\n<li>\n<p>When a sticker dominates another, we shouldn\'t include the dominated sticker in our sticker collection.  [Here, we say a sticker <code>A</code> dominates <code>B</code> if <code>A.count(letter) &gt;= B.count(letter)</code> for all letters.]</p>\n</li>\n</ul>\n<p><br></p>\n<p><strong>Algorithm</strong></p>\n<p>Firstly, for each sticker, let\'s create a count of that sticker (a mapping <code>letter -&gt; sticker.count(letter)</code>) that does not consider letters not in the target word.  Let <code>A</code> be an array of these counts.  Also, let\'s create <code>t_count</code>, a count of our <code>target</code> word.</p>\n<p>Secondly, let\'s remove dominated stickers.  Because dominance is a transitive relation, we only need to check if a sticker is not dominated by any other sticker once - the ones that aren\'t dominated are included in our collection.</p>\n<p>We are now ready to begin our exhaustive search.  A call to <code>search(ans)</code> denotes that we want to decide the minimum number of stickers we can used in <code>A</code> to satisfy the target count <code>t_count</code>.  <code>ans</code> will store the currently formed answer, and <code>best</code> will store the current best answer.</p>\n<p>If our current answer can\'t beat our current best answer, we should stop searching.  Also, if there are no stickers left and our target is satisfied, we should update our answer.</p>\n<p>Otherwise, we want to know the maximum number of this sticker we can use.  For example, if this sticker is <code>\'abb\'</code> and our target is <code>\'aaabbbbccccc\'</code>, then we could use a maximum of 3 stickers.  This is the maximum of <code>math.ceil(target.count(letter) / sticker.count(letter))</code>, taken over all <code>letter</code>s in <code>sticker</code>.  Let\'s call this quantity <code>used</code>.</p>\n<p>After, for the sticker we are currently considering, we try to use <code>used</code> of them, then <code>used - 1</code>, <code>used - 2</code> and so on.  The reason we do it in this order is so that we can arrive at a value for <code>best</code> more quickly, which will stop other branches of our exhaustive search from continuing.</p>\n<p>The Python version of this solution showcases using <code>collections.Counter</code> as a way to simplify some code sections, whereas the Java solution sticks to arrays.</p>\n<iframe frameborder="0" height="515" name="KP3fS7G3" src="https://leetcode.com/playground/KP3fS7G3/shared" width="100%"></iframe>\n<p><br></p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: Let <script type="math/tex; mode=display">N</script> be the number of stickers, and <script type="math/tex; mode=display">T</script> be the number of letters in the target word.  A bound for time complexity is <script type="math/tex; mode=display">O(N^{T+1} T^2)</script>: for each sticker, we\'ll have to try using it up to <script type="math/tex; mode=display">T+1</script> times, and updating our target count costs <script type="math/tex; mode=display">O(T)</script>, which we do up to <script type="math/tex; mode=display">T</script> times.  Alternatively, since the answer is bounded at <script type="math/tex; mode=display">T</script>, we can prove that we can only search up to <script type="math/tex; mode=display">\\binom{N+T-1}{T-1}</script> times.  This would be <script type="math/tex; mode=display">O(\\binom{N+T-1}{T-1} T^2)</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N+T)</script>, to store <code>stickersCount</code>, <code>targetCount</code>, and handle the recursive callstack when calling <code>search</code>.</p>\n</li>\n</ul>\n<p><br></p>\n<hr>\n<h4 id="approach-2-dynamic-programming">Approach 2: Dynamic Programming</h4>\n<p><br></p>\n<p><strong>Intuition</strong></p>\n<p>Suppose we need <code>dp[state]</code> stickers to satisfy all <code>target[i]</code>\'s for which the <code>i</code>-th bit of <code>state</code> is set.  We would like to know <code>dp[(1 &lt;&lt; len(target)) - 1]</code>.</p>\n<p><br></p>\n<p><strong>Algorithm</strong></p>\n<p>For each <code>state</code>, let\'s work with it as <code>now</code> and look at what happens to it after applying a sticker.  For each letter in the sticker that can satisfy an unset bit of <code>state</code>, we set the bit (<code>now |= 1 &lt;&lt; i</code>).  At the end, we know <code>now</code> is the result of applying that sticker to <code>state</code>, and we update our <code>dp</code> appropriately.</p>\n<p>When using Python, we will need some extra techniques from <em>Approach #1</em> to pass in time.</p>\n<iframe frameborder="0" height="515" name="JTZ2SYco" src="https://leetcode.com/playground/JTZ2SYco/shared" width="100%"></iframe>\n<p><br></p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(2^T * S * T)</script> where <script type="math/tex; mode=display">S</script> be the total number of letters in all stickers, and <script type="math/tex; mode=display">T</script> be the number of letters in the target word.  We can examine each loop carefully to arrive at this conclusion.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(2^T)</script>, the space used by <code>dp</code>.</p>\n</li>\n</ul>\n<p><br></p>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.  <a href="https://leetcode.com/contest/leetcode-weekly-contest-53/ranking">Approach #2</a> inspired by <a href="https://leetcode.com/dreamoon">@dreamoon</a>.</p>\n</div>\n          ',
    tags: ['IXL'],
  },
  {
    id: '692',
    name: 'Top K Frequent Words',
    acceptance: '40.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a non-empty list of words, return the <i>k</i> most frequent elements.</p>\n<p>Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> ["i", "love", "leetcode", "i", "love", "coding"], k = 2\n<b>Output:</b> ["i", "love"]\n<b>Explanation:</b> "i" and "love" are the two most frequent words.\n    Note that "i" comes before "love" due to a lower alphabetical order.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4\n<b>Output:</b> ["the", "is", "sunny", "day"]\n<b>Explanation:</b> "the", "is", "sunny" and "day" are the four most frequent words,\n    with the number of occurrence being 4, 3, 2 and 1 respectively.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>You may assume <i>k</i> is always valid, 1 ≤ <i>k</i> ≤ number of unique elements.</li>\n<li>Input words contain only lowercase letters.</li>\n</ol>\n<p></p>\n\n<p><b>Follow up:</b><br>\n</p><ol>\n<li>Try to solve it in <i>O</i>(<i>n</i> log <i>k</i>) time and <i>O</i>(<i>n</i>) extra space.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-sorting-accepted">Approach #1: Sorting [Accepted]</a></li>\n<li><a href="#approach-2-heap-accepted">Approach #2: Heap [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-sorting-accepted">Approach #1: Sorting [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Count the frequency of each word, and sort the words with a custom ordering relation that uses these frequencies.  Then take the best <code>k</code> of them.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>\n        <span class="n">count</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>\n        <span class="n">candidates</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>\n        <span class="n">candidates</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">count</span><span class="p">[</span><span class="n">w</span><span class="p">],</span> <span class="n">w</span><span class="p">))</span>\n        <span class="k">return</span> <span class="n">candidates</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">topKFrequent</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">:</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">count</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">candidates</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">keySet</span><span class="o">());</span>\n        <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">candidates</span><span class="o">,</span> <span class="o">(</span><span class="n">w1</span><span class="o">,</span> <span class="n">w2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">w1</span><span class="o">)</span> <span class="o">!=</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">w2</span><span class="o">)</span> <span class="o">?</span>\n                <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">w2</span><span class="o">)</span> <span class="o">-</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">w1</span><span class="o">)</span> <span class="o">:</span> <span class="n">w1</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">w2</span><span class="o">));</span>\n\n        <span class="k">return</span> <span class="n">candidates</span><span class="o">.</span><span class="na">subList</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N \\log{N})</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>words</code>.  We count the frequency of each word in <script type="math/tex; mode=display">O(N)</script> time, then we sort the given words in <script type="math/tex; mode=display">O(N \\log{N})</script> time.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the space used to store our <code>candidates</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-heap-accepted">Approach #2: Heap [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Count the frequency of each word, then add it to heap that stores the best <code>k</code> candidates.  Here, "best" is defined with our custom ordering relation, which puts the worst candidates at the top of the heap.  At the end, we pop off the heap up to <code>k</code> times and reverse the result so that the best candidates are first.</p>\n<p>In Python, we instead use <code>heapq.heapify</code>, which can turn a list into a heap in linear time, simplifying our work.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">topKFrequent</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">:</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">count</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">heap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;(</span>\n                <span class="o">(</span><span class="n">w1</span><span class="o">,</span> <span class="n">w2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">w1</span><span class="o">)</span> <span class="o">!=</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">w2</span><span class="o">)</span> <span class="o">?</span>\n                <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">w1</span><span class="o">)</span> <span class="o">-</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">w2</span><span class="o">)</span> <span class="o">:</span> <span class="n">w2</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">w1</span><span class="o">)</span> <span class="o">);</span>\n\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">:</span> <span class="n">count</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>\n            <span class="n">heap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="n">heap</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>\n        <span class="o">}</span>\n\n        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>\n        <span class="k">while</span> <span class="o">(!</span><span class="n">heap</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">heap</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>\n        <span class="n">Collections</span><span class="o">.</span><span class="na">reverse</span><span class="o">(</span><span class="n">ans</span><span class="o">);</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>\n        <span class="n">count</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>\n        <span class="n">heap</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="n">freq</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span> <span class="k">for</span> <span class="n">word</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">count</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>\n        <span class="n">heapq</span><span class="o">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>\n        <span class="k">return</span> <span class="p">[</span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time Complexity: <script type="math/tex; mode=display">O(N \\log{k})</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>words</code>.  We count the frequency of each word in <script type="math/tex; mode=display">O(N)</script> time, then we add <script type="math/tex; mode=display">N</script> words to the heap, each in <script type="math/tex; mode=display">O(\\log {k})</script> time.  Finally, we pop from the heap up to <script type="math/tex; mode=display">k</script> times.  As <script type="math/tex; mode=display">k \\leq N</script>, this is <script type="math/tex; mode=display">O(N \\log{k})</script> in total.</li>\n</ul>\n<p>In Python, we improve this to <script type="math/tex; mode=display">O(N + k \\log {N})</script>: our <code>heapq.heapify</code> operation and counting operations are <script type="math/tex; mode=display">O(N)</script>, and each of <script type="math/tex; mode=display">k</script>\n<code>heapq.heappop</code> operations are <script type="math/tex; mode=display">O(\\log {N})</script>.</p>\n<ul>\n<li>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the space used to store our <code>count</code>.</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Amazon', 'Bloomberg', 'Uber', 'Yelp', 'Pocket Gems'],
  },
  {
    id: '693',
    name: 'Binary Number with Alternating Bits',
    acceptance: '54.8%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> 5\n<b>Output:</b> True\n<b>Explanation:</b>\nThe binary representation of 5 is: 101\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> 7\n<b>Output:</b> False\n<b>Explanation:</b>\nThe binary representation of 7 is: 111.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> 11\n<b>Output:</b> False\n<b>Explanation:</b>\nThe binary representation of 11 is: 1011.\n</pre>\n<p></p>\n\n<p><b>Example 4:</b><br>\n</p><pre><b>Input:</b> 10\n<b>Output:</b> True\n<b>Explanation:</b>\nThe binary representation of 10 is: 1010.\n</pre>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-convert-to-string-accepted">Approach #1: Convert to String [Accepted]</a></li>\n<li><a href="#approach-2-divide-by-two-accepted">Approach #2: Divide By Two [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-convert-to-string-accepted">Approach #1: Convert to String [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Let\'s convert the given number into a string of binary digits.  Then, we should simply check that no two adjacent digits are the same.</p>\n<iframe frameborder="0" height="241" name="79o5Wvyy" src="https://leetcode.com/playground/79o5Wvyy/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(1)</script>.  For arbitrary inputs, we do <script type="math/tex; mode=display">O(w)</script> work, where <script type="math/tex; mode=display">w</script> is the number of bits in <code>n</code>.  However, <script type="math/tex; mode=display">w \\leq 32</script>.</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(1)</script>, or alternatively <script type="math/tex; mode=display">O(w)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-divide-by-two-accepted">Approach #2: Divide By Two [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>We can get the last bit and the rest of the bits via <code>n % 2</code> and <code>n // 2</code> operations.  Let\'s remember <code>cur</code>, the last bit of <code>n</code>.  If the last bit ever equals the last bit of the remaining, then two adjacent bits have the same value, and the answer is <code>False</code>.  Otherwise, the answer is <code>True</code>.</p>\n<p>Also note that instead of <code>n % 2</code> and <code>n // 2</code>, we could have used operators <code>n &amp; 1</code> and <code>n &gt;&gt;= 1</code> instead.</p>\n<iframe frameborder="0" height="258" name="oFAELrSA" src="https://leetcode.com/playground/oFAELrSA/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(1)</script>.  For arbitrary inputs, we do <script type="math/tex; mode=display">O(w)</script> work, where <script type="math/tex; mode=display">w</script> is the number of bits in <code>n</code>.  However, <script type="math/tex; mode=display">w \\leq 32</script>.</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Yahoo'],
  },
  {
    id: '694',
    name: 'Number of Distinct Islands ',
    acceptance: '44.7%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given a non-empty 2D array <code>grid</code> of 0's and 1's, an <b>island</b> is a group of <code>1</code>'s (representing land) connected 4-directionally (horizontal or vertical.)  You may assume all four edges of the grid are surrounded by water.</p>\n\n<p>Count the number of <b>distinct</b> islands.  An island is considered to be the same as another if and only if one island can be translated (and not rotated or reflected) to equal the other.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre>11000\n11000\n00011\n00011\n</pre>\nGiven the above grid map, return <code>1</code>.\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre>11011\n10000\n00001\n11011</pre>\nGiven the above grid map, return <code>3</code>.<br><br>\nNotice that:\n<pre>11\n1\n</pre>\nand\n<pre> 1\n11\n</pre>\nare considered different island shapes, because we do not consider reflection / rotation.\n<p></p>\n\n<p><b>Note:</b>\nThe length of each dimension in the given <code>grid</code> does not exceed 50.\n</p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-hash-by-local-coordinates-accepted">Approach #1: Hash By Local Coordinates [Accepted]</a></li>\n<li><a href="#approach-2-hash-by-path-signature-accepted">Approach #2: Hash By Path Signature [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-hash-by-local-coordinates-accepted">Approach #1: Hash By Local Coordinates [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>At the beginning, we need to find every island, which we can do using a straightforward depth-first search.  The hard part is deciding whether two islands are the same.</p>\n<p>Since two islands are the same if one can be translated to match another, let\'s translate every island so the top-left corner is <code>(0, 0)</code>  For example, if an island is made from squares <code>[(2, 3), (2, 4), (3, 4)]</code>, we can think of this shape as <code>[(0, 0), (0, 1), (1, 1)]</code> when anchored at the top-left corner.</p>\n<p>From there, we only need to check how many unique shapes there ignoring permutations (so <code>[(0, 0), (0, 1)]</code> is the same as <code>[(0, 1), (1, 0)]</code>).  We use sets directly as we have showcased below, but we could have also sorted each list and put those sorted lists in our set structure <code>shapes</code>.</p>\n<p>In the Java solution, we converted our tuples <code>(r - r0, c - c0)</code> to integers.  We multiplied the number of rows by <code>2 * grid[0].length</code> instead of <code>grid[0].length</code> because our local row-coordinate could be negative.</p>\n<iframe frameborder="0" height="515" name="nxmaQmqz" src="https://leetcode.com/playground/nxmaQmqz/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(R*C)</script>, where <script type="math/tex; mode=display">R</script> is the number of rows in the given <code>grid</code>, and <script type="math/tex; mode=display">C</script> is the number of columns.  We visit every square once.</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(R*C)</script>, the space used by <code>seen</code> to keep track of visited squares, and <code>shapes</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-hash-by-path-signature-accepted">Approach #2: Hash By Path Signature [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>When we start a depth-first search on the top-left square of some island, the path taken by our depth-first search will be the same if and only if the shape is the same.  We can exploit this by recording the path we take as our shape - keeping in mind to record both when we enter and when we exit the function.  The rest of the code remains as in <em>Approach #1</em>.</p>\n<iframe frameborder="0" height="515" name="XrUoq6EL" src="https://leetcode.com/playground/XrUoq6EL/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time and Space Complexity: <script type="math/tex; mode=display">O(R*C)</script>.  The analysis is the same as in <em>Approach #1</em>.</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>s</p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '695',
    name: 'Max Area of Island',
    acceptance: '52.3%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p></p><p>Given a non-empty 2D array <code>grid</code> of 0's and 1's, an <b>island</b> is a group of <code>1</code>'s (representing land) connected 4-directionally (horizontal or vertical.)  You may assume all four edges of the grid are surrounded by water.</p>\n<p>\nFind the maximum area of an island in the given 2D array.\n(If there is no island, the maximum area is 0.)\n</p>\n<p><b>Example 1:</b><br>\n</p><pre>[[0,0,1,0,0,0,0,1,0,0,0,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,1,1,0,1,0,0,0,0,0,0,0,0],\n [0,1,0,0,1,1,0,0,<b>1</b>,0,<b>1</b>,0,0],\n [0,1,0,0,1,1,0,0,<b>1</b>,<b>1</b>,<b>1</b>,0,0],\n [0,0,0,0,0,0,0,0,0,0,<b>1</b>,0,0],\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\n [0,0,0,0,0,0,0,1,1,0,0,0,0]]\n</pre>\nGiven the above grid, return <code>6</code>.\n\nNote the answer is not 11, because the island must be connected 4-directionally.\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre>[[0,0,0,0,0,0,0,0]]</pre>\nGiven the above grid, return <code>0</code>.\n<p></p>\n\n<p><b>Note:</b>\nThe length of each dimension in the given <code>grid</code> does not exceed 50.\n</p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-depth-first-search-recursive-accepted">Approach #1: Depth-First Search (Recursive) [Accepted]</a></li>\n<li><a href="#approach-2-depth-first-search-iterative-accepted">Approach #2: Depth-First Search (Iterative) [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-depth-first-search-recursive-accepted">Approach #1: Depth-First Search (Recursive) [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>We want to know the area of each connected shape in the grid, then take the maximum of these.</p>\n<p>If we are on a land square and explore every square connected to it 4-directionally (and recursively squares connected to those squares, and so on), then the total number of squares explored will be the area of that connected shape.</p>\n<p>To ensure we don\'t count squares in a shape more than once, let\'s use <code>seen</code> to keep track of squares we haven\'t visited before.  It will also prevent us from counting the same shape more than once.</p>\n<iframe frameborder="0" height="479" name="CQGNqDhr" src="https://leetcode.com/playground/CQGNqDhr/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(R*C)</script>, where <script type="math/tex; mode=display">R</script> is the number of rows in the given <code>grid</code>, and <script type="math/tex; mode=display">C</script> is the number of columns.  We visit every square once.</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(R*C)</script>, the space used by <code>seen</code> to keep track of visited squares, and the space used by the call stack during our recursion.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-depth-first-search-iterative-accepted">Approach #2: Depth-First Search (Iterative) [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>We can try the same approach using a stack based, (or "iterative") depth-first search.</p>\n<p>Here, <code>seen</code> will represent squares that have either been visited or are added to our list of squares to visit (<code>stack</code>).  For every starting land square that hasn\'t been visited, we will explore 4-directionally around it, adding land squares that haven\'t been added to <code>seen</code> to our <code>stack</code>.</p>\n<p>On the side, we\'ll keep a count <code>shape</code> of the total number of squares seen during the exploration of this shape.  We\'ll want the running max of these counts.</p>\n<iframe frameborder="0" height="515" name="khZHhSir" src="https://leetcode.com/playground/khZHhSir/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(R*C)</script>, where <script type="math/tex; mode=display">R</script> is the number of rows in the given <code>grid</code>, and <script type="math/tex; mode=display">C</script> is the number of columns.  We visit every square once.</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(R*C)</script>, the space used by <code>seen</code> to keep track of visited squares, and the space used by <code>stack</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Intuit'],
  },
  {
    id: '696',
    name: 'Count Binary Substrings',
    acceptance: '52.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Give a string <code>s</code>, count the number of non-empty (contiguous) substrings that have the same number of 0\'s and 1\'s, and all the 0\'s and all the 1\'s in these substrings are grouped consecutively. \n</p>\n<p>Substrings that occur multiple times are counted the number of times they occur.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> "00110011"\n<b>Output:</b> 6\n<b>Explanation:</b> There are 6 substrings that have equal number of consecutive 1\'s and 0\'s: "0011", "01", "1100", "10", "0011", and "01".\n<br>Notice that some of these substrings repeat and are counted the number of times they occur.\n<br>Also, "00110011" is not a valid substring because <b>all</b> the 0\'s (and 1\'s) are not grouped together.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> "10101"\n<b>Output:</b> 4\n<b>Explanation:</b> There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1\'s and 0\'s.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li><code>s.length</code> will be between 1 and 50,000.</li>\n<li><code>s</code> will only consist of "0" or "1" characters.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-group-by-character-accepted">Approach #1: Group By Character [Accepted]</a></li>\n<li><a href="#approach-2-linear-scan-accepted">Approach #2: Linear Scan [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-group-by-character-accepted">Approach #1: Group By Character [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can convert the string <code>s</code> into an array <code>groups</code> that represents the length of same-character contiguous blocks within the string.  For example, if <code>s = "110001111000000"</code>, then <code>groups = [2, 3, 4, 6]</code>.</p>\n<p>For every binary string of the form <code>\'0\' * k + \'1\' * k</code> or <code>\'1\' * k + \'0\' * k</code>, the middle of this string must occur between two groups.  </p>\n<p>Let\'s try to count the number of valid binary strings between <code>groups[i]</code> and <code>groups[i+1]</code>.  If we have <code>groups[i] = 2, groups[i+1] = 3</code>, then it represents either <code>"00111"</code> or <code>"11000"</code>.  We clearly can make <code>min(groups[i], groups[i+1])</code> valid binary strings within this string.  Because the binary digits to the left or right of this string must change at the boundary, our answer can never be larger.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let\'s create <code>groups</code> as defined above.  The first element of <code>s</code> belongs in it\'s own group.  From then on, each element either doesn\'t match the previous element, so that it starts a new group of size 1; or it does match, so that the size of the most recent group increases by 1.</p>\n<p>Afterwards, we will take the sum of <code>min(groups[i-1], groups[i])</code>.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">countBinarySubstrings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>\n        <span class="n">groups</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>\n        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>\n            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>\n                <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>\n            <span class="k">else</span><span class="p">:</span>\n                <span class="n">groups</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>\n\n        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>\n        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)):</span>\n            <span class="n">ans</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>\n        <span class="k">return</span> <span class="n">ans</span>\n</pre></div>\n<p><em>Alternate Implentation</em></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">countBinarySubstrings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>\n        <span class="n">groups</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>\n        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">groups</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countBinarySubstrings</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span><span class="o">[]</span> <span class="n">groups</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>\n        <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="n">groups</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>\n                <span class="n">groups</span><span class="o">[++</span><span class="n">t</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>\n            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>\n                <span class="n">groups</span><span class="o">[</span><span class="n">t</span><span class="o">]++;</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n\n        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="n">ans</span> <span class="o">+=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">groups</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span> <span class="n">groups</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>s</code>.  Every loop is through <script type="math/tex; mode=display">O(N)</script> items with <script type="math/tex; mode=display">O(1)</script> work inside the for-block.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the space used by <code>groups</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-linear-scan-accepted">Approach #2: Linear Scan [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>We can amend our <em>Approach #1</em> to calculate the answer on the fly.  Instead of storing <code>groups</code>, we will remember only <code>prev = groups[-2]</code> and <code>cur = groups[-1]</code>.  Then, the answer is the sum of <code>min(prev, cur)</code> over each different final <code>(prev, cur)</code> we see.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">countBinarySubstrings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>\n        <span class="n">ans</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>\n        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>\n            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>\n                <span class="n">ans</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">cur</span><span class="p">)</span>\n                <span class="n">prev</span><span class="p">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">,</span> <span class="mi">1</span>\n            <span class="k">else</span><span class="p">:</span>\n                <span class="n">cur</span> <span class="o">+=</span> <span class="mi">1</span>\n\n        <span class="k">return</span> <span class="n">ans</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">cur</span><span class="p">)</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">countBinarySubstrings</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>\n                <span class="n">ans</span> <span class="o">+=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">prev</span><span class="o">,</span> <span class="n">cur</span><span class="o">);</span>\n                <span class="n">prev</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>\n                <span class="n">cur</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>\n            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>\n                <span class="n">cur</span><span class="o">++;</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span> <span class="o">+</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">prev</span><span class="o">,</span> <span class="n">cur</span><span class="o">);</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>s</code>.  Every loop is through <script type="math/tex; mode=display">O(N)</script> items with <script type="math/tex; mode=display">O(1)</script> work inside the for-block.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>, the space used by <code>prev</code>, <code>cur</code>, and <code>ans</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Helix'],
  },
  {
    id: '697',
    name: 'Degree of an Array',
    acceptance: '46.6%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a non-empty array of non-negative integers <code>nums</code>, the <b>degree</b> of this array is defined as the maximum frequency of any one of its elements.</p>\n<p>Your task is to find the smallest possible length of a (contiguous) subarray of <code>nums</code>, that has the same degree as <code>nums</code>.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1, 2, 2, 3, 1]\n<b>Output:</b> 2\n<b>Explanation:</b> \nThe input array has a degree of 2 because both elements 1 and 2 appear twice.\nOf the subarrays that have the same degree:\n[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]\nThe shortest length is 2. So return 2.\n</pre>\n<p></p>\n\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [1,2,2,3,1,4,2]\n<b>Output:</b> 6\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li><code>nums.length</code> will be between 1 and 50,000.</li>\n<li><code>nums[i]</code> will be an integer between 0 and 49,999.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-left-and-right-index-accepted">Approach #1: Left and Right Index [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-left-and-right-index-accepted">Approach #1: Left and Right Index [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>An array that has degree <code>d</code>, must have some element <code>x</code> occur <code>d</code> times.  If some subarray has the same degree, then some element <code>x</code> (that occured <code>d</code> times), still occurs <code>d</code> times.  The shortest such subarray would be from the first occurrence of <code>x</code> until the last occurrence.</p>\n<p>For each element in the given array, let\'s know <code>left</code>, the index of its first occurrence; and <code>right</code>, the index of its last occurrence.  For example, with <code>nums = [1,2,3,2,5]</code> we have <code>left[2] = 1</code> and <code>right[2] = 3</code>.</p>\n<p>Then, for each element <code>x</code> that occurs the maximum number of times, <code>right[x] - left[x] + 1</code> will be our candidate answer, and we\'ll take the minimum of those candidates.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">findShortestSubArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>\n        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>\n        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>\n            <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">left</span><span class="p">:</span> <span class="n">left</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>\n            <span class="n">right</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>\n            <span class="n">count</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>\n\n        <span class="n">ans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>\n        <span class="n">degree</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">count</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>\n        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">count</span><span class="p">:</span>\n            <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">degree</span><span class="p">:</span>\n                <span class="n">ans</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">right</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-</span> <span class="n">left</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>\n\n        <span class="k">return</span> <span class="n">ans</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findShortestSubArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">(),</span>\n            <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">(),</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>\n\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">left</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="n">left</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>\n            <span class="n">right</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>\n            <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">count</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n        <span class="o">}</span>\n\n        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">degree</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">values</span><span class="o">());</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">:</span> <span class="n">count</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">==</span> <span class="n">degree</span><span class="o">)</span> <span class="o">{</span>\n                <span class="n">ans</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">right</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">-</span> <span class="n">left</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>.  Every loop is through <script type="math/tex; mode=display">O(N)</script> items with <script type="math/tex; mode=display">O(1)</script> work inside the for-block.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the space used by <code>left</code>, <code>right</code>, and <code>count</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['GE Digital'],
  },
  {
    id: '698',
    name: 'Partition to K Equal Sum Subsets',
    acceptance: '37.5%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>Given an array of integers <code>nums</code> and a positive integer <code>k</code>, find whether it's possible to divide this array into <code>k</code> non-empty subsets whose sums are all equal.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> nums = [4, 3, 2, 3, 5, 2, 1], k = 4\n<b>Output:</b> True\n<b>Explanation:</b> It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li><code>1 &lt;= k &lt;= len(nums) &lt;= 16</code>.</li>\n<li><code>0 &lt; nums[i] &lt; 10000</code>.</li>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-search-by-constructing-subset-sums-accepted">Approach #1: Search by Constructing Subset Sums [Accepted]</a></li>\n<li><a href="#approach-2-dynamic-programming-on-subsets-of-input-accepted">Approach #2: Dynamic Programming on Subsets of Input [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-search-by-constructing-subset-sums-accepted">Approach #1: Search by Constructing Subset Sums [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>As even when <code>k = 2</code>, the problem is a "Subset Sum" problem which is known to be NP-hard, (and because the given input limits are low,) our solution will focus on exhaustive search.</p>\n<p>A natural approach is to simulate the <code>k</code> groups (disjoint subsets of nums).  For each number in <code>nums</code>, we\'ll check whether putting it in the <code>i</code>-th group solves the problem.  We can check those possibilities by recursively searching.</p>\n<p><strong>Algorithm</strong></p>\n<p>Firstly, we know that each of the <code>k</code> group-sums must be equal to <code>target = sum(nums) / k</code>.  (If this quantity is not an integer, the task is impossible.)</p>\n<p>For each number in <code>nums</code>, we could add it into one of <code>k</code> group-sums, as long as the group\'s sum would not exceed the <code>target</code>.  For each of these choices, we recursively search with one less number to consider in <code>nums</code>.  If we placed every number successfully, then our search was successful.</p>\n<p>One important speedup is that we can ensure all the 0 values of each group occur at the end of the array <code>groups</code>, by enforcing <code>if (groups[i] == 0) break;</code>.  This greatly reduces repeated work - for example, in the first run of search, we will make only 1 recursive call, instead of <code>k</code>.  Actually, we could do better by skipping any repeated values of groups[i], but it isn\'t necessary.</p>\n<p>Another speedup is we could sort the array <code>nums</code>, so that we try to place the largest elements first.  When the answer is true and involves subsets with a low size, this method of placing elements will consider these lower size subsets sooner.  We can also handle elements <code>nums[i] &gt;= target</code> appropriately.  These tricks are not necessary to solve the problem, but they are presented in the solutions below.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">canPartitionKSubsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>\n        <span class="n">target</span><span class="p">,</span> <span class="n">rem</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span>\n        <span class="k">if</span> <span class="n">rem</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>\n\n        <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">groups</span><span class="p">):</span>\n            <span class="k">if</span> <span class="ow">not</span> <span class="n">nums</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>\n            <span class="n">v</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>\n            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">groups</span><span class="p">):</span>\n                <span class="k">if</span> <span class="n">group</span> <span class="o">+</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="p">:</span>\n                    <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span>\n                    <span class="k">if</span> <span class="n">search</span><span class="p">(</span><span class="n">groups</span><span class="p">):</span> <span class="k">return</span> <span class="bp">True</span>\n                    <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">v</span>\n                <span class="k">if</span> <span class="ow">not</span> <span class="n">group</span><span class="p">:</span> <span class="k">break</span>\n            <span class="n">nums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>\n            <span class="k">return</span> <span class="bp">False</span>\n\n        <span class="n">nums</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>\n        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>\n        <span class="k">while</span> <span class="n">nums</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>\n            <span class="n">nums</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>\n            <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>\n\n        <span class="k">return</span> <span class="n">search</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">groups</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">row</span><span class="o">--];</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">groups</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">groups</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>\n                <span class="n">groups</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">v</span><span class="o">;</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">search</span><span class="o">(</span><span class="n">groups</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">target</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n                <span class="n">groups</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-=</span> <span class="n">v</span><span class="o">;</span>\n            <span class="o">}</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">groups</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canPartitionKSubsets</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">nums</span><span class="o">).</span><span class="na">sum</span><span class="o">();</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="n">k</span><span class="o">;</span>\n\n        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>\n        <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">row</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">row</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">row</span><span class="o">--;</span>\n            <span class="n">k</span><span class="o">--;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">search</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">],</span> <span class="n">row</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(k^{N-k} k!)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>, and <script type="math/tex; mode=display">k</script> is as given.  As we skip additional zeroes in <code>groups</code>, naively we will make <script type="math/tex; mode=display">O(k!)</script> calls to <code>search</code>, then an additional <script type="math/tex; mode=display">O(k^{N-k})</script> calls after every element of <code>groups</code> is nonzero.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the space used by recursive calls to <code>search</code> in our call stack.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-dynamic-programming-on-subsets-of-input-accepted">Approach #2: Dynamic Programming on Subsets of Input [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>As in <em>Approach #1</em>, we investigate methods of exhaustive search, and find <code>target = sum(nums) / k</code> in the same way.</p>\n<p>Let <code>used</code> have the <code>i</code>-th bit set if and only if <code>nums[i]</code> has already been used.  Our goal is to use <code>nums</code> in some order so that placing them into groups in that order will be valid. <code>search(used, ...)</code> will answer the question: can we partition unused elements of <code>nums[i]</code> appropriately?</p>\n<p>This will depend on <code>todo</code>, the sum of the remaining unused elements, not crossing multiples of <code>target</code> within one number.  If for example our target is <code>10</code>, and our elements to be placed in order are <code>[6, 5, 5, 4]</code>, this would not work as <code>6 + 5</code> "crosses" <code>10</code> prematurely.</p>\n<p>If we could choose the order, then after placing <code>5</code>, our unused elements are <code>[4, 5, 6]</code>.  Using <code>6</code> would make <code>todo</code> go from <code>15</code> to <code>9</code>, which crosses <code>10</code> - something unwanted.  However, we could use <code>5</code> since <code>todo</code> goes from <code>15</code> to <code>10</code>; then later we could use <code>4</code> and <code>6</code> as those placements do not cross.</p>\n<p>It turns out the maximum value that can be chosen so as to not cross a multiple of <code>target</code>, is <code>targ = (todo - 1) % target + 1</code>.  This is essentially <code>todo % target</code>, plus <code>target</code> if that would be zero.</p>\n<p>Now for each unused number that doesn\'t cross, we\'ll search on that state, and we\'ll return <code>true</code> if any of those searches are <code>true</code>.</p>\n<p>Notice that the state <code>todo</code> depends only on the state <code>used</code>, so when memoizing our search, we only need to make lookups by <code>used</code>.</p>\n<p>In the solutions below, we present both a top-down dynamic programming solution, and a bottom-up one.  The bottom-up solution uses a different notion of state.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">canPartitionKSubsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>\n        <span class="n">target</span><span class="p">,</span> <span class="n">rem</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span>\n        <span class="k">if</span> <span class="n">rem</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>\n\n        <span class="n">memo</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>\n        <span class="n">memo</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>\n        <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">used</span><span class="p">,</span> <span class="n">todo</span><span class="p">):</span>\n            <span class="k">if</span> <span class="n">memo</span><span class="p">[</span><span class="n">used</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>\n                <span class="n">targ</span> <span class="o">=</span> <span class="p">(</span><span class="n">todo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">target</span> <span class="o">+</span> <span class="mi">1</span>\n                <span class="n">memo</span><span class="p">[</span><span class="n">used</span><span class="p">]</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">search</span><span class="p">(</span><span class="n">used</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">),</span> <span class="n">todo</span> <span class="o">-</span> <span class="n">num</span><span class="p">)</span>\n                                 <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>\n                                 <span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="n">targ</span><span class="p">)</span>\n            <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">used</span><span class="p">]</span>\n\n        <span class="k">return</span> <span class="n">search</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">target</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="n">Result</span> <span class="o">{</span> <span class="n">TRUE</span><span class="o">,</span> <span class="n">FALSE</span> <span class="o">}</span>\n\n<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span> <span class="n">used</span><span class="o">,</span> <span class="kt">int</span> <span class="n">todo</span><span class="o">,</span> <span class="n">Result</span><span class="o">[]</span> <span class="n">memo</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">memo</span><span class="o">[</span><span class="n">used</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">memo</span><span class="o">[</span><span class="n">used</span><span class="o">]</span> <span class="o">=</span> <span class="n">Result</span><span class="o">.</span><span class="na">FALSE</span><span class="o">;</span>\n            <span class="kt">int</span> <span class="n">targ</span> <span class="o">=</span> <span class="o">(</span><span class="n">todo</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">target</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n                <span class="k">if</span> <span class="o">((((</span><span class="n">used</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">targ</span><span class="o">)</span> <span class="o">{</span>\n                    <span class="k">if</span> <span class="o">(</span><span class="n">search</span><span class="o">(</span><span class="n">used</span> <span class="o">|</span> <span class="o">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">),</span> <span class="n">todo</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">memo</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">target</span><span class="o">))</span> <span class="o">{</span>\n                        <span class="n">memo</span><span class="o">[</span><span class="n">used</span><span class="o">]</span> <span class="o">=</span> <span class="n">Result</span><span class="o">.</span><span class="na">TRUE</span><span class="o">;</span>\n                        <span class="k">break</span><span class="o">;</span>\n                    <span class="o">}</span>\n                <span class="o">}</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">memo</span><span class="o">[</span><span class="n">used</span><span class="o">]</span> <span class="o">==</span> <span class="n">Result</span><span class="o">.</span><span class="na">TRUE</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canPartitionKSubsets</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">nums</span><span class="o">).</span><span class="na">sum</span><span class="o">();</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n\n        <span class="n">Result</span><span class="o">[]</span> <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Result</span><span class="o">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>\n        <span class="n">memo</span><span class="o">[(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">Result</span><span class="o">.</span><span class="na">TRUE</span><span class="o">;</span>\n        <span class="k">return</span> <span class="n">search</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">memo</span><span class="o">,</span> <span class="n">nums</span><span class="o">,</span> <span class="n">sum</span> <span class="o">/</span> <span class="n">k</span><span class="o">);</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><em>Bottom-Up Variation</em></p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">canPartitionKSubsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>\n        <span class="n">nums</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>\n        <span class="n">target</span><span class="p">,</span> <span class="n">rem</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span>\n        <span class="k">if</span> <span class="n">rem</span> <span class="ow">or</span> <span class="n">nums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>\n\n        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>\n        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>\n        <span class="n">total</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">))</span>\n\n        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>\n            <span class="k">if</span> <span class="ow">not</span> <span class="n">dp</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span> <span class="k">continue</span>\n            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>\n                <span class="n">future</span> <span class="o">=</span> <span class="n">state</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span>\n                <span class="k">if</span> <span class="n">state</span> <span class="o">!=</span> <span class="n">future</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dp</span><span class="p">[</span><span class="n">future</span><span class="p">]:</span>\n                    <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="n">target</span> <span class="o">-</span> <span class="p">(</span><span class="n">total</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">%</span> <span class="n">target</span><span class="p">)):</span>\n                        <span class="n">dp</span><span class="p">[</span><span class="n">future</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>\n                        <span class="n">total</span><span class="p">[</span><span class="n">future</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">+</span> <span class="n">num</span>\n                    <span class="k">else</span><span class="p">:</span>\n                        <span class="k">break</span>\n        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canPartitionKSubsets</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>\n        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">);</span>\n        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">nums</span><span class="o">).</span><span class="na">sum</span><span class="o">();</span>\n        <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="n">k</span><span class="o">;</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">%</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nums</span><span class="o">[</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n\n        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">N</span><span class="o">];</span>\n        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>\n        <span class="kt">int</span><span class="o">[]</span> <span class="n">total</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">N</span><span class="o">];</span>\n\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">state</span> <span class="o">&lt;</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">N</span><span class="o">);</span> <span class="n">state</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(!</span><span class="n">dp</span><span class="o">[</span><span class="n">state</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n                <span class="kt">int</span> <span class="n">future</span> <span class="o">=</span> <span class="n">state</span> <span class="o">|</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">);</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">future</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dp</span><span class="o">[</span><span class="n">future</span><span class="o">])</span> <span class="o">{</span>\n                    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">target</span> <span class="o">-</span> <span class="o">(</span><span class="n">total</span><span class="o">[</span><span class="n">state</span><span class="o">]</span> <span class="o">%</span> <span class="n">target</span><span class="o">))</span> <span class="o">{</span>\n                        <span class="n">dp</span><span class="o">[</span><span class="n">future</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>\n                        <span class="n">total</span><span class="o">[</span><span class="n">future</span><span class="o">]</span> <span class="o">=</span> <span class="n">total</span><span class="o">[</span><span class="n">state</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>\n                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>\n                        <span class="k">break</span><span class="o">;</span>\n                    <span class="o">}</span>\n                <span class="o">}</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">dp</span><span class="o">[(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">N</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N * 2^N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>.  There are <script type="math/tex; mode=display">2^N</script> states of <code>used</code> (or <code>state</code> in our bottom-up variant), and each state performs <code>O(N)</code> work searching through <code>nums</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(2^N)</script>, the space used by <code>memo</code> (or <code>dp</code>, <code>total</code> in our bottom-up variant).</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '699',
    name: 'Falling Squares',
    acceptance: '37.3%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>On an infinite number line (x-axis), we drop given squares in the order they are given.</p>\n<p>The <code>i</code>-th square dropped (<code>positions[i] = (left, side_length)</code>) is a square with the left-most point being <code>positions[i][0]</code> and sidelength <code>positions[i][1]</code>.</p>\n<p>The square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares.  We wait for each square to stick before dropping the next.</p>\n<p>The squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square).  Squares dropped adjacent to each other will not stick together prematurely.</p>\n\n<br>\n<p>Return a list <code>ans</code> of heights.  Each height <code>ans[i]</code> represents the current highest height of any square we have dropped, after dropping squares represented by <code>positions[0], positions[1], ..., positions[i]</code>.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [[1, 2], [2, 3], [6, 1]]\n<b>Output:</b> [2, 5, 5]\n<b>Explanation:</b>\n<p>\nAfter the first drop of <code>positions[0] = [1, 2]:\n_aa\n_aa\n-------\n</code>The maximum height of any square is 2.\n</p><p>\nAfter the second drop of <code>positions[1] = [2, 3]:\n__aaa\n__aaa\n__aaa\n_aa__\n_aa__\n--------------\n</code>The maximum height of any square is 5.  \nThe larger square stays on top of the smaller square despite where its center\nof gravity is, because squares are infinitely sticky on their bottom edge.\n</p><p>\nAfter the third drop of <code>positions[1] = [6, 1]:\n__aaa\n__aaa\n__aaa\n_aa\n_aa___a\n--------------\n</code>The maximum height of any square is still 5.\n\nThus, we return an answer of <code>[2, 5, 5]</code>.\n</p></pre>\n<p></p>\n\n<br>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> [[100, 100], [200, 100]]\n<b>Output:</b> [100, 100]\n<b>Explanation:</b> Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li><code>1 &lt;= positions.length &lt;= 1000</code>.</li>\n<li><code>1 &lt;= positions[i][0] &lt;= 10^8</code>.</li>\n<li><code>1 &lt;= positions[i][1] &lt;= 10^6</code>.</li>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-framework">Approach Framework</a></li>\n<li><a href="#approach-1-offline-propagation-accepted">Approach #1: Offline Propagation [Accepted]</a></li>\n<li><a href="#approach-2-brute-force-with-coordinate-compression-accepted">Approach #2: Brute Force with Coordinate Compression [Accepted]</a></li>\n<li><a href="#approach-3-block-square-root-decomposition-accepted">Approach #3: Block (Square Root) Decomposition [Accepted]</a></li>\n<li><a href="#approach-4-segment-tree-with-lazy-propagation-accepted">Approach #4: Segment Tree with Lazy Propagation [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-framework">Approach Framework</h4>\n<p><strong>Intuition</strong></p>\n<p>Intuitively, there are two operations: <code>update</code>, which updates our notion of the board (number line) after dropping a square; and <code>query</code>, which finds the largest height in the current board on some interval.  We will work on implementing these operations.</p>\n<p><strong>Coordinate Compression</strong></p>\n<p>In the below approaches, since there are only up to <code>2 * len(positions)</code> critical points, namely the left and right edges of each square, we can use a technique called <em>coordinate compression</em> to map these critical points to adjacent integers, as shown in the code snippets below.  </p>\n<p>For brevity, these snippets are omitted from the remaining solutions.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="n">coords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>\n<span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">:</span>\n    <span class="n">coords</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>\n    <span class="n">coords</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>\n<span class="n">index</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">coords</span><span class="p">))}</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">coords</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">();</span>\n<span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">pos</span><span class="o">:</span> <span class="n">positions</span><span class="o">)</span> <span class="o">{</span>\n    <span class="n">coords</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pos</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>\n    <span class="n">coords</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pos</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">pos</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>\n<span class="o">}</span>\n<span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">sortedCoords</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">(</span><span class="n">coords</span><span class="o">);</span>\n<span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">sortedCoords</span><span class="o">);</span>\n\n<span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">index</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>\n<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">coord</span><span class="o">:</span> <span class="n">sortedCoords</span><span class="o">)</span> <span class="n">index</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">coord</span><span class="o">,</span> <span class="n">t</span><span class="o">++);</span>\n</pre></div>\n<hr>\n<h4 id="approach-1-offline-propagation-accepted">Approach #1: Offline Propagation [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Instead of asking the question "what squares affect this query?", lets ask the question "what queries are affected by this square?"</p>\n<p><strong>Algorithm</strong></p>\n<p>Let <code>qans[i]</code> be the maximum height of the interval specified by <code>positions[i]</code>.  At the end, we\'ll return a running max of <code>qans</code>.</p>\n<p>For each square <code>positions[i]</code>, the maximum height will get higher by the size of the square we drop.  Then, for any future squares that intersect the interval <code>[left, right)</code> (where <code>left = positions[i][0], right = positions[i][0] + positions[i][1]</code>), we\'ll update the maximum height of that interval.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">fallingSquares</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>\n        <span class="n">qans</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>\n        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>\n            <span class="n">right</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">size</span>\n            <span class="n">qans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">size</span>\n            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)):</span>\n                <span class="n">left2</span><span class="p">,</span> <span class="n">size2</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>\n                <span class="n">right2</span> <span class="o">=</span> <span class="n">left2</span> <span class="o">+</span> <span class="n">size2</span>\n                <span class="k">if</span> <span class="n">left2</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right2</span><span class="p">:</span> <span class="c1">#intersect</span>\n                    <span class="n">qans</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">qans</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">qans</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>\n\n        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>\n        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">qans</span><span class="p">:</span>\n            <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">ans</span> <span class="k">else</span> <span class="n">x</span><span class="p">)</span>\n        <span class="k">return</span> <span class="n">ans</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">fallingSquares</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">positions</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span><span class="o">[]</span> <span class="n">qans</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">positions</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">positions</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">positions</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>\n            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">positions</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>\n            <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">size</span><span class="o">;</span>\n            <span class="n">qans</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">size</span><span class="o">;</span>\n\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">positions</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>\n                <span class="kt">int</span> <span class="n">left2</span> <span class="o">=</span> <span class="n">positions</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>\n                <span class="kt">int</span> <span class="n">size2</span> <span class="o">=</span> <span class="n">positions</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>\n                <span class="kt">int</span> <span class="n">right2</span> <span class="o">=</span> <span class="n">left2</span> <span class="o">+</span> <span class="n">size2</span><span class="o">;</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">left2</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right2</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//intersect</span>\n                    <span class="n">qans</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">qans</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">qans</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>\n                <span class="o">}</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n\n        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>\n        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">:</span> <span class="n">qans</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">cur</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">cur</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>\n            <span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>positions</code>.  We use two for-loops, each of complexity <script type="math/tex; mode=display">O(N)</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the space used by <code>qans</code> and <code>ans</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-brute-force-with-coordinate-compression-accepted">Approach #2: Brute Force with Coordinate Compression [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Let <code>N = len(positions)</code>.  After mapping the board to a board of length at most <script type="math/tex; mode=display">2* N \\leq 2000</script>, we can brute force the answer by simulating each square\'s drop directly.</p>\n<p>Our answer is either the current answer or the height of the square that was just dropped, and we\'ll update it appropriately.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">fallingSquares</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>\n        <span class="c1">#Coordinate Compression</span>\n        <span class="c1">#index = ...</span>\n\n        <span class="n">heights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>\n        <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>\n            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">heights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>\n\n        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>\n            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>\n                <span class="n">heights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">heights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span>\n\n        <span class="n">best</span> <span class="o">=</span> <span class="mi">0</span>\n        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>\n        <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">:</span>\n            <span class="n">L</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>\n            <span class="n">R</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">left</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>\n            <span class="n">h</span> <span class="o">=</span> <span class="n">query</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span>\n            <span class="n">update</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>\n            <span class="n">best</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">best</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>\n            <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best</span><span class="p">)</span>\n\n        <span class="k">return</span> <span class="n">ans</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kt">int</span><span class="o">[]</span> <span class="n">heights</span><span class="o">;</span>\n\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">query</span><span class="o">(</span><span class="kt">int</span> <span class="n">L</span><span class="o">,</span> <span class="kt">int</span> <span class="n">R</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">L</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="n">ans</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">heights</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="kt">int</span> <span class="n">L</span><span class="o">,</span> <span class="kt">int</span> <span class="n">R</span><span class="o">,</span> <span class="kt">int</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">L</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="n">heights</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">heights</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">h</span><span class="o">);</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">fallingSquares</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">positions</span><span class="o">)</span> <span class="o">{</span>\n        <span class="c1">//Coordinate Compression</span>\n        <span class="c1">//HashMap&lt;Integer, Integer&gt; index = ...;</span>\n        <span class="c1">//int t = ...;</span>\n\n        <span class="n">heights</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">t</span><span class="o">];</span>\n        <span class="kt">int</span> <span class="n">best</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>\n\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">pos</span><span class="o">:</span> <span class="n">positions</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">L</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pos</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>\n            <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pos</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">pos</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>\n            <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">query</span><span class="o">(</span><span class="n">L</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span> <span class="o">+</span> <span class="n">pos</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>\n            <span class="n">update</span><span class="o">(</span><span class="n">L</span><span class="o">,</span> <span class="n">R</span><span class="o">,</span> <span class="n">h</span><span class="o">);</span>\n            <span class="n">best</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">best</span><span class="o">,</span> <span class="n">h</span><span class="o">);</span>\n            <span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">best</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>positions</code>.  We use two for-loops, each of complexity <script type="math/tex; mode=display">O(N)</script> (because of coordinate compression.)</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the space used by <code>heights</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-block-square-root-decomposition-accepted">Approach #3: Block (Square Root) Decomposition [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Whenever we perform operations (like <code>update</code> and <code>query</code>) on some interval in a domain, we could segment that domain with size <script type="math/tex; mode=display">W</script> into blocks of size <script type="math/tex; mode=display">\\sqrt{W}</script>.  </p>\n<p>Then, instead of a typical brute force where we update our array <code>heights</code> representing the board, we will also hold another array <code>blocks</code>, where <code>blocks[i]</code> represents the <script type="math/tex; mode=display">B = \\lfloor \\sqrt{W} \\rfloor</script> elements <code>heights[B*i], heights[B*i + 1], ..., heights[B*i + B-1]</code>.  This allows us to write to the array in <script type="math/tex; mode=display">O(B)</script> operations.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let\'s get into the details.  We actually need another array, <code>blocks_read</code>.  When we update some element <code>i</code> in block <code>b = i / B</code>, we\'ll also update <code>blocks_read[b]</code>.  If later we want to read the entire block, we can read from here (and stuff written to the whole block in <code>blocks[b]</code>.)</p>\n<p>When we write to a block, we\'ll write in <code>blocks[b]</code>.  Later, when we want to read from an element <code>i</code> in block <code>b = i / B</code>, we\'ll read from <code>heights[i]</code> and <code>blocks[b]</code>.</p>\n<p>Our process for managing <code>query</code> and <code>update</code> will be similar.  While <code>left</code> isn\'t a multiple of <code>B</code>, we\'ll proceed with a brute-force-like approach, and similarly for <code>right</code>.  At the end, <code>[left, right+1)</code> will represent a series of contiguous blocks: the interval will have length which is a multiple of <code>B</code>, and <code>left</code> will also be a multiple of <code>B</code>.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">fallingSquares</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>\n        <span class="c1">#Coordinate compression</span>\n        <span class="c1">#index = ...</span>\n\n        <span class="n">W</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>\n        <span class="n">B</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">W</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span>\n        <span class="n">heights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">W</span>\n        <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">B</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>\n        <span class="n">blocks_read</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">B</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>\n\n        <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>\n            <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>\n            <span class="k">while</span> <span class="n">left</span> <span class="o">%</span> <span class="n">B</span> <span class="ow">and</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>\n                <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">heights</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left</span> <span class="o">/</span> <span class="n">B</span><span class="p">])</span>\n                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>\n            <span class="k">while</span> <span class="n">right</span> <span class="o">%</span> <span class="n">B</span> <span class="o">!=</span> <span class="n">B</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>\n                <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">heights</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="n">right</span> <span class="o">/</span> <span class="n">B</span><span class="p">])</span>\n                <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>\n            <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>\n                <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left</span> <span class="o">/</span> <span class="n">B</span><span class="p">],</span> <span class="n">blocks_read</span><span class="p">[</span><span class="n">left</span> <span class="o">/</span> <span class="n">B</span><span class="p">])</span>\n                <span class="n">left</span> <span class="o">+=</span> <span class="n">B</span>\n            <span class="k">return</span> <span class="n">ans</span>\n\n        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>\n            <span class="k">while</span> <span class="n">left</span> <span class="o">%</span> <span class="n">B</span> <span class="ow">and</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>\n                <span class="n">heights</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">heights</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span>\n                <span class="n">blocks_read</span><span class="p">[</span><span class="n">left</span> <span class="o">/</span> <span class="n">B</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">blocks_read</span><span class="p">[</span><span class="n">left</span> <span class="o">/</span> <span class="n">B</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span>\n                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>\n            <span class="k">while</span> <span class="n">right</span> <span class="o">%</span> <span class="n">B</span> <span class="o">!=</span> <span class="n">B</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>\n                <span class="n">heights</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">heights</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span>\n                <span class="n">blocks_read</span><span class="p">[</span><span class="n">right</span> <span class="o">/</span> <span class="n">B</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">blocks_read</span><span class="p">[</span><span class="n">right</span> <span class="o">/</span> <span class="n">B</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span>\n                <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>\n            <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>\n                <span class="n">blocks</span><span class="p">[</span><span class="n">left</span> <span class="o">/</span> <span class="n">B</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="n">left</span> <span class="o">/</span> <span class="n">B</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span>\n                <span class="n">left</span> <span class="o">+=</span> <span class="n">B</span>\n\n        <span class="n">best</span> <span class="o">=</span> <span class="mi">0</span>\n        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>\n        <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">:</span>\n            <span class="n">L</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>\n            <span class="n">R</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">left</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>\n            <span class="n">h</span> <span class="o">=</span> <span class="n">query</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span>\n            <span class="n">update</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>\n            <span class="n">best</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">best</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>\n            <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best</span><span class="p">)</span>\n\n        <span class="k">return</span> <span class="n">ans</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kt">int</span><span class="o">[]</span> <span class="n">heights</span><span class="o">;</span>\n    <span class="kt">int</span><span class="o">[]</span> <span class="n">blocks</span><span class="o">;</span>\n    <span class="kt">int</span><span class="o">[]</span> <span class="n">blocks_read</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">B</span><span class="o">;</span>\n\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">query</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">%</span> <span class="n">B</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">ans</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">heights</span><span class="o">[</span><span class="n">left</span><span class="o">]);</span>\n            <span class="n">ans</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">blocks</span><span class="o">[</span><span class="n">left</span> <span class="o">/</span> <span class="n">B</span><span class="o">]);</span>\n            <span class="n">left</span><span class="o">++;</span>\n        <span class="o">}</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">%</span> <span class="n">B</span> <span class="o">!=</span> <span class="n">B</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">ans</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">heights</span><span class="o">[</span><span class="n">right</span><span class="o">]);</span>\n            <span class="n">ans</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">blocks</span><span class="o">[</span><span class="n">right</span> <span class="o">/</span> <span class="n">B</span><span class="o">]);</span>\n            <span class="n">right</span><span class="o">--;</span>\n        <span class="o">}</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">ans</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">blocks</span><span class="o">[</span><span class="n">left</span> <span class="o">/</span> <span class="n">B</span><span class="o">]);</span>\n            <span class="n">ans</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">blocks_read</span><span class="o">[</span><span class="n">left</span> <span class="o">/</span> <span class="n">B</span><span class="o">]);</span>\n            <span class="n">left</span> <span class="o">+=</span> <span class="n">B</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">%</span> <span class="n">B</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">heights</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">heights</span><span class="o">[</span><span class="n">left</span><span class="o">],</span> <span class="n">h</span><span class="o">);</span>\n            <span class="n">blocks_read</span><span class="o">[</span><span class="n">left</span> <span class="o">/</span> <span class="n">B</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">blocks_read</span><span class="o">[</span><span class="n">left</span> <span class="o">/</span> <span class="n">B</span><span class="o">],</span> <span class="n">h</span><span class="o">);</span>\n            <span class="n">left</span><span class="o">++;</span>\n        <span class="o">}</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">right</span> <span class="o">%</span> <span class="n">B</span> <span class="o">!=</span> <span class="n">B</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">heights</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">heights</span><span class="o">[</span><span class="n">right</span><span class="o">],</span> <span class="n">h</span><span class="o">);</span>\n            <span class="n">blocks_read</span><span class="o">[</span><span class="n">right</span> <span class="o">/</span> <span class="n">B</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">blocks_read</span><span class="o">[</span><span class="n">right</span> <span class="o">/</span> <span class="n">B</span><span class="o">],</span> <span class="n">h</span><span class="o">);</span>\n            <span class="n">right</span><span class="o">--;</span>\n        <span class="o">}</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">blocks</span><span class="o">[</span><span class="n">left</span> <span class="o">/</span> <span class="n">B</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">blocks</span><span class="o">[</span><span class="n">left</span> <span class="o">/</span> <span class="n">B</span><span class="o">],</span> <span class="n">h</span><span class="o">);</span>\n            <span class="n">left</span> <span class="o">+=</span> <span class="n">B</span><span class="o">;</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">fallingSquares</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">positions</span><span class="o">)</span> <span class="o">{</span>\n        <span class="c1">//Coordinate Compression</span>\n        <span class="c1">//HashMap&lt;Integer, Integer&gt; index = ...;</span>\n        <span class="c1">//int t = ...;</span>\n\n        <span class="n">heights</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">t</span><span class="o">];</span>\n        <span class="n">B</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>\n        <span class="n">blocks</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">B</span><span class="o">+</span><span class="mi">2</span><span class="o">];</span>\n        <span class="n">blocks_read</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">B</span><span class="o">+</span><span class="mi">2</span><span class="o">];</span>\n\n        <span class="kt">int</span> <span class="n">best</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>\n\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">pos</span><span class="o">:</span> <span class="n">positions</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">L</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pos</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>\n            <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pos</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">pos</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>\n            <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">query</span><span class="o">(</span><span class="n">L</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span> <span class="o">+</span> <span class="n">pos</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>\n            <span class="n">update</span><span class="o">(</span><span class="n">L</span><span class="o">,</span> <span class="n">R</span><span class="o">,</span> <span class="n">h</span><span class="o">);</span>\n            <span class="n">best</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">best</span><span class="o">,</span> <span class="n">h</span><span class="o">);</span>\n            <span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">best</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N\\sqrt{N})</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>positions</code>.  Each <code>query</code> and <code>update</code> has complexity <script type="math/tex; mode=display">O(\\sqrt{N})</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the space used by <code>heights</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-segment-tree-with-lazy-propagation-accepted">Approach #4: Segment Tree with Lazy Propagation [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we were familiar with the idea of a segment tree (which supports queries and updates on intervals), we can immediately crack the problem.  </p>\n<p><strong>Algorithm</strong></p>\n<p>Segment trees work by breaking intervals into a disjoint sum of component intervals, whose number is at most <code>log(width)</code>.  The motivation is that when we change an element, we only need to change <code>log(width)</code> many intervals that aggregate on an interval containing that element.</p>\n<p>When we want to update an interval all at once, we need to use <em>lazy propagation</em> to ensure good run-time complexity.  This topic is covered in more depth <a href="https://leetcode.com/articles/recursive-approach-segment-trees-range-sum-queries-lazy-propagation/">here</a>.</p>\n<p>With such an implementation in hand, the problem falls out immediately.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SegmentTree</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">update_fn</span><span class="p">,</span> <span class="n">query_fn</span><span class="p">):</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">N</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="mi">1</span>\n        <span class="k">while</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>\n            <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">+=</span> <span class="mi">1</span>\n\n        <span class="bp">self</span><span class="o">.</span><span class="n">update_fn</span> <span class="o">=</span> <span class="n">update_fn</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">query_fn</span> <span class="o">=</span> <span class="n">query_fn</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">lazy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>\n\n    <span class="k">def</span> <span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>\n        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>\n            <span class="bp">self</span><span class="o">.</span><span class="n">lazy</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lazy</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>\n\n    <span class="k">def</span> <span class="nf">_pull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>\n        <span class="k">while</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>\n            <span class="n">x</span> <span class="o">/=</span> <span class="mi">2</span>\n            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>\n            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_fn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lazy</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>\n\n    <span class="k">def</span> <span class="nf">_push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>\n        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>\n            <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">h</span>\n            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lazy</span><span class="p">[</span><span class="n">y</span><span class="p">]:</span>\n                <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lazy</span><span class="p">[</span><span class="n">y</span><span class="p">])</span>\n                <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="mi">2</span><span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lazy</span><span class="p">[</span><span class="n">y</span><span class="p">])</span>\n                <span class="bp">self</span><span class="o">.</span><span class="n">lazy</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>\n\n    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>\n        <span class="n">L</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>\n        <span class="n">R</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>\n        <span class="n">L0</span><span class="p">,</span> <span class="n">R0</span> <span class="o">=</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span>\n        <span class="k">while</span> <span class="n">L</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">:</span>\n            <span class="k">if</span> <span class="n">L</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>\n                <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>\n                <span class="n">L</span> <span class="o">+=</span> <span class="mi">1</span>\n            <span class="k">if</span> <span class="n">R</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>\n                <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>\n                <span class="n">R</span> <span class="o">-=</span> <span class="mi">1</span>\n            <span class="n">L</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">R</span> <span class="o">/=</span> <span class="mi">2</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">_pull</span><span class="p">(</span><span class="n">L0</span><span class="p">)</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">_pull</span><span class="p">(</span><span class="n">R0</span><span class="p">)</span>\n\n    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>\n        <span class="n">L</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>\n        <span class="n">R</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">_push</span><span class="p">(</span><span class="n">L</span><span class="p">);</span> <span class="bp">self</span><span class="o">.</span><span class="n">_push</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>\n        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>\n        <span class="k">while</span> <span class="n">L</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">:</span>\n            <span class="k">if</span> <span class="n">L</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>\n                <span class="n">ans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_fn</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">L</span><span class="p">])</span>\n                <span class="n">L</span> <span class="o">+=</span> <span class="mi">1</span>\n            <span class="k">if</span> <span class="n">R</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>\n                <span class="n">ans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_fn</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">R</span><span class="p">])</span>\n                <span class="n">R</span> <span class="o">-=</span> <span class="mi">1</span>\n            <span class="n">L</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">R</span> <span class="o">/=</span> <span class="mi">2</span>\n        <span class="k">return</span> <span class="n">ans</span>\n\n<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">fallingSquares</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>\n        <span class="c1">#Coordinate compression</span>\n        <span class="c1">#index = ...</span>\n\n        <span class="n">tree</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="nb">max</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>\n        <span class="n">best</span> <span class="o">=</span> <span class="mi">0</span>\n        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>\n        <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">:</span>\n            <span class="n">L</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">index</span><span class="p">[</span><span class="n">left</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>\n            <span class="n">h</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span>\n            <span class="n">tree</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>\n            <span class="n">best</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">best</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>\n            <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best</span><span class="p">)</span>\n\n        <span class="k">return</span> <span class="n">ans</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">fallingSquares</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">positions</span><span class="o">)</span> <span class="o">{</span>\n        <span class="c1">//Coordinate Compression</span>\n        <span class="c1">//HashMap&lt;Integer, Integer&gt; index = ...;</span>\n\n        <span class="n">SegmentTree</span> <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SegmentTree</span><span class="o">(</span><span class="n">sortedCoords</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>\n        <span class="kt">int</span> <span class="n">best</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>\n\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">pos</span><span class="o">:</span> <span class="n">positions</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">L</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pos</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>\n            <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">pos</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">pos</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>\n            <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">L</span><span class="o">,</span> <span class="n">R</span><span class="o">)</span> <span class="o">+</span> <span class="n">pos</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>\n            <span class="n">tree</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">L</span><span class="o">,</span> <span class="n">R</span><span class="o">,</span> <span class="n">h</span><span class="o">);</span>\n            <span class="n">best</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">best</span><span class="o">,</span> <span class="n">h</span><span class="o">);</span>\n            <span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">best</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n\n<span class="kd">class</span> <span class="nc">SegmentTree</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">N</span><span class="o">,</span> <span class="n">H</span><span class="o">;</span>\n    <span class="kt">int</span><span class="o">[]</span> <span class="n">tree</span><span class="o">,</span> <span class="n">lazy</span><span class="o">;</span>\n\n    <span class="n">SegmentTree</span><span class="o">(</span><span class="kt">int</span> <span class="n">N</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">this</span><span class="o">.</span><span class="na">N</span> <span class="o">=</span> <span class="n">N</span><span class="o">;</span>\n        <span class="n">H</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="k">while</span> <span class="o">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">H</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">)</span> <span class="n">H</span><span class="o">++;</span>\n        <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="o">];</span>\n        <span class="n">lazy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">N</span><span class="o">];</span>\n    <span class="o">}</span>\n\n    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">tree</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">tree</span><span class="o">[</span><span class="n">x</span><span class="o">],</span> <span class="n">val</span><span class="o">);</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">)</span> <span class="n">lazy</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">lazy</span><span class="o">[</span><span class="n">x</span><span class="o">],</span> <span class="n">val</span><span class="o">);</span>\n    <span class="o">}</span>\n\n    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">pull</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>\n            <span class="n">tree</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">tree</span><span class="o">[</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">],</span> <span class="n">tree</span><span class="o">[</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]);</span>\n            <span class="n">tree</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">tree</span><span class="o">[</span><span class="n">x</span><span class="o">],</span> <span class="n">lazy</span><span class="o">[</span><span class="n">x</span><span class="o">]);</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n\n    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">H</span><span class="o">;</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">h</span><span class="o">--)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">h</span><span class="o">;</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">lazy</span><span class="o">[</span><span class="n">y</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n                <span class="n">apply</span><span class="o">(</span><span class="n">y</span> <span class="o">*</span> <span class="mi">2</span><span class="o">,</span> <span class="n">lazy</span><span class="o">[</span><span class="n">y</span><span class="o">]);</span>\n                <span class="n">apply</span><span class="o">(</span><span class="n">y</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">lazy</span><span class="o">[</span><span class="n">y</span><span class="o">]);</span>\n                <span class="n">lazy</span><span class="o">[</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="kt">int</span> <span class="n">L</span><span class="o">,</span> <span class="kt">int</span> <span class="n">R</span><span class="o">,</span> <span class="kt">int</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">L</span> <span class="o">+=</span> <span class="n">N</span><span class="o">;</span> <span class="n">R</span> <span class="o">+=</span> <span class="n">N</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">L0</span> <span class="o">=</span> <span class="n">L</span><span class="o">,</span> <span class="n">R0</span> <span class="o">=</span> <span class="n">R</span><span class="o">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">L</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">((</span><span class="n">L</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="n">apply</span><span class="o">(</span><span class="n">L</span><span class="o">++,</span> <span class="n">h</span><span class="o">);</span>\n            <span class="k">if</span> <span class="o">((</span><span class="n">R</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">apply</span><span class="o">(</span><span class="n">R</span><span class="o">--,</span> <span class="n">h</span><span class="o">);</span>\n            <span class="n">L</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">R</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="n">pull</span><span class="o">(</span><span class="n">L0</span><span class="o">);</span> <span class="n">pull</span><span class="o">(</span><span class="n">R0</span><span class="o">);</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">query</span><span class="o">(</span><span class="kt">int</span> <span class="n">L</span><span class="o">,</span> <span class="kt">int</span> <span class="n">R</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">L</span> <span class="o">+=</span> <span class="n">N</span><span class="o">;</span> <span class="n">R</span> <span class="o">+=</span> <span class="n">N</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="n">push</span><span class="o">(</span><span class="n">L</span><span class="o">);</span> <span class="n">push</span><span class="o">(</span><span class="n">R</span><span class="o">);</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">L</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">((</span><span class="n">L</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">tree</span><span class="o">[</span><span class="n">L</span><span class="o">++]);</span>\n            <span class="k">if</span> <span class="o">((</span><span class="n">R</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">tree</span><span class="o">[</span><span class="n">R</span><span class="o">--]);</span>\n            <span class="n">L</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">R</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N \\log N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>positions</code>.  This is the run-time complexity of using a segment tree.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the space used by our tree.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Uber', 'Square'],
  },
  {
    id: '711',
    name: 'Number of Distinct Islands II ',
    acceptance: '40.2%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>Given a non-empty 2D array <code>grid</code> of 0's and 1's, an <b>island</b> is a group of <code>1</code>'s (representing land) connected 4-directionally (horizontal or vertical.)  You may assume all four edges of the grid are surrounded by water.</p>\n\n<p>Count the number of <b>distinct</b> islands.  An island is considered to be the same as another if they have the same shape, or have the same shape after <b>rotation</b> (90, 180, or 270 degrees only) or <b>reflection</b> (left/right direction or up/down direction).</p>\n\n<p><b>Example 1:</b><br>\n</p><pre>11000\n10000\n00001\n00011\n</pre>\nGiven the above grid map, return <code>1</code>.\n<br><br>\nNotice that:\n<pre>11\n1\n</pre>\nand\n<pre> 1\n11\n</pre>\nare considered <b>same</b> island shapes. Because if we make a 180 degrees clockwise rotation on the first island, then two islands will have the same shapes.\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre>11100\n10001\n01001\n01110</pre>\nGiven the above grid map, return <code>2</code>.<br>\n<br>\nHere are the two distinct islands:\n<pre>111\n1\n</pre>\nand\n<pre>1\n1\n</pre>\n<br>\nNotice that:\n<pre>111\n1\n</pre>\nand\n<pre>1\n111\n</pre>\nare considered <b>same</b> island shapes. Because if we flip the first array in the up/down direction, then they have the same shapes.\n<p></p>\n\n<p><b>Note:</b>\nThe length of each dimension in the given <code>grid</code> does not exceed 50.\n</p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-canonical-hash-accepted">Approach #1: Canonical Hash [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-canonical-hash-accepted">Approach #1: Canonical Hash [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>As in <em>Approach #1</em> to the sister problem <a href="https://leetcode.com/articles/number-of-distinct-islands/">Number of Distinct Islands</a>, we determine local coordinates for each island.</p>\n<p>Afterwards, we will rotate and reflect the coordinates about the origin and translate the shape so that the bottom-left-most coordinate is (0, 0).  At the end, the smallest of these lists coordinates will be the <em>canonical representation</em> of the shape.</p>\n<p><strong>Algorithm</strong></p>\n<p>We feature two different implementations, but the core idea is the same.  We start with the code from the previous problem, <em>Number of Distinct Islands</em>.</p>\n<p>For each of 8 possible rotations and reflections of the shape, we will perform the transformation and then translate the shape so that the bottom-left-most coordinate is (0, 0).  Afterwards, we will consider the canonical hash of the shape to be the maximum of these 8 intermediate hashes.</p>\n<p>In Python, the motivation to use complex numbers is that rotation by 90 degrees is the same as multiplying by the imaginary unit, <code>1j</code>.  In Java, we manipulate the coordinates directly.  The 8 rotations and reflections of each point are <code>(x, y), (-x, y), (x, -y), (-x, -y), (y, x), (-y, x), (y, -x), (-y, -x)</code>.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">numDistinctIslands2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>\n        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>\n        <span class="k">def</span> <span class="nf">explore</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>\n            <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span>\n                    <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">):</span>\n                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>\n                <span class="n">shape</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>\n                <span class="n">explore</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>\n                <span class="n">explore</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>\n                <span class="n">explore</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>\n                <span class="n">explore</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>\n\n        <span class="k">def</span> <span class="nf">canonical</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>\n            <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>\n                <span class="n">w</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">),</span>\n                            <span class="nb">min</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">))</span>\n                <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">)</span>\n\n            <span class="n">ans</span> <span class="o">=</span> <span class="bp">None</span>\n            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>\n                <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">translate</span><span class="p">([</span><span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1j</span><span class="p">)</span><span class="o">**</span><span class="n">k</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">]))</span>\n                <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span>  <span class="n">translate</span><span class="p">([</span><span class="nb">complex</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1j</span><span class="p">)</span><span class="o">**</span><span class="n">k</span>\n                                           <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">]))</span>\n            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span>\n\n        <span class="n">shapes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>\n        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)):</span>\n            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>\n                <span class="n">shape</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>\n                <span class="n">explore</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>\n                <span class="k">if</span> <span class="n">shape</span><span class="p">:</span>\n                    <span class="n">shapes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">canonical</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>\n\n        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">;</span>\n    <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">seen</span><span class="o">;</span>\n    <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">shape</span><span class="o">;</span>\n\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">explore</span><span class="o">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">&amp;&amp;</span>\n                <span class="n">grid</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">seen</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">])</span> <span class="o">{</span>\n            <span class="n">seen</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>\n            <span class="n">shape</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">+</span> <span class="n">c</span><span class="o">);</span>\n            <span class="n">explore</span><span class="o">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>\n            <span class="n">explore</span><span class="o">(</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>\n            <span class="n">explore</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>\n            <span class="n">explore</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>\n        <span class="o">}</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="n">String</span> <span class="nf">canonical</span><span class="o">(</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">shape</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">String</span> <span class="n">ans</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">lift</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>\n        <span class="kt">int</span><span class="o">[]</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">shape</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>\n        <span class="kt">int</span><span class="o">[]</span> <span class="n">xs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">shape</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>\n        <span class="kt">int</span><span class="o">[]</span> <span class="n">ys</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">shape</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>\n\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">;</span> <span class="o">++</span><span class="n">c</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">z</span><span class="o">:</span> <span class="n">shape</span><span class="o">)</span> <span class="o">{</span>\n                <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">z</span> <span class="o">/</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>\n                <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">z</span> <span class="o">%</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>\n                <span class="c1">//x y, x -y, -x y, -x -y</span>\n                <span class="c1">//y x, y -x, -y x, -y -x</span>\n                <span class="n">xs</span><span class="o">[</span><span class="n">t</span><span class="o">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">&lt;=</span><span class="mi">1</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">c</span><span class="o">&lt;=</span><span class="mi">3</span> <span class="o">?</span> <span class="o">-</span><span class="n">x</span> <span class="o">:</span> <span class="n">c</span><span class="o">&lt;=</span><span class="mi">5</span> <span class="o">?</span> <span class="n">y</span> <span class="o">:</span> <span class="o">-</span><span class="n">y</span><span class="o">;</span>\n                <span class="n">ys</span><span class="o">[</span><span class="n">t</span><span class="o">++]</span> <span class="o">=</span> <span class="n">c</span><span class="o">&lt;=</span><span class="mi">3</span> <span class="o">?</span> <span class="o">(</span><span class="n">c</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span> <span class="o">?</span> <span class="n">y</span> <span class="o">:</span> <span class="o">-</span><span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">c</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="o">-</span><span class="n">x</span><span class="o">);</span>\n            <span class="o">}</span>\n\n            <span class="kt">int</span> <span class="n">mx</span> <span class="o">=</span> <span class="n">xs</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">my</span> <span class="o">=</span> <span class="n">ys</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">:</span> <span class="n">xs</span><span class="o">)</span> <span class="n">mx</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">mx</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">y</span><span class="o">:</span> <span class="n">ys</span><span class="o">)</span> <span class="n">my</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">my</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>\n\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">shape</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>\n                <span class="n">out</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">xs</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">mx</span><span class="o">)</span> <span class="o">*</span> <span class="n">lift</span> <span class="o">+</span> <span class="o">(</span><span class="n">ys</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">my</span><span class="o">);</span>\n            <span class="o">}</span>\n            <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">out</span><span class="o">);</span>\n            <span class="n">String</span> <span class="n">candidate</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">out</span><span class="o">);</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">ans</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">candidate</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numDistinctIslands2</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">this</span><span class="o">.</span><span class="na">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">;</span>\n        <span class="n">seen</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">];</span>\n        <span class="n">Set</span> <span class="n">shapes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>\n\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">r</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">c</span><span class="o">)</span> <span class="o">{</span>\n                <span class="n">shape</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>\n                <span class="n">explore</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>\n                <span class="k">if</span> <span class="o">(!</span><span class="n">shape</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>\n                    <span class="n">shapes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">canonical</span><span class="o">(</span><span class="n">shape</span><span class="o">));</span>\n                <span class="o">}</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n\n        <span class="k">return</span> <span class="n">shapes</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(R*C \\log{(R*C)})</script>, where <script type="math/tex; mode=display">R</script> is the number of rows in the given <code>grid</code>, and <script type="math/tex; mode=display">C</script> is the number of columns.  We visit every square once, and each square belongs to at most one shape.  The log factor comes from sorting the shapes.</p>\n</li>\n<li>\n<p>Space complexity: <script type="math/tex; mode=display">O(R*C)</script>, the space used to keep track of the shapes.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a></p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '712',
    name: 'Minimum ASCII Delete Sum for Two Strings',
    acceptance: '50.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given two strings <code>s1, s2</code>, find the lowest ASCII sum of deleted characters to make two strings equal.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> s1 = "sea", s2 = "eat"\n<b>Output:</b> 231\n<b>Explanation:</b> Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum.\nDeleting "t" from "eat" adds 116 to the sum.\nAt the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> s1 = "delete", s2 = "leet"\n<b>Output:</b> 403\n<b>Explanation:</b> Deleting "dee" from "delete" to turn the string into "let",\nadds 100[d]+101[e]+101[e] to the sum.  Deleting "e" from "leet" adds 101[e] to the sum.\nAt the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403.\nIf instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li><code>0 &lt; s1.length, s2.length &lt;= 1000</code>.</li>\n<li>All elements of each string will have an ASCII value in <code>[97, 122]</code>.</li> \n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Let <code>dp[i][j]</code> be the answer to the problem for the strings <code>s1[i:], s2[j:]</code>.</p>\n<p>When one of the input strings is empty, the answer is the ASCII-sum of the other string.  We can calculate this cumulatively using code like <code>dp[i][s2.length()] = dp[i+1][s2.length()] + s1.codePointAt(i)</code>.</p>\n<p>When <code>s1[i] == s2[j]</code>, we have <code>dp[i][j] = dp[i+1][j+1]</code> as we can ignore these two characters.</p>\n<p>When <code>s1[i] != s2[j]</code>, we will have to delete at least one of them.  We\'ll have <code>dp[i][j]</code> as the minimum of the answers after both deletion options.</p>\n<p>The solutions presented will use <em>bottom-up</em> dynamic programming.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">minimumDeleteSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>\n        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>\n\n        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>\n            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)]</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>\n        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>\n            <span class="n">dp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>\n\n        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>\n            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>\n                <span class="k">if</span> <span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>\n                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>\n                <span class="k">else</span><span class="p">:</span>\n                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>\n                                   <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>\n\n        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minimumDeleteSum</span><span class="o">(</span><span class="n">String</span> <span class="n">s1</span><span class="o">,</span> <span class="n">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>\n\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>\n            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">()]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">()]</span> <span class="o">+</span> <span class="n">s1</span><span class="o">.</span><span class="na">codePointAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>\n            <span class="n">dp</span><span class="o">[</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">s2</span><span class="o">.</span><span class="na">codePointAt</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">s2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>\n                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>\n                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>\n                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">s1</span><span class="o">.</span><span class="na">codePointAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span>\n                                        <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">s2</span><span class="o">.</span><span class="na">codePointAt</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>\n                <span class="o">}</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(M*N)</script>, where <script type="math/tex; mode=display">M, N</script> are the lengths of the given strings.  We use nested for loops: each loop is <script type="math/tex; mode=display">O(M)</script> and <script type="math/tex; mode=display">O(N)</script> respectively.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(M*N)</script>, the space used by <code>dp</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['TripleByte'],
  },
  {
    id: '713',
    name: 'Subarray Product Less Than K',
    acceptance: '33.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Your are given an array of positive integers <code>nums</code>.</p>\n<p>Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than <code>k</code>.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> nums = [10, 5, 2, 6], k = 100\n<b>Output:</b> 8\n<b>Explanation:</b> The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].\nNote that [10, 5, 2] is not included as the product of 100 is not strictly less than k.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li><code>0 &lt; nums.length &lt;= 50000</code>.</li>\n<li><code>0 &lt; nums[i] &lt; 1000</code>.</li>\n<li><code>0 &lt;= k &lt; 10^6</code>.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-binary-search-on-logarithms-accepted">Approach #1: Binary Search on Logarithms [Accepted]</a></li>\n<li><a href="#approach-2-sliding-window-accepted">Approach #2: Sliding Window [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-binary-search-on-logarithms-accepted">Approach #1: Binary Search on Logarithms [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Because <script type="math/tex; mode=display">\\log(\\prod_i x_i) = \\sum_i \\log x_i</script>, we can reduce the problem to subarray <em>sums</em> instead of subarray products.  The motivation for this is that the product of some arbitrary subarray may be way too large (potentially <code>1000^50000</code>), and also dealing with sums gives us some more familiarity as it becomes similar to other problems we may have solved before.</p>\n<p><strong>Algorithm</strong></p>\n<p>After this transformation where every value <code>x</code> becomes <code>log(x)</code>, let us take prefix sums <code>prefix[i+1] = nums[0] + nums[1] + ... + nums[i]</code>.  Now we are left with the problem of finding, for each <code>i</code>, the largest <code>j</code> so that <code>nums[i] + ... + nums[j] = prefix[j] - prefix[i] &lt; k</code>.</p>\n<p>Because <code>prefix</code> is a monotone increasing array, this can be solved with binary search.  We add the width of the interval <code>[i, j]</code> to our answer, which counts all subarrays <code>[i, k]</code> with <code>k &lt;= j</code>.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">numSubarrayProductLessThanK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>\n        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>\n        <span class="n">k</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>\n\n        <span class="n">prefix</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>\n        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>\n            <span class="n">prefix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prefix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>\n\n        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>\n        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prefix</span><span class="p">):</span>\n            <span class="n">j</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mf">1e-9</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>\n            <span class="n">ans</span> <span class="o">+=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>\n        <span class="k">return</span> <span class="n">ans</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numSubarrayProductLessThanK</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="kt">double</span> <span class="n">logk</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>\n        <span class="kt">double</span><span class="o">[]</span> <span class="n">prefix</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="n">prefix</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">Math</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>\n        <span class="o">}</span>\n\n        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prefix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>\n            <span class="k">while</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>\n                <span class="kt">int</span> <span class="n">mi</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="o">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">prefix</span><span class="o">[</span><span class="n">mi</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">prefix</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">logk</span> <span class="o">-</span> <span class="mf">1e-9</span><span class="o">)</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">mi</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n                <span class="k">else</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">mi</span><span class="o">;</span>\n            <span class="o">}</span>\n            <span class="n">ans</span> <span class="o">+=</span> <span class="n">lo</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N\\log N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>.  Inside our for loop, each binary search operation takes <script type="math/tex; mode=display">O(\\log N)</script> time.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the space used by <code>prefix</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-sliding-window-accepted">Approach #2: Sliding Window [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>For each <code>right</code>, call <code>opt(right)</code> the smallest <code>left</code> so that the product of the subarray <code>nums[left] * nums[left + 1] * ... * nums[right]</code> is less than <code>k</code>.  <code>opt</code> is a monotone increasing function, so we can use a sliding window.</p>\n<p><strong>Algorithm</strong></p>\n<p>Our loop invariant is that <code>left</code> is the smallest value so that the product in the window <code>prod = nums[left] * nums[left + 1] * ... * nums[right]</code> is less than <code>k</code>.</p>\n<p>For every right, we update <code>left</code> and <code>prod</code> to maintain this invariant.  Then, the number of intervals with subarray product less than <code>k</code> and with right-most coordinate <code>right</code>, is <code>right - left + 1</code>.  We\'ll count all of these for each value of <code>right</code>.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">numSubarrayProductLessThanK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>\n        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>\n        <span class="n">prod</span> <span class="o">=</span> <span class="mi">1</span>\n        <span class="n">ans</span> <span class="o">=</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>\n        <span class="k">for</span> <span class="n">right</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>\n            <span class="n">prod</span> <span class="o">*=</span> <span class="n">val</span>\n            <span class="k">while</span> <span class="n">prod</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>\n                <span class="n">prod</span> <span class="o">/=</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>\n                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>\n            <span class="n">ans</span> <span class="o">+=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span>\n        <span class="k">return</span> <span class="n">ans</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numSubarrayProductLessThanK</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="kt">int</span> <span class="n">prod</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">right</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="n">prod</span> <span class="o">*=</span> <span class="n">nums</span><span class="o">[</span><span class="n">right</span><span class="o">];</span>\n            <span class="k">while</span> <span class="o">(</span><span class="n">prod</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="o">)</span> <span class="n">prod</span> <span class="o">/=</span> <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">++];</span>\n            <span class="n">ans</span> <span class="o">+=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>.  <code>left</code> can only be incremented at most <code>N</code> times.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>, the space used by <code>prod</code>, <code>left</code>, and <code>ans</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Yatra'],
  },
  {
    id: '714',
    name: 'Best Time to Buy and Sell Stock with Transaction Fee',
    acceptance: '42.2%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p>\n<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.  You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>\n<p>Return the maximum profit you can make.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> prices = [1, 3, 2, 8, 4, 9], fee = 2\n<b>Output:</b> 8\n<b>Explanation:</b> The maximum profit can be achieved by:\n<li>Buying at prices[0] = 1</li><li>Selling at prices[3] = 8</li><li>Buying at prices[4] = 4</li><li>Selling at prices[5] = 9</li>The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li><code>0 &lt; prices.length &lt;= 50000</code>.</li>\n<li><code>0 &lt; prices[i] &lt; 50000</code>.</li>\n<li><code>0 &lt;= fee &lt; 50000</code>.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>At the end of the <code>i</code>-th day, we maintain <code>cash</code>, the maximum profit we could have if we did not have a share of stock, and <code>hold</code>, the maximum profit we could have if we owned a share of stock.</p>\n<p>To transition from the <code>i</code>-th day to the <code>i+1</code>-th day, we either sell our stock <code>cash = max(cash, hold + prices[i] - fee)</code> or buy a stock <code>hold = max(hold, cash - prices[i])</code>.  At the end, we want to return <code>cash</code>.  We can transform <code>cash</code> first without using temporary variables because selling and buying on the same day can\'t be better than just continuing to hold the stock.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">,</span> <span class="n">fee</span><span class="p">):</span>\n        <span class="n">cash</span><span class="p">,</span> <span class="n">hold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>\n        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)):</span>\n            <span class="n">cash</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cash</span><span class="p">,</span> <span class="n">hold</span> <span class="o">+</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">fee</span><span class="p">)</span>\n            <span class="n">hold</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">hold</span><span class="p">,</span> <span class="n">cash</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>\n        <span class="k">return</span> <span class="n">cash</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fee</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">cash</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">hold</span> <span class="o">=</span> <span class="o">-</span><span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="n">cash</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">cash</span><span class="o">,</span> <span class="n">hold</span> <span class="o">+</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">fee</span><span class="o">);</span>\n            <span class="n">hold</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">hold</span><span class="o">,</span> <span class="n">cash</span> <span class="o">-</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">cash</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the number of prices.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>, the space used by <code>cash</code> and <code>hold</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Facebook', 'Bloomberg'],
  },
  {
    id: '715',
    name: 'Range Module',
    acceptance: '30.7%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner.</p>\n\n<p></p><li><code>addRange(int left, int right)</code> Adds the half-open interval <code>[left, right)</code>, tracking every real number in that interval.  Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval <code>[left, right)</code> that are not already tracked.</li><p></p>\n\n<p></p><li><code>queryRange(int left, int right)</code> Returns true if and only if every real number in the interval <code>[left, right)</code>\n is currently being tracked.</li><p></p>\n\n<p></p><li><code>removeRange(int left, int right)</code> Stops tracking every real number currently being tracked in the interval <code>[left, right)</code>.</li><p></p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>addRange(10, 20)</b>: null\n<b>removeRange(14, 16)</b>: null\n<b>queryRange(10, 14)</b>: true (Every number in [10, 14) is being tracked)\n<b>queryRange(13, 15)</b>: false (Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)\n<b>queryRange(16, 17)</b>: true (The number 16 in [16, 17) is still being tracked, despite the remove operation)\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>A half open interval <code>[left, right)</code> denotes all real numbers <code>left &lt;= x &lt; right</code>.</li>\n\n<li><code>0 &lt; left &lt; right &lt; 10^9</code> in all calls to <code>addRange, queryRange, removeRange</code>.</li>\n<li>The total number of calls to <code>addRange</code> in a single test case is at most <code>1000</code>.</li>\n<li>The total number of calls to <code>queryRange</code> in a single test case is at most <code>5000</code>.</li>\n<li>The total number of calls to <code>removeRange</code> in a single test case is at most <code>1000</code>.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-maintain-sorted-disjoint-intervals-accepted">Approach #1: Maintain Sorted Disjoint Intervals [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-maintain-sorted-disjoint-intervals-accepted">Approach #1: Maintain Sorted Disjoint Intervals [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Because <code>left, right &lt; 10^9</code>, we need to deal with the coordinates abstractly.  Let\'s maintain some sorted structure of disjoint intervals.  These intervals will be closed (eg. we don\'t store <code>[[1, 2], [2, 3]]</code>; we would store <code>[[1, 3]]</code> instead.)</p>\n<p>In this article, we will go over Python and Java versions separately, as the data structures available to us that are relevant to the problem are substantially different.</p>\n<p><strong>Algorithm (Python)</strong></p>\n<p>We will maintain the structure as a <em>list</em> <code>self.ranges = []</code>.  </p>\n<p><em>Adding a Range</em></p>\n<p>When we want to add a range, we first find the indices <code>i, j = self._bounds(left, right)</code> for which <code>self.ranges[i: j+1]</code> touches (in a closed sense - not halfopen) the given interval <code>[left, right]</code>.  We can find this in log time by making steps of size 100, 10, then 1 in our linear search from both sides.</p>\n<p>Every interval touched by <code>[left, right]</code> will be replaced by the single interval <code>[min(left, self.ranges[i][0]), max(right, self.ranges[j][1])]</code>.</p>\n<p><em>Removing a Range</em></p>\n<p>Again, we use <code>i, j = self._bounds(...)</code> to only work in the relevant subset of <code>self.ranges</code> that is in the neighborhood of our given range <code>[left, right)</code>.  For each interval <code>[x, y)</code> from <code>self.ranges[i:j+1]</code>, we may have some subset of that interval to the left and/or right of <code>[left, right)</code>.  We replace our current interval <code>[x, y)</code> with those (up to 2) new intervals.</p>\n<p><em>Querying a Range</em></p>\n<p>As the intervals are sorted, we use binary search to find the single interval that could intersect <code>[left, right)</code>, then verify that it does.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">RangeModule</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span> <span class="o">=</span> <span class="p">[]</span>\n\n    <span class="k">def</span> <span class="nf">_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>\n        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>\n        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>\n            <span class="k">while</span> <span class="n">i</span> <span class="o">+</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">left</span><span class="p">:</span>\n                <span class="n">i</span> <span class="o">+=</span> <span class="n">d</span>\n            <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">:</span>\n                <span class="n">j</span> <span class="o">-=</span> <span class="n">d</span>\n        <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span>\n\n    <span class="k">def</span> <span class="nf">addRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>\n        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>\n        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>\n            <span class="n">left</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>\n            <span class="n">right</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)]</span>\n\n    <span class="k">def</span> <span class="nf">queryRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>\n        <span class="n">i</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">,</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">\'inf\'</span><span class="p">)))</span>\n        <span class="k">if</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>\n        <span class="k">return</span> <span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">)</span> <span class="ow">and</span>\n                <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">left</span> <span class="ow">and</span>\n                <span class="n">right</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>\n\n    <span class="k">def</span> <span class="nf">removeRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>\n        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>\n        <span class="n">merge</span> <span class="o">=</span> <span class="p">[]</span>\n        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>\n            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">left</span><span class="p">:</span>\n                <span class="n">merge</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">left</span><span class="p">))</span>\n            <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>\n                <span class="n">merge</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">merge</span>\n</pre></div>\n<hr>\n<p><strong>Algorithm (Java)</strong></p>\n<p>We will maintain the structure as a <em>TreeSet</em> <code>ranges = new TreeSet&lt;Interval&gt;();</code>.  We introduce a new <em>Comparable</em> class <code>Interval</code> to represent our half-open intervals.  They compare by <em>right-most</em> coordinate as later we will see that it simplifies our work.  Also note that this ordering is consistent with equals, which is important when dealing with <em>Sets</em>.</p>\n<p><em>Adding and Removing a Range</em></p>\n<p>The basic structure of adding and removing a range is the same.  First, we must iterate over the relevant subset of <code>ranges</code>.  This is done using iterators so that we can <code>itr.remove</code> on the fly, and breaking when the intervals go too far to the right.</p>\n<p>The critical logic of <code>addRange</code> is simply to make <code>left, right</code> the smallest and largest seen coordinates.  After, we add one giant interval representing the union of all intervals seen that touched <code>[left, right]</code>.</p>\n<p>The logic of <code>removeRange</code> is to remember in <code>todo</code> the intervals we wanted to replace the removed interval with.  After, we can add them all back in.</p>\n<p><em>Querying a Range</em></p>\n<p>As the intervals are sorted, we search to find the single interval that could intersect <code>[left, right)</code>, then verify that it does.  As the TreeSet uses a balanced (red-black) tree, this has logarithmic complexity.</p>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">RangeModule</span> <span class="o">{</span>\n    <span class="n">TreeSet</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="n">ranges</span><span class="o">;</span>\n    <span class="kd">public</span> <span class="nf">RangeModule</span><span class="o">()</span> <span class="o">{</span>\n        <span class="n">ranges</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeSet</span><span class="o">();</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">ranges</span><span class="o">.</span><span class="na">tailSet</span><span class="o">(</span><span class="k">new</span> <span class="n">Interval</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)).</span><span class="na">iterator</span><span class="o">();</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">itr</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>\n            <span class="n">Interval</span> <span class="n">iv</span> <span class="o">=</span> <span class="n">itr</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">iv</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>\n            <span class="n">left</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">iv</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>\n            <span class="n">right</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">iv</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>\n            <span class="n">itr</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>\n        <span class="o">}</span>\n        <span class="n">ranges</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Interval</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">));</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">queryRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">Interval</span> <span class="n">iv</span> <span class="o">=</span> <span class="n">ranges</span><span class="o">.</span><span class="na">higher</span><span class="o">(</span><span class="k">new</span> <span class="n">Interval</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">left</span><span class="o">));</span>\n        <span class="k">return</span> <span class="o">(</span><span class="n">iv</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">iv</span><span class="o">.</span><span class="na">left</span> <span class="o">&lt;=</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;=</span> <span class="n">iv</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">ranges</span><span class="o">.</span><span class="na">tailSet</span><span class="o">(</span><span class="k">new</span> <span class="n">Interval</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">left</span><span class="o">)).</span><span class="na">iterator</span><span class="o">();</span>\n        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;</span> <span class="n">todo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">itr</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>\n            <span class="n">Interval</span> <span class="n">iv</span> <span class="o">=</span> <span class="n">itr</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">iv</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">iv</span><span class="o">.</span><span class="na">left</span> <span class="o">&lt;</span> <span class="n">left</span><span class="o">)</span> <span class="n">todo</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Interval</span><span class="o">(</span><span class="n">iv</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">left</span><span class="o">));</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">iv</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="n">todo</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Interval</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">iv</span><span class="o">.</span><span class="na">right</span><span class="o">));</span>\n            <span class="n">itr</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>\n        <span class="o">}</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">Interval</span> <span class="n">iv</span><span class="o">:</span> <span class="n">todo</span><span class="o">)</span> <span class="n">ranges</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">iv</span><span class="o">);</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n\n<span class="kd">class</span> <span class="nc">Interval</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Interval</span><span class="o">&gt;{</span>\n    <span class="kt">int</span> <span class="n">left</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">right</span><span class="o">;</span>\n\n    <span class="kd">public</span> <span class="nf">Interval</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">){</span>\n        <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>\n        <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">Interval</span> <span class="n">that</span><span class="o">){</span>\n        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">-</span> <span class="n">that</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>\n        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">-</span> <span class="n">that</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: Let <script type="math/tex; mode=display">K</script> be the number of elements in <code>ranges</code>.  <code>addRange</code> and <code>removeRange</code> operations have <script type="math/tex; mode=display">O(K)</script> complexity.  <code>queryRange</code> has <script type="math/tex; mode=display">O(\\log K)</script> complexity.  Because <code>addRange, removeRange</code> adds at most 1 interval at a time, you can bound these further.  For example, if there are <script type="math/tex; mode=display">A</script>\n<code>addRange</code>, <script type="math/tex; mode=display">R</script>\n<code>removeRange</code>, and <script type="math/tex; mode=display">Q</script>\n<code>queryRange</code> number of operations respectively, we can express our complexity as <script type="math/tex; mode=display">O((A+R)^2 Q \\log(A+R))</script>. </p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(A+R)</script>, the space used by <code>ranges</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Coupang', 'Machine Zone'],
  },
  {
    id: '716',
    name: 'Max Stack ',
    acceptance: '35.8%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>Design a max stack that supports push, pop, top, peekMax and popMax.</p>\n\n<p>\n</p><ol>\n<li>push(x) -- Push element x onto stack.</li>\n<li>pop() -- Remove the element on top of the stack and return it.</li>\n<li>top() -- Get the element on the top.</li>\n<li>peekMax() -- Retrieve the maximum element in the stack.</li>\n<li>popMax() -- Retrieve the maximum element in the stack, and remove it. If you find more than one maximum elements, only remove the top-most one.</li>\n</ol>\n<p></p>\n\n<p><b>Example 1:</b><br>\n</p><pre>MaxStack stack = new MaxStack();\nstack.push(5); \nstack.push(1);\nstack.push(5);\nstack.top(); -&gt; 5\nstack.popMax(); -&gt; 5\nstack.top(); -&gt; 1\nstack.peekMax(); -&gt; 5\nstack.pop(); -&gt; 1\nstack.top(); -&gt; 5\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>-1e7 &lt;= x &lt;= 1e7</li>\n<li>Number of operations won't exceed 10000.</li>\n<li>The last four operations won't be called when stack is empty.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-two-stacks-accepted">Approach #1: Two Stacks [Accepted]</a></li>\n<li><a href="#approach-2-double-linked-list-treemap-accepted">Approach #2: Double Linked List + TreeMap [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-two-stacks-accepted">Approach #1: Two Stacks [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>A regular stack already supports the first 3 operations, so we focus on the last two.</p>\n<p>For <code>peekMax</code>, we remember the largest value we\'ve seen on the side.  For example if we add <code>[2, 1, 5, 3, 9]</code>, we\'ll remember <code>[2, 2, 5, 5, 9]</code>.  This works seamlessly with <code>pop</code> operations, and also it\'s easy to compute: it\'s just the maximum of the element we are adding and the previous maximum.</p>\n<p>For <code>popMax</code>, we know what the current maximum (<code>peekMax</code>) is.  We can pop until we find that maximum, then push the popped elements back on the stack.</p>\n<p>Our implementation in Python will showcase extending the <code>list</code> class.</p>\n<iframe frameborder="0" height="500" name="49Y3VvUj" src="https://leetcode.com/playground/49Y3VvUj/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script> for the <code>popMax</code> operation, and <script type="math/tex; mode=display">O(1)</script> for the other operations, where <script type="math/tex; mode=display">N</script> is the number of operations performed.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the maximum size of the stack.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-double-linked-list-treemap-accepted">Approach #2: Double Linked List + TreeMap [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Using structures like Array or Stack will never let us <code>popMax</code> quickly.  We turn our attention to tree and linked-list structures that have a lower time complexity for removal, with the aim of making <code>popMax</code> faster than <script type="math/tex; mode=display">O(N)</script> time complexity.</p>\n<p>Say we have a double linked list as our "stack".  This reduces the problem to finding which node to remove, since we can remove nodes in <script type="math/tex; mode=display">O(1)</script> time.</p>\n<p>We can use a TreeMap mapping values to a list of nodes to answer this question.  TreeMap can find the largest value, insert values, and delete values, all in <script type="math/tex; mode=display">O(\\log N)</script> time.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let\'s store the stack as a double linked list <code>dll</code>, and store a <code>map</code> from <code>value</code> to a <code>List</code> of <code>Node</code>.</p>\n<ul>\n<li>\n<p>When we <code>MaxStack.push(x)</code>, we add a node to our <code>dll</code>, and add or update our entry <code>map.get(x).add(node)</code>.</p>\n</li>\n<li>\n<p>When we <code>MaxStack.pop()</code>, we find the value <code>val = dll.pop()</code>, and remove the node from our <code>map</code>, deleting the entry if it was the last one.</p>\n</li>\n<li>\n<p>When we <code>MaxStack.popMax()</code>, we use the <code>map</code> to find the relevant node to <code>unlink</code>, and return it\'s value.</p>\n</li>\n</ul>\n<p>The above operations are more clear given that we have a working <code>DoubleLinkedList</code> class.  The implementation provided uses <code>head</code> and <code>tail</code> <em>sentinels</em> to simplify the relevant <code>DoubleLinkedList</code> operations.</p>\n<p>A Python implementation was not included for this approach because there is no analog to <em>TreeMap</em> available.</p>\n<iframe frameborder="0" height="500" name="7cWp6DCL" src="https://leetcode.com/playground/7cWp6DCL/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(\\log N)</script> for all operations except <code>peek</code> which is <script type="math/tex; mode=display">O(1)</script>, where <script type="math/tex; mode=display">N</script> is the number of operations performed.  Most operations involving <code>TreeMap</code> are <script type="math/tex; mode=display">O(\\log N)</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of the data structures used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '717',
    name: '1-bit and 2-bit Characters',
    acceptance: '50.5%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>We have two special characters. The first character can be represented by one bit <code>0</code>. The second character can be represented by two bits (<code>10</code> or <code>11</code>).  </p>\n\n<p>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \nbits = [1, 0, 0]\n<b>Output:</b> True\n<b>Explanation:</b> \nThe only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \nbits = [1, 1, 1, 0]\n<b>Output:</b> False\n<b>Explanation:</b> \nThe only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li><code>1 &lt;= len(bits) &lt;= 1000</code>.</li>\n<li><code>bits[i]</code> is always <code>0</code> or <code>1</code>.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-increment-pointer-accepted">Approach #1: Increment Pointer [Accepted]</a></li>\n<li><a href="#approach-2-greedy-accepted">Approach #2: Greedy [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-increment-pointer-accepted">Approach #1: Increment Pointer [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>When reading from the <code>i</code>-th position, if <code>bits[i] == 0</code>, the next character must have 1 bit; else if <code>bits[i] == 1</code>, the next character must have 2 bits.  We increment our read-pointer <code>i</code> to the start of the next character appropriately.  At the end, if our pointer is at <code>bits.length - 1</code>, then the last character must have a size of 1 bit.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">isOneBitCharacter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bits</span><span class="p">):</span>\n        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>\n        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>\n            <span class="n">i</span> <span class="o">+=</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>\n        <span class="k">return</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isOneBitCharacter</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">bits</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">bits</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">i</span> <span class="o">+=</span> <span class="n">bits</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">i</span> <span class="o">==</span> <span class="n">bits</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>bits</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>, the space used by <code>i</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-greedy-accepted">Approach #2: Greedy [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>The second-last <code>0</code> must be the end of a character (or, the beginning of the array if it doesn\'t exist).  Looking from that position forward, the array <code>bits</code> takes the form <code>[1, 1, ..., 1, 0]</code> where there are zero or more <code>1</code>\'s present in total.  It is easy to show that the answer is <code>true</code> if and only if there are an even number of ones present.</p>\n<p>In our algorithm, we will find the second last zero by performing a linear scan from the right.  We present two slightly different approaches below.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">isOneBitCharacter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bits</span><span class="p">):</span>\n        <span class="n">parity</span> <span class="o">=</span> <span class="n">bits</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>\n        <span class="k">while</span> <span class="n">bits</span> <span class="ow">and</span> <span class="n">bits</span><span class="o">.</span><span class="n">pop</span><span class="p">():</span> <span class="n">parity</span> <span class="o">^=</span> <span class="mi">1</span>\n        <span class="k">return</span> <span class="n">parity</span> <span class="o">==</span> <span class="mi">0</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isOneBitCharacter</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">bits</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">bits</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">;</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">bits</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">i</span><span class="o">--;</span>\n        <span class="k">return</span> <span class="o">(</span><span class="n">bits</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>bits</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>, the space used by <code>parity</code> (or <code>i</code>).</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Quora'],
  },
  {
    id: '718',
    name: 'Maximum Length of Repeated Subarray',
    acceptance: '40.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given two integer arrays <code>A</code> and <code>B</code>, return the maximum length of an subarray that appears in both arrays.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>\nA: [1,2,3,2,1]\nB: [3,2,1,4,7]\n<b>Output:</b> 3\n<b>Explanation:</b> \nThe repeated subarray with maximum length is [3, 2, 1].\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>1 &lt;= len(A), len(B) &lt;= 1000</li>\n<li>0 &lt;= A[i], B[i] &lt; 100</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-brute-force-with-initial-character-map-time-limit-exceeded">Approach #1: Brute Force with Initial Character Map [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-binary-search-with-naive-check-time-limit-exceeded">Approach #2: Binary Search with Naive Check [Time Limit Exceeded]</a></li>\n<li><a href="#approach-3-dynamic-programming-accepted">Approach #3: Dynamic Programming [Accepted]</a></li>\n<li><a href="#approach-4-binary-search-with-rolling-hash-accepted">Approach #4: Binary Search with Rolling Hash [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-brute-force-with-initial-character-map-time-limit-exceeded">Approach #1: Brute Force with Initial Character Map [Time Limit Exceeded]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>In a typical brute force, for all starting indices <code>i</code> of <code>A</code> and <code>j</code> of <code>B</code>, we will check for the longest matching subarray <code>A[i:i+k] == B[j:j+k]</code> of length <code>k</code>.  This would look roughly like the following psuedocode:</p>\n<div class="codehilite"><pre><span></span><span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>\n<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span> <span class="o">..</span> <span class="n">A</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>\n    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span> <span class="o">..</span> <span class="n">B</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>\n        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>\n        <span class="k">while</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">k</span><span class="p">]):</span> <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">#and i+k &lt; A.length etc.</span>\n        <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>\n</pre></div>\n<p>Our insight is that in typical cases, most of the time <code>A[i] != B[j]</code>.  We could instead keep a hashmap <code>Bstarts[A[i]] = all j such that B[j] == A[i]</code>, and only loop through those in our <code>j</code> loop.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">findLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>\n        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>\n        <span class="n">Bstarts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>\n        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>\n            <span class="n">Bstarts</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>\n\n        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>\n            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">Bstarts</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>\n                <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>\n                <span class="k">while</span> <span class="n">i</span><span class="o">+</span><span class="n">k</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span><span class="o">+</span><span class="n">k</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">k</span><span class="p">]:</span>\n                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>\n                <span class="n">ans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>\n        <span class="k">return</span> <span class="n">ans</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findLength</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">A</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">B</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">Bstarts</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">B</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>\n            <span class="n">Bstarts</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">B</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">()).</span><span class="na">add</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>\n        <span class="o">}</span>\n\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="k">if</span> <span class="o">(</span><span class="n">Bstarts</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">:</span> <span class="n">Bstarts</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>\n                <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n                <span class="k">while</span> <span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">+</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">B</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="o">]</span> <span class="o">==</span> <span class="n">B</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="n">k</span><span class="o">])</span> <span class="o">{</span>\n                    <span class="n">k</span><span class="o">++</span>\n                <span class="o">}</span>\n                <span class="n">ans</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">ans</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(M*N*\\min(M, N))</script>, where <script type="math/tex; mode=display">M, N</script> are the lengths of <code>A, B</code>.  The worst case is when all the elements are equal.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the space used by <code>Bstarts</code>.  (Of course, we could amend our algorithm to make this <script type="math/tex; mode=display">O(\\min(M, N))</script>.)</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-binary-search-with-naive-check-time-limit-exceeded">Approach #2: Binary Search with Naive Check [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>If there is a length <code>k</code> subarray common to <code>A</code> and <code>B</code>, then there is a length <code>j &lt;= k</code> subarray as well.  </p>\n<p>Let <code>check(length)</code> be the answer to the question "Is there a subarray with <code>length</code> length, common to <code>A</code> and <code>B</code>?"  This is a function with range that must take the form <code>[True, True, ..., True, False, False, ..., False]</code> with at least one <code>True</code>.  We can binary search on this function.</p>\n<p><strong>Algorithm</strong></p>\n<p>Focusing on the binary search, our invariant is that <code>check(hi)</code> will always be <code>False</code>.  We\'ll start with <code>hi = min(len(A), len(B)) + 1</code>; clearly <code>check(hi) is False</code>.</p>\n<p>Now we perform our check in the midpoint <code>mi</code> of <code>lo</code> and <code>hi</code>.  When it is possible, then <code>lo = mi + 1</code>, and when it isn\'t, <code>hi = mi</code>.  This maintains the invariant.  At the end of our binary search, <code>hi == lo</code> and <code>lo</code> is the lowest value such that <code>check(lo) is False</code>, so we want <code>lo - 1</code>.</p>\n<p>As for the check itself, we can naively check whether any <code>A[i:i+k] == B[j:j+k]</code> using set structures.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">findLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>\n        <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>\n            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">length</span><span class="p">])</span>\n                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>\n            <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="n">length</span><span class="p">])</span> <span class="ow">in</span> <span class="n">seen</span>\n                       <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">-</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>\n\n        <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>\n        <span class="k">while</span> <span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">:</span>\n            <span class="n">mi</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>\n            <span class="k">if</span> <span class="n">check</span><span class="p">(</span><span class="n">mi</span><span class="p">):</span>\n                <span class="n">lo</span> <span class="o">=</span> <span class="n">mi</span> <span class="o">+</span> <span class="mi">1</span>\n            <span class="k">else</span><span class="p">:</span>\n                <span class="n">hi</span> <span class="o">=</span> <span class="n">mi</span>\n        <span class="k">return</span> <span class="n">lo</span> <span class="o">-</span> <span class="mi">1</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span> <span class="n">length</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">A</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">B</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">seen</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">();</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">seen</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="n">length</span><span class="o">)));</span>\n        <span class="o">}</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">B</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">seen</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span><span class="o">+</span><span class="n">length</span><span class="o">))))</span> <span class="o">{</span>\n                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findLength</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">A</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">B</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">B</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">mi</span> <span class="o">=</span> <span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">check</span><span class="o">(</span><span class="n">mi</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">mi</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n            <span class="k">else</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">mi</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">lo</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O((M + N) * \\min(M, N) * \\log{(\\min(M, N))})</script>, where <script type="math/tex; mode=display">M, N</script> are the lengths of <code>A, B</code>.  The log factor comes from the binary search.  The complexity of our naive check of a given <script type="math/tex; mode=display">\\text{length}</script> is <script type="math/tex; mode=display">O((M+N) * \\text{length})</script>, as we will create the <code>seen</code> strings with complexity <script type="math/tex; mode=display">O(M * \\text{length})</script>, then search for them with complexity <script type="math/tex; mode=display">O(N * \\text{length})</script>, and our total complexity when performing our <code>check</code> is the addition of these two.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(M^2)</script>, the space used by <code>seen</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-dynamic-programming-accepted">Approach #3: Dynamic Programming [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Since a common subarray of <code>A</code> and <code>B</code> must start at some <code>A[i]</code> and <code>B[j]</code>, let <code>dp[i][j]</code> be the longest common prefix of <code>A[i:]</code> and <code>B[j:]</code>.  Whenever <code>A[i] == B[j]</code>, we know <code>dp[i][j] = dp[i+1][j+1] + 1</code>.  Also, the answer is <code>max(dp[i][j])</code> over all <code>i, j</code>.</p>\n<p>We can perform bottom-up dynamic programming to find the answer based on this recurrence.  Our loop invariant is that the answer is already calculated correctly and stored in <code>dp</code> for any larger <code>i, j</code>.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">findLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>\n        <span class="n">memo</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>\n        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>\n            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>\n                <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>\n                    <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>\n        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">)</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findLength</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">A</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">B</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="kt">int</span><span class="o">[][]</span> <span class="n">memo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">A</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">B</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">B</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>\n                    <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n                    <span class="k">if</span> <span class="o">(</span><span class="n">ans</span> <span class="o">&lt;</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">])</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">memo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>\n                <span class="o">}</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(M*N)</script>, where <script type="math/tex; mode=display">M, N</script> are the lengths of <code>A, B</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(M*N)</script>, the space used by <code>dp</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-4-binary-search-with-rolling-hash-accepted">Approach #4: Binary Search with Rolling Hash [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>As in <em>Approach #2</em>, we will binary search for the answer.  However, we will use a <em>rolling hash</em> (Rabin-Karp algorithm) to store hashes in our set structure.</p>\n<p><strong>Algorithm</strong></p>\n<p>For some prime <script type="math/tex; mode=display">p</script>, consider the following function modulo some prime modulus <script type="math/tex; mode=display">\\mathcal{M}</script>:</p>\n<p>\n<script type="math/tex; mode=display">\\text{hash}(S) = \\sum_{0 \\leq i < len(S)} p^i * S[i]</script>\n</p>\n<p>Notably, <script type="math/tex; mode=display">\\text{hash}(S[1:] + x) = \\frac{(\\text{hash}(S) - S[0])}{p} + p^{n-1} x</script>.  This shows we can get the hash of all <script type="math/tex; mode=display">A[i:i+\\text{guess}]</script> in linear time.  We will also use the fact that <script type="math/tex; mode=display">p^{-1} = p^{\\mathcal{M}-2} \\mod \\mathcal{M}</script>.</p>\n<p>For every <code>i &gt;= length - 1</code>, we will want to record the hash of <code>A[i-length+1], A[i-length+2], ..., A[i]</code>.  After, we will truncate the first element by <code>h = (h - A[i - (length - 1)]) * Pinv % MOD</code> to get ready to add the next element.</p>\n<p>To make our algorithm air tight, we also make a naive check when our work with rolling hashes says that we have found a match.</p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">findLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>\n        <span class="n">P</span><span class="p">,</span> <span class="n">MOD</span> <span class="o">=</span> <span class="mi">113</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span> <span class="o">+</span> <span class="mi">7</span>\n        <span class="n">Pinv</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">MOD</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">MOD</span><span class="p">)</span>\n        <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">guess</span><span class="p">):</span>\n            <span class="k">def</span> <span class="nf">rolling</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>\n                <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>\n                    <span class="k">yield</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>\n                    <span class="k">return</span>\n\n                <span class="n">h</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>\n                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>\n                    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">power</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span>\n                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>\n                        <span class="n">power</span> <span class="o">=</span> <span class="p">(</span><span class="n">power</span> <span class="o">*</span> <span class="n">P</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span>\n                    <span class="k">else</span><span class="p">:</span>\n                        <span class="k">yield</span> <span class="n">h</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>\n                        <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)])</span> <span class="o">*</span> <span class="n">Pinv</span> <span class="o">%</span> <span class="n">MOD</span>\n\n            <span class="n">hashes</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>\n            <span class="k">for</span> <span class="n">ha</span><span class="p">,</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">rolling</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">guess</span><span class="p">):</span>\n                <span class="n">hashes</span><span class="p">[</span><span class="n">ha</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>\n            <span class="k">for</span> <span class="n">ha</span><span class="p">,</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">rolling</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">guess</span><span class="p">):</span>\n                <span class="n">iarr</span> <span class="o">=</span> <span class="n">hashes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="p">[])</span>\n                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">guess</span><span class="p">]</span> <span class="o">==</span> <span class="n">B</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span><span class="o">+</span><span class="n">guess</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iarr</span><span class="p">):</span>\n                    <span class="k">return</span> <span class="bp">True</span>\n            <span class="k">return</span> <span class="bp">False</span>\n\n        <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>\n        <span class="k">while</span> <span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">:</span>\n            <span class="n">mi</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>\n            <span class="k">if</span> <span class="n">check</span><span class="p">(</span><span class="n">mi</span><span class="p">):</span>\n                <span class="n">lo</span> <span class="o">=</span> <span class="n">mi</span> <span class="o">+</span> <span class="mi">1</span>\n            <span class="k">else</span><span class="p">:</span>\n                <span class="n">hi</span> <span class="o">=</span> <span class="n">mi</span>\n        <span class="k">return</span> <span class="n">lo</span> <span class="o">-</span> <span class="mi">1</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">java.math.BigInteger</span><span class="o">;</span>\n\n<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kt">int</span> <span class="n">P</span> <span class="o">=</span> <span class="mi">113</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">MOD</span> <span class="o">=</span> <span class="mi">1_000_000_007</span><span class="o">;</span>\n    <span class="kt">int</span> <span class="n">Pinv</span> <span class="o">=</span> <span class="n">BigInteger</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">P</span><span class="o">).</span><span class="na">modInverse</span><span class="o">(</span><span class="n">BigInteger</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">MOD</span><span class="o">)).</span><span class="na">intValue</span><span class="o">();</span>\n\n    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">rolling</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">source</span><span class="o">,</span> <span class="kt">int</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span><span class="o">[]</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">source</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>\n        <span class="kt">long</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">power</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">source</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">h</span> <span class="o">=</span> <span class="o">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">source</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="n">power</span><span class="o">)</span> <span class="o">%</span> <span class="n">MOD</span><span class="o">;</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>\n                <span class="n">power</span> <span class="o">=</span> <span class="o">(</span><span class="n">power</span> <span class="o">*</span> <span class="n">P</span><span class="o">)</span> <span class="o">%</span> <span class="n">MOD</span><span class="o">;</span>\n            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>\n                <span class="n">ans</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="o">(</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">h</span><span class="o">;</span>\n                <span class="n">h</span> <span class="o">=</span> <span class="o">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">source</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="o">(</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)])</span> <span class="o">*</span> <span class="n">Pinv</span> <span class="o">%</span> <span class="n">MOD</span><span class="o">;</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">h</span> <span class="o">+=</span> <span class="n">MOD</span><span class="o">;</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n\n    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span> <span class="n">guess</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">A</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">B</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">hashes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>\n        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">:</span> <span class="n">rolling</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">guess</span><span class="o">))</span> <span class="o">{</span>\n            <span class="n">hashes</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">z</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">()).</span><span class="na">add</span><span class="o">(</span><span class="n">k</span><span class="o">++);</span>\n        <span class="o">}</span>\n        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">:</span> <span class="n">rolling</span><span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">guess</span><span class="o">))</span> <span class="o">{</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">:</span> <span class="n">hashes</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()))</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="n">guess</span><span class="o">),</span>\n                                  <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">B</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">j</span><span class="o">+</span><span class="n">guess</span><span class="o">)))</span> <span class="o">{</span>\n                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n                <span class="o">}</span>\n            <span class="n">j</span><span class="o">++;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">findLength</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">A</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">B</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">int</span> <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">B</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n        <span class="k">while</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">mi</span> <span class="o">=</span> <span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">check</span><span class="o">(</span><span class="n">mi</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">mi</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>\n            <span class="k">else</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">mi</span><span class="o">;</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">lo</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O((M+N) * \\log{(\\min(M, N))})</script>, where <script type="math/tex; mode=display">M, N</script> are the lengths of <code>A, B</code>.  The log factor is contributed by the binary search, while creating the rolling hashes is <script type="math/tex; mode=display">O(M + N)</script>.  The checks for duplicate hashes are <script type="math/tex; mode=display">O(1)</script>.  If we perform a naive check to make sure our answer is correct, it adds a factor of <script type="math/tex; mode=display">O(\\min(M, N))</script> to our cost of <code>check</code>, which keeps the complexity the same.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(M)</script>, the space used to store <code>hashes</code> and the subarrays in our final naive check.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.  Idea for Solution #2 by <a href="http://leetcode.com/stefanpochmann">@StefanPochmann</a>.</p>\n</div>\n          ',
    tags: ['Citadel'],
  },
  {
    id: '719',
    name: 'Find K-th Smallest Pair Distance',
    acceptance: '26.3%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given an integer array, return the k-th smallest <b>distance</b> among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. </p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b>\nnums = [1,3,1]\nk = 1\n<b>Output: 0</b> \n<b>Explanation:</b>\nHere are all the pairs:\n(1,3) -&gt; 2\n(1,1) -&gt; 0\n(3,1) -&gt; 2\nThen the 1st smallest distance pair is (1,1), and its distance is 0.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li><code>2 &lt;= len(nums) &lt;= 10000</code>.</li>\n<li><code>0 &lt;= nums[i] &lt; 1000000</code>.</li>\n<li><code>1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2</code>.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-heap-time-limit-exceeded">Approach #1: Heap [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-binary-search-prefix-sum-accepted">Approach #2: Binary Search + Prefix Sum [Accepted]</a></li>\n<li><a href="#approach-3-binary-search-sliding-window-accepted">Approach #3: Binary Search + Sliding Window [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-heap-time-limit-exceeded">Approach #1: Heap [Time Limit Exceeded]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Sort the points.  For every point with index <code>i</code>, the pairs with indexes <code>(i, j)</code> [by order of distance] are <code>(i, i+1), (i, i+2), ..., (i, N-1)</code>.</p>\n<p>Let\'s keep a heap of pairs, initially <code>heap = [(i, i+1) for all i]</code>, and ordered by distance (the distance of <code>(i, j)</code> is <code>nums[j] - nums[i]</code>.)  Whenever we use a pair <code>(i, x)</code> from our heap, we will add <code>(i, x+1)</code> to our heap when appropriate.</p>\n<iframe frameborder="0" height="500" name="haWM6KvQ" src="https://leetcode.com/playground/haWM6KvQ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O((k+N) \\log{N})</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>.  As <script type="math/tex; mode=display">k = O(N^2)</script>, this is <script type="math/tex; mode=display">O(N^2 \\log {N})</script> in the worst case.  The complexity added by our heap operations is either <script type="math/tex; mode=display">O((k+N) \\log N)</script> in the Java solution, or <script type="math/tex; mode=display">O(k \\log{N} + N)</script> in the Python solution because the <code>heapq.heapify</code> operation is linear time.  Additionally, we add <script type="math/tex; mode=display">O(N \\log N)</script> complexity due to sorting.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the space used to store our <code>heap</code> of at most <code>N-1</code> elements.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-binary-search-prefix-sum-accepted">Approach #2: Binary Search + Prefix Sum [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Let\'s binary search for the answer.  It\'s definitely in the range <code>[0, W]</code>, where <code>W = max(nums) - min(nums)]</code>.  </p>\n<p>Let <code>possible(guess)</code> be true if and only if there are <code>k</code> or more pairs with distance less than or equal to <code>guess</code>.  We will focus on evaluating our <code>possible</code> function quickly.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let <code>prefix[v]</code> be the number of points in <code>nums</code> less than or equal to <code>v</code>.  Also, let <code>multiplicity[j]</code> be the number of points <code>i</code> with <code>i &lt; j and nums[i] == nums[j]</code>.  We can record both of these with a simple linear scan.</p>\n<p>Now, for every point <code>i</code>, the number of points <code>j</code> with <code>i &lt; j</code> and <code>nums[j] - nums[i] &lt;= guess</code> is <code>prefix[x+guess] - prefix[x] + (count[i] - multiplicity[i])</code>, where <code>count[i]</code> is the number of ocurrences of <code>nums[i]</code> in <code>nums</code>.  The sum of this over all <code>i</code> is the number of pairs with distance <code>&lt;= guess</code>.  </p>\n<p>Finally, because the sum of <code>count[i] - multiplicity[i]</code> is the same as the sum of <code>multiplicity[i]</code>, we could just replace that term with <code>multiplicity[i]</code> without affecting the answer.  (Actually, the sum of multiplicities in total will be a constant used in the answer, so we could precalculate it if we wanted.)</p>\n<p>In our Java solution, we computed <code>possible = count &gt;= k</code> directly in the binary search instead of using a helper function.</p>\n<iframe frameborder="0" height="500" name="upbfbVHa" src="https://leetcode.com/playground/upbfbVHa/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(W + N \\log{W} + N \\log{N})</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>, and <script type="math/tex; mode=display">W</script> is equal to <code>nums[nums.length - 1] - nums[0]</code>.  We do <script type="math/tex; mode=display">O(W)</script> work to calculate <code>prefix</code> initially.  The <script type="math/tex; mode=display">\\log W</script> factor comes from our binary search, and we do <script type="math/tex; mode=display">O(N)</script> work inside our call to <code>possible</code> (or to calculate <code>count</code> in Java).  The final <script type="math/tex; mode=display">O(N\\log N)</script> factor comes from sorting.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N+W)</script>, the space used to store <code>multiplicity</code> and <code>prefix</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-binary-search-sliding-window-accepted">Approach #3: Binary Search + Sliding Window [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>As in <em>Approach #2</em>, let\'s binary search for the answer, and we will focus on evaluating our <code>possible</code> function quickly.</p>\n<p><strong>Algorithm</strong></p>\n<p>We will use a sliding window approach to count the number of pairs with distance <code>&lt;=</code> guess.  </p>\n<p>For every possible <code>right</code>, we maintain the loop invariant: <code>left</code> is the smallest value such that <code>nums[right] - nums[left] &lt;= guess</code>.  Then, the number of pairs with <code>right</code> as it\'s right-most endpoint is <code>right - left</code>, and we add all of these up.</p>\n<iframe frameborder="0" height="429" name="UD6QK4gU" src="https://leetcode.com/playground/UD6QK4gU/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N \\log{W} + N \\log{N})</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>, and <script type="math/tex; mode=display">W</script> is equal to <code>nums[nums.length - 1] - nums[0]</code>.  The <script type="math/tex; mode=display">\\log W</script> factor comes from our binary search, and we do <script type="math/tex; mode=display">O(N)</script> work inside our call to <code>possible</code> (or to calculate <code>count</code> in Java).  The final <script type="math/tex; mode=display">O(N\\log N)</script> factor comes from sorting.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>.  No additional space is used except for integer variables.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '720',
    name: 'Longest Word in Dictionary',
    acceptance: '40.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given a list of strings <code>words</code> representing an English Dictionary, find the longest word in <code>words</code> that can be built one character at a time by other words in <code>words</code>.  If there is more than one possible answer, return the longest word with the smallest lexicographical order.</p>  If there is no answer, return the empty string.\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \nwords = ["w","wo","wor","worl", "world"]\n<b>Output:</b> "world"\n<b>Explanation:</b> \nThe word "world" can be built one character at a time by "w", "wo", "wor", and "worl".\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \nwords = ["a", "banana", "app", "appl", "ap", "apply", "apple"]\n<b>Output:</b> "apple"\n<b>Explanation:</b> \nBoth "apply" and "apple" can be built from other words in the dictionary. However, "apple" is lexicographically smaller than "apply".\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>All the strings in the input will only contain lowercase letters.</li>\n<li>The length of <code>words</code> will be in the range <code>[1, 1000]</code>.</li>\n<li>The length of <code>words[i]</code> will be in the range <code>[1, 30]</code>.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-trie-depth-first-search-accepted">Approach #2: Trie + Depth-First Search [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>For each word, check if all prefixes word[:k] are present.  We can use a <code>Set</code> structure to check this quickly.</p>\n<p><strong>Algorithm</strong></p>\n<p>Whenever our found word would be superior, we check if all it\'s prefixes are present, then replace our answer.</p>\n<p>Alternatively, we could have sorted the words beforehand, so that we know the word we are considering would be the answer if all it\'s prefixes are present.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">longestWord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>\n    <span class="n">ans</span> <span class="o">=</span> <span class="s2">""</span>\n    <span class="n">wordset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>\n    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>\n        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span> <span class="ow">and</span> <span class="n">word</span> <span class="o">&lt;</span> <span class="n">ans</span><span class="p">:</span>\n            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">word</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span> <span class="ow">in</span> <span class="n">wordset</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">))):</span>\n                <span class="n">ans</span> <span class="o">=</span> <span class="n">word</span>\n\n    <span class="k">return</span> <span class="n">ans</span>\n</pre></div>\n<p><em>Alternate Implementation</em></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">longestWord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>\n        <span class="n">wordset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>\n        <span class="n">words</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">c</span><span class="p">))</span>\n        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>\n            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">word</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span> <span class="ow">in</span> <span class="n">wordset</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">))):</span>\n                <span class="k">return</span> <span class="n">word</span>\n\n        <span class="k">return</span> <span class="s2">""</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="n">String</span> <span class="nf">longestWord</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">String</span> <span class="n">ans</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>\n        <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">wordset</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">();</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">:</span> <span class="n">words</span><span class="o">)</span> <span class="n">wordset</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">:</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">ans</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">||</span>\n                    <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="n">ans</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">ans</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n                <span class="kt">boolean</span> <span class="n">good</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>\n                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n                    <span class="k">if</span> <span class="o">(!</span><span class="n">wordset</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">k</span><span class="o">)))</span> <span class="o">{</span>\n                        <span class="n">good</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>\n                        <span class="k">break</span><span class="o">;</span>\n                    <span class="o">}</span>\n                <span class="o">}</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">good</span><span class="o">)</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">word</span><span class="o">;</span>\n            <span class="o">}</span>    \n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><em>Alternate Implementation</em></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="n">String</span> <span class="nf">longestWord</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">wordset</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">();</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">:</span> <span class="n">words</span><span class="o">)</span> <span class="n">wordset</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>\n        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">words</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">()</span>\n                    <span class="o">?</span> <span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">:</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">boolean</span> <span class="n">good</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>\n            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">k</span><span class="o">)</span> <span class="o">{</span>\n                <span class="k">if</span> <span class="o">(!</span><span class="n">wordset</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">k</span><span class="o">)))</span> <span class="o">{</span>\n                    <span class="n">good</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>\n                    <span class="k">break</span><span class="o">;</span>\n                <span class="o">}</span>\n            <span class="o">}</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">good</span><span class="o">)</span> <span class="k">return</span> <span class="n">word</span><span class="o">;</span>\n        <span class="o">}</span>\n\n        <span class="k">return</span> <span class="s">""</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(\\sum w_i^2)</script>, where <script type="math/tex; mode=display">w_i</script> is the length of <code>words[i]</code>.  Checking whether all prefixes of <code>words[i]</code> are in the set is <script type="math/tex; mode=display">O(\\sum w_i^2)</script>.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(\\sum w_i^2)</script> to create the substrings.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-trie-depth-first-search-accepted">Approach #2: Trie + Depth-First Search [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>As prefixes of strings are involved, this is usually a natural fit for a <em>trie</em> (a prefix tree.)</p>\n<p><strong>Algorithm</strong></p>\n<p>Put every word in a trie, then depth-first-search from the start of the trie, only searching nodes that ended a word.  Every node found (except the root, which is a special case) then represents a word with all it\'s prefixes present.  We take the best such word.</p>\n<p>In Python, we showcase a method using defaultdict, while in Java, we stick to a more general object-oriented approach.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">longestWord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>\n        <span class="n">Trie</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="n">Trie</span><span class="p">)</span>\n        <span class="n">trie</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>\n        <span class="n">END</span> <span class="o">=</span> <span class="bp">True</span>\n\n        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">words</span><span class="p">):</span>\n            <span class="nb">reduce</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">trie</span><span class="p">)[</span><span class="n">END</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>\n\n        <span class="n">stack</span> <span class="o">=</span> <span class="n">trie</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>\n        <span class="n">ans</span> <span class="o">=</span> <span class="s2">""</span>\n        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>\n            <span class="n">cur</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>\n            <span class="k">if</span> <span class="n">END</span> <span class="ow">in</span> <span class="n">cur</span><span class="p">:</span>\n                <span class="n">word</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">cur</span><span class="p">[</span><span class="n">END</span><span class="p">]]</span>\n                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span> <span class="ow">and</span> <span class="n">word</span> <span class="o">&lt;</span> <span class="n">ans</span><span class="p">:</span>\n                    <span class="n">ans</span> <span class="o">=</span> <span class="n">word</span>\n                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">cur</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">cur</span> <span class="k">if</span> <span class="n">letter</span> <span class="o">!=</span> <span class="n">END</span><span class="p">])</span>\n\n        <span class="k">return</span> <span class="n">ans</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="n">String</span> <span class="nf">longestWord</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">Trie</span> <span class="n">trie</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Trie</span><span class="o">();</span>\n        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">:</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">trie</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="o">++</span><span class="n">index</span><span class="o">);</span> <span class="c1">//indexed by 1</span>\n        <span class="o">}</span>\n        <span class="n">trie</span><span class="o">.</span><span class="na">words</span> <span class="o">=</span> <span class="n">words</span><span class="o">;</span>\n        <span class="k">return</span> <span class="n">trie</span><span class="o">.</span><span class="na">dfs</span><span class="o">();</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>\n    <span class="kt">char</span> <span class="n">c</span><span class="o">;</span>\n    <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>\n    <span class="kt">int</span> <span class="n">end</span><span class="o">;</span>\n    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">){</span>\n        <span class="k">this</span><span class="o">.</span><span class="na">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n\n<span class="kd">class</span> <span class="nc">Trie</span> <span class="o">{</span>\n    <span class="n">Node</span> <span class="n">root</span><span class="o">;</span>\n    <span class="n">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">;</span>\n    <span class="kd">public</span> <span class="nf">Trie</span><span class="o">()</span> <span class="o">{</span>\n        <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="sc">\'0\'</span><span class="o">);</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">Node</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>\n            <span class="n">cur</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">c</span><span class="o">));</span>\n            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="n">cur</span><span class="o">.</span><span class="na">end</span> <span class="o">=</span> <span class="n">index</span><span class="o">;</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="n">String</span> <span class="nf">dfs</span><span class="o">()</span> <span class="o">{</span>\n        <span class="n">String</span> <span class="n">ans</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>\n        <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">();</span>\n        <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>\n        <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">empty</span><span class="o">())</span> <span class="o">{</span>\n            <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">end</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">node</span> <span class="o">==</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>\n                    <span class="n">String</span> <span class="n">word</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">node</span><span class="o">.</span><span class="na">end</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>\n                    <span class="k">if</span> <span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">ans</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">||</span>\n                            <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="n">ans</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">word</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">ans</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n                        <span class="n">ans</span> <span class="o">=</span> <span class="n">word</span><span class="o">;</span>\n                    <span class="o">}</span>\n                <span class="o">}</span>\n                <span class="k">for</span> <span class="o">(</span><span class="n">Node</span> <span class="n">nei</span><span class="o">:</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>\n                    <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">nei</span><span class="o">);</span>\n                <span class="o">}</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time Complexity: <script type="math/tex; mode=display">O(\\sum w_i)</script>, where <script type="math/tex; mode=display">w_i</script> is the length of <code>words[i]</code>.  This is the complexity to build the trie and to search it.</li>\n</ul>\n<p>If we used a BFS instead of a DFS, and ordered the children in an array, we could drop the need to check whether the candidate word at each node is better than the answer, by forcing that the last node visited will be the best answer.</p>\n<ul>\n<li>Space Complexity: <script type="math/tex; mode=display">O(\\sum w_i)</script>, the space used by our trie.</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Pinterest'],
  },
  {
    id: '721',
    name: 'Accounts Merge',
    acceptance: '30.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a list <code>accounts</code>, each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code> is a <i>name</i>, and the rest of the elements are <i>emails</i> representing emails of the account.</p>\n\n<p>Now, we would like to merge these accounts.  Two accounts definitely belong to the same person if there is some email that is common to both accounts.  Note that even if two accounts have the same name, they may belong to different people as people could have the same name.  A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>\n\n<p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails <b>in sorted order</b>.  The accounts themselves can be returned in any order.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre style="white-space: pre-wrap"><b>Input:</b> \naccounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]\n<b>Output:</b> [["John", \'john00@mail.com\', \'john_newyork@mail.com\', \'johnsmith@mail.com\'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]\n<b>Explanation:</b> \nThe first and third John\'s are the same person as they have the common email "johnsmith@mail.com".\nThe second John and Mary are different people as none of their email addresses are used by other accounts.\nWe could return these lists in any order, for example the answer [[\'Mary\', \'mary@mail.com\'], [\'John\', \'johnnybravo@mail.com\'], \n[\'John\', \'john00@mail.com\', \'john_newyork@mail.com\', \'johnsmith@mail.com\']] would still be accepted.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>The length of <code>accounts</code> will be in the range <code>[1, 1000]</code>.</li>\n<li>The length of <code>accounts[i]</code> will be in the range <code>[1, 10]</code>.</li>\n<li>The length of <code>accounts[i][j]</code> will be in the range <code>[1, 30]</code>.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</a></li>\n<li><a href="#approach-2-union-find-accepted">Approach #2: Union-Find [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Draw an edge between two emails if they occur in the same account.  The problem comes down to finding connected components of this graph.</p>\n<p><strong>Algorithm</strong></p>\n<p>For each account, draw the edge from the first email to all other emails.  Additionally, we\'ll remember a map from emails to names on the side.  After finding each connected component using a depth-first search, we\'ll add that to our answer.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">accountsMerge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">accounts</span><span class="p">):</span>\n        <span class="n">em_to_name</span> <span class="o">=</span> <span class="p">{}</span>\n        <span class="n">graph</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>\n        <span class="k">for</span> <span class="n">acc</span> <span class="ow">in</span> <span class="n">accounts</span><span class="p">:</span>\n            <span class="n">name</span> <span class="o">=</span> <span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>\n            <span class="k">for</span> <span class="n">email</span> <span class="ow">in</span> <span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>\n                <span class="n">graph</span><span class="p">[</span><span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>\n                <span class="n">graph</span><span class="p">[</span><span class="n">email</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>\n                <span class="n">em_to_name</span><span class="p">[</span><span class="n">email</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>\n\n        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>\n        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>\n        <span class="k">for</span> <span class="n">email</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>\n            <span class="k">if</span> <span class="n">email</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>\n                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>\n                <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">email</span><span class="p">]</span>\n                <span class="n">component</span> <span class="o">=</span> <span class="p">[]</span>\n                <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>\n                    <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>\n                    <span class="n">component</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>\n                    <span class="k">for</span> <span class="n">nei</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>\n                        <span class="k">if</span> <span class="n">nei</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>\n                            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nei</span><span class="p">)</span>\n                            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nei</span><span class="p">)</span>\n                <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">em_to_name</span><span class="p">[</span><span class="n">email</span><span class="p">]]</span> <span class="o">+</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">component</span><span class="p">))</span>\n        <span class="k">return</span> <span class="n">ans</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="nf">accountsMerge</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">accounts</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">emailToName</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>\n        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">account</span><span class="o">:</span> <span class="n">accounts</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>\n            <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">email</span><span class="o">:</span> <span class="n">account</span><span class="o">)</span> <span class="o">{</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">""</span><span class="o">)</span> <span class="o">{</span>\n                    <span class="n">name</span> <span class="o">=</span> <span class="n">email</span><span class="o">;</span>\n                    <span class="k">continue</span><span class="o">;</span>\n                <span class="o">}</span>\n                <span class="n">graph</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">email</span><span class="o">,</span> <span class="n">x</span><span class="o">-&gt;</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()).</span><span class="na">add</span><span class="o">(</span><span class="n">account</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>\n                <span class="n">graph</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">account</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="n">x</span><span class="o">-&gt;</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()).</span><span class="na">add</span><span class="o">(</span><span class="n">email</span><span class="o">);</span>\n                <span class="n">emailToName</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">email</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n\n        <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">seen</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">();</span>\n        <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">email</span><span class="o">:</span> <span class="n">graph</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>\n            <span class="k">if</span> <span class="o">(!</span><span class="n">seen</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">email</span><span class="o">))</span> <span class="o">{</span>\n                <span class="n">seen</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">email</span><span class="o">);</span>\n                <span class="n">Stack</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">();</span>\n                <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">email</span><span class="o">);</span>\n                <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">component</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>\n                <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">empty</span><span class="o">())</span> <span class="o">{</span>\n                    <span class="n">String</span> <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>\n                    <span class="n">component</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>\n                    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">nei</span><span class="o">:</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span>\n                        <span class="k">if</span> <span class="o">(!</span><span class="n">seen</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">nei</span><span class="o">))</span> <span class="o">{</span>\n                            <span class="n">seen</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nei</span><span class="o">);</span>\n                            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">nei</span><span class="o">);</span>\n                        <span class="o">}</span>\n                    <span class="o">}</span>\n                <span class="o">}</span>\n                <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">component</span><span class="o">);</span>\n                <span class="n">component</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">emailToName</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">email</span><span class="o">));</span>\n                <span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">component</span><span class="o">);</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(\\sum a_i \\log a_i)</script>, where <script type="math/tex; mode=display">a_i</script> is the length of <code>accounts[i]</code>.  Without the log factor, this is the complexity to build the graph and search for each component.  The log factor is for sorting each component at the end.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(\\sum a_i)</script>, the space used by our graph and our search.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-union-find-accepted">Approach #2: Union-Find [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>As in <em>Approach #1</em>, our problem comes down to finding the connected components of a graph.  This is a natural fit for a <em>Disjoint Set Union</em> (DSU) structure.</p>\n<p><strong>Algorithm</strong></p>\n<p>As in <em>Approach #1</em>, draw edges between emails if they occur in the same account.  For easier interoperability between our DSU template, we will map each email to some integer index by using <code>emailToID</code>.  Then, <code>dsu.find(email)</code> will tell us a unique id representing what component that email is in.</p>\n<p>For more information on DSU, please look at <em>Approach #2</em> in the <a href="https://leetcode.com/articles/redundant-connection/">article here</a>.  For brevity, the solutions showcased below do not use <em>union-by-rank</em>.</p>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">DSU</span><span class="p">:</span>\n    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10001</span><span class="p">)</span>\n    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>\n        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>\n            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>\n        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>\n    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>\n        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>\n\n<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">accountsMerge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">accounts</span><span class="p">):</span>\n        <span class="n">dsu</span> <span class="o">=</span> <span class="n">DSU</span><span class="p">()</span>\n        <span class="n">em_to_name</span> <span class="o">=</span> <span class="p">{}</span>\n        <span class="n">em_to_id</span> <span class="o">=</span> <span class="p">{}</span>\n        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>\n        <span class="k">for</span> <span class="n">acc</span> <span class="ow">in</span> <span class="n">accounts</span><span class="p">:</span>\n            <span class="n">name</span> <span class="o">=</span> <span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>\n            <span class="k">for</span> <span class="n">email</span> <span class="ow">in</span> <span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>\n                <span class="n">em_to_name</span><span class="p">[</span><span class="n">email</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>\n                <span class="k">if</span> <span class="n">email</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">em_to_id</span><span class="p">:</span>\n                    <span class="n">em_to_id</span><span class="p">[</span><span class="n">email</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>\n                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>\n                <span class="n">dsu</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">em_to_id</span><span class="p">[</span><span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">em_to_id</span><span class="p">[</span><span class="n">email</span><span class="p">])</span>\n\n        <span class="n">ans</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>\n        <span class="k">for</span> <span class="n">email</span> <span class="ow">in</span> <span class="n">em_to_name</span><span class="p">:</span>\n            <span class="n">ans</span><span class="p">[</span><span class="n">dsu</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">em_to_id</span><span class="p">[</span><span class="n">email</span><span class="p">])]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>\n\n        <span class="k">return</span> <span class="p">[[</span><span class="n">em_to_name</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span> <span class="o">+</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ans</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="nf">accountsMerge</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">accounts</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">DSU</span> <span class="n">dsu</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DSU</span><span class="o">();</span>\n        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">emailToName</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>\n        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">emailToID</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>\n        <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">account</span><span class="o">:</span> <span class="n">accounts</span><span class="o">)</span> <span class="o">{</span>\n            <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>\n            <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">email</span><span class="o">:</span> <span class="n">account</span><span class="o">)</span> <span class="o">{</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">""</span><span class="o">)</span> <span class="o">{</span>\n                    <span class="n">name</span> <span class="o">=</span> <span class="n">email</span><span class="o">;</span>\n                    <span class="k">continue</span><span class="o">;</span>\n                <span class="o">}</span>\n                <span class="n">emailToName</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">email</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>\n                <span class="k">if</span> <span class="o">(!</span><span class="n">emailToID</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">email</span><span class="o">))</span> <span class="o">{</span>\n                    <span class="n">emailToID</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">email</span><span class="o">,</span> <span class="n">id</span><span class="o">++);</span>\n                <span class="o">}</span>\n                <span class="n">dsu</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">emailToID</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">account</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">)),</span> <span class="n">emailToID</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">email</span><span class="o">));</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n\n        <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">email</span><span class="o">:</span> <span class="n">emailToName</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">dsu</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">emailToID</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">email</span><span class="o">));</span>\n            <span class="n">ans</span><span class="o">.</span><span class="na">computeIfAbsent</span><span class="o">(</span><span class="n">index</span><span class="o">,</span> <span class="n">x</span><span class="o">-&gt;</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">()).</span><span class="na">add</span><span class="o">(</span><span class="n">email</span><span class="o">);</span>\n        <span class="o">}</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">component</span><span class="o">:</span> <span class="n">ans</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>\n            <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">component</span><span class="o">);</span>\n            <span class="n">component</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">emailToName</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">component</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">)));</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">(</span><span class="n">ans</span><span class="o">.</span><span class="na">values</span><span class="o">());</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n<span class="kd">class</span> <span class="nc">DSU</span> <span class="o">{</span>\n    <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>\n    <span class="kd">public</span> <span class="nf">DSU</span><span class="o">()</span> <span class="o">{</span>\n        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10001</span><span class="o">];</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10000</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>\n            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>\n    <span class="o">}</span>\n    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>\n        <span class="k">if</span> <span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">!=</span> <span class="n">x</span><span class="o">)</span> <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]);</span>\n        <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>\n    <span class="o">}</span>\n    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">parent</span><span class="o">[</span><span class="n">find</span><span class="o">(</span><span class="n">x</span><span class="o">)]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(A \\log A)</script>, where <script type="math/tex; mode=display">A = \\sum a_i</script>, and <script type="math/tex; mode=display">a_i</script> is the length of <code>accounts[i]</code>.  If we used union-by-rank, this complexity improves to <script type="math/tex; mode=display">O(A \\alpha(A)) \\approx O(A)</script>, where <script type="math/tex; mode=display">\\alpha</script> is the <em>Inverse-Ackermann</em> function.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(A)</script>, the space used by our DSU structure.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '722',
    name: 'Remove Comments',
    acceptance: '26.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a C++ program, remove comments from it. The program <code>source</code> is an array where <code>source[i]</code> is the <code>i</code>-th line of the source code.  This represents the result of splitting the original source code string by the newline character <code>\\n</code>.</p>\n\n<p>In C++, there are two types of comments, line comments, and block comments.</p>\n<p>\nThe string <code>//</code> denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored.\n</p><p>\nThe string <code>/*</code> denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of <code>*/</code> should be ignored.  (Here, occurrences happen in reading order: line by line from left to right.)  To be clear, the string <code>/*/</code> does not yet end the block comment, as the ending would be overlapping the beginning.\n</p><p>\nThe first effective comment takes precedence over others: if the string <code>//</code> occurs in a block comment, it is ignored. Similarly, if the string <code>/*</code> occurs in a line or block comment, it is also ignored.\n</p><p>\nIf a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.\n</p><p>\nThere will be no control characters, single quote, or double quote characters.  For example, <code>source = "string s = "/* Not a comment. */";"</code> will not be a test case.  (Also, nothing else such as defines or macros will interfere with the comments.)\n</p><p>\nIt is guaranteed that every open block comment will eventually be closed, so <code>/*</code> outside of a line or block comment always starts a new comment.\n</p><p>\nFinally, implicit newline characters can be deleted by block comments.  Please see the examples below for details.\n</p>\n\n<p>After removing the comments from the source code, return the source code in the same format.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre style="white-space: pre-wrap"><b>Input:</b> \nsource = ["/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"]\n\nThe line by line code is visualized as below:\n/*Test program */\nint main()\n{ \n  // variable declaration \nint a, b, c;\n/* This is a test\n   multiline  \n   comment for \n   testing */\na = b + c;\n}\n\n<b>Output:</b> ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]\n\nThe line by line code is visualized as below:\nint main()\n{ \n  \nint a, b, c;\na = b + c;\n}\n\n<b>Explanation:</b> \nThe string <code>/*</code> denotes a block comment, including line 1 and lines 6-9. The string <code>//</code> denotes line 4 as comments.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre style="white-space: pre-wrap"><b>Input:</b> \nsource = ["a/*comment", "line", "more_comment*/b"]\n<b>Output:</b> ["ab"]\n<b>Explanation:</b> The original source string is "a/*comment<b>\\n</b>line<b>\\n</b>more_comment*/b", where we have bolded the newline characters.  After deletion, the <i>implicit</i> newline characters are deleted, leaving the string "ab", which when delimited by newline characters becomes ["ab"].\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>The length of <code>source</code> is in the range <code>[1, 100]</code>.</li>\n<li>The length of <code>source[i]</code> is in the range <code>[0, 80]</code>.</li>\n<li>Every open block comment is eventually closed.</li>\n<li>There are no single-quote, double-quote, or control characters in the source code.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-parsing-accepted">Approach #1: Parsing [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-parsing-accepted">Approach #1: Parsing [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>We need to parse the <code>source</code> line by line.  Our state is that we either are in a block comment or not.</p>\n<ul>\n<li>\n<p>If we start a block comment and we aren\'t in a block, then we will skip over the next two characters and change our state to be in a block.</p>\n</li>\n<li>\n<p>If we end a block comment and we are in a block, then we will skip over the next two characters and change our state to be <em>not</em> in a block.</p>\n</li>\n<li>\n<p>If we start a line comment and we aren\'t in a block, then we will ignore the rest of the line.</p>\n</li>\n<li>\n<p>If we aren\'t in a block comment (and it wasn\'t the start of a comment), we will record the character we are at.</p>\n</li>\n<li>\n<p>At the end of each line, if we aren\'t in a block, we will record the line.</p>\n</li>\n</ul>\n<p><strong>Python</strong></p>\n<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>\n    <span class="k">def</span> <span class="nf">removeComments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>\n        <span class="n">in_block</span> <span class="o">=</span> <span class="bp">False</span>\n        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>\n        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>\n            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>\n            <span class="k">if</span> <span class="ow">not</span> <span class="n">in_block</span><span class="p">:</span>\n                <span class="n">newline</span> <span class="o">=</span> <span class="p">[]</span>\n            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>\n                <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">\'/*\'</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">in_block</span><span class="p">:</span>\n                    <span class="n">in_block</span> <span class="o">=</span> <span class="bp">True</span>\n                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>\n                <span class="k">elif</span> <span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">\'*/\'</span> <span class="ow">and</span> <span class="n">in_block</span><span class="p">:</span>\n                    <span class="n">in_block</span> <span class="o">=</span> <span class="bp">False</span>\n                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>\n                <span class="k">elif</span> <span class="ow">not</span> <span class="n">in_block</span> <span class="ow">and</span> <span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">\'//\'</span><span class="p">:</span>\n                    <span class="k">break</span>\n                <span class="k">elif</span> <span class="ow">not</span> <span class="n">in_block</span><span class="p">:</span>\n                    <span class="n">newline</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>\n                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>\n            <span class="k">if</span> <span class="n">newline</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">in_block</span><span class="p">:</span>\n                <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">newline</span><span class="p">))</span>\n\n        <span class="k">return</span> <span class="n">ans</span>\n</pre></div>\n<p><strong>Java</strong></p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>\n    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">removeComments</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">source</span><span class="o">)</span> <span class="o">{</span>\n        <span class="kt">boolean</span> <span class="n">inBlock</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>\n        <span class="n">StringBuilder</span> <span class="n">newline</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>\n        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>\n        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">line</span><span class="o">:</span> <span class="n">source</span><span class="o">)</span> <span class="o">{</span>\n            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n            <span class="kt">char</span><span class="o">[]</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>\n            <span class="k">if</span> <span class="o">(!</span><span class="n">inBlock</span><span class="o">)</span> <span class="n">newline</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>\n            <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">line</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>\n                <span class="k">if</span> <span class="o">(!</span><span class="n">inBlock</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">line</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">chars</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">\'/\'</span> <span class="o">&amp;&amp;</span> <span class="n">chars</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="sc">\'*\'</span><span class="o">)</span> <span class="o">{</span>\n                    <span class="n">inBlock</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>\n                    <span class="n">i</span><span class="o">++;</span>\n                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">inBlock</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">line</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">chars</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">\'*\'</span> <span class="o">&amp;&amp;</span> <span class="n">chars</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="sc">\'/\'</span><span class="o">)</span> <span class="o">{</span>\n                    <span class="n">inBlock</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>\n                    <span class="n">i</span><span class="o">++;</span>\n                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(!</span><span class="n">inBlock</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">line</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">chars</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">\'/\'</span> <span class="o">&amp;&amp;</span> <span class="n">chars</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="sc">\'/\'</span><span class="o">)</span> <span class="o">{</span>\n                    <span class="k">break</span><span class="o">;</span>\n                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(!</span><span class="n">inBlock</span><span class="o">)</span> <span class="o">{</span>\n                    <span class="n">newline</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">chars</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>\n                <span class="o">}</span>\n                <span class="n">i</span><span class="o">++;</span>\n            <span class="o">}</span>\n            <span class="k">if</span> <span class="o">(!</span><span class="n">inBlock</span> <span class="o">&amp;&amp;</span> <span class="n">newline</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>\n                <span class="n">ans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">newline</span><span class="o">));</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(S)</script>, where <script type="math/tex; mode=display">S</script> is the total length of the source code.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(S)</script>, the space used by recording the source code into <code>ans</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Microsoft'],
  },
  {
    id: '723',
    name: 'Candy Crush ',
    acceptance: '55.8%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>This question is about implementing a basic elimination algorithm for Candy Crush.</p>\n\n<p>Given a 2D integer array <code>board</code> representing the grid of candy, different positive integers <code>board[i][j]</code> represent different types of candies.  A value of <code>board[i][j] = 0</code> represents that the cell at position <code>(i, j)</code> is empty.  The given board represents the state of the game following the player\'s move.  Now, you need to restore the board to a <i>stable state</i> by crushing candies according to the following rules:</p>\n\n<ol>\n<li>If three or more candies of the same type are adjacent vertically or horizontally, "crush" them all at the same time - these positions become empty.</li>\n<li>After crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. (No new candies will drop outside the top boundary.)</li>\n<li>After the above steps, there may exist more candies that can be crushed.  If so, you need to repeat the above steps.</li>\n<li>If there does not exist more candies that can be crushed (ie. the board is <i>stable</i>), then return the current board.</li>\n</ol>\n\n<p>You need to perform the above rules until the board becomes stable, then return the current board.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre style="white-space: pre-line"><b>Input:</b>\nboard = \n[[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]]\n<b>Output:</b>\n[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],[310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],[710,311,412,613,714],[810,411,512,713,1014]]\n<b>Explanation:</b> \n<img src="https://leetcode.com/static/images/problemset/candy_crush_example_2.png">\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The length of <code>board</code> will be in the range [3, 50].</li>\n<li>The length of <code>board[i]</code> will be in the range [3, 50].</li>\n<li>Each <code>board[i][j]</code> will initially start as an integer in the range [1, 2000].</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-ad-hoc-accepted">Approach #1: Ad-Hoc [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-ad-hoc-accepted">Approach #1: Ad-Hoc [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We need to simply perform the algorithm as described.  It consists of two major steps: a crush step, and a gravity step.  We work through each step individually.</p>\n<p><strong>Algorithm</strong></p>\n<p><em>Crushing Step</em></p>\n<p>When crushing, one difficulty is that we might accidentally crush candy that is part of another row.  For example, if the board is:</p>\n<div class="codehilite"><pre><span></span><span class="mi">123</span>\n<span class="mi">145</span>\n<span class="mi">111</span>\n</pre></div>\n<p>and we crush the vertical row of <code>1</code>s early, we may not see there was also a horizontal row.</p>\n<p>To remedy this, we should flag candy that should be crushed first.  We could use an auxillary <code>toCrush</code> boolean array, or we could mark it directly on the board by making the entry negative (ie. <code>board[i][j] = -Math.abs(board[i][j])</code>)</p>\n<p>As for how to scan the board, we have two approaches.  Let\'s call a <em>line</em> any row or column of the board.  </p>\n<p>For each line, we could use a sliding window (or <code>itertools.groupby</code> in Python) to find contiguous segments of the same character.  If any of these segments have length 3 or more, we should flag them.</p>\n<p>Alternatively, for each line, we could look at each width-3 slice of the line: if they are all the same, then we should flag those 3.</p>\n<p>After, we can crush the candy by setting all flagged <code>board</code> cells to zero.</p>\n<p><em>Gravity Step</em></p>\n<p>For each column, we want all the candy to go to the bottom.  One way is to iterate through and keep a stack of the (uncrushed) candy, popping and setting as we iterate through the column in reverse order.</p>\n<p>Alternatively, we could use a sliding window approach, maintaining a read and write head.  As the read head iterates through the column in reverse order, when the read head sees candy, the write head will write it down and move one place.  Then, the write head will write zeroes to the remainder of the column.</p>\n<p>We showcase the simplest approaches to these steps in the solutions below.</p>\n<iframe frameborder="0" height="500" name="NMCdS4xd" src="https://leetcode.com/playground/NMCdS4xd/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O((R*C)^2)</script>, where <script type="math/tex; mode=display">R, C</script> is the number of rows and columns in <code>board</code>.  We need <script type="math/tex; mode=display">O(R*C)</script> to scan the board, and we might crush only 3 candies repeatedly.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script> additional complexity, as we edit the board in place.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Rubrik'],
  },
  {
    id: '724',
    name: 'Find Pivot Index',
    acceptance: '40.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given an array of integers <code>nums</code>, write a method that returns the "pivot" index of this array.\n</p><p>\nWe define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.\n</p><p>\nIf no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \nnums = [1, 7, 3, 6, 5, 6]\n<b>Output:</b> 3\n<b>Explanation:</b> \nThe sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.\nAlso, 3 is the first index where this occurs.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \nnums = [1, 2, 3]\n<b>Output:</b> -1\n<b>Explanation:</b> \nThere is no index that satisfies the conditions in the problem statement.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>The length of <code>nums</code> will be in the range <code>[0, 10000]</code>.</li>\n<li>Each element <code>nums[i]</code> will be an integer in the range <code>[-1000, 1000]</code>.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-prefix-sum-accepted">Approach #1: Prefix Sum [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-prefix-sum-accepted">Approach #1: Prefix Sum [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>We need to quickly compute the sum of values to the left and the right of every index.</p>\n<p>Let\'s say we knew <code>S</code> as the sum of the numbers, and we are at index <code>i</code>.  If we knew the sum of numbers <code>leftsum</code> that are to the left of index <code>i</code>, then the other sum to the right of the index would just be <code>S - nums[i] - leftsum</code>.  </p>\n<p>As such, we only need to know about <code>leftsum</code> to check whether an index is a pivot index in constant time.  Let\'s do that: as we iterate through candidate indexes <code>i</code>, we will maintain the correct value of <code>leftsum</code>.</p>\n<iframe frameborder="0" height="242" name="332EfbBV" src="https://leetcode.com/playground/332EfbBV/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>, the space used by <code>leftsum</code> and <code>S</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Coupang', 'Radius'],
  },
  {
    id: '725',
    name: 'Split Linked List in Parts',
    acceptance: '49.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a (singly) linked list with head node <code>root</code>, write a function to split the linked list into <code>k</code> consecutive linked list "parts".\n</p><p>\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than 1.  This may lead to some parts being null.\n</p><p>\nThe parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.\n</p><p>\nReturn a List of ListNode\'s representing the linked list parts that are formed.\n</p>\n\nExamples\n1-&gt;2-&gt;3-&gt;4, k = 5 // 5 equal parts\n[ [1], \n[2],\n[3],\n[4],\nnull ]\n\n<p><b>Example 1:</b><br>\n</p><pre style="white-space: pre-line"><b>Input:</b> \nroot = [1, 2, 3], k = 5\n<b>Output:</b> [[1],[2],[3],[],[]]\n<b>Explanation:</b>\nThe input and each element of the output are ListNodes, not arrays.\nFor example, the input root has root.val = 1, root.next.val = 2, \\root.next.next.val = 3, and root.next.next.next = null.\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but it\'s string representation as a ListNode is [].\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \nroot = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3\n<b>Output:</b> [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]\n<b>Explanation:</b>\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>The length of <code>root</code> will be in the range <code>[0, 1000]</code>.</li>\n<li>Each value of a node in the input will be an integer in the range <code>[0, 999]</code>.</li>\n<li><code>k</code> will be an integer in the range <code>[1, 50]</code>.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-create-new-lists-accepted">Approach #1: Create New Lists [Accepted]</a></li>\n<li><a href="#approach-2-split-input-list-accepted">Approach #2: Split Input List [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-create-new-lists-accepted">Approach #1: Create New Lists [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>If there are <script type="math/tex; mode=display">N</script> nodes in the linked list <code>root</code>, then there are <script type="math/tex; mode=display">N / k</script> items in each part, plus the first <script type="math/tex; mode=display">N \\% k</script> parts have an extra item.  We can count <script type="math/tex; mode=display">N</script> with a simple loop.</p>\n<p>Now for each part, we have calculated how many nodes that part will have: <code>width + (i &lt; remainder ? 1 : 0)</code>.  We create a new list and write the part to that list.</p>\n<p>Our solution showcases constructs of the form <code>a = b = c</code>.  Note that this syntax behaves differently for different languages.</p>\n<iframe frameborder="0" height="463" name="mPv7qf7R" src="https://leetcode.com/playground/mPv7qf7R/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N + k)</script>, where <script type="math/tex; mode=display">N</script> is the number of nodes in the given list.  If <script type="math/tex; mode=display">k</script> is large, it could still require creating many new empty lists.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(max(N, k))</script>, the space used in writing the answer.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-split-input-list-accepted">Approach #2: Split Input List [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>As in <em>Approach #1</em>, we know the size of each part.  Instead of creating new lists, we will split the input list directly and return a list of pointers to nodes in the original list as appropriate.</p>\n<p>Our solution proceeds similarly.  For a part of size <code>L = width + (i &lt; remainder ? 1 : 0)</code>, instead of stepping <code>L</code> times, we will step <code>L-1</code> times, and our final time will also sever the link between the last node from the previous part and the first node from the next part.</p>\n<iframe frameborder="0" height="500" name="RmD7xooU" src="https://leetcode.com/playground/RmD7xooU/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N + k)</script>, where <script type="math/tex; mode=display">N</script> is the number of nodes in the given list.  If <script type="math/tex; mode=display">k</script> is large, it could still require creating many new empty lists.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(k)</script>, the additional space used in writing the answer.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '726',
    name: 'Number of Atoms',
    acceptance: '44.9%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>Given a chemical <code>formula</code> (given as a string), return the count of each atom.\n</p><p>\nAn atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\n</p><p>\n1 or more digits representing the count of that element may follow if the count is greater than 1.  If the count is 1, no digits will follow.  For example, H2O and H2O2 are possible, but H1O2 is impossible.\n</p><p>\nTwo formulas concatenated together produce another formula.  For example, H2O2He3Mg4 is also a formula.  \n</p><p>\nA formula placed in parentheses, and a count (optionally added) is also a formula.  For example, (H2O2) and (H2O2)3 are formulas.\n</p><p>\nGiven a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \nformula = \"H2O\"\n<b>Output:</b> \"H2O\"\n<b>Explanation:</b> \nThe count of elements are {'H': 2, 'O': 1}.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \nformula = \"Mg(OH)2\"\n<b>Output:</b> \"H2MgO2\"\n<b>Explanation:</b> \nThe count of elements are {'H': 2, 'Mg': 1, 'O': 2}.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> \nformula = \"K4(ON(SO3)2)2\"\n<b>Output:</b> \"K4N2O14S4\"\n<b>Explanation:</b> \nThe count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>All atom names consist of lowercase letters, except for the first character which is uppercase.</li>\n<li>The length of <code>formula</code> will be in the range <code>[1, 1000]</code>.</li>\n<li><code>formula</code> will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.</li>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-recursion-accepted">Approach #1: Recursion [Accepted]</a></li>\n<li><a href="#approach-2-stack-accepted">Approach #2: Stack [Accepted]</a></li>\n<li><a href="#approach-3-regular-expressions-accepted">Approach #3: Regular Expressions [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-recursion-accepted">Approach #1: Recursion [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Write a function <code>parse</code> that parses the formula from index <code>i</code>, returning a map <code>count</code> from names to multiplicities (the number of times that name is recorded).</p>\n<p>We will put <code>i</code> in global state: our <code>parse</code> function increments <code>i</code> throughout any future calls to <code>parse</code>.</p>\n<ul>\n<li>\n<p>When we see a <code>\'(\'</code>, we will parse whatever is inside the brackets (up to the closing ending bracket) and add it to our count.</p>\n</li>\n<li>\n<p>Otherwise, we should see an uppercase character: we will parse the rest of the letters to get the name, and add that (plus the multiplicity if there is one.)</p>\n</li>\n<li>\n<p>At the end, if there is a final multiplicity (representing the multiplicity of a bracketed sequence), we\'ll multiply our answer by this.</p>\n</li>\n</ul>\n<iframe frameborder="0" height="500" name="pdZAZ5dG" src="https://leetcode.com/playground/pdZAZ5dG/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script>, where <script type="math/tex; mode=display">N</script> is the length of the formula.  It is <script type="math/tex; mode=display">O(N)</script> to parse through the formula, but each of <script type="math/tex; mode=display">O(N)</script> multiplicities after a bracket may increment the count of each name in the formula (inside those brackets), leading to an <script type="math/tex; mode=display">O(N^2)</script> complexity.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>.  We aren\'t recording more intermediate information than what is contained in the formula.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-stack-accepted">Approach #2: Stack [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Instead of recursion, we can simulate the call stack by using a stack of <code>count</code>s directly.</p>\n<iframe frameborder="0" height="500" name="KLEWBfKw" src="https://leetcode.com/playground/KLEWBfKw/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time Complexity <script type="math/tex; mode=display">O(N^2)</script>, and Space Complexity <script type="math/tex; mode=display">O(N)</script>.  The analysis is the same as <em>Approach #1</em>.</li>\n</ul>\n<hr>\n<h4 id="approach-3-regular-expressions-accepted">Approach #3: Regular Expressions [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Whenever parsing is involved, we can use <em>regular expressions</em>, a language for defining patterns in text.</p>\n<p>Our regular expression will be <code>"([A-Z][a-z]*)(\\d*)|(\\()|(\\))(\\d*)"</code>.  Breaking this down by <em>capture group</em>, this is:</p>\n<ul>\n<li><code>([A-Z][a-z]*)</code> Match an uppercase character followed by any number of lowercase characters, then (<code>(\\d*)</code>) match any number of digits.</li>\n<li>OR, <code>(\\()</code> match a left bracket or <code>(\\))</code> right bracket, then <code>(\\d*)</code> match any number of digits.</li>\n</ul>\n<p>Now we can proceed as in <em>Approach #2</em>.</p>\n<ul>\n<li>\n<p>If we parsed a name and multiplicity <code>([A-Z][a-z]*)(\\d*)</code>, we will add it to our current count.</p>\n</li>\n<li>\n<p>If we parsed a left bracket, we will append a new <code>count</code> to our stack, representing the nested depth of parentheses.</p>\n</li>\n<li>\n<p>If we parsed a right bracket (and possibly another multiplicity), we will multiply our deepest level <code>count</code>, <code>top = stack.pop()</code>, and add those entries to our current count.</p>\n</li>\n</ul>\n<iframe frameborder="0" height="500" name="rnaR7xpb" src="https://leetcode.com/playground/rnaR7xpb/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time Complexity <script type="math/tex; mode=display">O(N^2)</script>, and Space Complexity <script type="math/tex; mode=display">O(N)</script>.  The analysis is the same as <em>Approach #1</em>, as this regular expression did not look backwards when parsing.</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.  Approaches #1 and #2 inspired by <a href="https://leetcode.com/zestypanda/">@zestypanda</a>.  Java solution for #3 by <a href="https://discuss.leetcode.com/user/jianchao-li-fighter">@jianchao.li.fighter</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '727',
    name: 'Minimum Window Subsequence ',
    acceptance: '30.6%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>Given strings <code>S</code> and <code>T</code>, find the minimum (contiguous) <b>substring</b> <code>W</code> of <code>S</code>, so that <code>T</code> is a <b>subsequence</b> of <code>W</code>.\n</p><p>\nIf there is no such window in <code>S</code> that covers all characters in <code>T</code>, return the empty string <code>""</code>.  If there are multiple such minimum-length windows, return the one with the left-most starting index.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \nS = "abcdebdde", T = "bde"\n<b>Output:</b> "bcde"\n<b>Explanation:</b> \n"bcde" is the answer because it occurs before "bdde" which has the same length.\n"deb" is not a smaller window because the elements of T in the window must occur in order.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>All the strings in the input will only contain lowercase letters.</li>\n<li>The length of <code>S</code> will be in the range <code>[1, 20000]</code>.</li>\n<li>The length of <code>T</code> will be in the range <code>[1, 100]</code>.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-dynamic-programming-postfix-variation-accepted">Approach #1: Dynamic Programming (Postfix Variation) [Accepted]</a></li>\n<li><a href="#approach-2-dynamic-programming-next-array-variation-accepted">Approach #2: Dynamic Programming (Next Array Variation) [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-dynamic-programming-postfix-variation-accepted">Approach #1: Dynamic Programming (Postfix Variation) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Let\'s work on a simpler problem: <code>T = \'abc\'</code>.  Whenever <code>S[k] = \'c\'</code>, the most recent window <code>[i, j]</code> before it (that contains <code>\'ab\'</code>) becomes the window <code>[i, k]</code>.</p>\n<p>Here, a window is the best possible window that ends at a given index, which ensures every window considered has increasing starting and ending indices.</p>\n<p>For example, if <code>S = \'aacbbc\'</code>, then after considering <code>T = \'ab\'</code>, the windows are <code>[[1, 3], [1, 4]]</code>, and after parsing <code>\'c\'</code>, the windows are <code>[[1, 5]]</code>.</p>\n<p>As we iterate through <code>k</code> for <code>S[k] = T[2]</code>, we could just remember the last window seen.  This leads to a dynamic programming solution.  </p>\n<p><strong>Algorithm</strong></p>\n<p>As we iterate through <code>T[j]</code>, let\'s maintain <code>cur[e] = s</code> as the largest index such that <code>T[:j]</code> is a subsequence of <code>S[s: e+1]</code>, (or <code>-1</code> if impossible.)  Now we want to find <code>new</code>, the largest indexes for <code>T[:j+1]</code>.</p>\n<p>To update our knowledge as <code>j += 1</code>, if <code>S[i] == T[j]</code>, then <code>last</code> (the largest <code>s</code> we have seen so far) represents a new valid window <code>[s, i]</code>.</p>\n<p>In Python, we use <code>cur</code> and <code>new</code>, while in Java we use <code>dp[j]</code> and <code>dp[~j]</code> to keep track of the last two rows of our dynamic programming.</p>\n<p>At the end, we look at all the windows we have and choose the best.</p>\n<iframe frameborder="0" height="500" name="wNGBW5iX" src="https://leetcode.com/playground/wNGBW5iX/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(ST)</script>, where <script type="math/tex; mode=display">S, T</script> are the lengths of <code>S, T</code>.  We have two for-loops.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(S)</script>, the length of <code>dp</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-dynamic-programming-next-array-variation-accepted">Approach #2: Dynamic Programming (Next Array Variation) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Let\'s guess that the minimum window will start at <code>S[i]</code>.  We can assume that <code>S[i] = T[0]</code>.  Then, we should find the next occurrence of <code>T[1]</code> in <code>S[i+1:]</code>, say at <code>S[j]</code>.  Then, we should find the next occurrence of <code>T[2]</code> in <code>S[j+1:]</code>, and so on.</p>\n<p>Finding the next occurrence can be precomputed in linear time so that each guess becomes <script type="math/tex; mode=display">O(T)</script> work.</p>\n<p><strong>Algorithm</strong></p>\n<p>We can precompute (for each <code>i</code> and <code>letter</code>), <code>next[i][letter]</code>: the index of the first occurrence of <code>letter</code> in <code>S[i:]</code>, or <code>-1</code> if it is not found.</p>\n<p>Then, we\'ll maintain a set of minimum windows for <code>T[:j]</code> as <code>j</code> increases.  At the end, we\'ll take the best minimum window.</p>\n<iframe frameborder="0" height="500" name="uekjLsTw" src="https://leetcode.com/playground/uekjLsTw/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(ST)</script>, where <script type="math/tex; mode=display">S, T</script> are the lengths of <code>S, T</code>, and assuming a fixed-sized alphabet.  The precomputation of <code>nxt</code> is <script type="math/tex; mode=display">O(S)</script>, and the other work happens in two for-loops.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(S)</script>, the size of <code>windows</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.  Approach #1 inspired by <a href="https://leetcode.com/zestypanda/">@zestypanda</a>.</p>\n</div>\n          ',
    tags: ['Google', 'eBay'],
  },
  {
    id: '728',
    name: 'Self Dividing Numbers',
    acceptance: '68.1%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nA <i>self-dividing number</i> is a number that is divisible by every digit it contains.\n</p><p>\nFor example, 128 is a self-dividing number because <code>128 % 1 == 0</code>, <code>128 % 2 == 0</code>, and <code>128 % 8 == 0</code>.\n</p><p>\nAlso, a self-dividing number is not allowed to contain the digit zero.\n</p><p>\nGiven a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.\n</p>\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \nleft = 1, right = 22\n<b>Output:</b> [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>The boundaries of each input argument are <code>1 &lt;= left &lt;= right &lt;= 10000</code>.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>For each number in the given range, we will directly test if that number is self-dividing.</p>\n<p>By definition, we want to test each whether each digit is non-zero and divides the number.  For example, with <code>128</code>, we want to test <code>d != 0 &amp;&amp; 128 % d == 0</code> for <code>d = 1, 2, 8</code>.  To do that, we need to iterate over each digit of the number.</p>\n<p>A straightforward approach to that problem would be to convert the number into a character array (string in Python), and then convert back to integer to perform the modulo operation when checking <code>n % d == 0</code>.</p>\n<p>We could also continually divide the number by 10 and peek at the last digit.  That is shown as a variation in a comment.</p>\n<iframe frameborder="0" height="500" name="6GUVmusj" src="https://leetcode.com/playground/6GUVmusj/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(D)</script>, where <script type="math/tex; mode=display">D</script> is the number of integers in the range <script type="math/tex; mode=display">[L, R]</script>, and assuming <script type="math/tex; mode=display">\\log(R)</script> is bounded.  (In general, the complexity would be <script type="math/tex; mode=display">O(D\\log R)</script>.)</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(D)</script>, the length of the answer.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Epic Systems'],
  },
  {
    id: '729',
    name: 'My Calendar I',
    acceptance: '40.3%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nImplement a <code>MyCalendar</code> class to store your events. A new event can be added if adding the event will not cause a double booking.\n</p><p>\nYour class will have the method, <code>book(int start, int end)</code>.  Formally, this represents a booking on the half open interval <code>[start, end)</code>, the range of real numbers <code>x</code> such that <code>start &lt;= x &lt; end</code>.\n</p><p>\nA <i>double booking</i> happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)\n</p><p>\nFor each call to the method <code>MyCalendar.book</code>, return <code>true</code> if the event can be added to the calendar successfully without causing a double booking.  Otherwise, return <code>false</code> and do not add the event to the calendar.\n</p>\n\nYour class will be called like this:\n<code>MyCalendar cal = new MyCalendar();</code>\n<code>MyCalendar.book(start, end)</code>\n\n<p><b>Example 1:</b><br>\n</p><pre>MyCalendar();\nMyCalendar.book(10, 20); // returns true\nMyCalendar.book(15, 25); // returns false\nMyCalendar.book(20, 30); // returns true\n<b>Explanation:</b> \nThe first event can be booked.  The second can't because time 15 is already booked by another event.\nThe third event can be booked, as the first event takes every time less than 20, but not including 20.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>The number of calls to <code>MyCalendar.book</code> per test case will be at most <code>1000</code>.</li>\n<li>In calls to <code>MyCalendar.book(start, end)</code>, <code>start</code> and <code>end</code> are integers in the range <code>[0, 10^9]</code>.</li>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-balanced-tree-accepted">Approach #2: Balanced Tree [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>When booking a new event <code>[start, end)</code>, check if every current event conflicts with the new event.  If none of them do, we can book the event.</p>\n<p><strong>Algorithm</strong></p>\n<p>We will maintain a list of interval <em>events</em> (not necessarily sorted).  Evidently, two events <code>[s1, e1)</code> and <code>[s2, e2)</code> do <em>not</em> conflict if and only if one of them starts after the other one ends: either <code>e1 &lt;= s2</code> OR <code>e2 &lt;= s1</code>.  By De Morgan\'s laws, this means the events conflict when <code>s1 &lt; e2</code> AND <code>s2 &lt; e1</code>.</p>\n<iframe frameborder="0" height="310" name="RbxQb2Zj" src="https://leetcode.com/playground/RbxQb2Zj/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script>, where <script type="math/tex; mode=display">N</script> is the number of events booked.  For each new event, we process every previous event to decide whether the new event can be booked.  This leads to <script type="math/tex; mode=display">\\sum_k^N O(k) = O(N^2)</script> complexity.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of the <code>calendar</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-balanced-tree-accepted">Approach #2: Balanced Tree [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we maintained our events in <em>sorted</em> order, we could check whether an event could be booked in <script type="math/tex; mode=display">O(\\log N)</script> time (where <script type="math/tex; mode=display">N</script> is the number of events already booked) by binary searching for where the event should be placed.  We would also have to insert the event in our sorted structure.</p>\n<p><strong>Algorithm</strong></p>\n<p>We need a data structure that keeps elements sorted and supports fast insertion.  In Java, a <code>TreeMap</code> is the perfect candidate.  In Python, we can build our own binary tree structure.</p>\n<p>For Java, we will have a <code>TreeMap</code> where the keys are the start of each interval, and the values are the ends of those intervals.  When inserting the interval <code>[start, end)</code>, we check if there is a conflict on each side with neighboring intervals: we would like <code>calendar.get(prev)) &lt;= start &lt;= end &lt;= next</code> for the booking to be valid (or for <code>prev</code> or <code>next</code> to be null respectively.)</p>\n<p>For Python, we will create a binary tree.  Each node represents some interval <code>[self.start, self.end)</code> while <code>self.left, self.right</code> represents nodes that are smaller or larger than the current node.</p>\n<iframe frameborder="0" height="500" name="huRxLsMu" src="https://leetcode.com/playground/huRxLsMu/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity (Java): <script type="math/tex; mode=display">O(N \\log N)</script>, where <script type="math/tex; mode=display">N</script> is the number of events booked.  For each new event, we search that the event is legal in <script type="math/tex; mode=display">O(\\log N)</script> time, then insert it in <script type="math/tex; mode=display">O(1)</script> time.</p>\n</li>\n<li>\n<p>Time Complexity (Python): <script type="math/tex; mode=display">O(N^2)</script> worst case, with <script type="math/tex; mode=display">O(N \\log N)</script> on random data.  For each new event, we insert the event into our binary tree.  As this tree may not be balanced, it may take a linear number of steps to add each event.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of the data structures used.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.  Solutions in Approach #2 inspired by <a href="https://discuss.leetcode.com/topic/111205/java-8-liner-treemap">@shawngao</a> and  <a href="https://discuss.leetcode.com/topic/111203/binary-search-tree-python">@persianPanda</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '730',
    name: 'Count Different Palindromic Subsequences',
    acceptance: '32.5%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>\nGiven a string S, find the number of different non-empty palindromic subsequences in S, and <b>return that number modulo <code>10^9 + 7</code>.</b>\n</p><p>\nA subsequence of a string S is obtained by deleting 0 or more characters from S.\n</p><p>\nA sequence is palindromic if it is equal to the sequence reversed.\n</p><p>\nTwo sequences <code>A_1, A_2, ...</code> and <code>B_1, B_2, ...</code> are different if there is some <code>i</code> for which <code>A_i != B_i</code>.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \nS = 'bccb'\n<b>Output:</b> 6\n<b>Explanation:</b> \nThe 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.\nNote that 'bcb' is counted only once, even though it occurs twice.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \nS = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba'\n<b>Output:</b> 104860361\n<b>Explanation:</b> \nThere are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>The length of <code>S</code> will be in the range <code>[1, 1000]</code>.</li>\n<li>Each character <code>S[i]</code> will be in the set <code>{'a', 'b', 'c', 'd'}</code>.</li>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-dynamic-programming-using-3d-array-accepted">Approach #1 Dynamic Programming (using 3D array) [Accepted]</a></li>\n<li><a href="#approach-2-dynamic-programming-using-2d-array-accepted">Approach #2: Dynamic Programming (using 2D array) [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-dynamic-programming-using-3d-array-accepted">Approach #1 Dynamic Programming (using 3D array) [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Let <code>dp[x][i][j]</code> be the answer for the substring <code>S[i...j]</code> where\n<code>S[i] == S[j] == \'a\'+x</code>. Note that since we only have 4 characters <code>a,\nb, c, d</code>, thus <code>0 &lt;= x &lt; 4</code>. The DP formula goes as follows:</p>\n<ul>\n<li>\n<p>If <code>S[i] != \'a\'+x</code>, then <code>dp[x][i][j] = dp[x][i+1][j]</code>, note that\n  here we leave the first character <code>S[i]</code> in the window out due to\n  our definition of <code>dp[x][i][j]</code>.</p>\n</li>\n<li>\n<p>If <code>S[j] != \'a\'+x</code>, then <code>dp[x][i][j] = dp[x][i][j-1]</code>, leaving the\n  last character <code>S[j]</code> out.</p>\n</li>\n<li>\n<p>If <code>S[i] == S[j] == \'a\'+x</code>, then <code>dp[x][i][j] = 2 +\n  dp[0][i+1][j-1] + dp[1][i+1][j-1] + dp[2][i+1][j-1] +\n  dp[3][i+1][j-1]</code>. When the first and last characters are the same, we\n  need to count all the distinct palindromes (for each of <code>a,b,c,d</code>) within\n  the sub-window <code>S[i+1][j-1]</code> plus the <code>2</code> palindromes contributed by\n  the first and last characters.</p>\n</li>\n</ul>\n<p>Let <code>n</code> be the length of the input string <code>S</code>, The final answer would\nbe <code>dp[0][0][n-1] + dp[1][0][n-1] + dp[2][0][n-1] + dp[3][0][n-1]</code>\nmod <code>1000000007</code>.</p>\n<iframe frameborder="0" height="500" name="4MHeaWhk" src="https://leetcode.com/playground/4MHeaWhk/shared" width="100%"></iframe>\n<p><strong>Example Walkthrough</strong></p>\n<p>Indeed this is a hard problem to solve and thoroughly understanding\nits solution is also challenging. Maybe the best way to understand the\nabove approach is to walkthrough some simple examples to help build up\nintuitions.</p>\n<p>Let\'s first look at the strategy we used to fill the DP table and then walkthrough a concrete example to see how it works.</p>\n<p align="center"><img alt="DP Table Filling Strategy" src="https://leetcode.com/articles/Figures/730/730_Table_Fill.svg" width="539px"></p>\n<p>!?!../Documents/730_Example_Walkthrough.json:1280,720!?!</p>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time complexity : <script type="math/tex; mode=display">O(N^2)</script> where <script type="math/tex; mode=display">N</script> is the length of the input\n  string <script type="math/tex; mode=display">S</script>. It takes quadratic time to fill up the DP table.</p>\n</li>\n<li>\n<p>Space complexity : <script type="math/tex; mode=display">O(N^2)</script> where <script type="math/tex; mode=display">N</script> is the length of the input\n  string <script type="math/tex; mode=display">S</script>. The DP table takes quadratic space.</p>\n</li>\n</ul>\n<p>Note that we ignore the constant factor <script type="math/tex; mode=display">4</script> in the above analysis.</p>\n<p><strong>Conclusion</strong></p>\n<p>As we look back, this problem reveals a key attribute which indicates\nthat dynamic programming might be a good fit: <code>overlapping\nsub-problems</code> as we recall the DP formula. By practicing more\nproblems, we can build up this kind of intuition.</p>\n<p><em>Credit</em>: the above solution is inspired by\n<a href="https://discuss.leetcode.com/topic/111241/c-o-n-2-time-o-n-memory-with-explanation">this post</a>\nwritten by <a href="https://discuss.leetcode.com/user/elastico">@elastico</a>. His solution is space optimized. However, I found\nthat my approach is relatively easy to understand for people who found\nthis problem hard to approach.</p>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/imsure">@imsure</a>.  </p>\n<h4 id="approach-2-dynamic-programming-using-2d-array-accepted">Approach #2: Dynamic Programming (using 2D array) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Almost every palindrome is going to take one of these four forms: <code>a_a</code>, <code>b_b</code>, <code>c_c</code>, or <code>d_d</code>, where <code>_</code> represents a palindrome of zero or more characters.  (The only other palindromes are <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, and the empty string.)</p>\n<p>Let\'s try to count palindromes of the form <code>a_a</code> - the other types are similar.  Evidently, we should take the first and last <code>a</code>, then count all the palindromes that can be formed in between, as this provides us strictly more possibilities for <code>_</code> to be a palindrome.  This reveals an <em>optimal substructure</em> that is ideal for <em>dynamic programming</em>.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let <code>dp(i, j)</code> be the number of palindromes (including the palindrome <code>\'\'</code>) in the string <code>T = S[i], S[i+1], ..., S[j]</code>.  To count palindromes in <code>T</code> of the form <code>a_a</code>, we will need to know the first and last occurrence of <code>\'a\'</code> in this string.  This can be done by a precomputed dp: <code>next[i][0]</code> will be the next occurrence of <code>\'a\'</code> in <code>S[i:]</code>, <code>next[i][1]</code> will be the next occurrence of <code>\'b\'</code> in <code>S[i:]</code>, and so on.  </p>\n<p>Also, we will need to know the number of unique letters in <code>T</code> to count the single letter palindromes.  We can use the information from <code>next</code> to deduce it: if <code>next[i][0]</code> is in the interval <code>[i, j]</code>, then <code>\'a\'</code> occurs in <code>T</code>, and so on.</p>\n<p>As many states <code>dp(i, j)</code> do not need to be computed, the most natural approach is a <em>top-down</em> variation of dynamic programming.</p>\n<iframe frameborder="0" height="500" name="dhYtsJUH" src="https://leetcode.com/playground/dhYtsJUH/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script>, where <script type="math/tex; mode=display">N</script> is the size of the string <code>S</code>.  Our calculation of <code>prv</code> and <code>nxt</code> happens in <script type="math/tex; mode=display">O(N)</script> time, then our evaluation of <code>dp</code> with at most <script type="math/tex; mode=display">N^2</script> states is <script type="math/tex; mode=display">O(1)</script> work per state.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N^2)</script>, the size of <code>memo</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '731',
    name: 'My Calendar II',
    acceptance: '35.4%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nImplement a <code>MyCalendarTwo</code> class to store your events. A new event can be added if adding the event will not cause a <b>triple</b> booking.\n</p><p>\nYour class will have one method, <code>book(int start, int end)</code>.  Formally, this represents a booking on the half open interval <code>[start, end)</code>, the range of real numbers <code>x</code> such that <code>start &lt;= x &lt; end</code>.\n</p><p>\nA <i>triple booking</i> happens when <b>three</b> events have some non-empty intersection (ie., there is some time that is common to all 3 events.)\n</p><p>\nFor each call to the method <code>MyCalendar.book</code>, return <code>true</code> if the event can be added to the calendar successfully without causing a <b>triple</b> booking.  Otherwise, return <code>false</code> and do not add the event to the calendar.\n</p>\n\nYour class will be called like this:\n<code>MyCalendar cal = new MyCalendar();</code>\n<code>MyCalendar.book(start, end)</code>\n\n<p><b>Example 1:</b><br>\n</p><pre>MyCalendar();\nMyCalendar.book(10, 20); // returns true\nMyCalendar.book(50, 60); // returns true\nMyCalendar.book(10, 40); // returns true\nMyCalendar.book(5, 15); // returns false\nMyCalendar.book(5, 10); // returns true\nMyCalendar.book(25, 55); // returns true\n<b>Explanation:</b> \nThe first two events can be booked.  The third event can be double booked.\nThe fourth event (5, 15) can't be booked, because it would result in a triple booking.\nThe fifth event (5, 10) can be booked, as it does not use time 10 which is already double booked.\nThe sixth event (25, 55) can be booked, as the time in [25, 40) will be double booked with the third event;\nthe time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>The number of calls to <code>MyCalendar.book</code> per test case will be at most <code>1000</code>.</li>\n<li>In calls to <code>MyCalendar.book(start, end)</code>, <code>start</code> and <code>end</code> are integers in the range <code>[0, 10^9]</code>.</li>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</a></li>\n<li><a href="#approach-2-boundary-count-accepted">Approach #2: Boundary Count [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-brute-force-accepted">Approach #1: Brute Force [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Maintain a list of bookings and a list of double bookings.  When booking a new event <code>[start, end)</code>, if it conflicts with a double booking, it will have a triple booking and be invalid.  Otherwise, parts that overlap the calendar will be a double booking.</p>\n<p><strong>Algorithm</strong></p>\n<p>Evidently, two events <code>[s1, e1)</code> and <code>[s2, e2)</code> do <em>not</em> conflict if and only if one of them starts after the other one ends: either <code>e1 &lt;= s2</code> OR <code>e2 &lt;= s1</code>.  By De Morgan\'s laws, this means the events conflict when <code>s1 &lt; e2</code> AND <code>s2 &lt; e1</code>.</p>\n<p>If our event conflicts with a double booking, it\'s invalid.  Otherwise, we add conflicts with the calendar to our double bookings, and add the event to our calendar.</p>\n<iframe frameborder="0" height="395" name="LWSnt2kz" src="https://leetcode.com/playground/LWSnt2kz/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script>, where <script type="math/tex; mode=display">N</script> is the number of events booked.  For each new event, we process every previous event to decide whether the new event can be booked.  This leads to <script type="math/tex; mode=display">\\sum_k^N O(k) = O(N^2)</script> complexity.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of the <code>calendar</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-boundary-count-accepted">Approach #2: Boundary Count [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>When booking a new event <code>[start, end)</code>, count <code>delta[start]++</code> and <code>delta[end]--</code>.  When processing the values of <code>delta</code> in sorted order of their keys, the running sum <code>active</code> is the number of events open at that time.  If the sum is 3 or more, that time is (at least) triple booked.</p>\n<p>A Python implementation was not included for this approach because there is no analog to <em>TreeMap</em> available.</p>\n<div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">MyCalendarTwo</span> <span class="o">{</span>\n    <span class="n">TreeMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">delta</span><span class="o">;</span>\n\n    <span class="kd">public</span> <span class="nf">MyCalendarTwo</span><span class="o">()</span> <span class="o">{</span>\n        <span class="n">delta</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeMap</span><span class="o">();</span>\n    <span class="o">}</span>\n\n    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">book</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>\n        <span class="n">delta</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">delta</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n        <span class="n">delta</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">end</span><span class="o">,</span> <span class="n">delta</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">end</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>\n\n        <span class="kt">int</span> <span class="n">active</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>\n        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">d</span><span class="o">:</span> <span class="n">delta</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>\n            <span class="n">active</span> <span class="o">+=</span> <span class="n">d</span><span class="o">;</span>\n            <span class="k">if</span> <span class="o">(</span><span class="n">active</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>\n                <span class="n">delta</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">delta</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">start</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>\n                <span class="n">delta</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">end</span><span class="o">,</span> <span class="n">delta</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">end</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>\n                <span class="k">if</span> <span class="o">(</span><span class="n">delta</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">start</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>\n                    <span class="n">delta</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>\n                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>\n            <span class="o">}</span>\n        <span class="o">}</span>\n        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>\n    <span class="o">}</span>\n<span class="o">}</span>\n</pre></div>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script>, where <script type="math/tex; mode=display">N</script> is the number of events booked.  For each new event, we traverse <code>delta</code> in <script type="math/tex; mode=display">O(N)</script> time.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of <code>delta</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.  Solution in Approach #2 inspired by <a href="https://discuss.leetcode.com/topic/111276/simplified-winner-s-solution">@cchao</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '732',
    name: 'My Calendar III',
    acceptance: '52.8%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nImplement a <code>MyCalendarThree</code> class to store your events. A new event can <b>always</b> be added.\n</p><p>\nYour class will have one method, <code>book(int start, int end)</code>.  Formally, this represents a booking on the half open interval <code>[start, end)</code>, the range of real numbers <code>x</code> such that <code>start &lt;= x &lt; end</code>.\n</p><p>\nA <i>K-booking</i> happens when <b>K</b> events have some non-empty intersection (ie., there is some time that is common to all K events.)\n</p><p>\nFor each call to the method <code>MyCalendar.book</code>, return an integer <code>K</code> representing the largest integer such that there exists a <code>K</code>-booking in the calendar.\n</p>\n\nYour class will be called like this:\n<code>MyCalendarThree cal = new MyCalendarThree();</code>\n<code>MyCalendarThree.book(start, end)</code>\n\n<p><b>Example 1:</b><br>\n</p><pre>MyCalendarThree();\nMyCalendarThree.book(10, 20); // returns 1\nMyCalendarThree.book(50, 60); // returns 1\nMyCalendarThree.book(10, 40); // returns 2\nMyCalendarThree.book(5, 15); // returns 3\nMyCalendarThree.book(5, 10); // returns 3\nMyCalendarThree.book(25, 55); // returns 3\n<b>Explanation:</b> \nThe first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking.\nThe third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking.\nThe remaining events cause the maximum K-booking to be only a 3-booking.\nNote that the last event locally causes a 2-booking, but the answer is still 3 because\neg. [10, 20), [10, 40), and [5, 15) are still triple booked.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>The number of calls to <code>MyCalendarThree.book</code> per test case will be at most <code>400</code>.</li>\n<li>In calls to <code>MyCalendarThree.book(start, end)</code>, <code>start</code> and <code>end</code> are integers in the range <code>[0, 10^9]</code>.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-boundary-count-accepted">Approach #1: Boundary Count [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-boundary-count-accepted">Approach #1: Boundary Count [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>When booking a new event <code>[start, end)</code>, count <code>delta[start]++</code> and <code>delta[end]--</code>.  When processing the values of <code>delta</code> in sorted order of their keys, the largest such value is the answer.</p>\n<p>In Python, we sort the set each time instead, as there is no analog to <em>TreeMap</em> available.</p>\n<iframe frameborder="0" height="378" name="yJnnXvTf" src="https://leetcode.com/playground/yJnnXvTf/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script>, where <script type="math/tex; mode=display">N</script> is the number of events booked.  For each new event, we traverse <code>delta</code> in <script type="math/tex; mode=display">O(N)</script> time.  In Python, this is <script type="math/tex; mode=display">O(N^2 \\log N)</script> owing to the extra sort step.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of <code>delta</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.  Solution in Approach #2 inspired by <a href="https://discuss.leetcode.com/topic/111276/simplified-winner-s-solution">@cchao</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '733',
    name: 'Flood Fill',
    acceptance: '49.3%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nAn <code>image</code> is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).\n</p><p>\nGiven a coordinate <code>(sr, sc)</code> representing the starting pixel (row and column) of the flood fill, and a pixel value <code>newColor</code>, "flood fill" the image.\n</p><p>\nTo perform a "flood fill", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.  Replace the color of all of the aforementioned pixels with the newColor.\n</p><p>\nAt the end, return the modified image.\n</p>\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \nimage = [[1,1,1],[1,1,0],[1,0,1]]\nsr = 1, sc = 1, newColor = 2\n<b>Output:</b> [[2,2,2],[2,2,0],[2,0,1]]\n<b>Explanation:</b> \nFrom the center of the image (with position (sr, sc) = (1, 1)), all pixels connected \nby a path of the same color as the starting pixel are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected\nto the starting pixel.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>The length of <code>image</code> and <code>image[0]</code> will be in the range <code>[1, 50]</code>.</li>\n<li>The given starting pixel will satisfy <code>0 &lt;= sr &lt; image.length</code> and <code>0 &lt;= sc &lt; image[0].length</code>.</li>\n<li>The value of each color in <code>image[i][j]</code> and <code>newColor</code> will be an integer in <code>[0, 65535]</code>.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We perform the algorithm explained in the problem description: paint the starting pixels, plus adjacent pixels of the same color, and so on.</p>\n<p><strong>Algorithm</strong></p>\n<p>Say <code>color</code> is the color of the starting pixel.  Let\'s floodfill the starting pixel: we change the color of that pixel to the new color, then check the 4 neighboring pixels to make sure they are valid pixels of the same <code>color</code>, and of the valid ones, we floodfill those, and so on.</p>\n<p>We can use a function <code>dfs</code> to perform a floodfill on a target pixel.</p>\n<iframe frameborder="0" height="327" name="iMoEAq7k" src="https://leetcode.com/playground/iMoEAq7k/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the number of pixels in the image.  We might process every pixel.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of the implicit call stack when calling <code>dfs</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Uber'],
  },
  {
    id: '734',
    name: 'Sentence Similarity ',
    acceptance: '38.2%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>Given two sentences <code>words1, words2</code> (each represented as an array of strings), and a list of similar word pairs <code>pairs</code>, determine if two sentences are similar.\n</p><p>\nFor example, "great acting skills" and "fine drama talent" are similar, if the similar word pairs are <code>pairs = [["great", "fine"],\n ["acting","drama"], ["skills","talent"]]</code>.\n</p><p>\nNote that the similarity relation is not transitive. For example, if "great" and "fine" are similar, and "fine" and "good" are similar, "great" and "good" are <b>not</b> necessarily similar.\n</p><p>\nHowever, similarity is symmetric.  For example, "great" and "fine" being similar is the same as "fine" and "great" being similar.\n</p><p>\nAlso, a word is always similar with itself.  For example, the sentences <code>words1 = ["great"], words2 = ["great"], pairs = []</code> are similar, even though there are no specified similar word pairs.\n</p><p>\nFinally, sentences can only be similar if they have the same number of words.  So a sentence like <code>words1 = ["great"]</code> can never be similar to <code>words2 = ["doubleplus","good"]</code>.\n</p>\n\n<p><b>Note:</b>\n</p><li>The length of <code>words1</code> and <code>words2</code> will not exceed <code>1000</code>.</li>\n<li>The length of <code>pairs</code> will not exceed <code>2000</code>.</li>\n<li>The length of each <code>pairs[i]</code> will be <code>2</code>.</li>\n<li>The length of each <code>words[i]</code> and <code>pairs[i][j]</code> will be in the range <code>[1, 20]</code>.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-set-accepted">Approach #1: Set [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-set-accepted">Approach #1: Set [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>To check whether <code>words1[i]</code> and <code>words2[i]</code> are similar, either they are the same word, or <code>(words1[i], words2[i])</code> or <code>(words2[i], words1[i])</code> appear in <code>pairs</code>.</p>\n<p>To check whether <code>(words1[i], words2[i])</code> appears in <code>pairs</code> quickly, we could put all such pairs into a Set structure.</p>\n<iframe frameborder="0" height="361" name="svWbu6oA" src="https://leetcode.com/playground/svWbu6oA/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N+P)</script>, where <script type="math/tex; mode=display">N</script> is the maximum length of <code>words1</code> and <code>words2</code>, and <script type="math/tex; mode=display">P</script> is the length of <code>pairs</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(P)</script>, the size of <code>pairs</code>.  Intermediate objects created in evaluating whether a pair of words are similar are created one at a time, so they don\'t take additional space.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '735',
    name: 'Asteroid Collision',
    acceptance: '37.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nWe are given an array <code>asteroids</code> of integers representing asteroids in a row.\n</p><p>\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left).  Each asteroid moves at the same speed.\n</p><p>\nFind out the state of the asteroids after all collisions.  If two asteroids meet, the smaller one will explode.  If both are the same size, both will explode.  Two asteroids moving in the same direction will never meet.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \nasteroids = [5, 10, -5]\n<b>Output:</b> [5, 10]\n<b>Explanation:</b> \nThe 10 and -5 collide resulting in 10.  The 5 and 10 never collide.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> \nasteroids = [8, -8]\n<b>Output:</b> []\n<b>Explanation:</b> \nThe 8 and -8 collide exploding each other.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> \nasteroids = [10, 2, -5]\n<b>Output:</b> [10]\n<b>Explanation:</b> \nThe 2 and -5 collide resulting in -5.  The 10 and -5 collide resulting in 10.\n</pre>\n<p></p>\n\n<p><b>Example 4:</b><br>\n</p><pre><b>Input:</b> \nasteroids = [-2, -1, 1, 2]\n<b>Output:</b> [-2, -1, 1, 2]\n<b>Explanation:</b> \nThe -2 and -1 are moving left, while the 1 and 2 are moving right.\nAsteroids moving the same direction never meet, so no asteroids will meet each other.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>The length of <code>asteroids</code> will be at most <code>10000</code>.</li>\n<li>Each asteroid will be a non-zero integer in the range <code>[-1000, 1000].</code>.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-stack-accepted">Approach #1: Stack [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-stack-accepted">Approach #1: Stack [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>A row of asteroids is stable if no further collisions will occur.  After adding a new asteroid to the right, some more collisions may happen before it becomes stable again, and all of those collisions (if they happen) must occur right to left.  This is the perfect situation for using a <em>stack</em>.</p>\n<p><strong>Algorithm</strong></p>\n<p>Say we have our answer as a stack with rightmost asteroid <code>top</code>, and a <code>new</code> asteroid comes in.  If <code>new</code> is moving right (<code>new &gt; 0</code>), or if <code>top</code> is moving left (<code>top &lt; 0</code>), no collision occurs.</p>\n<p>Otherwise, if <code>abs(new) &lt; abs(top)</code>, then the <code>new</code> asteroid will blow up; if <code>abs(new) == abs(top)</code> then both asteroids will blow up; and if <code>abs(new) &gt; abs(top)</code>, then the <code>top</code> asteroid will blow up (and possibly more asteroids will, so we should continue checking.)</p>\n<iframe frameborder="0" height="480" name="CyN24YU5" src="https://leetcode.com/playground/CyN24YU5/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the number of asteroids.  Our stack pushes and pops each asteroid at most once.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of <code>ans</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Uber'],
  },
  {
    id: '736',
    name: 'Parse Lisp Expression',
    acceptance: '41.5%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nYou are given a string <code>expression</code> representing a Lisp-like expression to return the integer value of.\n</p><p>\nThe syntax for these expressions is given as follows.\n</p><p>\n</p><li>An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.</li>\n<p></p><p>\n</p><li>(An integer could be positive or negative.)</li>\n<p></p><p>\n</p><li>A let-expression takes the form <code>(let v1 e1 v2 e2 ... vn en expr)</code>, where <code>let</code> is always the string <code>"let"</code>, then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable <code>v1</code> is assigned the value of the expression <code>e1</code>, the second variable <code>v2</code> is assigned the value of the expression <code>e2</code>, and so on <b>sequentially</b>; and then the value of this let-expression is the value of the expression <code>expr</code>.</li>\n<p></p><p>\n</p><li>An add-expression takes the form <code>(add e1 e2)</code> where <code>add</code> is always the string <code>"add"</code>, there are always two expressions <code>e1, e2</code>, and this expression evaluates to the addition of the evaluation of <code>e1</code> and the evaluation of <code>e2</code>.</li>\n<p></p><p>\n</p><li>A mult-expression takes the form <code>(mult e1 e2)</code> where <code>mult</code> is always the string <code>"mult"</code>, there are always two expressions <code>e1, e2</code>, and this expression evaluates to the multiplication of the evaluation of <code>e1</code> and the evaluation of <code>e2</code>.</li>\n<p></p><p>\n</p><li>For the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names "add", "let", or "mult" are protected and will never be used as variable names.</li>\n<p></p><p>\n</p><li>Finally, there is the concept of scope.  When an expression of a variable name is evaluated, <b>within the context of that evaluation</b>, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.</li>\n<p></p>\n\n<p><b>Evaluation Examples:</b><br>\n</p><pre><b>Input:</b> (add 1 2)\n<b>Output:</b> 3\n\n<b>Input:</b> (mult 3 (add 2 3))\n<b>Output:</b> 15\n\n<b>Input:</b> (let x 2 (mult x 5))\n<b>Output:</b> 10\n\n<b>Input:</b> (let x 2 (mult x (let x 3 y 4 (add x y))))\n<b>Output:</b> 14\n<b>Explanation:</b> In the expression (add x y), when checking for the value of the variable x,\nwe check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.\nSince x = 3 is found first, the value of x is 3.\n\n<b>Input:</b> (let x 3 x 2 x)\n<b>Output:</b> 2\n<b>Explanation:</b> Assignment in let statements is processed sequentially.\n\n<b>Input:</b> (let x 1 y 2 x (add x y) (add x y))\n<b>Output:</b> 5\n<b>Explanation:</b> The first (add x y) evaluates as 3, and is assigned to x.\nThe second (add x y) evaluates as 3+2 = 5.\n\n<b>Input:</b> (let x 2 (add (let x 3 (let x 4 x)) x))\n<b>Output:</b> 6\n<b>Explanation:</b> Even though (let x 4 x) has a deeper scope, it is outside the context\nof the final x in the add-expression.  That final x will equal 2.\n\n<b>Input:</b> (let a1 3 b2 (add a1 1) b2) \n<b>Output</b> 4\n<b>Explanation:</b> Variable names can contain digits after the first character.\n\n</pre>\n\n<p><b>Note:</b>\n</p><li>The given string <code>expression</code> is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses.  The expression is guaranteed to be legal and evaluate to an integer.</li>\n<li>The length of <code>expression</code> is at most 2000.  (It is also non-empty, as that would not be a legal expression.)</li>\n<li>The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-recursive-parsing-accepted">Approach #1: Recursive Parsing [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-recursive-parsing-accepted">Approach #1: Recursive Parsing [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>This question is relatively straightforward in terms of the idea of the solution, but presents substantial difficulties in the implementation.</p>\n<p>Expressions may involve the evaluation of other expressions, which motivates a recursive approach.</p>\n<p>One difficulty is managing the correct scope of the variables.  We can use a stack of hashmaps.  As we enter an inner scope defined by parentheses, we need to add that scope to our stack, and when we exit, we need to pop that scope off.</p>\n<p>Our main <code>evaluate</code> function will go through each case of what form the <code>expression</code> could take.</p>\n<ul>\n<li>\n<p>If the expression starts with a digit or \'-\', it\'s an integer: return it.</p>\n</li>\n<li>\n<p>If the expression starts with a letter, it\'s a variable.  Recall it by checking the current scope in reverse order.</p>\n</li>\n<li>\n<p>Otherwise, group the tokens (variables or expressions) within this expression by counting the "balance" <code>bal</code> of the occurrences of <code>\'(\'</code> minus the number of occurrences of <code>\')\'</code>.  When the balance is zero, we have ended a token.  For example, <code>(add 1 (add 2 3))</code> should have tokens <code>\'1\'</code> and <code>\'(add 2 3)\'</code>.</p>\n</li>\n<li>\n<p>For add and mult expressions, evaluate each token and return the addition or multiplication of them.</p>\n</li>\n<li>\n<p>For let expressions, evaluate each expression sequentially and assign it to the variable in the current scope, then return the evaluation of the final expression.</p>\n</li>\n</ul>\n<iframe frameborder="0" height="500" name="NPtxmW53" src="https://leetcode.com/playground/NPtxmW53/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>expression</code>.  Each expression is evaluated once, but within that evaluation we may search the entire scope.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N^2)</script>.  We may pass <script type="math/tex; mode=display">O(N)</script> new strings to our <code>evaluate</code> function when making intermediate evaluations, each of length <script type="math/tex; mode=display">O(N)</script>.  With effort, we could reduce the total space complexity to <script type="math/tex; mode=display">O(N)</script> with interning or passing pointers.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Affirm'],
  },
  {
    id: '737',
    name: 'Sentence Similarity II ',
    acceptance: '40.4%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given two sentences <code>words1, words2</code> (each represented as an array of strings), and a list of similar word pairs <code>pairs</code>, determine if two sentences are similar.\n</p><p>\nFor example, <code>words1 = ["great", "acting", "skills"]</code> and <code>words2 = ["fine", "drama", "talent"]</code> are similar, if the similar word pairs are <code>pairs = [["great", "good"], ["fine", "good"], \n ["acting","drama"], ["skills","talent"]]</code>.\n</p><p>\nNote that the similarity relation <b>is</b> transitive. For example, if "great" and "good" are similar, and "fine" and "good" are similar, then "great" and "fine" <b>are similar</b>.\n</p><p>\nSimilarity is also symmetric.  For example, "great" and "fine" being similar is the same as "fine" and "great" being similar.\n</p><p>\nAlso, a word is always similar with itself.  For example, the sentences <code>words1 = ["great"], words2 = ["great"], pairs = []</code> are similar, even though there are no specified similar word pairs.\n</p><p>\nFinally, sentences can only be similar if they have the same number of words.  So a sentence like <code>words1 = ["great"]</code> can never be similar to <code>words2 = ["doubleplus","good"]</code>.\n</p>\n\n<p><b>Note:</b>\n</p><li>The length of <code>words1</code> and <code>words2</code> will not exceed <code>1000</code>.</li>\n<li>The length of <code>pairs</code> will not exceed <code>2000</code>.</li>\n<li>The length of each <code>pairs[i]</code> will be <code>2</code>.</li>\n<li>The length of each <code>words[i]</code> and <code>pairs[i][j]</code> will be in the range <code>[1, 20]</code>.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</a></li>\n<li><a href="#approach-2-union-find-accepted">Approach #2: Union-Find [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Two words are similar if they are the same, or there is a path connecting them from edges represented by <code>pairs</code>.</p>\n<p>We can check whether this path exists by performing a depth-first search from a word and seeing if we reach the other word.  The search is performed on the underlying graph specified by the edges in <code>pairs</code>.</p>\n<p><strong>Algorithm</strong></p>\n<p>We start by building our <code>graph</code> from the edges in <code>pairs</code>.  </p>\n<p>The specific algorithm we go for is an iterative depth-first search.  The implementation we go for is a typical "visitor pattern": when searching whether there is a path from <code>w1 = words1[i]</code> to <code>w2 = words2[i]</code>, <code>stack</code> will contain all the nodes that are queued up for processing, while <code>seen</code> will be all the nodes that have been queued for processing (whether they have been processed or not).</p>\n<iframe frameborder="0" height="500" name="e6oi8YFg" src="https://leetcode.com/playground/e6oi8YFg/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(NP)</script>, where <script type="math/tex; mode=display">N</script> is the maximum length of <code>words1</code> and <code>words2</code>, and <script type="math/tex; mode=display">P</script> is the length of <code>pairs</code>.  Each of <script type="math/tex; mode=display">N</script> searches could search the entire graph.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(P)</script>, the size of <code>pairs</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-union-find-accepted">Approach #2: Union-Find [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>As in <em>Approach #1</em>, we want to know if there is path connecting two words from edges represented by <code>pairs</code>.</p>\n<p>Our problem comes down to finding the connected components of a graph.  This is a natural fit for a <em>Disjoint Set Union</em> (DSU) structure.</p>\n<p><strong>Algorithm</strong></p>\n<p>Draw edges between words if they are similar.  For easier interoperability between our DSU template, we will map each <code>word</code> to some integer <code>ix = index[word]</code>.  Then, <code>dsu.find(ix)</code> will tell us a unique id representing what component that word is in.</p>\n<p>For more information on DSU, please look at <em>Approach #2</em> in the <a href="https://leetcode.com/articles/redundant-connection/">article here</a>.  For brevity, the solutions showcased below do not use <em>union-by-rank</em>.</p>\n<p>After putting each word in <code>pairs</code> into our DSU template, we check successive pairs of words <code>w1, w2 = words1[i], words2[i]</code>.  We require that <code>w1 == w2</code>, or <code>w1</code> and <code>w2</code> are in the same component.  This is easily checked using <code>dsu.find</code>.</p>\n<iframe frameborder="0" height="500" name="RM4pqebc" src="https://leetcode.com/playground/RM4pqebc/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N \\log P + P)</script>, where <script type="math/tex; mode=display">N</script> is the maximum length of <code>words1</code> and <code>words2</code>, and <script type="math/tex; mode=display">P</script> is the length of <code>pairs</code>.  If we used union-by-rank, this complexity improves to <script type="math/tex; mode=display">O(N * \\alpha(P) + P) \\approx O(N + P)</script>, where <script type="math/tex; mode=display">\\alpha</script> is the <em>Inverse-Ackermann</em> function.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(P)</script>, the size of <code>pairs</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '738',
    name: 'Monotone Increasing Digits',
    acceptance: '41.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a non-negative integer <code>N</code>, find the largest number that is less than or equal to <code>N</code> with monotone increasing digits.\n</p><p>\n(Recall that an integer has <i>monotone increasing digits</i> if and only if each pair of adjacent digits <code>x</code> and <code>y</code> satisfy <code>x &lt;= y</code>.)\n</p><p>\n\n</p><p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> N = 10\n<b>Output:</b> 9\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> N = 1234\n<b>Output:</b> 1234\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> N = 332\n<b>Output:</b> 299\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n<code>N</code> is an integer in the range <code>[0, 10^9]</code>.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-greedy-accepted">Approach #1: Greedy [Accepted]</a></li>\n<li><a href="#approach-2-truncate-after-cliff-accepted">Approach #2: Truncate After Cliff [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-greedy-accepted">Approach #1: Greedy [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Let\'s construct the answer digit by digit.</p>\n<p>If the current answer is say, <code>123</code>, and the next digit is <code>5</code>, then the answer must be at least <code>123555...5</code>, since the digits in the answer must be monotonically increasing.  If this is larger than <code>N</code>, then it\'s impossible.</p>\n<p><strong>Algorithm</strong></p>\n<p>For each digit of <code>N</code>, let\'s build the next digit of our answer <code>ans</code>.  We\'ll find the smallest possible digit <code>d</code> such that <code>ans + (d repeating) &gt; N</code> when comparing by string; that means <code>d-1</code> must have satisfied <code>ans + (d-1 repeating) &lt;= N</code>, and so we\'ll add <code>d-1</code> to our answer.  If we don\'t find such a digit, we can add a <code>9</code> instead.</p>\n<iframe frameborder="0" height="429" name="FBLCwPuk" src="https://leetcode.com/playground/FBLCwPuk/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(D^2)</script>, where <script type="math/tex; mode=display">D \\approx \\log N</script> is the number of digits in <script type="math/tex; mode=display">N</script>.  We do <script type="math/tex; mode=display">O(D)</script> work building and comparing each candidate, and we do this <script type="math/tex; mode=display">O(D)</script> times.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(D)</script>, the size of the answer and the temporary string we are comparing.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-truncate-after-cliff-accepted">Approach #2: Truncate After Cliff [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>One initial thought that comes to mind is we can always have a candidate answer of <code>d999...9</code> (a digit <code>0 &lt;= d &lt;= 9</code> followed by some number of nines.)  For example if <code>N = 432543654</code>, we could always have an answer of at least <code>399999999</code>.</p>\n<p>We can do better.  For example, when the number is <code>123454321</code>, we could have a candidate of <code>123449999</code>.  It seems like a decent strategy is to take a monotone increasing prefix of <code>N</code>, then decrease the number before the "cliff" (the index where adjacent digits decrease for the first time) if it exists, and replace the rest of the characters with <code>9</code>s.</p>\n<p>When does that strategy fail?  If <code>N = 333222</code>, then our strategy would give us the candidate answer of <code>332999</code> - but this isn\'t monotone increasing.  However, since we are looking at all indexes before the original first occurrence of a cliff, the only place where a cliff could exist, is next to where we just decremented a digit.</p>\n<p>Thus, we can repair our strategy, by successfully morphing our answer <code>332999 -&gt; 329999 -&gt; 299999</code> with a linear scan.</p>\n<p><strong>Algorithm</strong></p>\n<p>We\'ll find the first cliff <code>S[i-1] &gt; S[i]</code>.  Then, while the cliff exists, we\'ll decrement the appropriate digit and move <code>i</code> back.  Finally, we\'ll make the rest of the digits <code>9</code>s and return our work.</p>\n<p>We can prove our algorithm is correct because every time we encounter a cliff, the digit we decrement has to decrease by at least 1.  Then, the largest possible selection for the rest of the digits is all nines, which is always going to be monotone increasing with respect to the other digits occurring earlier in the number.</p>\n<iframe frameborder="0" height="242" name="yeDAMaRm" src="https://leetcode.com/playground/yeDAMaRm/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(D)</script>, where <script type="math/tex; mode=display">D \\approx \\log N</script> is the number of digits in <script type="math/tex; mode=display">N</script>.  Each step in the algorithm is a linear scan of the digits.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(D)</script>, the size of the answer.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '739',
    name: 'Daily Temperatures',
    acceptance: '52.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a list of daily <code>temperatures</code>, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature.  If there is no future day for which this is possible, put <code>0</code> instead.\n</p><p>\nFor example, given the list <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>, your output should be <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>.\n</p>\n\n<p><b>Note:</b>\nThe length of <code>temperatures</code> will be in the range <code>[1, 30000]</code>.\nEach temperature will be an integer in the range <code>[30, 100]</code>.\n</p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-next-array-accepted">Approach #1: Next Array [Accepted]</a></li>\n<li><a href="#approach-2-stack-accepted">Approach #2: Stack [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-next-array-accepted">Approach #1: Next Array [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>The problem statement asks us to find the next occurrence of a warmer temperature.  Because temperatures can only be in <code>[30, 100]</code>, if the temperature right now is say, <code>T[i] = 50</code>, we only need to check for the next occurrence of <code>51</code>, <code>52</code>, ..., <code>100</code> and take the one that occurs soonest.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let\'s process each <code>i</code> in reverse (decreasing order).  At each <code>T[i]</code>, to know when the next occurrence of say, temperature <code>100</code> is, we should just remember the last one we\'ve seen, <code>next[100]</code>.</p>\n<p>Then, the first occurrence of a warmer value occurs at <code>warmer_index</code>, the minimum of <code>next[T[i]+1], next[T[i]+2], ..., next[100]</code>.</p>\n<iframe frameborder="0" height="361" name="zXoveQ5r" src="https://leetcode.com/playground/zXoveQ5r/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(NW)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>T</code> and <script type="math/tex; mode=display">W</script> is the number of allowed values for <code>T[i]</code>.  Since <script type="math/tex; mode=display">W = 71</script>, we can consider this complexity <script type="math/tex; mode=display">O(N)</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N + W)</script>, the size of the answer and the next array.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-stack-accepted">Approach #2: Stack [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Consider trying to find the next warmer occurrence at <code>T[i]</code>.  What information (about <code>T[j]</code> for <code>j &gt; i</code>) must we remember?</p>\n<p>Say we are trying to find <code>T[0]</code>.  If we remembered <code>T[10] = 50</code>, knowing <code>T[20] = 50</code> wouldn\'t help us, as any <code>T[i]</code> that has its next warmer ocurrence at <code>T[20]</code> would have it at <code>T[10]</code> instead.  However, <code>T[20] = 100</code> would help us, since if <code>T[0]</code> were <code>80</code>, then <code>T[20]</code> might be its next warmest occurrence, while <code>T[10]</code> couldn\'t.</p>\n<p>Thus, we should remember a list of indices representing a strictly increasing list of temperatures.  For example, <code>[10, 20, 30]</code> corresponding to temperatures <code>[50, 80, 100]</code>.  When we get a new temperature like <code>T[i] = 90</code>, we will have <code>[5, 30]</code> as our list of indices (corresponding to temperatures <code>[90, 100]</code>).  The most basic structure that will satisfy our requirements is a <em>stack</em>, where the top of the stack is the first value in the list, and so on.</p>\n<p><strong>Algorithm</strong></p>\n<p>As in <em>Approach #1</em>, process indices <code>i</code> in descending order.  We\'ll keep a <code>stack</code> of indices such that <code>T[stack[-1]] &lt; T[stack[-2]] &lt; ...</code>, where <code>stack[-1]</code> is the top of the stack, <code>stack[-2]</code> is second from the top, and so on; and where <code>stack[-1] &gt; stack[-2] &gt; ...</code>; and we will maintain this invariant as we process each temperature.</p>\n<p>After, it is easy to know the next occurrence of a warmer temperature: it\'s simply the top index in the stack.</p>\n<p>Here is a worked example of the contents of the <code>stack</code> as we work through <code>T = [73, 74, 75, 71, 69, 72, 76, 73]</code> in reverse order, at the end of the loop (after we add <code>T[i]</code>).  For clarity, <code>stack</code> only contains indices <code>i</code>, but we will write the value of <code>T[i]</code> beside it in brackets, such as <code>0 (73)</code>.</p>\n<ul>\n<li>When <code>i = 7</code>, <code>stack = [7 (73)]</code>.  <code>ans[i] = 0</code>.</li>\n<li>When <code>i = 6</code>, <code>stack = [6 (76)]</code>.  <code>ans[i] = 0</code>.</li>\n<li>When <code>i = 5</code>, <code>stack = [5 (72), 6 (76)]</code>.  <code>ans[i] = 1</code>.</li>\n<li>When <code>i = 4</code>, <code>stack = [4 (69), 5 (72), 6 (76)]</code>.  <code>ans[i] = 1</code>.</li>\n<li>When <code>i = 3</code>, <code>stack = [3 (71), 5 (72), 6 (76)]</code>.  <code>ans[i] = 2</code>.</li>\n<li>When <code>i = 2</code>, <code>stack = [2 (75), 6 (76)]</code>.  <code>ans[i] = 4</code>.</li>\n<li>When <code>i = 1</code>, <code>stack = [1 (74), 2 (75), 6 (76)]</code>.  <code>ans[i] = 1</code>.</li>\n<li>When <code>i = 0</code>, <code>stack = [0 (73), 1 (74), 2 (75), 6 (76)]</code>.  <code>ans[i] = 1</code>.</li>\n</ul>\n<iframe frameborder="0" height="259" name="GrKNCrcf" src="https://leetcode.com/playground/GrKNCrcf/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>T</code> and <script type="math/tex; mode=display">W</script> is the number of allowed values for <code>T[i]</code>.  Each index gets pushed and popped at most once from the stack.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(W)</script>.  The size of the stack is bounded as it represents strictly increasing temperatures.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '740',
    name: 'Delete and Earn',
    acceptance: '42.0%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nGiven an array <code>nums</code> of integers, you can perform operations on the array.\n</p><p>\nIn each operation, you pick any <code>nums[i]</code> and delete it to earn <code>nums[i]</code> points.  After, you must delete <b>every</b> element equal to <code>nums[i] - 1</code> or <code>nums[i] + 1</code>.\n</p><p>\nYou start with 0 points.  Return the maximum number of points you can earn by applying such operations.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> nums = [3, 4, 2]\n<b>Output:</b> 6\n<b>Explanation:</b> \nDelete 4 to earn 4 points, consequently 3 is also deleted.\nThen, delete 2 to earn 2 points. 6 total points are earned.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> nums = [2, 2, 3, 3, 3, 4]\n<b>Output:</b> 9\n<b>Explanation:</b> \nDelete 3 to earn 3 points, deleting both 2's and the 4.\nThen, delete 3 again to earn 3 points, and 3 again to earn 3 points.\n9 total points are earned.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>The length of <code>nums</code> is at most <code>20000</code>.</li>\n<li>Each element <code>nums[i]</code> is an integer in the range <code>[1, 10000]</code>.</li>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Because all numbers are positive, if we "take" a number (use it to score points), we might as well take all copies of it, since we\'ve already erased all its neighbors.  We could keep a count of each number so we know how many points taking a number is worth total.</p>\n<p>Now let\'s investigate what happens when we add a new number <code>X</code> (plus copies) that is larger than all previous numbers.  Naively, our answer would be the previous answer, plus the value of <code>X</code> - which can be solved with dynamic programming.  However, this fails if our previous answer had a number taken that was adjacent to <code>X</code>.</p>\n<p>Luckily, we can remedy this.  Let\'s say we knew <code>using</code>, the value of our previous answer, and <code>avoid</code>, the value of our previous answer that doesn\'t use the previously largest value <code>prev</code>.  Then we could compute new values of <code>using</code> and <code>avoid</code> appropriately.</p>\n<p><strong>Algorithm</strong></p>\n<p>For each unique value <code>k</code> of <code>nums</code> in increasing order, let\'s maintain the correct values of <code>avoid</code> and <code>using</code>, which represent the answer if we don\'t take or take <code>k</code> respectively.</p>\n<p>If the new value <code>k</code> is adjacent to the previously largest value <code>prev</code>, then the answer if we must take <code>k</code> is <code>(the point value of k) + avoid</code>, while the answer if we must not take <code>k</code> is <code>max(avoid, using)</code>.  Similarly, if <code>k</code> is not adjacent to <code>prev</code>, the answer if we must take <code>k</code> is <code>(the point value of k) + max(avoid, using)</code>, and the answer if we must not take <code>k</code> is <code>max(avoid, using)</code>.</p>\n<p>At the end, the best answer may or may not use the largest value in <code>nums</code>, so we return <code>max(avoid, using)</code>.</p>\n<p>Our demonstrated solutions showcase two different kinds of sorts: a library one, and a radix sort.  For each language, the other kind of solution can be done without much difficulty, by using an array (Python) or HashMap (Java) respectively.</p>\n<iframe frameborder="0" height="395" name="TBKVkiLD" src="https://leetcode.com/playground/TBKVkiLD/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity (Python): <script type="math/tex; mode=display">O(N \\log N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>.  We make a single pass through the sorted keys of <script type="math/tex; mode=display">N</script>, and the complexity is dominated by the sorting step.</p>\n</li>\n<li>\n<p>Space Complexity (Python): <script type="math/tex; mode=display">O(N)</script>, the size of our <code>count</code>.</p>\n</li>\n<li>\n<p>Time Complexity (Java): We performed a radix sort instead, so our complexity is <script type="math/tex; mode=display">O(N+W)</script> where <script type="math/tex; mode=display">W</script> is the range of allowable values for <code>nums[i]</code>.</p>\n</li>\n<li>\n<p>Space Complexity (Java): <script type="math/tex; mode=display">O(W)</script>, the size of our <code>count</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Akuna Capital'],
  },
  {
    id: '741',
    name: 'Cherry Pickup',
    acceptance: '22.4%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nIn a N x N <code>grid</code> representing a field of cherries, each cell is one of three possible integers.\n</p><p>\n</p><li>0 means the cell is empty, so you can pass through;</li>\n<li>1 means the cell contains a cherry, that you can pick up and pass through;</li>\n<li>-1 means the cell contains a thorn that blocks your way.</li>\n<p></p><p>\nYour task is to collect maximum number of cherries possible by following the rules below:\n</p><p>\n</p><li>Starting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1);</li>\n<li>After reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells;</li>\n<li>When passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0);</li>\n<li>If there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected.</li>\n<p></p><p>\n\n</p><p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> grid =\n[[0, 1, -1],\n [1, 0, -1],\n [1, 1,  1]]\n<b>Output:</b> 5\n<b>Explanation:</b> \nThe player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible.\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li><code>grid</code> is an <code>N</code> by <code>N</code> 2D array, with <code>1 &lt;= N &lt;= 50</code>.</li>\n<li>Each <code>grid[i][j]</code> is an integer in the set <code>{-1, 0, 1}</code>.</li>\n<li>It is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1.</li><li>\n<p></p>\n          </li>',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-greedy-wrong-answer">Approach #1: Greedy [Wrong Answer]</a></li>\n<li><a href="#approach-2-dynamic-programming-top-down-accepted">Approach #2: Dynamic Programming (Top Down) [Accepted]</a></li>\n<li><a href="#approach-3-dynamic-programming-bottom-up-accepted">Approach #3: Dynamic Programming (Bottom Up) [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-greedy-wrong-answer">Approach #1: Greedy [Wrong Answer]</h4>\n<p><strong>Intuition</strong></p>\n<p>Let\'s find the most cherries we can pick up with one path, pick them up, then find the most cherries we can pick up with a second path on the remaining field.</p>\n<p>Though a counter example might be hard to think of, this approach fails to find the best answer to this case:</p>\n<div class="codehilite"><pre><span></span><span class="mi">11100</span>\n<span class="mo">00101</span>\n<span class="mi">10100</span>\n<span class="mo">00100</span>\n<span class="mo">00111</span>\n</pre></div>\n<p><strong>Algorithm</strong></p>\n<p>We can use dynamic programming to find the most number of cherries <code>dp[i][j]</code> that can be picked up from any location <code>(i, j)</code> to the bottom right corner.  This is a classic question very similar to <a href="https://leetcode.com/problems/minimum-path-sum/description/">Minimum Path Sum</a>, refer to the link if you are not familiar with this type of question.</p>\n<p>After, we can find an first path that maximizes the number of cherries taken by using our completed <code>dp</code> as an oracle for deciding where to move.  We\'ll choose the move that allows us to pick up more cherries (based on comparing <code>dp[i+1][j]</code> and <code>dp[i][j+1]</code>).</p>\n<p>After taking the cherries from that path (and removing it from the grid), we\'ll take the cherries again.</p>\n<iframe frameborder="0" height="500" name="DezZpWur" src="https://leetcode.com/playground/DezZpWur/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>grid</code>.  Our dynamic programming consists of two for-loops of length <code>N</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N^2)</script>, the size of <code>dp</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-dynamic-programming-top-down-accepted">Approach #2: Dynamic Programming (Top Down) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Instead of walking from end to beginning, let\'s reverse the second leg of the path, so we are only considering two paths from the beginning to the end.</p>\n<p>Notice after <code>t</code> steps, each position <code>(r, c)</code> we could be, is on the line <code>r + c = t</code>.  So if we have two people at positions <code>(r1, c1)</code> and <code>(r2, c2)</code>, then <code>r2 = r1 + c1 - c2</code>.  That means the variables <code>r1, c1, c2</code> uniquely determine 2 people who have walked the same <code>r1 + c1</code> number of steps.  This sets us up for dynamic programming quite nicely.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let <code>dp[r1][c1][c2]</code> be the most number of cherries obtained by two people starting at <code>(r1, c1)</code> and <code>(r2, c2)</code> and walking towards <code>(N-1, N-1)</code> picking up cherries, where <code>r2 = r1+c1-c2</code>.</p>\n<p>If <code>grid[r1][c1]</code> and <code>grid[r2][c2]</code> are not thorns, then the value of <code>dp[r1][c1][c2]</code> is <code>(grid[r1][c1] + grid[r2][c2])</code>, plus the maximum of <code>dp[r1+1][c1][c2]</code>, <code>dp[r1][c1+1][c2]</code>, <code>dp[r1+1][c1][c2+1]</code>, <code>dp[r1][c1+1][c2+1]</code> as appropriate.  We should also be careful to not double count in case <code>(r1, c1) == (r2, c2)</code>.</p>\n<iframe frameborder="0" height="500" name="ykWmWdzo" src="https://leetcode.com/playground/ykWmWdzo/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^3)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>grid</code>.  Our dynamic programming has <script type="math/tex; mode=display">O(N^3)</script> states.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N^3)</script>, the size of <code>memo</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-dynamic-programming-bottom-up-accepted">Approach #3: Dynamic Programming (Bottom Up) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Like in <em>Approach #2</em>, we have the idea of dynamic programming.</p>\n<p>Say <code>r1 + c1 = t</code> is the <code>t</code>-th layer.  Since our recursion only references the next layer, we only need to keep two layers in memory at a time.</p>\n<p><strong>Algorithm</strong></p>\n<p>At time <code>t</code>, let <code>dp[c1][c2]</code> be the most cherries that we can pick up for two people going from <code>(0, 0)</code> to <code>(r1, c1)</code> and <code>(0, 0)</code> to <code>(r2, c2)</code>, where <code>r1 = t-c1, r2 = t-c2</code>.  Our dynamic program proceeds similarly to <em>Approach #2</em>.</p>\n<iframe frameborder="0" height="500" name="dC4XmymT" src="https://leetcode.com/playground/dC4XmymT/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^3)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>grid</code>.  We have three for-loops of size <script type="math/tex; mode=display">O(N)</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N^2)</script>, the sizes of <code>dp</code> and <code>dp2</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.  Solution 3 inspired by <a href="https://leetcode.com/contest/weekly-contest-61/ranking">@uwi</a>.</p>\n</div>\n          ',
    tags: ['Akuna Capital'],
  },
  {
    id: '742',
    name: 'Closest Leaf in a Binary Tree ',
    acceptance: '31.6%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>Given a binary tree <b>where every node has a unique value</b>, and a target key <code>k</code>, find the value of the nearest leaf node to target <code>k</code> in the tree.\n</p><p>\nHere, <i>nearest</i> to a leaf means the least number of edges travelled on the binary tree to reach any leaf of the tree.  Also, a node is called a <i>leaf</i> if it has no children.\n</p><p>\nIn the following examples, the input tree is represented in flattened form row by row.\nThe actual <code>root</code> tree given will be a TreeNode object.\n</p><p>\n<b>Example 1:</b>\n</p><pre><b>Input:</b>\nroot = [1, 3, 2], k = 1\nDiagram of binary tree:\n          1\n         / \\\n        3   2\n\n<b>Output:</b> 2 (or 3)\n\n<b>Explanation:</b> Either 2 or 3 is the nearest leaf node to the target of 1.\n</pre>\n<p></p><p>\n<b>Example 2:</b>\n</p><pre><b>Input:</b>\nroot = [1], k = 1\n<b>Output:</b> 1\n\n<b>Explanation:</b> The nearest leaf node is the root node itself.\n</pre>\n<p></p>\n\n<p>\n<b>Example 3:</b>\n</p><pre><b>Input:</b>\nroot = [1,2,3,4,null,null,null,5,null,6], k = 2\nDiagram of binary tree:\n             1\n            / \\\n           2   3\n          /\n         4\n        /\n       5\n      /\n     6\n\n<b>Output:</b> 3\n<b>Explanation:</b> The leaf node with value 3 (and not the leaf node with value 6) is nearest to the node with value 2.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li><code>root</code> represents a binary tree with at least <code>1</code> node and at most <code>1000</code> nodes.</li>\n<li>Every node has a unique <code>node.val</code> in range <code>[1, 1000]</code>.</li>\n<li>There exists some node in the given binary tree for which <code>node.val == k</code>.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-convert-to-graph-accepted">Approach #1: Convert to Graph [Accepted]</a></li>\n<li><a href="#approach-2-annotate-closest-leaf-accepted">Approach #2: Annotate Closest Leaf [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-convert-to-graph-accepted">Approach #1: Convert to Graph [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Instead of a binary tree, if we converted the tree to a general graph, we could find the shortest path to a leaf using breadth-first search.</p>\n<p><strong>Algorithm</strong></p>\n<p>We use a depth-first search to record in our graph each edge travelled from parent to node.</p>\n<p>After, we use a breadth-first search on nodes that started with a value of <code>k</code>, so that we are visiting nodes in order of their distance to <code>k</code>.  When the node is a leaf (it has one outgoing edge, where the <code>root</code> has a "ghost" edge to <code>null</code>), it must be the answer.</p>\n<iframe frameborder="0" height="500" name="aNFt9XoX" src="https://leetcode.com/playground/aNFt9XoX/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script> where <script type="math/tex; mode=display">N</script> is the number of nodes in the given input tree.  We visit every node a constant number of times.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of the graph.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-annotate-closest-leaf-accepted">Approach #2: Annotate Closest Leaf [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Say from each node, we already knew where the closest leaf in it\'s subtree is.  Using any kind of traversal plus memoization, we can remember this information.</p>\n<p>Then the closest leaf to the target (in general, not just subtree) has to have a lowest common ancestor with the <code>target</code> that is on the path from the <code>root</code> to the <code>target</code>.  We can find the path from <code>root</code> to <code>target</code> via any kind of traversal, and look at our annotation for each node on this path to determine all leaf candidates, choosing the best one.</p>\n<iframe frameborder="0" height="500" name="2PTUezHd" src="https://leetcode.com/playground/2PTUezHd/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>Time and Space Complexity: <script type="math/tex; mode=display">O(N)</script>.  The analysis is the same as in <em>Approach #1</em>.</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Amazon', 'databricks'],
  },
  {
    id: '743',
    name: 'Network Delay Time',
    acceptance: '32.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nThere are <code>N</code> network nodes, labelled <code>1</code> to <code>N</code>.\n</p><p>\nGiven <code>times</code>, a list of travel times as <b>directed</b> edges <code>times[i] = (u, v, w)</code>, where <code>u</code> is the source node, <code>v</code> is the target node, and <code>w</code> is the time it takes for a signal to travel from source to target.\n</p><p>\nNow, we send a signal from a certain node <code>K</code>.  How long will it take for all nodes to receive the signal?  If it is impossible, return <code>-1</code>.\n</p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li><code>N</code> will be in the range <code>[1, 100]</code>.</li>\n<li><code>K</code> will be in the range <code>[1, N]</code>.</li>\n<li>The length of <code>times</code> will be in the range <code>[1, 6000]</code>.</li>\n<li>All edges <code>times[i] = (u, v, w)</code> will have <code>1 &lt;= u, v &lt;= N</code> and <code>1 &lt;= w &lt;= 100</code>.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</a></li>\n<li><a href="#approach-2-dijkstras-algorithm-accepted">Approach #2: Dijkstra\'s Algorithm [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-depth-first-search-accepted">Approach #1: Depth-First Search [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Let\'s record the time <code>dist[node]</code> when the signal reaches the node.  If some signal arrived earlier, we don\'t need to broadcast it anymore.  Otherwise, we should broadcast the signal.</p>\n<p><strong>Algorithm</strong></p>\n<p>We\'ll maintain <code>dist[node]</code>, the earliest that we arrived at each <code>node</code>.  When visiting a <code>node</code> while <code>elapsed</code> time has elapsed, if this is the currently-fastest signal at this node, let\'s broadcast signals from this node.</p>\n<p>To speed things up, at each visited node we\'ll consider signals exiting the node that are faster first, by sorting the edges.</p>\n<iframe frameborder="0" height="500" name="YadsYraY" src="https://leetcode.com/playground/YadsYraY/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^N + E \\log E)</script> where <script type="math/tex; mode=display">E</script> is the length of <code>times</code>.  We can only fully visit each node up to <script type="math/tex; mode=display">N-1</script> times, one per each other node.  Plus, we have to explore every edge and sort them.  Sorting each small bucket of outgoing edges is bounded by sorting all of them, because of repeated use of the inequality <script type="math/tex; mode=display">x \\log x + y \\log y \\leq (x+y) \\log (x+y)</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N + E)</script>, the size of the graph (<script type="math/tex; mode=display">O(E)</script>), plus the size of the implicit call stack in our DFS (<script type="math/tex; mode=display">O(N)</script>).</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-dijkstras-algorithm-accepted">Approach #2: Dijkstra\'s Algorithm [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>We use <em>Dijkstra\'s algorithm</em> to find the shortest path from our source to all targets.  This is a textbook algorithm, refer to <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">this link</a> for more details.</p>\n<p>Dijkstra\'s algorithm is based on repeatedly making the candidate move that has the least distance travelled.</p>\n<p>In our implementations below, we showcase both <script type="math/tex; mode=display">O(N^2)</script> (basic) and <script type="math/tex; mode=display">O(N \\log N)</script> (heap) approaches.</p>\n<p><em>Basic Implementation</em>\n<iframe frameborder="0" height="500" name="HxrhmhUo" src="https://leetcode.com/playground/HxrhmhUo/shared" width="100%"></iframe></p>\n<p><em>Heap Implementation</em></p>\n<iframe frameborder="0" height="500" name="FAHPcmsE" src="https://leetcode.com/playground/FAHPcmsE/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2 + E)</script>m where <script type="math/tex; mode=display">E</script> is the length of <code>times</code> in the basic implementation, and <script type="math/tex; mode=display">O(E \\log E)</script> in the heap implementation, as potentially every edge gets added to the heap.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N + E)</script>, the size of the graph (<script type="math/tex; mode=display">O(E)</script>), plus the size of the other objects used (<script type="math/tex; mode=display">O(N)</script>).</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Akuna Capital'],
  },
  {
    id: '744',
    name: 'Find Smallest Letter Greater Than Target',
    acceptance: '50.5%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a list of sorted characters <code>letters</code> containing only lowercase letters, and given a target letter <code>target</code>, find the smallest element in the list that is larger than the given target.\n</p><p>\nLetters also wrap around.  For example, if the target is <code>target = \'z\'</code> and <code>letters = [\'a\', \'b\']</code>, the answer is <code>\'a\'</code>.\n</p>\n\n<p><b>Examples:</b><br>\n</p><pre><b>Input:</b>\nletters = ["c", "f", "j"]\ntarget = "a"\n<b>Output:</b> "c"\n\n<b>Input:</b>\nletters = ["c", "f", "j"]\ntarget = "c"\n<b>Output:</b> "f"\n\n<b>Input:</b>\nletters = ["c", "f", "j"]\ntarget = "d"\n<b>Output:</b> "f"\n\n<b>Input:</b>\nletters = ["c", "f", "j"]\ntarget = "g"\n<b>Output:</b> "j"\n\n<b>Input:</b>\nletters = ["c", "f", "j"]\ntarget = "j"\n<b>Output:</b> "c"\n\n<b>Input:</b>\nletters = ["c", "f", "j"]\ntarget = "k"\n<b>Output:</b> "c"\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li><code>letters</code> has a length in range <code>[2, 10000]</code>.</li>\n<li><code>letters</code> consists of lowercase letters, and contains at least 2 unique letters.</li>\n<li><code>target</code> is a lowercase letter.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-record-letters-seen-accepted">Approach #1: Record Letters Seen [Accepted]</a></li>\n<li><a href="#approach-2-linear-scan-accepted">Approach #2: Linear Scan [Accepted]</a></li>\n<li><a href="#approach-3-binary-search-accepted">Approach #3: Binary Search [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-record-letters-seen-accepted">Approach #1: Record Letters Seen [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Let\'s scan through <code>letters</code> and record if we see a letter or not.  We could do this with an array of size 26, or with a Set structure.</p>\n<p>Then, for every next letter (starting with the letter that is one greater than the target), let\'s check if we\'ve seen it.  If we have, it must be the answer.</p>\n<iframe frameborder="0" height="276" name="auZQ7CwK" src="https://leetcode.com/playground/auZQ7CwK/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>letters</code>.  We scan every element of the array.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>, the maximum size of <code>seen</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-linear-scan-accepted">Approach #2: Linear Scan [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Since <code>letters</code> are sorted, if we see something larger when scanning form left to right, it must be the answer.  Otherwise, (since <code>letters</code> is non-empty), the answer is <code>letters[0]</code>.</p>\n<iframe frameborder="0" height="174" name="RvMYaXpq" src="https://leetcode.com/playground/RvMYaXpq/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>letters</code>.  We scan every element of the array.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>, as we maintain only pointers.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-binary-search-accepted">Approach #3: Binary Search [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Like in <em>Approach #2</em>, we want to find something larger than target in a sorted array.  This is ideal for a <em>binary search</em>: Let\'s find the rightmost position to insert <code>target</code> into <code>letters</code> so that it remains sorted.</p>\n<p>Our binary search (a typical one) proceeds in a number of rounds.  At each round, let\'s maintain the <em>loop invariant</em> that the answer must be in the interval <code>[lo, hi]</code>.  Let <code>mi = (lo + hi) / 2</code>.  If <code>letters[mi] &lt;= target</code>, then we must insert it in the interval <code>[mi + 1, hi]</code>.  Otherwise, we must insert it in the interval <code>[lo, mi]</code>.</p>\n<p>At the end, if our insertion position says to insert <code>target</code> into the last position <code>letters.length</code>, we return <code>letters[0]</code> instead.  This is what the modulo operation does.</p>\n<iframe frameborder="0" height="242" name="bQDjgxiu" src="https://leetcode.com/playground/bQDjgxiu/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(\\log N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>letters</code>.  We peek only at <script type="math/tex; mode=display">\\log N</script> elements in the array.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>, as we maintain only pointers.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['LinkedIn'],
  },
  {
    id: '745',
    name: 'Prefix and Suffix Search',
    acceptance: '21.5%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nGiven many <code>words</code>, <code>words[i]</code> has weight <code>i</code>.\n</p><p>\nDesign a class <code>WordFilter</code> that supports one function, <code>WordFilter.f(String prefix, String suffix)</code>.\nIt will return the word with given <code>prefix</code> and <code>suffix</code> with maximum weight.  If no word exists, return -1.\n</p>\n\n<p><b>Examples:</b><br>\n</p><pre><b>Input:</b>\nWordFilter(["apple"])\nWordFilter.f("a", "e") // returns 0\nWordFilter.f("b", "") // returns -1\n</pre><p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li><code>words</code> has length in range <code>[1, 15000]</code>.</li>\n<li>For each test case, up to <code>words.length</code> queries <code>WordFilter.f</code> may be made.</li>\n<li><code>words[i]</code> has length in range <code>[1, 10]</code>.</li>\n<li><code>prefix, suffix</code> have lengths in range <code>[0, 10]</code>.</li>\n<li><code>words[i]</code> and <code>prefix, suffix</code> queries consist of lowercase letters only.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-trie-set-intersection-time-limit-exceeded">Approach #1: Trie + Set Intersection [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-paired-trie-accepted">Approach #2: Paired Trie [Accepted]</a></li>\n<li><a href="#approach-3-trie-of-suffix-wrapped-words-accepted">Approach #3: Trie of Suffix Wrapped Words [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-trie-set-intersection-time-limit-exceeded">Approach #1: Trie + Set Intersection [Time Limit Exceeded]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>We use two tries to separately find all words that match the prefix, plus all words that match the suffix.  Then, we try to find the highest weight element in the intersection of these sets.</p>\n<p>Of course, these sets could still be large, so we might TLE if we aren\'t careful.</p>\n<iframe frameborder="0" height="500" name="ihA9cm57" src="https://leetcode.com/playground/ihA9cm57/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(NK + Q(N+K))</script> where <script type="math/tex; mode=display">N</script> is the number of words, <script type="math/tex; mode=display">K</script> is the maximum length of a word, and <script type="math/tex; mode=display">Q</script> is the number of queries.  If we use memoization in our solution, we could produce tighter bounds for this complexity, as the complex queries are somewhat disjoint.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(NK)</script>, the size of the tries.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-paired-trie-accepted">Approach #2: Paired Trie [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Say we are inserting the word <code>apple</code>.  We could insert <code>(\'a\', \'e\'), (\'p\', \'l\'), (\'p\', \'p\'), (\'l\', \'p\'), (\'e\', \'a\')</code> into our trie.  Then, if we had equal length queries like <code>prefix = "ap", suffix = "le"</code>, we could find the node <code>trie[\'a\', \'e\'][\'p\', \'l\']</code> in our trie.  This seems promising.</p>\n<p>What about queries that aren\'t equal?  We should just insert them like normal.  For example, to capture a case like <code>prefix = "app", suffix = "e"</code>, we could create nodes <code>trie[\'a\', \'e\'][\'p\', None][\'p\', None]</code>.</p>\n<p>After inserting these pairs into our trie, our searches are straightforward.</p>\n<iframe frameborder="0" height="500" name="rphE5ncp" src="https://leetcode.com/playground/rphE5ncp/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(NK^2 + QK)</script> where <script type="math/tex; mode=display">N</script> is the number of words, <script type="math/tex; mode=display">K</script> is the maximum length of a word, and <script type="math/tex; mode=display">Q</script> is the number of queries.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(NK^2)</script>, the size of the trie.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-3-trie-of-suffix-wrapped-words-accepted">Approach #3: Trie of Suffix Wrapped Words [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Consider the word <code>\'apple\'</code>.  For each suffix of the word, we could insert that suffix, followed by <code>\'#\'</code>, followed by the word, all into the trie.</p>\n<p>For example, we will insert <code>\'#apple\', \'e#apple\', \'le#apple\', \'ple#apple\', \'pple#apple\', \'apple#apple\'</code> into the trie.  Then for a query like <code>prefix = "ap", suffix = "le"</code>, we can find it by querying our trie for <code>le#ap</code>.</p>\n<iframe frameborder="0" height="500" name="hSdRfBf4" src="https://leetcode.com/playground/hSdRfBf4/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(NK^2 + QK)</script> where <script type="math/tex; mode=display">N</script> is the number of words, <script type="math/tex; mode=display">K</script> is the maximum length of a word, and <script type="math/tex; mode=display">Q</script> is the number of queries.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(NK^2)</script>, the size of the trie.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '746',
    name: 'Min Cost Climbing Stairs',
    acceptance: '47.9%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nOn a staircase, the <code>i</code>-th step has some non-negative cost <code>cost[i]</code> assigned (0 indexed).\n</p><p>\nOnce you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> cost = [10, 15, 20]\n<b>Output:</b> 15\n<b>Explanation:</b> Cheapest is start on cost[1], pay that cost and go to the top.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n<b>Output:</b> 6\n<b>Explanation:</b> Cheapest is start on cost[0], and only step on 1s, skipping cost[3].\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li><code>cost</code> will have a length in the range <code>[2, 1000]</code>.</li>\n<li>Every <code>cost[i]</code> will be an integer in the range <code>[0, 999]</code>.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-dynamic-programming-accepted">Approach #1: Dynamic Programming [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>There is a clear recursion available: the final cost <code>f[i]</code> to climb the staircase from some step <code>i</code> is <code>f[i] = cost[i] + min(f[i+1], f[i+2])</code>.  This motivates <em>dynamic programming</em>.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let\'s evaluate <code>f</code> backwards in order.  That way, when we are deciding what <code>f[i]</code> will be, we\'ve already figured out <code>f[i+1]</code> and <code>f[i+2]</code>.</p>\n<p>We can do even better than that.  At the <code>i</code>-th step, let <code>f1, f2</code> be the old value of <code>f[i+1]</code>, <code>f[i+2]</code>, and update them to be the new values <code>f[i], f[i+1]</code>.  We keep these updated as we iterate through <code>i</code> backwards.  At the end, we want <code>min(f1, f2)</code>.</p>\n<iframe frameborder="0" height="242" name="R8h7KgV3" src="https://leetcode.com/playground/R8h7KgV3/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script> where <script type="math/tex; mode=display">N</script> is the length of <code>cost</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>, the space used by <code>f1, f2</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '747',
    name: 'Largest Number At Least Twice of Others',
    acceptance: '45.3%',
    difficulty: 'Easy',
    questionHtml:
      "\n            <br>\n            <p>\nIn a given integer array <code>nums</code>, there is always exactly one largest element.\n</p><p>\nFind whether the largest element in the array is at least twice as much as every other number in the array.\n</p><p>\nIf it is, return the <b>index</b> of the largest element, otherwise return -1.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> nums = [3, 6, 1, 0]\n<b>Output:</b> 1\n<b>Explanation:</b> 6 is the largest integer, and for every other number in the array x,\n6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> nums = [1, 2, 3, 4]\n<b>Output:</b> -1\n<b>Explanation:</b> 4 isn't at least as big as twice the value of 3, so we return -1.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li><code>nums</code> will have a length in the range <code>[1, 50]</code>.</li>\n<li>Every <code>nums[i]</code> will be an integer in the range <code>[0, 99]</code>.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-linear-scan-accepted">Approach #1: Linear Scan [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-linear-scan-accepted">Approach #1: Linear Scan [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Scan through the array to find the unique largest element <code>m</code>, keeping track of it\'s index <code>maxIndex</code>.</p>\n<p>Scan through the array again.  If we find some <code>x != m</code> with <code>m &lt; 2*x</code>, we should return <code>-1</code>.</p>\n<p>Otherwise, we should return <code>maxIndex</code>.</p>\n<iframe frameborder="0" height="293" name="j3xuZ4yh" src="https://leetcode.com/playground/j3xuZ4yh/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script> where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>, the space used by our <code>int</code> variables.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '748',
    name: 'Shortest Completing Word',
    acceptance: '54.7%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nFind the minimum length word from a given dictionary <code>words</code>, which has all the letters from the string <code>licensePlate</code>.  Such a word is said to <i>complete</i> the given string <code>licensePlate</code>\n</p><p>\nHere, for letters we ignore case.  For example, <code>"P"</code> on the <code>licensePlate</code> still matches <code>"p"</code> on the word.\n</p><p>\nIt is guaranteed an answer exists.  If there are multiple answers, return the one that occurs first in the array.\n</p><p>\nThe license plate might have the same letter occurring multiple times.  For example, given a <code>licensePlate</code> of <code>"PP"</code>, the word <code>"pair"</code> does not complete the <code>licensePlate</code>, but the word <code>"supper"</code> does.\n</p><p>\n\n</p><p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"]\n<b>Output:</b> "steps"\n<b>Explanation:</b> The smallest length word that contains the letters "S", "P", "S", and "T".\nNote that the answer is not "step", because the letter "s" must occur in the word twice.\nAlso note that we ignored case for the purposes of comparing whether a letter exists in the word.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"]\n<b>Output:</b> "pest"\n<b>Explanation:</b> There are 3 smallest length words that contains the letters "s".\nWe return the one that occurred first.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li><code>licensePlate</code> will be a string with length in range <code>[1, 7]</code>.</li>\n<li><code>licensePlate</code> will contain digits, spaces, or letters (uppercase or lowercase).</li>\n<li><code>words</code> will have a length in the range <code>[10, 1000]</code>.</li>\n<li>Every <code>words[i]</code> will consist of lowercase letters, and have length in range <code>[1, 15]</code>.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-compare-counts-accepted">Approach #1: Compare Counts [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-compare-counts-accepted">Approach #1: Compare Counts [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>A natural question is, how to tell whether a <code>word</code> like <code>"steps"</code> completes a <code>licensePlate</code> like <code>"12s pst"</code>?</p>\n<p>We count the number of letters in both <code>word</code> and <code>licensePlate</code>, converting to lowercase and ignoring non-letter characters.  If the count of each letter is greater or equal in the word, then that word completes the <code>licensePlate</code>.</p>\n<p>From the words that complete <code>licensePlate</code>, we should keep the one with the shortest length (with ties broken by whether it occurs first.)</p>\n<iframe frameborder="0" height="500" name="spVMv3Zw" src="https://leetcode.com/playground/spVMv3Zw/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script> where <script type="math/tex; mode=display">N</script> is the length of <code>words</code>, and assuming the lengths of <code>licensePlate</code> and <code>words[i]</code> are bounded by <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script> in additional space.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '749',
    name: 'Contain Virus',
    acceptance: '36.2%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nA virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\n</p><p>\nThe world is modeled as a 2-D array of cells, where <code>0</code> represents uninfected cells, and <code>1</code> represents cells contaminated with the virus.  A wall (and only one wall) can be installed <b>between any two 4-directionally adjacent cells</b>, on the shared boundary.\n</p><p>\nEvery night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall.\nResources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.\n</p><p>\nCan you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.\n</p><p>\n\n</p><p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> grid = \n[[0,1,0,0,0,0,0,1],\n [0,1,0,0,0,0,0,1],\n [0,0,0,0,0,0,0,1],\n [0,0,0,0,0,0,0,0]]\n<b>Output:</b> 10\n<b>Explanation:</b>\nThere are 2 contaminated regions.\nOn the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\n\n[[0,1,0,0,0,0,1,1],\n [0,1,0,0,0,0,1,1],\n [0,0,0,0,0,0,1,1],\n [0,0,0,0,0,0,0,1]]\n\nOn the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> grid = \n[[1,1,1],\n [1,0,1],\n [1,1,1]]\n<b>Output:</b> 4\n<b>Explanation:</b> Even though there is only one cell saved, there are 4 walls built.\nNotice that walls are only built on the shared boundary of two different cells.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> grid = \n[[1,1,1,0,0,0,0,0,0],\n [1,0,1,0,1,1,1,1,1],\n [1,1,1,0,0,0,0,0,0]]\n<b>Output:</b> 13\n<b>Explanation:</b> The region on the left only builds two new walls.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The number of rows and columns of <code>grid</code> will each be in the range <code>[1, 50]</code>.</li>\n<li>Each <code>grid[i][j]</code> will be either <code>0</code> or <code>1</code>.</li>\n<li>Throughout the described process, there is always a contiguous viral region that will infect <b>strictly more</b> uncontaminated squares in the next round.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-simulation-accepted">Approach #1: Simulation [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-simulation-accepted">Approach #1: Simulation [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Let\'s work on simulating one turn of the process.  We can repeat this as necessary while there are still infected regions.</p>\n<p><strong>Algorithm</strong></p>\n<p>Though the implementation is long, the algorithm is straightforward.  We perform the following steps:</p>\n<ul>\n<li>\n<p>Find all viral regions (connected components), additionally for each region keeping track of the frontier (neighboring uncontaminated cells), and the perimeter of the region.</p>\n</li>\n<li>\n<p>Disinfect the most viral region, adding it\'s perimeter to the answer.</p>\n</li>\n<li>\n<p>Spread the virus in the remaining regions outward by 1 square.</p>\n</li>\n</ul>\n<iframe frameborder="0" height="500" name="VFSzJzRe" src="https://leetcode.com/playground/VFSzJzRe/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O((R*C)^{\\frac{4}{3}})</script> where <script type="math/tex; mode=display">R, C</script> is the number of rows and columns.  After time <script type="math/tex; mode=display">t</script>, viral regions that are alive must have size at least <script type="math/tex; mode=display">t^2 + (t-1)^2</script>, so the total number removed across all time is <script type="math/tex; mode=display">\\Omega(t^3) \\leq R*C</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(R*C)</script> in additional space.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Bloomberg'],
  },
  {
    id: '750',
    name: 'Number Of Corner Rectangles ',
    acceptance: '46.5%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a grid where each entry is only 0 or 1, find the number of corner rectangles.\n</p><p>\nA <i>corner rectangle</i> is 4 distinct 1s on the grid that form an axis-aligned rectangle.  Note that only the corners need to have the value 1.  Also, all four 1s used must be distinct.\n</p><p>\n\n</p><p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> grid = \n[[1, 0, 0, 1, 0],\n [0, 0, 1, 0, 1],\n [0, 0, 0, 1, 0],\n [1, 0, 1, 0, 1]]\n<b>Output:</b> 1\n<b>Explanation:</b> There is only one corner rectangle, with corners grid[1][2], grid[1][4], grid[3][2], grid[3][4].\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> grid = \n[[1, 1, 1],\n [1, 1, 1],\n [1, 1, 1]]\n<b>Output:</b> 9\n<b>Explanation:</b> There are four 2x2 rectangles, four 2x3 and 3x2 rectangles, and one 3x3 rectangle.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> grid = \n[[1, 1, 1, 1]]\n<b>Output:</b> 0\n<b>Explanation:</b> Rectangles must have four distinct corners.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The number of rows and columns of <code>grid</code> will each be in the range <code>[1, 200]</code>.</li>\n<li>Each <code>grid[i][j]</code> will be either <code>0</code> or <code>1</code>.</li>\n<li>The number of <code>1</code>s in the grid will be at most <code>6000</code>.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-count-corners-accepted">Approach #1: Count Corners [Accepted]</a></li>\n<li><a href="#approach-2-heavy-and-light-rows-accepted">Approach #2: Heavy and Light Rows [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-count-corners-accepted">Approach #1: Count Corners [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We ask the question: for each additional row, how many more rectangles are added?</p>\n<p>For each pair of 1s in the new row (say at <code>new_row[i]</code> and <code>new_row[j]</code>), we could create more rectangles where that pair forms the base.  The number of new rectangles is the number of times some previous row had <code>row[i] = row[j] = 1</code>.</p>\n<p><strong>Algorithm</strong></p>\n<p>Let\'s maintain a count <code>count[i, j]</code>, the number of times we saw <code>row[i] = row[j] = 1</code>.  When we process a new row, for every pair <code>new_row[i] = new_row[j] = 1</code>, we add <code>count[i, j]</code> to the answer, then we increment <code>count[i, j]</code>.</p>\n<iframe frameborder="0" height="344" name="GXKvhMXU" src="https://leetcode.com/playground/GXKvhMXU/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(R*C^2)</script> where <script type="math/tex; mode=display">R, C</script> is the number of rows and columns.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(R*C)</script> in additional space.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-heavy-and-light-rows-accepted">Approach #2: Heavy and Light Rows [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>Can we improve on the ideas in <em>Approach #1</em>?  When a row is filled with <script type="math/tex; mode=display">X</script> 1s, we do <script type="math/tex; mode=display">O(X^2)</script> work to enumerate every pair of 1s.  This is okay when <script type="math/tex; mode=display">X</script> is small, but expensive when <script type="math/tex; mode=display">X</script> is big.</p>\n<p>Say the entire top row is filled with 1s.  When looking at the next row with say, <code>f</code> 1s that match the top row, the number of rectangles created is just the number of pairs of 1s, which is <code>f * (f-1) / 2</code>.  We could find each <code>f</code> quickly using a Set and a simple linear scan of each row.</p>\n<p>Let\'s call a row to be <em>heavy</em> if it has more than <script type="math/tex; mode=display">\\sqrt N</script> points.  The above algorithm changes the complexity of counting a heavy row from <script type="math/tex; mode=display">O(C^2)</script> to <script type="math/tex; mode=display">O(N)</script>, and there are at most <script type="math/tex; mode=display">\\sqrt N</script> heavy rows.</p>\n<iframe frameborder="0" height="500" name="atVBecyS" src="https://leetcode.com/playground/atVBecyS/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N \\sqrt N)</script> where <script type="math/tex; mode=display">N</script> is the number of ones in the grid.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N + R + C^2)</script> in additional space, for <code>rows</code>, <code>target</code>, and <code>count</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '751',
    name: 'IP to CIDR ',
    acceptance: '55.7%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven a start IP address <code>ip</code> and a number of ips we need to cover <code>n</code>, return a representation of the range as a list (of smallest possible length) of CIDR blocks.\n</p><p>\nA CIDR block is a string consisting of an IP, followed by a slash, and then the prefix length.  For example: "123.45.67.89/20".  That prefix length "20" represents the number of common prefix bits in the specified range.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> ip = "255.0.0.7", n = 10\n<b>Output:</b> ["255.0.0.7/32","255.0.0.8/29","255.0.0.16/32"]\n<b>Explanation:</b>\nThe initial ip address, when converted to binary, looks like this (spaces added for clarity):\n255.0.0.7 -&gt; 11111111 00000000 00000000 00000111\nThe address "255.0.0.7/32" specifies all addresses with a common prefix of 32 bits to the given address,\nie. just this one address.\n\nThe address "255.0.0.8/29" specifies all addresses with a common prefix of 29 bits to the given address:\n255.0.0.8 -&gt; 11111111 00000000 00000000 00001000\nAddresses with common prefix of 29 bits are:\n11111111 00000000 00000000 00001000\n11111111 00000000 00000000 00001001\n11111111 00000000 00000000 00001010\n11111111 00000000 00000000 00001011\n11111111 00000000 00000000 00001100\n11111111 00000000 00000000 00001101\n11111111 00000000 00000000 00001110\n11111111 00000000 00000000 00001111\n\nThe address "255.0.0.16/32" specifies all addresses with a common prefix of 32 bits to the given address,\nie. just 11111111 00000000 00000000 00010000.\n\nIn total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 .\n\nThere were other representations, such as:\n["255.0.0.7/32","255.0.0.8/30", "255.0.0.12/30", "255.0.0.16/32"],\nbut our answer was the shortest possible.\n\nAlso note that a representation beginning with say, "255.0.0.7/30" would be incorrect,\nbecause it includes addresses like 255.0.0.4 = 11111111 00000000 00000000 00000100 \nthat are outside the specified range.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li><code>ip</code> will be a valid IPv4 address.</li>\n<li>Every implied address <code>ip + x</code> (for <code>x &lt; n</code>) will be a valid IPv4 address.</li>\n<li><code>n</code> will be an integer in the range <code>[1, 1000]</code>.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-direct-accepted">Approach #1: Direct [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-direct-accepted">Approach #1: Direct [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>This problem is about performing the steps directly as written.  The tricky part is managing the bit manipulations involved.</p>\n<p>Let\'s ask the question: for a number <code>n</code> of ip addresses desired, and the starting address <code>ip</code> of that range, what is the CIDR block representing the most ip addresses in that range starting at <code>ip</code>?  Evidently, this greedy approach will work, and we can keep repeating this until we are done, so let\'s just focus on creating one largest block.</p>\n<p><strong>Algorithm</strong></p>\n<p>We\'ll need to be able to convert <code>ip</code> addresses back and forth to integers (<code>long</code>).  We can do this with some basic manipulations - see the code for more details.</p>\n<p>Then, with an ip address like <code>255.0.0.24</code> converted to <code>start</code>, it ends in the binary <code>00011000</code>.  There are some cases.  If <code>n &gt;= 8</code>, then we should use the entire block <code>255.0.0.24/29</code>.  Otherwise, we can only take a number of addresses equal to the largest power of 2 less than or equal to <code>n</code>.</p>\n<p>In a more general setting, we use the bit lengths of both <code>n</code> and <code>start &amp; -start</code> (the lowest bit of <code>start</code>) to compute the <code>mask</code> which represents <script type="math/tex; mode=display">2^{32 - \\text{mask}}</script> ip addresses.  Then, we adjust <code>start</code> and <code>n</code> appropriately.</p>\n<p>In Java and C++, we should be careful to use <code>long</code> data types to represent the converted ip addresses, since the number could exceed <script type="math/tex; mode=display">2^{31}</script>.</p>\n<iframe frameborder="0" height="500" name="GPWsnGbw" src="https://leetcode.com/playground/GPWsnGbw/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script> where <script type="math/tex; mode=display">N</script> is the length of <code>nums</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>, the space used by our <code>int</code> variables.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Airbnb'],
  },
  {
    id: '752',
    name: 'Open the Lock',
    acceptance: '37.1%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nYou have a lock in front of you with 4 circular wheels.  Each wheel has 10 slots: <code>\'0\', \'1\', \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\'</code>.  The wheels can rotate freely and wrap around: for example we can turn <code>\'9\'</code> to be <code>\'0\'</code>, or <code>\'0\'</code> to be <code>\'9\'</code>.  Each move consists of turning one wheel one slot.\n</p><p>\nThe lock initially starts at <code>\'0000\'</code>, a string representing the state of the 4 wheels.\n</p><p>\nYou are given a list of <code>deadends</code> dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\n</p><p>\nGiven a <code>target</code> representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> deadends = ["0201","0101","0102","1212","2002"], target = "0202"\n<b>Output:</b> 6\n<b>Explanation:</b>\nA sequence of valid moves would be "0000" -&gt; "1000" -&gt; "1100" -&gt; "1200" -&gt; "1201" -&gt; "1202" -&gt; "0202".\nNote that a sequence like "0000" -&gt; "0001" -&gt; "0002" -&gt; "0102" -&gt; "0202" would be invalid,\nbecause the wheels of the lock become stuck after the display becomes the dead end "0102".\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> deadends = ["8888"], target = "0009"\n<b>Output:</b> 1\n<b>Explanation:</b>\nWe can turn the last wheel in reverse to move from "0000" -&gt; "0009".\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"\n<b>Output:</b> -1\n<b>Explanation:</b>\nWe can\'t reach the target without getting stuck.\n</pre>\n<p></p>\n\n<p><b>Example 4:</b><br>\n</p><pre><b>Input:</b> deadends = ["0000"], target = "8888"\n<b>Output:</b> -1\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li>The length of <code>deadends</code> will be in the range <code>[1, 500]</code>.</li>\n<li><code>target</code> will not be in the list <code>deadends</code>.</li>\n<li>Every string in <code>deadends</code> and the string <code>target</code> will be a string of 4 digits from the 10,000 possibilities <code>\'0000\'</code> to <code>\'9999\'</code>.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-breadth-first-search-accepted">Approach #1: Breadth-First Search [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-breadth-first-search-accepted">Approach #1: Breadth-First Search [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can think of this problem as a shortest path problem on a graph: there are <code>10000</code> nodes (strings <code>\'0000\'</code> to <code>\'9999\'</code>), and there is an edge between two nodes if they differ in one digit, that digit differs by 1 (wrapping around, so <code>\'0\'</code> and <code>\'9\'</code> differ by 1), and if both nodes are not in <code>deadends</code>.</p>\n<p><strong>Algorithm</strong></p>\n<p>To solve a shortest path problem, we use a breadth-first search.  The basic structure uses a Queue <code>queue</code> plus a Set <code>seen</code> that records if a node has ever been enqueued.  This pushes all the work to the <code>neighbors</code> function - in our Python implementation, all the code after <code>while queue:</code> is template code, except for <code>if node in dead: continue</code>.</p>\n<p>As for the <code>neighbors</code> function, for each position in the lock <code>i = 0, 1, 2, 3</code>, for each of the turns <code>d = -1, 1</code>, we determine the value of the lock after the <code>i</code>-th wheel has been turned in the direction <code>d</code>.</p>\n<p>Care should be taken in our algorithm, as the graph does not have an edge unless <em>both</em> nodes are not in <code>deadends</code>.  If our <code>neighbors</code> function checks only the <code>target</code> for being in <code>deadends</code>, we also need to check whether <code>\'0000\'</code> is in <code>deadends</code> at the beginning.  In our implementation, we check at the visitor level so as to neatly handle this problem in all cases.</p>\n<p>In Java, our implementation also inlines the neighbors function for convenience, and uses <code>null</code> inputs in the <code>queue</code> to represent a layer change.  When the layer changes, we <code>depth++</code> our global counter, and <code>queue.peek() != null</code> checks if there are still nodes enqueued.</p>\n<iframe frameborder="0" height="500" name="bCLjzEUu" src="https://leetcode.com/playground/bCLjzEUu/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(\\mathcal{A}^N + D)</script> where <script type="math/tex; mode=display">\\mathcal{A}</script> is the number of digits in our alphabet, <script type="math/tex; mode=display">N</script> is the number of digits in the lock, and <script type="math/tex; mode=display">D</script> is the size of <code>deadends</code>.  We might visit every lock combination, plus we need to instantiate our set <code>dead</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(\\mathcal{A}^N + D)</script>, for the <code>queue</code> and the set <code>dead</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: [],
  },
  {
    id: '753',
    name: 'Cracking the Safe',
    acceptance: '39.4%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\nThere is a box protected by a password.  The password is <code>n</code> digits, where each letter can be one of the first <code>k</code> digits <code>0, 1, ..., k-1</code>.\n</p><p>\nYou can keep inputting the password, the password will automatically be matched against the last <code>n</code> digits entered.\n</p><p>\nFor example, assuming the password is <code>"345"</code>, I can open it when I type <code>"012345"</code>, but I enter a total of 6 digits.\n</p><p>\nPlease return any string of minimum length that is guaranteed to open the box after the entire string is inputted.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> n = 1, k = 2\n<b>Output:</b> "01"\n<b>Note:</b> "10" will be accepted too.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> n = 2, k = 2\n<b>Output:</b> "00110"\n<b>Note:</b> "01100", "10011", "11001" will be accepted too.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li><code>n</code> will be in the range <code>[1, 4]</code>.</li>\n<li><code>k</code> will be in the range <code>[1, 10]</code>.</li>\n<li><code>k^n</code> will be at most <code>4096</code>.</li>\n</ol>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-hierholzers-algorithm-accepted">Approach #1: Hierholzer\'s Algorithm [Accepted]</a></li>\n<li><a href="#approach-2-inverse-burrows-wheeler-transform-accepted">Approach #2: Inverse Burrows-Wheeler Transform [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-hierholzers-algorithm-accepted">Approach #1: Hierholzer\'s Algorithm [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can think of this problem as the problem of finding an Euler path (a path visiting every edge exactly once) on the following graph: there are <script type="math/tex; mode=display">k^{n-1}</script> nodes with each node having <script type="math/tex; mode=display">k</script> edges.</p>\n<p>For example, when <code>k = 4, n = 3</code>, the nodes are <code>\'00\', \'01\', \'02\', ..., \'32\', \'33\'</code> and each node has 4 edges <code>\'0\', \'1\', \'2\', \'3\'</code>.  A node plus edge represents a <em>complete edge</em> and viewing that substring in our answer.</p>\n<p>Any connected directed graph where all nodes have equal in-degree and out-degree has an Euler circuit (an Euler path ending where it started.)  Because our graph is highly connected and symmetric, we should expect intuitively that taking any path greedily in some order will probably result in an Euler path.  </p>\n<p>This intuition is called Hierholzer\'s algorithm: whenever there is an Euler cycle, we can construct it greedily.  The algorithm goes as follows:</p>\n<ul>\n<li>\n<p>Starting from a vertex <code>u</code>, we walk through (unwalked) edges until we get stuck.  Because the in-degrees and out-degrees of each node are equal, we can only get stuck at <code>u</code>, which forms a cycle.</p>\n</li>\n<li>\n<p>Now, for any node <code>v</code> we had visited that has unwalked edges, we start a new cycle from <code>v</code> with the same procedure as above, and then merge the cycles together to form a new cycle <script type="math/tex; mode=display">u \\rightarrow \\dots \\rightarrow v \\rightarrow \\dots \\rightarrow v \\rightarrow \\dots \\rightarrow u</script>.</p>\n</li>\n</ul>\n<p><strong>Algorithm</strong></p>\n<p>We will modify our standard depth-first search: instead of keeping track of nodes, we keep track of (complete) edges: <code>seen</code> records if an edge has been visited.</p>\n<p>Also, we\'ll need to visit in a sort of "post-order", recording the answer after visiting the edge.  This is to prevent getting stuck.  For example, with <code>k = 2, n = 2</code>, we have the nodes <code>\'0\', \'1\'</code>.  If we greedily visit complete edges <code>\'00\', \'01\', \'10\'</code>, we will be stuck at the node <code>\'0\'</code> prematurely.  However, if we visit in post-order, we\'ll end up visiting <code>\'00\', \'01\', \'11\', \'10\'</code> correctly.</p>\n<p>In general, during our Hierholzer walk, we will record the results of other subcycles first, before recording the main cycle we started from, just as in our first description of the algorithm.  Technically, we are recording backwards, as we exit the nodes.</p>\n<p>For example, we will walk (in the "original cycle") until we get stuck, then record the node as we exit.  (Every edge walked is always marked immediately so that it can no longer be used.)  Then in the penultimate node of our original cycle, we will do a Hierholzer walk and then record this node; then in the third-last node of our original cycle we will do a Hierholzer walk and then record this node, and so on.</p>\n<iframe frameborder="0" height="500" name="r4ngufQr" src="https://leetcode.com/playground/r4ngufQr/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(n * k^n)</script>.  We visit every edge once in our depth-first search, and nodes take <script type="math/tex; mode=display">O(n)</script> space.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(n * k^n)</script>, the size of <code>seen</code>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-inverse-burrows-wheeler-transform-accepted">Approach #2: Inverse Burrows-Wheeler Transform [Accepted]</h4>\n<p><strong>Explanation</strong></p>\n<p>If we are familiar with the theory of combinatorics on words, recall that a <em>Lyndon Word</em> <code>L</code> is a word that is the unique minimum of it\'s rotations.</p>\n<p>One important mathematical result (due to <a href="http://www-igm.univ-mlv.fr/~perrin/Recherche/Publications/Articles/debruijnRevised3.pdf">Fredericksen and Maiorana</a>), is that the concatenation in lexicographic order of Lyndon words with length dividing <code>n</code>, forms a <em>de Bruijin</em> sequence: a sequence where every every word (from the <script type="math/tex; mode=display">k^n</script> available) appears as a substring of length <code>n</code> (where we are allowed to wrap around.)</p>\n<p>For example, when <code>n = 6, k = 2</code>, all the Lyndon words with length dividing <code>n</code> in lexicographic order are (spaces for convenience):\n<code>0 000001 000011 000101 000111 001 001011 001101 001111 01\n010111 011 011111 1</code>.  It turns out this is the smallest de Bruijin sequence.</p>\n<p>We can use the <em>Inverse Burrows-Wheeler Transform</em> (IBWT) to generate these Lyndon words.  Consider two sequences: <code>S</code> is the alphabet repeated <script type="math/tex; mode=display">k^{n-1}</script> times: <code>S = 0123...0123...0123....</code>, and <code>S\'</code> is the alphabet repeated <script type="math/tex; mode=display">k^{n-1}</script> times for each letter: <code>S\' = 00...0011...1122....</code>  We can think of <code>S\'</code> and <code>S</code> as defining a permutation, where the <code>j</code>-th occurrence of each letter of the alphabet in <code>S\'</code> maps to the corresponding <code>j</code>-th occurrence in <code>S</code>.  The cycles of this permutation turn out to be the corresponding smallest de Bruijin sequence (<a href="http://www.macs.hw.ac.uk/~markl/Higgins.pdf">link</a>).</p>\n<p>Under this view, the permutation <script type="math/tex; mode=display">S\' \\rightarrow S</script> [mapping permutation indices <script type="math/tex; mode=display">(i * k^{n-1} + q) \\rightarrow (q * k + i)</script>] form the desired Lyndon words.</p>\n<iframe frameborder="0" height="463" name="hRmTee3d" src="https://leetcode.com/playground/hRmTee3d/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(k^n)</script>.  We loop through every possible substring.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(k^n)</script>, the size of <code>P</code> and <code>ans</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '754',
    name: 'Reach a Number',
    acceptance: '23.9%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nYou are standing at position <code>0</code> on an infinite number line.  There is a goal at position <code>target</code>.\n</p><p>\nOn each move, you can either go left or right.  During the <i>n</i>-th move (starting from 1), you take <i>n</i> steps.\n</p><p>\nReturn the minimum number of steps required to reach the destination.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> target = 3\n<b>Output:</b> 2\n<b>Explanation:</b>\nOn the first move we step from 0 to 1.\nOn the second step we step from 1 to 3.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> target = 2\n<b>Output:</b> 3\n<b>Explanation:</b>\nOn the first move we step from 0 to 1.\nOn the second move we step  from 1 to -1.\nOn the third move we step from -1 to 2.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><li><code>target</code> will be a non-zero integer in the range <code>[-10^9, 10^9]</code>.</li>\n<p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-mathematical-accepted">Approach #1: Mathematical [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-mathematical-accepted">Approach #1: Mathematical [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>The crux of the problem is to put <code>+</code> and <code>-</code> signs on the numbers <code>1, 2, 3, ..., k</code> so that the sum is <code>target</code>.</p>\n<p>When <code>target &lt; 0</code> and we made a sum of <code>target</code>, we could switch the signs of all the numbers so that it equals <code>Math.abs(target)</code>.  Thus, the answer for <code>target</code> is the same as <code>Math.abs(target)</code>, and so without loss of generality, we can consider only <code>target &gt; 0</code>.</p>\n<p>Now let\'s say <code>k</code> is the smallest number with <code>S = 1 + 2 + ... + k &gt;= target</code>.  If <code>S == target</code>, the answer is clearly <code>k</code>.</p>\n<p>If <code>S &gt; target</code>, we need to change some number signs.  If <code>delta = S - target</code> is even, then we can always find a subset of <code>{1, 2, ..., k}</code> equal to <code>delta / 2</code> and switch the signs, so the answer is <code>k</code>.  (This depends on <code>T = delta / 2</code> being at most <code>S</code>.)  [The proof is simple: either <code>T &lt;= k</code> and we choose it, or we choose <code>k</code> in our subset and try to solve the same instance of the problem for <code>T -= k</code> and the set <code>{1, 2, ..., k-1}</code>.]</p>\n<p>Otherwise, if <code>delta</code> is odd, we can\'t do it, as every sign change from positive to negative changes the sum by an even number.  So let\'s consider a candidate answer of <code>k+1</code>, which changes <code>delta</code> by <code>k+1</code>.  If this is odd, then <code>delta</code> will be even and we can have an answer of <code>k+1</code>.  Otherwise, <code>delta</code> will be odd, and we will have an answer of <code>k+2</code>.</p>\n<p>For concrete examples of the above four cases, consider the following:</p>\n<ul>\n<li>If <code>target = 3</code>, then <code>k = 2, delta = 0</code> and the answer is <code>k = 2</code>.</li>\n<li>If <code>target = 4</code>, then <code>k = 3, delta = 2</code>, delta is even and the answer is <code>k = 3</code>.</li>\n<li>If <code>target = 7</code>, then <code>k = 4, delta = 3</code>, delta is odd and adding <code>k+1</code> makes delta even.  The answer is <code>k+1 = 5</code>.</li>\n<li>If <code>target = 5</code>, then <code>k = 3, delta = 1</code>, delta is odd and adding <code>k+1</code> keeps delta odd.  The answer is <code>k+2 = 5</code>.</li>\n</ul>\n<p><strong>Algorithm</strong></p>\n<p>Subtract <code>++k</code> from <code>target</code> until it goes non-positive.  Then <code>k</code> will be as described, and <code>target</code> will be <code>delta</code> as described.  We can output the four cases above: if <code>delta</code> is even then the answer is <code>k</code>, if <code>delta</code> is odd then the answer is <code>k+1</code> or <code>k+2</code> depending on the parity of <code>k</code>.</p>\n<iframe frameborder="0" height="208" name="VZd5DozE" src="https://leetcode.com/playground/VZd5DozE/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(\\sqrt{\\text{target}})</script>.  Our while loop needs this many steps, as <script type="math/tex; mode=display">1 + 2 + \\dots + k = \\frac{k(k+1)}{2}</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['inmobi'],
  },
  {
    id: '755',
    name: 'Pour Water',
    acceptance: '34.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nWe are given an elevation map, <code>heights[i]</code> representing the height of the terrain at that index.  The width at each index is 1.  After <code>V</code> units of water fall at index <code>K</code>, how much water is at each index?\n</p><p>\nWater first drops at index <code>K</code> and rests on top of the highest terrain or water at that index.  Then, it flows according to the following rules:\n</p><li>If the droplet would eventually fall by moving left, then move left.</li>\n<li>Otherwise, if the droplet would eventually fall by moving right, then move right.</li>\n<li>Otherwise, rise at it\'s current position.</li>\nHere, "eventually fall" means that the droplet will eventually be at a lower level if it moves in that direction.\nAlso, "level" means the height of the terrain plus any water in that column.\n<p></p><p>\nWe can assume there\'s infinitely high terrain on the two sides out of bounds of the array.  Also, there could not be partial water being spread out evenly on more than 1 grid block - each unit of water has to be in exactly one block.\n</p><p>\n\n</p><p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> heights = [2,1,1,2,1,2,2], V = 4, K = 3\n<b>Output:</b> [2,2,2,3,2,2,2]\n<b>Explanation:</b>\n#       #\n#       #\n##  # ###\n#########\n 0123456    &lt;- index\n\nThe first drop of water lands at index K = 3:\n\n#       #\n#   w   #\n##  # ###\n#########\n 0123456    \n\nWhen moving left or right, the water can only move to the same level or a lower level.\n(By level, we mean the total height of the terrain plus any water in that column.)\nSince moving left will eventually make it fall, it moves left.\n(A droplet "made to fall" means go to a lower height than it was at previously.)\n\n#       #\n#       #\n## w# ###\n#########\n 0123456    \n\nSince moving left will not make it fall, it stays in place.  The next droplet falls:\n\n#       #\n#   w   #\n## w# ###\n#########\n 0123456  \n\nSince the new droplet moving left will eventually make it fall, it moves left.\nNotice that the droplet still preferred to move left,\neven though it could move right (and moving right makes it fall quicker.)\n\n#       #\n#  w    #\n## w# ###\n#########\n 0123456  \n\n#       #\n#       #\n##ww# ###\n#########\n 0123456  \n\nAfter those steps, the third droplet falls.\nSince moving left would not eventually make it fall, it tries to move right.\nSince moving right would eventually make it fall, it moves right.\n\n#       #\n#   w   #\n##ww# ###\n#########\n 0123456  \n\n#       #\n#       #\n##ww#w###\n#########\n 0123456  \n\nFinally, the fourth droplet falls.\nSince moving left would not eventually make it fall, it tries to move right.\nSince moving right would not eventually make it fall, it stays in place:\n\n#       #\n#   w   #\n##ww#w###\n#########\n 0123456  \n\nThe final answer is [2,2,2,3,2,2,2]:\n\n    #    \n ####### \n ####### \n 0123456 \n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> heights = [1,2,3,4], V = 2, K = 2\n<b>Output:</b> [2,3,3,4]\n<b>Explanation:</b>\nThe last droplet settles at index 1, since moving further left would not cause it to eventually fall to a lower height.\n</pre>\n<p></p>\n\n<p><b>Example 3:</b><br>\n</p><pre><b>Input:</b> heights = [3,1,3], V = 5, K = 1\n<b>Output:</b> [4,4,4]\n</pre>\n<p></p>\n\n<p><b>Note:</b><br></p><ol>\n<li><code>heights</code> will have length in <code>[1, 100]</code> and contain integers in <code>[0, 99]</code>.</li>\n<li><code>V</code> will be in range <code>[0, 2000]</code>.</li>\n<li><code>K</code> will be in range <code>[0, heights.length - 1]</code>.</li>\n</ol><p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-simulation-accepted">Approach #1: Simulation [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-simulation-accepted">Approach #1: Simulation [Accepted]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>We attempt to perform the steps directly as described.</p>\n<p>First, notice that an index with terrain or with water is indistinguishable with respect to the flow of water.  Thus, we can model <code>heights</code> as the total level of terrain and water directly as we perform our simulation.</p>\n<p>When a droplet falls, we should check if it is possible for it to fall left.  For our left pointer <code>i = K</code>, if <code>i - 1</code> is in bounds and <code>heights[i - 1] &lt;= heights[i]</code>, the water will fall to a candidate block in that direction.  We keep track of every time we actually fall at index <code>best</code>.  If we "eventually fall" (<code>best != K</code>) as described in the problem statement, then we will drop the water there.</p>\n<p>Otherwise, (if moving left will not cause the droplet to eventually fall), we can perform a similar check for <code>i = K</code> going right, and otherwise the droplet stays in place.</p>\n<p>For convenience, we will name the initial array <code>H = heights</code>.</p>\n<iframe frameborder="0" height="378" name="zuFhiDKG" src="https://leetcode.com/playground/zuFhiDKG/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(V * N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>heights</code>.  For each of <script type="math/tex; mode=display">V</script> droplets, our while loop might iterate <script type="math/tex; mode=display">N</script> times.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script> in additional space complexity.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Airbnb'],
  },
  {
    id: '756',
    name: 'Pyramid Transition Matrix',
    acceptance: '42.2%',
    difficulty: 'Medium',
    questionHtml:
      "\n            <br>\n            <p>\nWe are stacking blocks to form a pyramid.  Each block has a color which is a one letter string, like `'Z'`.\n</p><p>\nFor every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`.  We are allowed to place the block there only if `(A, B, C)` is an allowed triple.\n</p><p>\nWe start with a bottom row of <code>bottom</code>, represented as a single string.  We also start with a list of allowed triples <code>allowed</code>.  Each allowed triple is represented as a string of length 3.\n</p><p>\nReturn true if we can build the pyramid all the way to the top, otherwise false.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> bottom = \"XYZ\", allowed = [\"XYD\", \"YZE\", \"DEA\", \"FFF\"]\n<b>Output:</b> true\n<b>Explanation:</b>\nWe can stack the pyramid like this:\n    A\n   / \\\n  D   E\n / \\ / \\\nX   Y   Z\n\nThis works because ('X', 'Y', 'D'), ('Y', 'Z', 'E'), and ('D', 'E', 'A') are allowed triples.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> bottom = \"XXYX\", allowed = [\"XXX\", \"XXY\", \"XYX\", \"XYY\", \"YXZ\"]\n<b>Output:</b> false\n<b>Explanation:</b>\nWe can't stack the pyramid to the top.\nNote that there could be allowed triples (A, B, C) and (A, B, D) with C != D.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li><code>bottom</code> will be a string with length in range <code>[2, 8]</code>.</li>\n<li><code>allowed</code> will have length in range <code>[0, 200]</code>.</li>\n<li>Letters in all strings will be chosen from the set <code>{'A', 'B', 'C', 'D', 'E', 'F', 'G'}</code>.</li>\n</ol>\n<p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-state-to-state-transition-wrong-answer">Approach #1: State to State Transition [Wrong Answer]</a></li>\n<li><a href="#approach-2-depth-first-search-accepted">Approach #2: Depth-First Search [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-state-to-state-transition-wrong-answer">Approach #1: State to State Transition [Wrong Answer]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>We model the states that blocks can be in.  Each state is a binary number where the <code>k</code>th bit is set if the <code>k</code>th type of block is a possibility.  Then, we create a transition map <code>T[state1][state2] -&gt; state</code> that takes a left state and a right state and outputs all possible parent states.</p>\n<p>At the end, applying these transitions is straightforward.  However, this approach is not correct, because the transitions are not independent.  If for example we have states in a row <code>A, {B or C}, A</code>, and allowed triples <code>(A, B, D)</code>, <code>(C, A, D)</code>, then regardless of the choice of <code>{B or C}</code> we cannot create the next row of the pyramid.</p>\n<iframe frameborder="0" height="429" name="FoBNczLu" src="https://leetcode.com/playground/FoBNczLu/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(2^{2\\mathcal{A}}A + N^2)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>bottom</code>, <script type="math/tex; mode=display">A</script> is the length of <code>allowed</code>, and <script type="math/tex; mode=display">\\mathcal{A}</script> is the size of the alphabet.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(2^{2\\mathcal{A}})</script> in additional space complexity.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-depth-first-search-accepted">Approach #2: Depth-First Search [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We exhaustively try every combination of blocks.</p>\n<p><strong>Algorithm</strong></p>\n<p>We can work in either strings or integers, but we need to create a transition map <code>T</code> from the list of allowed triples.  This map <code>T[x][y] = {set of z}</code> will be all possible parent blocks for a left child of <code>x</code> and a right child of <code>y</code>.  When we work in strings, we use <code>Set</code>, and when we work in integers, we will use the set bits of the result integer.</p>\n<p>Afterwards, to <code>solve</code> a row, we generate every possible combination of the next row and solve them.  If any of those new rows are solvable, we return <code>True</code>, otherwise <code>False</code>.</p>\n<p>We can also cache intermediate results, saving us time.  This is illustrated in the comments for Python.  For Java, all caching is done with lines of code that mention the integer <code>R</code>.</p>\n<iframe frameborder="0" height="500" name="W723Lgci" src="https://leetcode.com/playground/W723Lgci/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(\\mathcal{A}^{N})</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>bottom</code>, and <script type="math/tex; mode=display">\\mathcal{A}</script> is the size of the alphabet, and assuming we cache intermediate results.  We might try every sequence of letters for each row.  [The total complexity is because <script type="math/tex; mode=display">O(\\sum_{k}^n \\mathcal{A}^{k})</script> is a geometric series equal to <script type="math/tex; mode=display">O(\\frac{\\mathcal{A^{n+1}}-1}{\\mathcal{A}-1})</script>.]  Without intermediate caching, this would be <script type="math/tex; mode=display">O(\\mathcal{A}^{N^2})</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N^2)</script> additional space complexity.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Google', 'Airbnb'],
  },
  {
    id: '757',
    name: 'Set Intersection Size At Least Two',
    acceptance: '33.7%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>\nAn integer interval <code>[a, b]</code> (for integers <code>a &lt; b</code>) is a set of all consecutive integers from <code>a</code> to <code>b</code>, including <code>a</code> and <code>b</code>.\n</p><p>\nFind the minimum size of a set S such that for every integer interval A in <code>intervals</code>, the intersection of S with A has size at least 2.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> intervals = [[1, 3], [1, 4], [2, 5], [3, 5]]\n<b>Output:</b> 3\n<b>Explanation:</b>\nConsider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval.\nAlso, there isn't a smaller size set that fulfills the above condition.\nThus, we output the size of this set, which is 3.\n</pre>\n<p></p>\n\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> intervals = [[1, 2], [2, 3], [2, 4], [4, 5]]\n<b>Output:</b> 5\n<b>Explanation:</b>\nAn example of a minimum sized set is {1, 2, 3, 4, 5}.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br></p><ol>\n<li><code>intervals</code> will have length in range <code>[1, 3000]</code>.</li>\n<li><code>intervals[i]</code> will have length <code>2</code>, representing some integer interval.</li>\n<li><code>intervals[i][j]</code> will be an integer in <code>[0, 10^8]</code>.</li>\n</ol><p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-greedy-accepted">Approach #1: Greedy [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-greedy-accepted">Approach #1: Greedy [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Let\'s try to solve a simpler problem: what is the answer when the set intersection size is at least <em>one</em>?</p>\n<p>Sort the points.  Take the last interval <code>[s, e]</code>, which point on this interval will be in <code>S</code>?  Since every other interval has start point <code>&lt;= s</code>, it is strictly better to choose <code>s</code> as the start.  So we can repeatedly take <code>s</code> in our set <code>S</code> and remove all intervals containing <code>s</code>.</p>\n<p>We will try to extend this solution to the case when we want an intersection of size two.</p>\n<p><strong>Algorithm</strong></p>\n<p>For each interval, we will perform the algorithm described above, storing a <code>todo</code> <em>multiplicity</em> which starts at <code>2</code>.  As we identify points in <code>S</code>, we will subtract from these multiplicities as appropriate.</p>\n<p>One case that is important to handle is the following:\n<code>[[1, 2], [2, 3], [2, 4], [4, 5]]</code>.  If we put <code>4, 5</code> in <code>S</code>, then we put <code>2</code> in <code>S</code>, when handling <code>[2, 3]</code> we need to put <code>3</code> in <code>S</code>, not <code>2</code> which was already put.</p>\n<p>We can handle this case succinctly by sorting intervals <code>[s, e]</code> by <code>s</code> ascending, then <code>e</code> descending.  This makes it so that any interval encountered with the same <code>s</code> has the lowest possible <code>e</code>, and so it has the highest <em>multiplicity</em>.  When at interval <code>[s, e]</code> and choosing points to be included into <code>S</code>, it will always be the case that the start of the interval (either <code>s</code> or <code>s, s+1</code>) will be unused.</p>\n<iframe frameborder="0" height="412" name="w4QM4e3U" src="https://leetcode.com/playground/w4QM4e3U/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script>, where <script type="math/tex; mode=display">N</script> is the length of <code>intervals</code>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Drawbridge'],
  },
  {
    id: '759',
    name: 'Employee Free Time',
    acceptance: '50.3%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>\nWe are given a list <code>schedule</code> of employees, which represents the working time for each employee.\n</p><p>\nEach employee has a list of non-overlapping <code>Intervals</code>, and these intervals are in sorted order.\n</p><p>\nReturn the list of finite intervals representing <b>common, positive-length free time</b> for <i>all</i> employees, also in sorted order.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]\n<b>Output:</b> [[3,4]]\n<b>Explanation:</b>\nThere are a total of three employees, and all common\nfree time intervals would be [-inf, 1], [3, 4], [10, inf].\nWe discard any intervals that contain inf as they aren't finite.\n</pre>\n<p></p>\n<p><b>Example 2:</b><br>\n</p><pre><b>Input:</b> schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]\n<b>Output:</b> [[5,6],[7,9]]\n</pre>\n<p></p>\n\n<p>\n(Even though we are representing <code>Intervals</code> in the form <code>[x, y]</code>, the objects inside are <code>Intervals</code>, not lists or arrays.  For example, <code>schedule[0][0].start = 1, schedule[0][0].end = 2</code>, and <code>schedule[0][0][0]</code> is not defined.)\n</p><p>\nAlso, we wouldn't include intervals like [5, 5] in our answer, as they have zero length.\n</p>\n\n<p><b>Note:</b></p><ol>\n<li><code>schedule</code> and <code>schedule[i]</code> are lists with lengths in range <code>[1, 50]</code>.</li>\n<li><code>0 &lt;= schedule[i].start &lt; schedule[i].end &lt;= 10^8</code>.</li>\n</ol><p></p>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-events-line-sweep-accepted">Approach #1: Events (Line Sweep) [Accepted]</a></li>\n<li><a href="#approach-2-priority-queue-accepted">Approach #2: Priority Queue [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-events-line-sweep-accepted">Approach #1: Events (Line Sweep) [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If some interval overlaps <em>any</em> interval (for any employee), then it won\'t be included in the answer.  So we could reduce our problem to the following: given a set of intervals, find all places where there are no intervals.</p>\n<p>To do this, we can use an "events" approach present in other interval problems.  For each interval <code>[s, e]</code>, we can think of this as two events: <code>balance++</code> when <code>time = s</code>, and <code>balance--</code> when <code>time = e</code>.  We want to know the regions where <code>balance == 0</code>.</p>\n<p><strong>Algorithm</strong></p>\n<p>For each interval, create two events as described above, and sort the events.  Now for each event occuring at time <code>t</code>, if the <code>balance</code> is <code>0</code>, then the preceding segment <code>[prev, t]</code> did not have any intervals present, where <code>prev</code> is the previous value of <code>t</code>.</p>\n<iframe frameborder="0" height="497" name="kBSV5SQo" src="https://leetcode.com/playground/kBSV5SQo/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(C\\log C)</script>, where <script type="math/tex; mode=display">C</script> is the number of intervals across all employees.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(C)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-priority-queue-accepted">Approach #2: Priority Queue [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Say we are at some time where no employee is working.  That work-free period will last until the next time some employee has to work.</p>\n<p>So let\'s maintain a heap of the next time an employee has to work, and it\'s associated job.  When we process the next time from the heap, we can add the next job for that employee.</p>\n<p><strong>Algorithm</strong></p>\n<p>Keep track of the latest time <code>anchor</code> that we don\'t know of a job overlapping that time.</p>\n<p>When we process the earliest occurring job not yet processed, it occurs at time <code>t</code>, by employee <code>e_id</code>, and it was that employee\'s <code>e_jx</code>\'th job.  If <code>anchor &lt; t</code>, then there was a free interval <code>Interval(anchor, t)</code>.</p>\n<iframe frameborder="0" height="500" name="6F67ionM" src="https://leetcode.com/playground/6F67ionM/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(C\\log N)</script>, where <script type="math/tex; mode=display">N</script> is the number of employees, and <script type="math/tex; mode=display">C</script> is the number of jobs across all employees.  The maximum size of the heap is <script type="math/tex; mode=display">N</script>, so each push and pop operation is <script type="math/tex; mode=display">O(\\log N)</script>, and there are <script type="math/tex; mode=display">O(C)</script> such operations.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script> in additional space complexity.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Airbnb'],
  },
  {
    id: '760',
    name: 'Find Anagram Mappings',
    acceptance: '78.2%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven two lists <code>A</code>and <code>B</code>, and <code>B</code> is an anagram of <code>A</code>. <code>B</code> is an anagram of <code>A</code> means <code>B</code> is made by randomizing the order of the elements in <code>A</code>.\n</p><p>\nWe want to find an <i>index mapping</i> <code>P</code>, from <code>A</code> to <code>B</code>. A mapping <code>P[i] = j</code> means the <code>i</code>th element in <code>A</code> appears in <code>B</code> at index <code>j</code>.\n</p><p>\nThese lists <code>A</code> and <code>B</code> may contain duplicates.  If there are multiple answers, output any of them.\n</p>\n\n<p>\nFor example, given\n</p><pre>A = [12, 28, 46, 32, 50]\nB = [50, 12, 32, 46, 28]\n</pre>\n<p></p>\nWe should return\n<pre>[1, 4, 3, 2, 0]\n</pre>\nas <code>P[0] = 1</code> because the <code>0</code>th element of <code>A</code> appears at <code>B[1]</code>,\nand <code>P[1] = 4</code> because the <code>1</code>st element of <code>A</code> appears at <code>B[4]</code>,\nand so on.\n<p></p>\n\n<p><b>Note:</b></p><ol>\n<li><code>A, B</code> have equal lengths in range <code>[1, 100]</code>.</li>\n<li><code>A[i], B[i]</code> are integers in range <code>[0, 10^5]</code>.</li>\n</ol><p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-hash-table-accepted">Approach #1: Hash Table [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-hash-table-accepted">Approach #1: Hash Table [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Take the example <code>A = [12, 28, 46]</code>, <code>B = [46, 12, 28]</code>.  We want to know where the <code>12</code> occurs in <code>B</code>, say at position <code>1</code>; then where the <code>28</code> occurs in <code>B</code>, which is position <code>2</code>; then where the <code>46</code> occurs in <code>B</code>, which is position <code>0</code>.</p>\n<p>If we had a dictionary (hash table) <code>D = {46: 0, 12: 1, 28: 2}</code>, then this question could be handled easily.</p>\n<p><strong>Algorithm</strong></p>\n<p>Create the hash table <code>D</code> as described above.  Then, the answer is a list of <code>D[A[i]]</code> for <code>i = 0, 1, ...</code>.</p>\n<iframe frameborder="0" height="276" name="iGtg87vW" src="https://leetcode.com/playground/iGtg87vW/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <script type="math/tex; mode=display">A</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
  {
    id: '761',
    name: 'Special Binary String',
    acceptance: '33.5%',
    difficulty: 'Hard',
    questionHtml:
      '\n            <br>\n            <p>\n<i>Special</i> binary strings are binary strings with the following two properties:\n</p><p>\n</p><li>The number of 0\'s is equal to the number of 1\'s.</li>\n<li>Every prefix of the binary string has at least as many 1\'s as 0\'s.</li>\n<p></p><p>\nGiven a special string <code>S</code>, a <i>move</i> consists of choosing two consecutive, non-empty, special substrings of <code>S</code>, and swapping them.  <i>(Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)</i>\n</p><p>\nAt the end of any number of moves, what is the lexicographically largest resulting string possible?\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> S = "11011000"\n<b>Output:</b> "11100100"\n<b>Explanation:</b>\nThe strings "10" [occuring at S[1]] and "1100" [at S[3]] are swapped.\nThis is the lexicographically largest string possible after some number of swaps.\n</pre>\n<p></p>\n\n<p><b>Note:</b></p><ol>\n<li><code>S</code> has length at most <code>50</code>.</li>\n<li><code>S</code> is guaranteed to be a <i>special</i> binary string as defined above.</li>\n</ol><p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-recursion-accepted">Approach #1: Recursion [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-recursion-accepted">Approach #1: Recursion [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>We can represent binary strings as "up and down" drawings, as follows:</p>\n<p><img height="80%" src="https://leetcode.com/articles/Figures/761/Special_Binary_String_1.png" width="80%"></p>\n<p>In such a drawing, <code>"1"</code> is a line up one unit, and <code>"0"</code> is a line down one unit, where all lines are 45 degrees from horizontal.</p>\n<p>Then, a binary string is <em>special</em> if and only if its up and down drawing does not cross below the starting horizontal line.</p>\n<p>Now, say a special binary string is a <em>mountain</em> if it has no special proper prefix.  When viewed through the lens of up and down drawings, a special binary string is a mountain if it touches the starting horizontal line only at the very beginning and the very end of the drawing.  Notice that every special string can be written as consecutive mountains.</p>\n<p>Without loss of generality, we can assume we only swap mountains.  Because if we swap special adjacent substrings A and B, and A has mountain decomposition <script type="math/tex; mode=display">A = M_1M_2\\dots M_k</script>, then we could instead swap <script type="math/tex; mode=display">B</script> and <script type="math/tex; mode=display">M_k</script>, then <script type="math/tex; mode=display">B</script> and <script type="math/tex; mode=display">M_{k-1}</script>, and so on.</p>\n<p>Also, if <script type="math/tex; mode=display">S</script> has mountain decomposition <script type="math/tex; mode=display">S = M_1M_2\\dots M_k</script>, and we choose <script type="math/tex; mode=display">A</script> to start not at the start of some <script type="math/tex; mode=display">M_i</script>, then <script type="math/tex; mode=display">A</script> has global height <script type="math/tex; mode=display">h > 0</script>, and so <script type="math/tex; mode=display">A</script> cannot be special if it includes parts of another mountain <script type="math/tex; mode=display">M_{i+1}</script> as the end of mountain <script type="math/tex; mode=display">M_i</script> will cause it to dip to global height <script type="math/tex; mode=display">0 < h</script>.</p>\n<p><strong>Algorithm</strong></p>\n<p>Say <code>F(String S)</code> is the desired <code>makeLargestSpecial</code> function.  If <code>S</code> has mountain decomposition <script type="math/tex; mode=display">S = M_1M_2\\dots M_k</script>, the answer is <script type="math/tex; mode=display">\\text{reverse_sorted}(F(M_1), F(M_2), \\dots, F(M_k))</script>, as swaps <code>A, B</code> involving multiple <script type="math/tex; mode=display">M_i</script> cannot have <code>A</code> or <code>B</code> start differently from where these <script type="math/tex; mode=display">M_i</script> start.</p>\n<p>It remains to determine how to handle the case when <script type="math/tex; mode=display">S = S_0, S_1, \\dots , S_{N-1}</script> is a mountain.  In that case, it must start with <code>"1"</code> and end with <code>"0"</code>, so the answer is <code>"1" + F([S[1], S[2], ..., S[N-2]]) + "0"</code>.</p>\n<iframe frameborder="0" height="378" name="seasLy82" src="https://leetcode.com/playground/seasLy82/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script>, where <script type="math/tex; mode=display">N</script> is the length of <script type="math/tex; mode=display">S</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Coursera', 'Quip'],
  },
  {
    id: '762',
    name: 'Prime Number of Set Bits in Binary Representation',
    acceptance: '54.0%',
    difficulty: 'Easy',
    questionHtml:
      '\n            <br>\n            <p>\nGiven two integers <code>L</code> and <code>R</code>, find the count of numbers in the range <code>[L, R]</code> (inclusive) having a prime number of set bits in their binary representation.\n</p><p>\n(Recall that the number of set bits an integer has is the number of <code>1</code>s present when written in binary.  For example, <code>21</code> written in binary is <code>10101</code> which has 3 set bits.  Also, 1 is not a prime.)\n</p><p>\n\n</p><p><b>Example 1:</b><br></p><pre><b>Input:</b> L = 6, R = 10\n<b>Output:</b> 4\n<b>Explanation:</b>\n6 -&gt; 110 (2 set bits, 2 is prime)\n7 -&gt; 111 (3 set bits, 3 is prime)\n9 -&gt; 1001 (2 set bits , 2 is prime)\n10-&gt;1010 (2 set bits , 2 is prime)\n</pre><p></p>\n\n<p><b>Example 2:</b><br></p><pre><b>Input:</b> L = 10, R = 15\n<b>Output:</b> 5\n<b>Explanation:</b>\n10 -&gt; 1010 (2 set bits, 2 is prime)\n11 -&gt; 1011 (3 set bits, 3 is prime)\n12 -&gt; 1100 (2 set bits, 2 is prime)\n13 -&gt; 1101 (3 set bits, 3 is prime)\n14 -&gt; 1110 (3 set bits, 3 is prime)\n15 -&gt; 1111 (4 set bits, 4 is not prime)\n</pre><p></p>\n\n<p><b>Note:</b><br></p><ol>\n<li><code>L, R</code> will be integers <code>L &lt;= R</code> in the range <code>[1, 10^6]</code>.</li>\n<li><code>R - L</code> will be at most 10000.</li>\n</ol><p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-direct-accepted">Approach #1: Direct [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-direct-accepted">Approach #1: Direct [Accepted]</h4>\n<p><strong>Intuition and Approach</strong></p>\n<p>For each number from <code>L</code> to <code>R</code>, let\'s find out how many set bits it has.  If that number is <code>2, 3, 5, 7, 11, 13, 17</code>, or <code>19</code>, then we add one to our count.  We only need primes up to 19 because <script type="math/tex; mode=display">R \\leq 10^6 < 2^{20}</script>.</p>\n<iframe frameborder="0" height="276" name="uUmgeEHK" src="https://leetcode.com/playground/uUmgeEHK/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(D)</script>, where <script type="math/tex; mode=display">D = R-L</script> is the number of integers considered.  In a bit complexity model, this would be <script type="math/tex; mode=display">O(D\\log D)</script> as we have to count the bits in <script type="math/tex; mode=display">O(\\log D)</script> time.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '763',
    name: 'Partition Labels',
    acceptance: '67.3%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nA string <code>S</code> of lowercase letters is given.  We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.\n</p><p>\n\n</p><p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> S = "ababcbacadefegdehijhklij"\n<b>Output:</b> [9,7,8]\n<b>Explanation:</b>\nThe partition is "ababcbaca", "defegde", "hijhklij".\nThis is a partition so that each letter appears in at most one part.\nA partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.\n</pre>\n<p></p>\n\n<p><b>Note:</b><br></p><ol>\n<li><code>S</code> will have length in range <code>[1, 500]</code>.</li>\n<li><code>S</code> will consist of lowercase letters (<code>\'a\'</code> to <code>\'z\'</code>) only.</li>\n</ol><p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-greedy-accepted">Approach #1: Greedy [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-greedy-accepted">Approach #1: Greedy [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>Let\'s try to repeatedly choose the smallest left-justified partition.\nConsider the first label, say it\'s <code>\'a\'</code>.  The first partition must include it, and also the last occurrence of <code>\'a\'</code>.\nHowever, between those two occurrences of <code>\'a\'</code>, there could be other labels that make the minimum size of this partition bigger.  For example, in <code>"abccaddbeffe"</code>, the minimum first partition is <code>"abccaddb"</code>. \nThis gives us the idea for the algorithm:  For each letter encountered, process the last occurrence of that letter, extending the current partition <code>[anchor, j]</code> appropriately.</p>\n<p><strong>Algorithm</strong></p>\n<p>We need an array <code>last[char] -&gt; index of S where char occurs last</code>.\nThen, let <code>anchor</code> and <code>j</code> be the start and end of the current partition.\nIf we are at a label that occurs last at some index after <code>j</code>, we\'ll extend the partition <code>j = last[c]</code>.  If we are at the end of the partition (<code>i == j</code>) then we\'ll append a partition size to our answer, and set the start of our new partition to <code>i+1</code>.</p>\n<iframe frameborder="0" height="361" name="AMVEbc95" src="https://leetcode.com/playground/AMVEbc95/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where <script type="math/tex; mode=display">N</script> is the length of <script type="math/tex; mode=display">S</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Amazon'],
  },
  {
    id: '764',
    name: 'Largest Plus Sign',
    acceptance: '32.0%',
    difficulty: 'Medium',
    questionHtml:
      '\n            <br>\n            <p>\nIn a 2D <code>grid</code> from (0, 0) to (N-1, N-1), every cell contains a <code>1</code>, except those cells in the given list <code>mines</code> which are <code>0</code>.  What is the largest axis-aligned plus sign of <code>1</code>s contained in the grid?  Return the order of the plus sign.  If there is none, return 0.\n</p><p>\nAn "<i>axis-aligned plus sign of <code>1</code>s</i> of order <b>k</b>" has some center <code>grid[x][y] = 1</code> along with 4 arms of length <code>k-1</code> going up, down, left, and right, and made of <code>1</code>s.  This is demonstrated in the diagrams below.  Note that there could be <code>0</code>s or <code>1</code>s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.\n</p><p>\n\n</p><p><b>Examples of Axis-Aligned Plus Signs of Order k:</b><br></p><pre>Order 1:\n000\n0<b>1</b>0\n000\n\nOrder 2:\n00000\n00<b>1</b>00\n0<b>111</b>0\n00<b>1</b>00\n00000\n\nOrder 3:\n0000000\n000<b>1</b>000\n000<b>1</b>000\n0<b>11111</b>0\n000<b>1</b>000\n000<b>1</b>000\n0000000\n</pre><p></p>\n\n<p><b>Example 1:</b><br></p><pre><b>Input:</b> N = 5, mines = [[4, 2]]\n<b>Output:</b> 2\n<b>Explanation:</b>\n11111\n11111\n1<b>1</b>111\n<b>111</b>11\n1<b>1</b>011\nIn the above grid, the largest plus sign can only be order 2.  One of them is marked in bold.\n</pre><p></p>\n\n<p><b>Example 2:</b><br></p><pre><b>Input:</b> N = 2, mines = []\n<b>Output:</b> 1\n<b>Explanation:</b>\nThere is no plus sign of order 2, but there is of order 1.\n</pre><p></p>\n\n<p><b>Example 3:</b><br></p><pre><b>Input:</b> N = 1, mines = [[0, 0]]\n<b>Output:</b> 0\n<b>Explanation:</b>\nThere is no plus sign, so return 0.\n</pre><p></p>\n\n<p><b>Note:</b><br></p><ol>\n<li><code>N</code> will be an integer in the range <code>[1, 500]</code>.</li>\n<li><code>mines</code> will have length at most <code>5000</code>.</li>\n<li><code>mines[i]</code> will be length 2 and consist of integers in the range <code>[0, N-1]</code>.</li>\n<li><i>(Additionally, programs submitted in C, C++, or C# will be judged with a slightly smaller time limit.)</i></li>\n</ol><p></p>\n          ',
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-1-brute-force-time-limit-exceeded">Approach #1: Brute Force [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-dynamic-programming-accepted">Approach #2: Dynamic Programming [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-1-brute-force-time-limit-exceeded">Approach #1: Brute Force [Time Limit Exceeded]</h4>\n<p><strong>Intuition and Algorithm</strong></p>\n<p>For each possible center, find the largest plus sign that could be placed by repeatedly expanding it.\nWe expect this algorithm to be <script type="math/tex; mode=display">O(N^3)</script>, and so take roughly <script type="math/tex; mode=display">500^3 = (1.25) * 10^8</script> operations.  This is a little bit too big for us to expect it to run in time.</p>\n<iframe frameborder="0" height="412" name="Ubn5xfpi" src="https://leetcode.com/playground/Ubn5xfpi/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^3)</script>, as we perform two outer loops (<script type="math/tex; mode=display">O(N^2)</script>), plus the inner loop involving <code>k</code> is <script type="math/tex; mode=display">O(N)</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(\\text{mines.length})</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-dynamic-programming-accepted">Approach #2: Dynamic Programming [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>How can we improve our bruteforce?  One way is to try to speed up the inner loop involving <code>k</code>, the order of the candidate plus sign.\nIf we knew the longest possible arm length <script type="math/tex; mode=display">L_u, L_l, L_d, L_r</script> in each direction from a center, we could know the order <script type="math/tex; mode=display">\\min(L_u, L_l, L_d, L_r)</script> of a plus sign at that center.  We could find these lengths separately using dynamic programming.</p>\n<p><strong>Algorithm</strong></p>\n<p>For each (cardinal) direction, and for each coordinate <code>(r, c)</code> let\'s compute the <code>count</code> of that coordinate: the longest line of <code>\'1\'</code>s starting from <code>(r, c)</code> and going in that direction.\nWith dynamic programming, it is either 0 if <code>grid[r][c]</code> is zero, else it is <code>1</code> plus the count of the coordinate in the same direction.\nFor example, if the direction is left and we have a row like <code>01110110</code>, the corresponding count values are <code>01230120</code>, and the integers are either 1 more than their successor, or 0.\nFor each square, we want <code>dp[r][c]</code> to end up being the minimum of the 4 possible counts.  At the end, we take the maximum value in <code>dp</code>.</p>\n<iframe frameborder="0" height="500" name="vWbH6piJ" src="https://leetcode.com/playground/vWbH6piJ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N^2)</script>, as the work we do under two nested for loops is <script type="math/tex; mode=display">O(1)</script>.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N^2)</script>, the size of <code>dp</code>.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Facebook'],
  },
  {
    id: '765',
    name: 'Couples Holding Hands',
    acceptance: '43.4%',
    difficulty: 'Hard',
    questionHtml:
      "\n            <br>\n            <p>\nN couples sit in 2N seats arranged in a row and want to hold hands.  We want to know the minimum number of swaps so that every couple is sitting side by side.  A <i>swap</i> consists of choosing <b>any</b> two people, then they stand up and switch seats. \n</p><p>\nThe people and seats are represented by an integer from <code>0</code> to <code>2N-1</code>, the couples are numbered in order, the first couple being <code>(0, 1)</code>, the second couple being <code>(2, 3)</code>, and so on with the last couple being <code>(2N-2, 2N-1)</code>.\n</p><p>\nThe couples' initial seating is given by <code>row[i]</code> being the value of the person who is initially sitting in the i-th seat.\n\n</p><p><b>Example 1:</b><br></p><pre><b>Input:</b> row = [0, 2, 1, 3]\n<b>Output:</b> 1\n<b>Explanation:</b> We only need to swap the second (row[1]) and third (row[2]) person.\n</pre><p></p>\n\n<p><b>Example 2:</b><br></p><pre><b>Input:</b> row = [3, 2, 0, 1]\n<b>Output:</b> 0\n<b>Explanation:</b> All couples are already seated side by side.\n</pre><p></p>\n\n<p>\n<b>Note:</b>\n</p><ol> \n<li> <code>len(row)</code> is even and in the range of <code>[4, 60]</code>.</li>\n<li> <code>row</code> is guaranteed to be a permutation of <code>0...len(row)-1</code>.</li>\n</ol>\n          ",
    solutionHtml:
      '\n            <br>\n            <div class="block-markdown">\n<div class="toc">\n<ul>\n<li><a href="#approach-framework">Approach Framework</a></li>\n<li><a href="#approach-1-backtracking-time-limit-exceeded">Approach #1: Backtracking [Time Limit Exceeded]</a></li>\n<li><a href="#approach-2-cycle-finding-accepted">Approach #2: Cycle Finding [Accepted]</a></li>\n</ul>\n</div>\n<h4 id="approach-framework">Approach Framework</h4>\n<p><strong>Observations</strong></p>\n<p>First, instead of couples <code>(0, 1), (2, 3), (4, 5), ...</code>, we could just consider couples <code>(0, 0), (1, 1), (2, 2), ...</code> without changing the answer.  Also, we could imagine that we have <code>N</code> two-seat couches <code>0, 1, 2, ..., N-1</code>.  This is because the person sitting on the left-most seat of the row must be paired with the person sitting on the second-left-most seat, the third-left-most paired with the fourth-left-most, and so on.\nCall a person happy if they are with their partner on the same couch.  Intuitively, a swap that keeps both persons swapped unhappy is not part of some optimal solution.  We\'ll call this the <em>happy swap assumption</em> (HSA), and we\'ll prove it in Approach #2.</p>\n<hr>\n<h4 id="approach-1-backtracking-time-limit-exceeded">Approach #1: Backtracking [Time Limit Exceeded]</h4>\n<p><strong>Intuition</strong></p>\n<p>We could guess without proof that a solution where we make the people on each couch happy in order is optimal.  This assumption is stronger than HSA, but it seems reasonable because at each move we are making at least 1 couple happy.  (See Approach #2 for a proof.)\nUnder such an assumption, for some couch with unhappy people X and Y, we either replace Y with X\'s partner, or replace X with Y\'s partner.\nFor each of the two possibilities, we can try both using a backtracking approach.</p>\n<p><strong>Algorithm</strong></p>\n<p>For each couch with two possibilities (ie. both people on the couch are unhappy), we will try the first possibility, find the answer as <code>ans1</code>, then undo our move and try the second possibility, find the associated answer as <code>ans2</code>, undo our move and then return the smallest answer.</p>\n<iframe frameborder="0" height="500" name="LGc8vjZQ" src="https://leetcode.com/playground/LGc8vjZQ/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N * 2^N)</script>, where <script type="math/tex; mode=display">N</script> is the number of couples, as for each couch we check up to two complete possibilities.  The <script type="math/tex; mode=display">N</script> factor is from searching for <code>jx</code> and <code>jy</code>; this factor can be removed with a more efficient algorithm that keeps track of where <code>pairs[j][k]</code> is <code>x</code> as we swap elements through pairs.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>.</p>\n</li>\n</ul>\n<hr>\n<h4 id="approach-2-cycle-finding-accepted">Approach #2: Cycle Finding [Accepted]</h4>\n<p><strong>Intuition</strong></p>\n<p>If we take the HSA as true, it means that if a couple is on two separate couches, there are two possible moves to make this couple happy, depending on which partner visits their partner and which stays in place.\nThis leads to the following idea: for each couple sitting at couches X and Y (possibly the same), draw an undirected edge from X to Y.  Call such a graph the couples graph.  This graph is 2-regular (every node has degree 2), and it is easy to see that every connected component of this graph must be a cycle.\nThen, making a swap for <script type="math/tex; mode=display">X_1</script> to meet their partner <script type="math/tex; mode=display">X_2</script> has a corresponding move on the couples graph equivalent to contracting the corresponding edge to <script type="math/tex; mode=display">X_1X_2</script> plus having a node with a single self edge.\nOur goal is to have <code>N</code> connected components in the graph, one for each couch.  Every swap (allowed by the scheme above) always increases that number by exactly 1, so under HSA, the answer is just <code>N</code> minus the number of connected components in the couples graph.\nNow to prove HSA, observe that it is impossible with <em>any</em> swap to create more than 1 additional connected component in the couples graph.  So any optimal solution must have at least the number of moves in the answer we\'ve constructed.  (This also proves the ordering assumption made in Approach #1, as we can make edge contractions of a cycle in any order without changing the answer.)</p>\n<p><strong>Algorithm</strong></p>\n<p>We\'ll construct the graph: <code>adj[node]</code> will be the index of the two nodes that this <code>node</code> is adjacent to.\nAfter, we\'ll find all connected components (which are also cycles.)  If at some couch (node) a person is unvisited, we will visit it and repeatedly visit some neighbor until we complete the cycle.</p>\n<iframe frameborder="0" height="500" name="YvZzYzvt" src="https://leetcode.com/playground/YvZzYzvt/shared" width="100%"></iframe>\n<p><strong>Complexity Analysis</strong></p>\n<ul>\n<li>\n<p>Time Complexity: <script type="math/tex; mode=display">O(N)</script>, where N is the number of couples.</p>\n</li>\n<li>\n<p>Space Complexity: <script type="math/tex; mode=display">O(N)</script>, the size of <code>adj</code> and associated data structures.</p>\n</li>\n</ul>\n<hr>\n<p>Analysis written by: <a href="https://leetcode.com/awice">@awice</a>.</p>\n</div>\n          ',
    tags: ['Google'],
  },
];
